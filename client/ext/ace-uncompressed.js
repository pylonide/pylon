/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * Define a module along with a payload
 * @param module a name for the payload
 * @param payload a function to call with (require, exports, module) params
 */

(function() {

var ACE_NAMESPACE = "";

var global = (function() {
    return this;
})();

var _define = function(module, deps, payload) {
    if (typeof module !== 'string') {
        if (_define.original)
            _define.original.apply(window, arguments);
        else {
            console.error('dropping module because define wasn\'t a string.');
            console.trace();
        }
        return;
    }

    if (arguments.length == 2)
        payload = deps;

    if (!_define.modules)
        _define.modules = {};

    _define.modules[module] = payload;
};

/**
 * Get at functionality define()ed using the function above
 */
var _require = function(parentId, module, callback) {
    if (Object.prototype.toString.call(module) === "[object Array]") {
        var params = [];
        for (var i = 0, l = module.length; i < l; ++i) {
            var dep = lookup(parentId, module[i]);
            if (!dep && _require.original)
                return _require.original.apply(window, arguments);
            params.push(dep);
        }
        if (callback) {
            callback.apply(null, params);
        }
    }
    else if (typeof module === 'string') {
        var payload = lookup(parentId, module);
        if (!payload && _require.original)
            return _require.original.apply(window, arguments);

        if (callback) {
            callback();
        }

        return payload;
    }
    else {
        if (_require.original)
            return _require.original.apply(window, arguments);
    }
};

var normalizeModule = function(parentId, moduleName) {
    // normalize plugin requires
    if (moduleName.indexOf("!") !== -1) {
        var chunks = moduleName.split("!");
        return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
    }
    // normalize relative requires
    if (moduleName.charAt(0) == ".") {
        var base = parentId.split("/").slice(0, -1).join("/");
        moduleName = base + "/" + moduleName;

        while(moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
        }
    }

    return moduleName;
};

/**
 * Internal function to lookup moduleNames and resolve them by calling the
 * definition function if needed.
 */
var lookup = function(parentId, moduleName) {

    moduleName = normalizeModule(parentId, moduleName);

    var module = _define.modules[moduleName];
    if (!module) {
        return null;
    }

    if (typeof module === 'function') {
        var exports = {};
        var mod = {
            id: moduleName,
            uri: '',
            exports: exports,
            packaged: true
        };

        var req = function(module, callback) {
            return _require(moduleName, module, callback);
        };

        var returnValue = module(req, exports, mod);
        exports = returnValue || mod.exports;

        // cache the resulting module object for next time
        _define.modules[moduleName] = exports;
        return exports;
    }

    return module;
};

function exportAce(ns) {

    if (typeof requirejs !== "undefined") {

        var define = global.define;
        global.define = function(id, deps, callback) {
            if (typeof callback !== "function")
                return define.apply(this, arguments);

            return define(id, deps, function(require, exports, module) {
                if (deps[2] == "module")
                    module.packaged = true;
                return callback.apply(this, arguments);
            });
        };
        global.define.packaged = true;

        return;
    }

    var require = function(module, callback) {
        return _require("", module, callback);
    };
    require.packaged = true;

    var root = global;
    if (ns) {
        if (!global[ns])
            global[ns] = {};
        root = global[ns];
    }

    if (root.define) {
        _define.original = root.define;
        for (var k in root.define) {
            _define[k] = root.define[k];
        }
    }

    root.define = _define;

    if (root.require) {
        _require.original = root.require;
        for (var k in root.require) {
            _require[k] = root.require[k];
        }        
    }

    root.require = require;
}

exportAce(ACE_NAMESPACE);

})();/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Skywriter.
 *
 * The Initial Developer of the Original Code is
 * Mozilla.
 * Portions created by the Initial Developer are Copyright (C) 2009
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Kevin Dangoor (kdangoor@mozilla.com)
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/ace', ['require', 'exports', 'module' , 'ace/lib/fixoldbrowsers', 'ace/lib/dom', 'ace/lib/event', 'ace/editor', 'ace/edit_session', 'ace/undomanager', 'ace/virtual_renderer', 'ace/worker/worker', 'ace/worker/worker_client', 'ace/keyboard/hash_handler', 'ace/keyboard/state_handler', 'ace/lib/net', 'ace/placeholder', 'ace/theme/textmate'], function(require, exports, module) {
"use strict";

require("./lib/fixoldbrowsers");

var Dom = require("./lib/dom");
var Event = require("./lib/event");

var Editor = require("./editor").Editor;
var EditSession = require("./edit_session").EditSession;
var UndoManager = require("./undomanager").UndoManager;
var Renderer = require("./virtual_renderer").VirtualRenderer;

// The following require()s are for inclusion in the built ace file
require("./worker/worker");
require("./worker/worker_client");
require("./keyboard/hash_handler");
require("./keyboard/state_handler");
require("./lib/net");
require("./placeholder");

exports.edit = function(el) {
    if (typeof(el) == "string") {
        el = document.getElementById(el);
    }

    var doc = new EditSession(Dom.getInnerText(el));
    doc.setUndoManager(new UndoManager());
    el.innerHTML = '';

    var editor = new Editor(new Renderer(el, require("./theme/textmate")));
    editor.setSession(doc);

    var env = {};
    env.document = doc;
    env.editor = editor;
    editor.resize();
    Event.addListener(window, "resize", function() {
        editor.resize();
    });
    el.env = env;
    // Store env on editor such that it can be accessed later on from
    // the returned object.
    editor.env = env;
    return editor;
};

});// vim:set ts=4 sts=4 sw=4 st:
// -- kriskowal Kris Kowal Copyright (C) 2009-2010 MIT License
// -- tlrobinson Tom Robinson Copyright (C) 2009-2010 MIT License (Narwhal Project)
// -- dantman Daniel Friesen Copyright(C) 2010 XXX No License Specified
// -- fschaefer Florian Schäfer Copyright (C) 2010 MIT License
// -- Irakli Gozalishvili Copyright (C) 2010 MIT License

/*!
    Copyright (c) 2009, 280 North Inc. http://280north.com/
    MIT License. http://github.com/280north/narwhal/blob/master/README.md
*/

define('ace/lib/fixoldbrowsers', ['require', 'exports', 'module' , 'ace/lib/regexp', 'ace/lib/es5-shim'], function(require, exports, module) {
"use strict";

require("./regexp");
require("./es5-shim");

});/**
 *  Based on code from:
 *
 * XRegExp 1.5.0
 * (c) 2007-2010 Steven Levithan
 * MIT License
 * <http://xregexp.com>
 * Provides an augmented, extensible, cross-browser implementation of regular expressions,
 * including support for additional syntax, flags, and methods
 */
 
define('ace/lib/regexp', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

    //---------------------------------
    //  Private variables
    //---------------------------------

    var real = {
            exec: RegExp.prototype.exec,
            test: RegExp.prototype.test,
            match: String.prototype.match,
            replace: String.prototype.replace,
            split: String.prototype.split
        },
        compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined, // check `exec` handling of nonparticipating capturing groups
        compliantLastIndexIncrement = function () {
            var x = /^/g;
            real.test.call(x, "");
            return !x.lastIndex;
        }();

    //---------------------------------
    //  Overriden native methods
    //---------------------------------

    // Adds named capture support (with backreferences returned as `result.name`), and fixes two
    // cross-browser issues per ES3:
    // - Captured values for nonparticipating capturing groups should be returned as `undefined`,
    //   rather than the empty string.
    // - `lastIndex` should not be incremented after zero-length matches.
    RegExp.prototype.exec = function (str) {
        var match = real.exec.apply(this, arguments),
            name, r2;
        if ( typeof(str) == 'string' && match) {
            // Fix browsers whose `exec` methods don't consistently return `undefined` for
            // nonparticipating capturing groups
            if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
                // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed
                // matching due to characters outside the match
                real.replace.call(str.slice(match.index), r2, function () {
                    for (var i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined)
                            match[i] = undefined;
                    }
                });
            }
            // Attach named capture properties
            if (this._xregexp && this._xregexp.captureNames) {
                for (var i = 1; i < match.length; i++) {
                    name = this._xregexp.captureNames[i - 1];
                    if (name)
                       match[name] = match[i];
                }
            }
            // Fix browsers that increment `lastIndex` after zero-length matches
            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
        }
        return match;
    };

    // Don't override `test` if it won't change anything
    if (!compliantLastIndexIncrement) {
        // Fix browser bug in native method
        RegExp.prototype.test = function (str) {
            // Use the native `exec` to skip some processing overhead, even though the overriden
            // `exec` would take care of the `lastIndex` fix
            var match = real.exec.call(this, str);
            // Fix browsers that increment `lastIndex` after zero-length matches
            if (match && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
            return !!match;
        };
    }

    //---------------------------------
    //  Private helper functions
    //---------------------------------

    function getNativeFlags (regex) {
        return (regex.global     ? "g" : "") +
               (regex.ignoreCase ? "i" : "") +
               (regex.multiline  ? "m" : "") +
               (regex.extended   ? "x" : "") + // Proposed for ES4; included in AS3
               (regex.sticky     ? "y" : "");
    };

    function indexOf (array, item, from) {
        if (Array.prototype.indexOf) // Use the native array method if available
            return array.indexOf(item, from);
        for (var i = from || 0; i < array.length; i++) {
            if (array[i] === item)
                return i;
        }
        return -1;
    };

});
// vim: ts=4 sts=4 sw=4 expandtab
// -- kriskowal Kris Kowal Copyright (C) 2009-2011 MIT License
// -- tlrobinson Tom Robinson Copyright (C) 2009-2010 MIT License (Narwhal Project)
// -- dantman Daniel Friesen Copyright (C) 2010 XXX TODO License or CLA
// -- fschaefer Florian Schäfer Copyright (C) 2010 MIT License
// -- Gozala Irakli Gozalishvili Copyright (C) 2010 MIT License
// -- kitcambridge Kit Cambridge Copyright (C) 2011 MIT License
// -- kossnocorp Sasha Koss XXX TODO License or CLA
// -- bryanforbes Bryan Forbes XXX TODO License or CLA
// -- killdream Quildreen Motta Copyright (C) 2011 MIT Licence
// -- michaelficarra Michael Ficarra Copyright (C) 2011 3-clause BSD License
// -- sharkbrainguy Gerard Paapu Copyright (C) 2011 MIT License
// -- bbqsrc Brendan Molloy (C) 2011 Creative Commons Zero (public domain)
// -- iwyg XXX TODO License or CLA
// -- DomenicDenicola Domenic Denicola Copyright (C) 2011 MIT License
// -- xavierm02 Montillet Xavier XXX TODO License or CLA
// -- Raynos Raynos XXX TODO License or CLA
// -- samsonjs Sami Samhuri Copyright (C) 2010 MIT License
// -- rwldrn Rick Waldron Copyright (C) 2011 MIT License
// -- lexer Alexey Zakharov XXX TODO License or CLA

/*!
    Copyright (c) 2009, 280 North Inc. http://280north.com/
    MIT License. http://github.com/280north/narwhal/blob/master/README.md
*/

define('ace/lib/es5-shim', ['require', 'exports', 'module' ], function(require, exports, module) {

/**
 * Brings an environment as close to ECMAScript 5 compliance
 * as is possible with the facilities of erstwhile engines.
 *
 * Annotated ES5: http://es5.github.com/ (specific links below)
 * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
 *
 * @module
 */

/*whatsupdoc*/

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (typeof target != "function")
            throw new TypeError(); // TODO message
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var bound = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal 
                //   method of target providing args as the arguments.

                var F = function(){};
                F.prototype = target.prototype;
                var self = new F;

                var result = target.apply(
                    self,
                    args.concat(slice.call(arguments))
                );
                if (result !== null && Object(result) === result)
                    return result;
                return self;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the 
                //   list boundArgs in the same order followed by the same 
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method 
                //   of target providing boundThis as the this value and 
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(slice.call(arguments))
                );

            }

        };
        // XXX bound.length is never writable, so don't even try
        //
        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is 
        //       larger.
        // 16. Else set the length own property of F to 0.
        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.
        
        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with 
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and 
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with 
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower, 
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not 
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    };
}

// Shortcut to an often accessed properties, in order to avoid multiple
// dereference that costs universally.
// _Please note: Shortcuts are defined after `Function.prototype.bind` as we
// us it in defining shortcuts.
var call = Function.prototype.call;
var prototypeOfArray = Array.prototype;
var prototypeOfObject = Object.prototype;
var slice = prototypeOfArray.slice;
var toString = call.bind(prototypeOfObject.toString);
var owns = call.bind(prototypeOfObject.hasOwnProperty);

// If JS engine supports accessors creating shortcuts.
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors;
if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
}

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
if (!Array.isArray) {
    Array.isArray = function isArray(obj) {
        return toString(obj) == "[object Array]";
    };
}

// The IsCallable() check in the Array functions
// has been replaced with a strict check on the
// internal class of the object to trap cases where
// the provided function was actually a regular
// expression literal, which in V8 and
// JavaScriptCore is a typeof "function".  Only in
// V8 are regular expression literals permitted as
// reduce parameters, so it is desirable in the
// general case for the shim to match the more
// strict and common behavior of rejecting regular
// expressions.

// ES5 15.4.4.18
// http://es5.github.com/#x15.4.4.18
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function forEach(fun /*, thisp*/) {
        var self = toObject(this),
            thisp = arguments[1],
            i = 0,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        while (i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object context
                fun.call(thisp, self[i], i, self);
            }
            i++;
        }
    };
}

// ES5 15.4.4.19
// http://es5.github.com/#x15.4.4.19
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
if (!Array.prototype.map) {
    Array.prototype.map = function map(fun /*, thisp*/) {
        var self = toObject(this),
            length = self.length >>> 0,
            result = Array(length),
            thisp = arguments[1];

        // If no callback function or if callback is not a callable function
        if (toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        for (var i = 0; i < length; i++) {
            if (i in self)
                result[i] = fun.call(thisp, self[i], i, self);
        }
        return result;
    };
}

// ES5 15.4.4.20
// http://es5.github.com/#x15.4.4.20
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
if (!Array.prototype.filter) {
    Array.prototype.filter = function filter(fun /*, thisp */) {
        var self = toObject(this),
            length = self.length >>> 0,
            result = [],
            thisp = arguments[1];

        // If no callback function or if callback is not a callable function
        if (toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, self))
                result.push(self[i]);
        }
        return result;
    };
}

// ES5 15.4.4.16
// http://es5.github.com/#x15.4.4.16
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
if (!Array.prototype.every) {
    Array.prototype.every = function every(fun /*, thisp */) {
        var self = toObject(this),
            length = self.length >>> 0,
            thisp = arguments[1];

        // If no callback function or if callback is not a callable function
        if (toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        for (var i = 0; i < length; i++) {
            if (i in self && !fun.call(thisp, self[i], i, self))
                return false;
        }
        return true;
    };
}

// ES5 15.4.4.17
// http://es5.github.com/#x15.4.4.17
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
if (!Array.prototype.some) {
    Array.prototype.some = function some(fun /*, thisp */) {
        var self = toObject(this),
            length = self.length >>> 0,
            thisp = arguments[1];

        // If no callback function or if callback is not a callable function
        if (toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, self))
                return true;
        }
        return false;
    };
}

// ES5 15.4.4.21
// http://es5.github.com/#x15.4.4.21
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
if (!Array.prototype.reduce) {
    Array.prototype.reduce = function reduce(fun /*, initial*/) {
        var self = toObject(this),
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        // no value to return if no initial value and an empty array
        if (!length && arguments.length == 1)
            throw new TypeError(); // TODO message

        var i = 0;
        var result;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i++];
                    break;
                }

                // if array contains no values, no initial value to return
                if (++i >= length)
                    throw new TypeError(); // TODO message
            } while (true);
        }

        for (; i < length; i++) {
            if (i in self)
                result = fun.call(void 0, result, self[i], i, self);
        }

        return result;
    };
}

// ES5 15.4.4.22
// http://es5.github.com/#x15.4.4.22
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
if (!Array.prototype.reduceRight) {
    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
        var self = toObject(this),
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        // no value to return if no initial value, empty array
        if (!length && arguments.length == 1)
            throw new TypeError(); // TODO message

        var result, i = length - 1;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i--];
                    break;
                }

                // if array contains no values, no initial value to return
                if (--i < 0)
                    throw new TypeError(); // TODO message
            } while (true);
        }

        do {
            if (i in this)
                result = fun.call(void 0, result, self[i], i, self);
        } while (i--);

        return result;
    };
}

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
        var self = toObject(this),
            length = self.length >>> 0;

        if (!length)
            return -1;

        var i = 0;
        if (arguments.length > 1)
            i = toInteger(arguments[1]);

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    };
}

// ES5 15.4.4.15
// http://es5.github.com/#x15.4.4.15
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
if (!Array.prototype.lastIndexOf) {
    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
        var self = toObject(this),
            length = self.length >>> 0;

        if (!length)
            return -1;
        var i = length - 1;
        if (arguments.length > 1)
            i = Math.min(i, toInteger(arguments[1]));
        // handle negative indices
        i = i >= 0 ? i : length - Math.abs(i);
        for (; i >= 0; i--) {
            if (i in self && sought === self[i])
                return i;
        }
        return -1;
    };
}

//
// Object
// ======
//

// ES5 15.2.3.2
// http://es5.github.com/#x15.2.3.2
if (!Object.getPrototypeOf) {
    // https://github.com/kriskowal/es5-shim/issues#issue/2
    // http://ejohn.org/blog/objectgetprototypeof/
    // recommended by fschaefer on github
    Object.getPrototypeOf = function getPrototypeOf(object) {
        return object.__proto__ || (
            object.constructor ?
            object.constructor.prototype :
            prototypeOfObject
        );
    };
}

// ES5 15.2.3.3
// http://es5.github.com/#x15.2.3.3
if (!Object.getOwnPropertyDescriptor) {
    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +
                         "non-object: ";
    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT + object);
        // If object does not owns property return undefined immediately.
        if (!owns(object, property))
            return;

        var descriptor, getter, setter;

        // If object has a property then it's for sure both `enumerable` and
        // `configurable`.
        descriptor =  { enumerable: true, configurable: true };

        // If JS engine supports accessor properties then property may be a
        // getter or setter.
        if (supportsAccessors) {
            // Unfortunately `__lookupGetter__` will return a getter even
            // if object has own non getter property along with a same named
            // inherited getter. To avoid misbehavior we temporary remove
            // `__proto__` so that `__lookupGetter__` will return getter only
            // if it's owned by an object.
            var prototype = object.__proto__;
            object.__proto__ = prototypeOfObject;

            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);

            // Once we have getter and setter we can put values back.
            object.__proto__ = prototype;

            if (getter || setter) {
                if (getter) descriptor.get = getter;
                if (setter) descriptor.set = setter;

                // If it was accessor property we're done and return here
                // in order to avoid adding `value` to the descriptor.
                return descriptor;
            }
        }

        // If we got this far we know that object has an own property that is
        // not an accessor so we set it as a value and return descriptor.
        descriptor.value = object[property];
        return descriptor;
    };
}

// ES5 15.2.3.4
// http://es5.github.com/#x15.2.3.4
if (!Object.getOwnPropertyNames) {
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
        return Object.keys(object);
    };
}

// ES5 15.2.3.5
// http://es5.github.com/#x15.2.3.5
if (!Object.create) {
    Object.create = function create(prototype, properties) {
        var object;
        if (prototype === null) {
            object = { "__proto__": null };
        } else {
            if (typeof prototype != "object")
                throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
            var Type = function () {};
            Type.prototype = prototype;
            object = new Type();
            // IE has no built-in implementation of `Object.getPrototypeOf`
            // neither `__proto__`, but this manually setting `__proto__` will
            // guarantee that `Object.getPrototypeOf` will work as expected with
            // objects created using `Object.create`
            object.__proto__ = prototype;
        }
        if (properties !== void 0)
            Object.defineProperties(object, properties);
        return object;
    };
}

// ES5 15.2.3.6
// http://es5.github.com/#x15.2.3.6

// Patch for WebKit and IE8 standard mode
// Designed by hax <hax.github.com>
// related issue: https://github.com/kriskowal/es5-shim/issues#issue/5
// IE8 Reference:
//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
// WebKit Bugs:
//     https://bugs.webkit.org/show_bug.cgi?id=36423

function doesDefinePropertyWork(object) {
    try {
        Object.defineProperty(object, "sentinel", {});
        return "sentinel" in object;
    } catch (exception) {
        // returns falsy
    }
}

// check whether defineProperty works if it's given. Otherwise,
// shim partially.
if (Object.defineProperty) {
    var definePropertyWorksOnObject = doesDefinePropertyWork({});
    var definePropertyWorksOnDom = typeof document == "undefined" ||
        doesDefinePropertyWork(document.createElement("div"));
    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
        var definePropertyFallback = Object.defineProperty;
    }
}

if (!Object.defineProperty || definePropertyFallback) {
    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: "
    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
                                      "on this javascript engine";

    Object.defineProperty = function defineProperty(object, property, descriptor) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
        if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);

        // make a valiant attempt to use the real defineProperty
        // for I8's DOM elements.
        if (definePropertyFallback) {
            try {
                return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {
                // try the shim if the real one doesn't work
            }
        }

        // If it's a data property.
        if (owns(descriptor, "value")) {
            // fail silently if "writable", "enumerable", or "configurable"
            // are requested but not supported
            /*
            // alternate approach:
            if ( // can't implement these features; allow false but not true
                !(owns(descriptor, "writable") ? descriptor.writable : true) ||
                !(owns(descriptor, "enumerable") ? descriptor.enumerable : true) ||
                !(owns(descriptor, "configurable") ? descriptor.configurable : true)
            )
                throw new RangeError(
                    "This implementation of Object.defineProperty does not " +
                    "support configurable, enumerable, or writable."
                );
            */

            if (supportsAccessors && (lookupGetter(object, property) ||
                                      lookupSetter(object, property)))
            {
                // As accessors are supported only on engines implementing
                // `__proto__` we can safely override `__proto__` while defining
                // a property to make sure that we don't hit an inherited
                // accessor.
                var prototype = object.__proto__;
                object.__proto__ = prototypeOfObject;
                // Deleting a property anyway since getter / setter may be
                // defined on object itself.
                delete object[property];
                object[property] = descriptor.value;
                // Setting original `__proto__` back now.
                object.__proto__ = prototype;
            } else {
                object[property] = descriptor.value;
            }
        } else {
            if (!supportsAccessors)
                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            // If we got that far then getters and setters can be defined !!
            if (owns(descriptor, "get"))
                defineGetter(object, property, descriptor.get);
            if (owns(descriptor, "set"))
                defineSetter(object, property, descriptor.set);
        }

        return object;
    };
}

// ES5 15.2.3.7
// http://es5.github.com/#x15.2.3.7
if (!Object.defineProperties) {
    Object.defineProperties = function defineProperties(object, properties) {
        for (var property in properties) {
            if (owns(properties, property))
                Object.defineProperty(object, property, properties[property]);
        }
        return object;
    };
}

// ES5 15.2.3.8
// http://es5.github.com/#x15.2.3.8
if (!Object.seal) {
    Object.seal = function seal(object) {
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}

// ES5 15.2.3.9
// http://es5.github.com/#x15.2.3.9
if (!Object.freeze) {
    Object.freeze = function freeze(object) {
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}

// detect a Rhino bug and patch it
try {
    Object.freeze(function () {});
} catch (exception) {
    Object.freeze = (function freeze(freezeObject) {
        return function freeze(object) {
            if (typeof object == "function") {
                return object;
            } else {
                return freezeObject(object);
            }
        };
    })(Object.freeze);
}

// ES5 15.2.3.10
// http://es5.github.com/#x15.2.3.10
if (!Object.preventExtensions) {
    Object.preventExtensions = function preventExtensions(object) {
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}

// ES5 15.2.3.11
// http://es5.github.com/#x15.2.3.11
if (!Object.isSealed) {
    Object.isSealed = function isSealed(object) {
        return false;
    };
}

// ES5 15.2.3.12
// http://es5.github.com/#x15.2.3.12
if (!Object.isFrozen) {
    Object.isFrozen = function isFrozen(object) {
        return false;
    };
}

// ES5 15.2.3.13
// http://es5.github.com/#x15.2.3.13
if (!Object.isExtensible) {
    Object.isExtensible = function isExtensible(object) {
        // 1. If Type(O) is not Object throw a TypeError exception.
        if (Object(object) === object) {
            throw new TypeError(); // TODO message
        }
        // 2. Return the Boolean value of the [[Extensible]] internal property of O.
        var name = '';
        while (owns(object, name)) {
            name += '?';
        }
        object[name] = true;
        var returnValue = owns(object, name);
        delete object[name];
        return returnValue;
    };
}

// ES5 15.2.3.14
// http://es5.github.com/#x15.2.3.14
if (!Object.keys) {
    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
    var hasDontEnumBug = true,
        dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
        ],
        dontEnumsLength = dontEnums.length;

    for (var key in {"toString": null})
        hasDontEnumBug = false;

    Object.keys = function keys(object) {

        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError("Object.keys called on a non-object");

        var keys = [];
        for (var name in object) {
            if (owns(object, name)) {
                keys.push(name);
            }
        }

        if (hasDontEnumBug) {
            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                var dontEnum = dontEnums[i];
                if (owns(object, dontEnum)) {
                    keys.push(dontEnum);
                }
            }
        }

        return keys;
    };

}

//
// Date
// ====
//

// ES5 15.9.5.43
// http://es5.github.com/#x15.9.5.43
// This function returns a String value represent the instance in time 
// represented by this Date object. The format of the String is the Date Time 
// string format defined in 15.9.1.15. All fields are present in the String. 
// The time zone is always UTC, denoted by the suffix Z. If the time value of 
// this object is not a finite Number a RangeError exception is thrown.
if (!Date.prototype.toISOString || (new Date(-62198755200000).toISOString().indexOf('-000001') === -1)) {
    Date.prototype.toISOString = function toISOString() {
        var result, length, value, year;
        if (!isFinite(this))
            throw new RangeError;

        // the date time string format is specified in 15.9.1.15.
        result = [this.getUTCMonth() + 1, this.getUTCDate(),
            this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds()];
        year = this.getUTCFullYear();
        year = (year < 0 ? '-' : (year > 9999 ? '+' : '')) + ('00000' + Math.abs(year)).slice(0 <= year && year <= 9999 ? -4 : -6);

        length = result.length;
        while (length--) {
            value = result[length];
            // pad months, days, hours, minutes, and seconds to have two digits.
            if (value < 10)
                result[length] = "0" + value;
        }
        // pad milliseconds to have three digits.
        return year + "-" + result.slice(0, 2).join("-") + "T" + result.slice(2).join(":") + "." +
            ("000" + this.getUTCMilliseconds()).slice(-3) + "Z";
    }
}

// ES5 15.9.4.4
// http://es5.github.com/#x15.9.4.4
if (!Date.now) {
    Date.now = function now() {
        return new Date().getTime();
    };
}

// ES5 15.9.5.44
// http://es5.github.com/#x15.9.5.44
// This function provides a String representation of a Date object for use by 
// JSON.stringify (15.12.3).
if (!Date.prototype.toJSON) {
    Date.prototype.toJSON = function toJSON(key) {
        // When the toJSON method is called with argument key, the following 
        // steps are taken:

        // 1.  Let O be the result of calling ToObject, giving it the this
        // value as its argument.
        // 2. Let tv be ToPrimitive(O, hint Number).
        // 3. If tv is a Number and is not finite, return null.
        // XXX
        // 4. Let toISO be the result of calling the [[Get]] internal method of
        // O with argument "toISOString".
        // 5. If IsCallable(toISO) is false, throw a TypeError exception.
        if (typeof this.toISOString != "function")
            throw new TypeError(); // TODO message
        // 6. Return the result of calling the [[Call]] internal method of
        //  toISO with O as the this value and an empty argument list.
        return this.toISOString();

        // NOTE 1 The argument is ignored.

        // NOTE 2 The toJSON function is intentionally generic; it does not
        // require that its this value be a Date object. Therefore, it can be
        // transferred to other kinds of objects for use as a method. However,
        // it does require that any such object have a toISOString method. An
        // object is free to use the argument key to filter its
        // stringification.
    };
}

// ES5 15.9.4.2
// http://es5.github.com/#x15.9.4.2
// based on work shared by Daniel Friesen (dantman)
// http://gist.github.com/303249
if (Date.parse("+275760-09-13T00:00:00.000Z") !== 8.64e15) {
    // XXX global assignment won't work in embeddings that use
    // an alternate object for the context.
    Date = (function(NativeDate) {

        // Date.length === 7
        var Date = function Date(Y, M, D, h, m, s, ms) {
            var length = arguments.length;
            if (this instanceof NativeDate) {
                var date = length == 1 && String(Y) === Y ? // isString(Y)
                    // We explicitly pass it through parse:
                    new NativeDate(Date.parse(Y)) :
                    // We have to manually make calls depending on argument
                    // length here
                    length >= 7 ? new NativeDate(Y, M, D, h, m, s, ms) :
                    length >= 6 ? new NativeDate(Y, M, D, h, m, s) :
                    length >= 5 ? new NativeDate(Y, M, D, h, m) :
                    length >= 4 ? new NativeDate(Y, M, D, h) :
                    length >= 3 ? new NativeDate(Y, M, D) :
                    length >= 2 ? new NativeDate(Y, M) :
                    length >= 1 ? new NativeDate(Y) :
                                  new NativeDate();
                // Prevent mixups with unfixed Date object
                date.constructor = Date;
                return date;
            }
            return NativeDate.apply(this, arguments);
        };

        // 15.9.1.15 Date Time String Format.
        var isoDateExpression = new RegExp("^" +
            "(\\d{4}|[\+\-]\\d{6})" + // four-digit year capture or sign + 6-digit extended year
            "(?:-(\\d{2})" + // optional month capture
            "(?:-(\\d{2})" + // optional day capture
            "(?:" + // capture hours:minutes:seconds.milliseconds
                "T(\\d{2})" + // hours capture
                ":(\\d{2})" + // minutes capture
                "(?:" + // optional :seconds.milliseconds
                    ":(\\d{2})" + // seconds capture
                    "(?:\\.(\\d{3}))?" + // milliseconds capture
                ")?" +
            "(?:" + // capture UTC offset component
                "Z|" + // UTC capture
                "(?:" + // offset specifier +/-hours:minutes
                    "([-+])" + // sign capture
                    "(\\d{2})" + // hours offset capture
                    ":(\\d{2})" + // minutes offset capture
                ")" +
            ")?)?)?)?" +
        "$");

        // Copy any custom methods a 3rd party library may have added
        for (var key in NativeDate)
            Date[key] = NativeDate[key];

        // Copy "native" methods explicitly; they may be non-enumerable
        Date.now = NativeDate.now;
        Date.UTC = NativeDate.UTC;
        Date.prototype = NativeDate.prototype;
        Date.prototype.constructor = Date;

        // Upgrade Date.parse to handle simplified ISO 8601 strings
        Date.parse = function parse(string) {
            var match = isoDateExpression.exec(string);
            if (match) {
                match.shift(); // kill match[0], the full match
                // parse months, days, hours, minutes, seconds, and milliseconds
                for (var i = 1; i < 7; i++) {
                    // provide default values if necessary
                    match[i] = +(match[i] || (i < 3 ? 1 : 0));
                    // match[1] is the month. Months are 0-11 in JavaScript
                    // `Date` objects, but 1-12 in ISO notation, so we
                    // decrement.
                    if (i == 1)
                        match[i]--;
                }

                // parse the UTC offset component
                var minuteOffset = +match.pop(), hourOffset = +match.pop(), sign = match.pop();

                // compute the explicit time zone offset if specified
                var offset = 0;
                if (sign) {
                    // detect invalid offsets and return early
                    if (hourOffset > 23 || minuteOffset > 59)
                        return NaN;

                    // express the provided time zone offset in minutes. The offset is
                    // negative for time zones west of UTC; positive otherwise.
                    offset = (hourOffset * 60 + minuteOffset) * 6e4 * (sign == "+" ? -1 : 1);
                }

                // Date.UTC for years between 0 and 99 converts year to 1900 + year
                // The Gregorian calendar has a 400-year cycle, so 
                // to Date.UTC(year + 400, .... ) - 12622780800000 == Date.UTC(year, ...),
                // where 12622780800000 - number of milliseconds in Gregorian calendar 400 years
                var year = +match[0];
                if (0 <= year && year <= 99) {
                    match[0] = year + 400;
                    return NativeDate.UTC.apply(this, match) + offset - 12622780800000;
                }

                // compute a new UTC date value, accounting for the optional offset
                return NativeDate.UTC.apply(this, match) + offset;
            }
            return NativeDate.parse.apply(this, arguments);
        };

        return Date;
    })(Date);
}

//
// String
// ======
//

// ES5 15.5.4.20
// http://es5.github.com/#x15.5.4.20
var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
    "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
    "\u2029\uFEFF";
if (!String.prototype.trim || ws.trim()) {
    // http://blog.stevenlevithan.com/archives/faster-trim-javascript
    // http://perfectionkills.com/whitespace-deviations/
    ws = "[" + ws + "]";
    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
        trimEndRegexp = new RegExp(ws + ws + "*$");
    String.prototype.trim = function trim() {
        return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
    };
}

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer
var toInteger = function (n) {
    n = +n;
    if (n !== n) // isNaN
        n = 0;
    else if (n !== 0 && n !== (1/0) && n !== -(1/0))
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    return n;
};

var prepareString = "a"[0] != "a",
    // ES5 9.9
    // http://es5.github.com/#x9.9
    toObject = function (o) {
        if (o == null) { // this matches both null and undefined
            throw new TypeError(); // TODO message
        }
        // If the implementation doesn't support by-index access of
        // string characters (ex. IE < 7), split the string
        if (prepareString && typeof o == "string" && o) {
            return o.split("");
        }
        return Object(o);
    };
});/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Mihai Sucan <mihai AT sucan AT gmail ODT com>
 *      Irakli Gozalishvili <rfobic@gmail.com> (http://jeditoolkit.com)
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/lib/dom', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

var XHTML_NS = "http://www.w3.org/1999/xhtml";

exports.createElement = function(tag, ns) {
    return document.createElementNS ?
           document.createElementNS(ns || XHTML_NS, tag) :
           document.createElement(tag);
};

exports.setText = function(elem, text) {
    if (elem.innerText !== undefined) {
        elem.innerText = text;
    }
    if (elem.textContent !== undefined) {
        elem.textContent = text;
    }
};

exports.hasCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g);
    return classes.indexOf(name) !== -1;
};

/**
* Add a CSS class to the list of classes on the given node
*/
exports.addCssClass = function(el, name) {
    if (!exports.hasCssClass(el, name)) {
        el.className += " " + name;
    }
};

/**
* Remove a CSS class from the list of classes on the given node
*/
exports.removeCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g);
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        classes.splice(index, 1);
    }
    el.className = classes.join(" ");
};

exports.toggleCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g), add = true;
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        add = false;
        classes.splice(index, 1);
    }
    if(add)
        classes.push(name);

    el.className = classes.join(" ");
    return add;
};

/**
 * Add or remove a CSS class from the list of classes on the given node
 * depending on the value of <tt>include</tt>
 */
exports.setCssClass = function(node, className, include) {
    if (include) {
        exports.addCssClass(node, className);
    } else {
        exports.removeCssClass(node, className);
    }
};

exports.hasCssString = function(id, doc) {
    var index = 0, sheets;
    doc = doc || document;

    if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
        while (index < sheets.length)
            if (sheets[index++].owningElement.id === id) return true;
    } else if ((sheets = doc.getElementsByTagName("style"))) {
        while (index < sheets.length)
            if (sheets[index++].id === id) return true;
    }

    return false;
};

exports.importCssString = function importCssString(cssText, id, doc) {
    doc = doc || document;
    // If style is already imported return immediately.
    if (id && exports.hasCssString(id, doc))
        return null;
    
    var style;
    
    if (doc.createStyleSheet) {
        style = doc.createStyleSheet();
        style.cssText = cssText;
        if (id)
            style.owningElement.id = id;
    } else {
        style = doc.createElementNS
            ? doc.createElementNS(XHTML_NS, "style")
            : doc.createElement("style");

        style.appendChild(doc.createTextNode(cssText));
        if (id)
            style.id = id;

        var head = doc.getElementsByTagName("head")[0] || doc.documentElement;
        head.appendChild(style);
    }
};

exports.importCssStylsheet = function(uri, doc) {
    if (doc.createStyleSheet) {
        doc.createStyleSheet(uri);
    } else {
        var link = exports.createElement('link');
        link.rel = 'stylesheet';
        link.href = uri;

        var head = doc.getElementsByTagName("head")[0] || doc.documentElement;
        head.appendChild(link);
    }
};

exports.getInnerWidth = function(element) {
    return (
        parseInt(exports.computedStyle(element, "paddingLeft"), 10) +
        parseInt(exports.computedStyle(element, "paddingRight"), 10) + 
        element.clientWidth
    );
};

exports.getInnerHeight = function(element) {
    return (
        parseInt(exports.computedStyle(element, "paddingTop"), 10) +
        parseInt(exports.computedStyle(element, "paddingBottom"), 10) +
        element.clientHeight
    );
};

if (window.pageYOffset !== undefined) {
    exports.getPageScrollTop = function() {
        return window.pageYOffset;
    };

    exports.getPageScrollLeft = function() {
        return window.pageXOffset;
    };
}
else {
    exports.getPageScrollTop = function() {
        return document.body.scrollTop;
    };

    exports.getPageScrollLeft = function() {
        return document.body.scrollLeft;
    };
}

if (window.getComputedStyle)
    exports.computedStyle = function(element, style) {
        if (style)
            return (window.getComputedStyle(element, "") || {})[style] || "";
        return window.getComputedStyle(element, "") || {};
    };
else
    exports.computedStyle = function(element, style) {
        if (style)
            return element.currentStyle[style];
        return element.currentStyle;
    };

exports.scrollbarWidth = function(document) {

    var inner = exports.createElement("p");
    inner.style.width = "100%";
    inner.style.minWidth = "0px";
    inner.style.height = "200px";

    var outer = exports.createElement("div");
    var style = outer.style;

    style.position = "absolute";
    style.left = "-10000px";
    style.overflow = "hidden";
    style.width = "200px";
    style.minWidth = "0px";
    style.height = "150px";

    outer.appendChild(inner);

    var body = document.body || document.documentElement;
    body.appendChild(outer);

    var noScrollbar = inner.offsetWidth;

    style.overflow = "scroll";
    var withScrollbar = inner.offsetWidth;

    if (noScrollbar == withScrollbar) {
        withScrollbar = outer.clientWidth;
    }

    body.removeChild(outer);

    return noScrollbar-withScrollbar;
};

/**
 * Optimized set innerHTML. This is faster than plain innerHTML if the element
 * already contains a lot of child elements.
 *
 * See http://blog.stevenlevithan.com/archives/faster-than-innerhtml for details
 */
exports.setInnerHtml = function(el, innerHtml) {
    var element = el.cloneNode(false);//document.createElement("div");
    element.innerHTML = innerHtml;
    el.parentNode.replaceChild(element, el);
    return element;
};

exports.setInnerText = function(el, innerText) {
    var document = el.ownerDocument;
    if (document.body && "textContent" in document.body)
        el.textContent = innerText;
    else
        el.innerText = innerText;

};

exports.getInnerText = function(el) {
    var document = el.ownerDocument;
    if (document.body && "textContent" in document.body)
        return el.textContent;
    else
         return el.innerText || el.textContent || "";
};

exports.getParentWindow = function(document) {
    return document.defaultView || document.parentWindow;
};

});/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/lib/event', ['require', 'exports', 'module' , 'ace/lib/keys', 'ace/lib/useragent', 'ace/lib/dom'], function(require, exports, module) {
"use strict";

var keys = require("./keys");
var useragent = require("./useragent");
var dom = require("./dom");

exports.addListener = function(elem, type, callback) {
    if (elem.addEventListener) {
        return elem.addEventListener(type, callback, false);
    }
    if (elem.attachEvent) {
        var wrapper = function() {
            callback(window.event);
        };
        callback._wrapper = wrapper;
        elem.attachEvent("on" + type, wrapper);
    }
};

exports.removeListener = function(elem, type, callback) {
    if (elem.removeEventListener) {
        return elem.removeEventListener(type, callback, false);
    }
    if (elem.detachEvent) {
        elem.detachEvent("on" + type, callback._wrapper || callback);
    }
};

/**
* Prevents propagation and clobbers the default action of the passed event
*/
exports.stopEvent = function(e) {
    exports.stopPropagation(e);
    exports.preventDefault(e);
    return false;
};

exports.stopPropagation = function(e) {
    if (e.stopPropagation)
        e.stopPropagation();
    else
        e.cancelBubble = true;
};

exports.preventDefault = function(e) {
    if (e.preventDefault)
        e.preventDefault();
    else
        e.returnValue = false;
};

exports.getDocumentX = function(e) {
    if (e.clientX) {
        return e.clientX + dom.getPageScrollLeft();
    } else {
        return e.pageX;
    }
};

exports.getDocumentY = function(e) {
    if (e.clientY) {
        return e.clientY + dom.getPageScrollTop();
    } else {
        return e.pageY;
    }
};

/**
 * @return {Number} 0 for left button, 1 for middle button, 2 for right button
 */
exports.getButton = function(e) {
    if (e.type == "dblclick")
        return 0;
    else if (e.type == "contextmenu")
        return 2;

    // DOM Event
    if (e.preventDefault) {
        return e.button;
    }
    // old IE
    else {
        return {1:0, 2:2, 4:1}[e.button];
    }
};

if (document.documentElement.setCapture) {
    exports.capture = function(el, eventHandler, releaseCaptureHandler) {
        function onMouseMove(e) {
            eventHandler(e);
            return exports.stopPropagation(e);
        }

        var called = false;
        function onReleaseCapture(e) {
            eventHandler(e);

            if (!called) {
                called = true;
                releaseCaptureHandler(e);
            }

            exports.removeListener(el, "mousemove", eventHandler);
            exports.removeListener(el, "mouseup", onReleaseCapture);
            exports.removeListener(el, "losecapture", onReleaseCapture);

            el.releaseCapture();
        }

        exports.addListener(el, "mousemove", eventHandler);
        exports.addListener(el, "mouseup", onReleaseCapture);
        exports.addListener(el, "losecapture", onReleaseCapture);
        el.setCapture();
    };
}
else {
    exports.capture = function(el, eventHandler, releaseCaptureHandler) {
        function onMouseMove(e) {
            eventHandler(e);
            e.stopPropagation();
        }

        function onMouseUp(e) {
            eventHandler && eventHandler(e);
            releaseCaptureHandler && releaseCaptureHandler(e);

            document.removeEventListener("mousemove", onMouseMove, true);
            document.removeEventListener("mouseup", onMouseUp, true);

            e.stopPropagation();
        }

        document.addEventListener("mousemove", onMouseMove, true);
        document.addEventListener("mouseup", onMouseUp, true);
    };
}

exports.addMouseWheelListener = function(el, callback) {
    var factor = 8;
    var listener = function(e) {
        if (e.wheelDelta !== undefined) {
            if (e.wheelDeltaX !== undefined) {
                e.wheelX = -e.wheelDeltaX / factor;
                e.wheelY = -e.wheelDeltaY / factor;
            } else {
                e.wheelX = 0;
                e.wheelY = -e.wheelDelta / factor;
            }
        }
        else {
            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
                e.wheelX = (e.detail || 0) * 5;
                e.wheelY = 0;
            } else {
                e.wheelX = 0;
                e.wheelY = (e.detail || 0) * 5;
            }
        }
        callback(e);
    };
    exports.addListener(el, "DOMMouseScroll", listener);
    exports.addListener(el, "mousewheel", listener);
};

exports.addMultiMouseDownListener = function(el, button, count, timeout, callback) {
    var clicks = 0;
    var startX, startY;

    var listener = function(e) {
        clicks += 1;
        if (clicks == 1) {
            startX = e.clientX;
            startY = e.clientY;

            setTimeout(function() {
                clicks = 0;
            }, timeout || 600);
        }

        var isButton = exports.getButton(e) == button;
        if (!isButton || Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5)
            clicks = 0;

        if (clicks == count) {
            clicks = 0;
            callback(e);
        }

        if (isButton)
            return exports.preventDefault(e);
    };

    exports.addListener(el, "mousedown", listener);
    useragent.isOldIE && exports.addListener(el, "dblclick", listener);
};

function normalizeCommandKeys(callback, e, keyCode) {
    var hashId = 0;
    if (useragent.isOpera && useragent.isMac) {
        hashId = 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0)
            | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
    } else {
        hashId = 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0)
            | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
    }

    if (keyCode in keys.MODIFIER_KEYS) {
        switch (keys.MODIFIER_KEYS[keyCode]) {
            case "Alt":
                hashId = 2;
                break;
            case "Shift":
                hashId = 4;
                break;
            case "Ctrl":
                hashId = 1;
                break;
            default:
                hashId = 8;
                break;
        }
        keyCode = 0;
    }

    if (hashId & 8 && (keyCode == 91 || keyCode == 93)) {
        keyCode = 0;
    }

    // If there is no hashID and the keyCode is not a function key, then
    // we don't call the callback as we don't handle a command key here
    // (it's a normal key/character input).
    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
        return false;
    }
    return callback(e, hashId, keyCode);
}

exports.addCommandKeyListener = function(el, callback) {
    var addListener = exports.addListener;
    if (useragent.isOldGecko || useragent.isOpera) {
        // Old versions of Gecko aka. Firefox < 4.0 didn't repeat the keydown
        // event if the user pressed the key for a longer time. Instead, the
        // keydown event was fired once and later on only the keypress event.
        // To emulate the 'right' keydown behavior, the keyCode of the initial
        // keyDown event is stored and in the following keypress events the
        // stores keyCode is used to emulate a keyDown event.
        var lastKeyDownKeyCode = null;
        addListener(el, "keydown", function(e) {
            lastKeyDownKeyCode = e.keyCode;
        });
        addListener(el, "keypress", function(e) {
            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
        });
    } else {
        var lastDown = null;

        addListener(el, "keydown", function(e) {
            lastDown = e.keyIdentifier || e.keyCode;
            return normalizeCommandKeys(callback, e, e.keyCode);
        });
    }
};

if (window.postMessage) {
    var postMessageId = 1;
    exports.nextTick = function(callback, win) {
        win = win || window;
        var messageName = "zero-timeout-message-" + postMessageId;            
        exports.addListener(win, "message", function listener(e) {
            if (e.data == messageName) {
                exports.stopPropagation(e);
                exports.removeListener(win, "message", listener);
                callback();
            }
        });
        win.postMessage(messageName, "*");
    };
}
else {
    exports.nextTick = function(callback, win) {
        win = win || window;
        window.setTimeout(callback, 0);
    };
}

});
/*! @license
==========================================================================
SproutCore -- JavaScript Application Framework
copyright 2006-2009, Sprout Systems Inc., Apple Inc. and contributors.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

SproutCore and the SproutCore logo are trademarks of Sprout Systems, Inc.

For more information about SproutCore, visit http://www.sproutcore.com


==========================================================================
@license */

// Most of the following code is taken from SproutCore with a few changes.

define('ace/lib/keys', ['require', 'exports', 'module' , 'ace/lib/oop'], function(require, exports, module) {
"use strict";

var oop = require("./oop");

/**
 * Helper functions and hashes for key handling.
 */
var Keys = (function() {
    var ret = {
        MODIFIER_KEYS: {
            16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'
        },

        KEY_MODS: {
            "ctrl": 1, "alt": 2, "option" : 2,
            "shift": 4, "meta": 8, "command": 8
        },

        FUNCTION_KEYS : {
            8  : "Backspace",
            9  : "Tab",
            13 : "Return",
            19 : "Pause",
            27 : "Esc",
            32 : "Space",
            33 : "PageUp",
            34 : "PageDown",
            35 : "End",
            36 : "Home",
            37 : "Left",
            38 : "Up",
            39 : "Right",
            40 : "Down",
            44 : "Print",
            45 : "Insert",
            46 : "Delete",
            96 : "Numpad0",
            97 : "Numpad1",
            98 : "Numpad2",
            99 : "Numpad3",
            100: "Numpad4",
            101: "Numpad5",
            102: "Numpad6",
            103: "Numpad7",
            104: "Numpad8",
            105: "Numpad9",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "Numlock",
            145: "Scrolllock"
        },

        PRINTABLE_KEYS: {
           32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',
           54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',
           66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',
           73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',
           80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',
           87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',
          188: ',', 190: '.', 191: '/', 192: '`', 219: '[', 220: '\\',
          221: ']', 222: '\"'
        }
    };

    // A reverse map of FUNCTION_KEYS
    for (var i in ret.FUNCTION_KEYS) {
        var name = ret.FUNCTION_KEYS[i].toUpperCase();
        ret[name] = parseInt(i, 10);
    }

    // Add the MODIFIER_KEYS, FUNCTION_KEYS and PRINTABLE_KEYS to the KEY
    // variables as well.
    oop.mixin(ret, ret.MODIFIER_KEYS);
    oop.mixin(ret, ret.PRINTABLE_KEYS);
    oop.mixin(ret, ret.FUNCTION_KEYS);

    return ret;
})();
oop.mixin(exports, Keys);

exports.keyCodeToString = function(keyCode) {
    return (Keys[keyCode] || String.fromCharCode(keyCode)).toLowerCase();
}

});/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/lib/oop', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

exports.inherits = (function() {
    var tempCtor = function() {};
    return function(ctor, superCtor) {
        tempCtor.prototype = superCtor.prototype;
        ctor.super_ = superCtor.prototype;
        ctor.prototype = new tempCtor();
        ctor.prototype.constructor = ctor;
    };
}());

exports.mixin = function(obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
};

exports.implement = function(proto, mixin) {
    exports.mixin(proto, mixin);
};

});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/lib/useragent', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
var ua = navigator.userAgent;

/** Is the user using a browser that identifies itself as Windows */
exports.isWin = (os == "win");

/** Is the user using a browser that identifies itself as Mac OS */
exports.isMac = (os == "mac");

/** Is the user using a browser that identifies itself as Linux */
exports.isLinux = (os == "linux");

exports.isIE = 
    navigator.appName == "Microsoft Internet Explorer"
    && parseFloat(navigator.userAgent.match(/MSIE ([0-9]+[\.0-9]+)/)[1]);
    
exports.isOldIE = exports.isIE && exports.isIE < 9;

/** Is this Firefox or related? */
exports.isGecko = exports.isMozilla = window.controllers && window.navigator.product === "Gecko";

/** oldGecko == rev < 2.0 **/
exports.isOldGecko = exports.isGecko && parseInt((navigator.userAgent.match(/rv\:(\d+)/)||[])[1], 10) < 4;

/** Is this Opera */
exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";

/** Is the user using a browser that identifies itself as WebKit */
exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

exports.isIPad = ua.indexOf("iPad") >= 0;

exports.isTouchPad = ua.indexOf("TouchPad") >= 0;

/**
 * I hate doing this, but we need some way to determine if the user is on a Mac
 * The reason is that users have different expectations of their key combinations.
 *
 * Take copy as an example, Mac people expect to use CMD or APPLE + C
 * Windows folks expect to use CTRL + C
 */
exports.OS = {
    LINUX: "LINUX",
    MAC: "MAC",
    WINDOWS: "WINDOWS"
};

/**
 * Return an exports.OS constant
 */
exports.getOS = function() {
    if (exports.isMac) {
        return exports.OS.MAC;
    } else if (exports.isLinux) {
        return exports.OS.LINUX;
    } else {
        return exports.OS.WINDOWS;
    }
};

});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Irakli Gozalishvili <rfobic@gmail.com> (http://jeditoolkit.com)
 *      Julian Viereck <julian.viereck@gmail.com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/editor', ['require', 'exports', 'module' , 'ace/lib/fixoldbrowsers', 'ace/lib/oop', 'ace/lib/lang', 'ace/lib/useragent', 'ace/keyboard/textinput', 'ace/mouse/mouse_handler', 'ace/mouse/fold_handler', 'ace/keyboard/keybinding', 'ace/edit_session', 'ace/search', 'ace/range', 'ace/lib/event_emitter', 'ace/commands/command_manager', 'ace/commands/default_commands'], function(require, exports, module) {
"use strict";

require("./lib/fixoldbrowsers");

var oop = require("./lib/oop");
var lang = require("./lib/lang");
var useragent = require("./lib/useragent");
var TextInput = require("./keyboard/textinput").TextInput;
var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
var FoldHandler = require("./mouse/fold_handler").FoldHandler;
//var TouchHandler = require("./touch_handler").TouchHandler;
var KeyBinding = require("./keyboard/keybinding").KeyBinding;
var EditSession = require("./edit_session").EditSession;
var Search = require("./search").Search;
var Range = require("./range").Range;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var CommandManager = require("./commands/command_manager").CommandManager;
var defaultCommands = require("./commands/default_commands").commands;

var Editor = function(renderer, session) {
    var container = renderer.getContainerElement();
    this.container = container;
    this.renderer = renderer;
    
    this.textInput  = new TextInput(renderer.getTextAreaContainer(), this);
    this.keyBinding = new KeyBinding(this);

    // TODO detect touch event support
    if (useragent.isIPad) {
        //this.$mouseHandler = new TouchHandler(this);
    } else {
        this.$mouseHandler = new MouseHandler(this);
        new FoldHandler(this);
    }

    this.$blockScrolling = 0;
    this.$search = new Search().set({
        wrap: true
    });

    this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
    this.setSession(session || new EditSession(""));
};

(function(){

    oop.implement(this, EventEmitter);

    this.setKeyboardHandler = function(keyboardHandler) {
        this.keyBinding.setKeyboardHandler(keyboardHandler);
    };

    this.getKeyboardHandler = function() {
        return this.keyBinding.getKeyboardHandler();
    };

    this.setSession = function(session) {
        if (this.session == session)
            return;

        if (this.session) {
            var oldSession = this.session;
            this.session.removeEventListener("change", this.$onDocumentChange);
            this.session.removeEventListener("changeMode", this.$onChangeMode);
            this.session.removeEventListener("tokenizerUpdate", this.$onTokenizerUpdate);
            this.session.removeEventListener("changeTabSize", this.$onChangeTabSize);
            this.session.removeEventListener("changeWrapLimit", this.$onChangeWrapLimit);
            this.session.removeEventListener("changeWrapMode", this.$onChangeWrapMode);
            this.session.removeEventListener("onChangeFold", this.$onChangeFold);
            this.session.removeEventListener("changeFrontMarker", this.$onChangeFrontMarker);
            this.session.removeEventListener("changeBackMarker", this.$onChangeBackMarker);
            this.session.removeEventListener("changeBreakpoint", this.$onChangeBreakpoint);
            this.session.removeEventListener("changeAnnotation", this.$onChangeAnnotation);
            this.session.removeEventListener("changeOverwrite", this.$onCursorChange);
            this.session.removeEventListener("changeScrollTop", this.$onScrollTopChange);
            this.session.removeEventListener("changeLeftTop", this.$onScrollLeftChange);

            var selection = this.session.getSelection();
            selection.removeEventListener("changeCursor", this.$onCursorChange);
            selection.removeEventListener("changeSelection", this.$onSelectionChange);
        }

        this.session = session;

        this.$onDocumentChange = this.onDocumentChange.bind(this);
        session.addEventListener("change", this.$onDocumentChange);
        this.renderer.setSession(session);

        this.$onChangeMode = this.onChangeMode.bind(this);
        session.addEventListener("changeMode", this.$onChangeMode);

        this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
        session.addEventListener("tokenizerUpdate", this.$onTokenizerUpdate);

        this.$onChangeTabSize = this.renderer.updateText.bind(this.renderer);
        session.addEventListener("changeTabSize", this.$onChangeTabSize);

        this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
        session.addEventListener("changeWrapLimit", this.$onChangeWrapLimit);

        this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
        session.addEventListener("changeWrapMode", this.$onChangeWrapMode);

        this.$onChangeFold = this.onChangeFold.bind(this);
        session.addEventListener("changeFold", this.$onChangeFold);

        this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
        this.session.addEventListener("changeFrontMarker", this.$onChangeFrontMarker);

        this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
        this.session.addEventListener("changeBackMarker", this.$onChangeBackMarker);

        this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
        this.session.addEventListener("changeBreakpoint", this.$onChangeBreakpoint);

        this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
        this.session.addEventListener("changeAnnotation", this.$onChangeAnnotation);

        this.$onCursorChange = this.onCursorChange.bind(this);
        this.session.addEventListener("changeOverwrite", this.$onCursorChange);

        this.$onScrollTopChange = this.onScrollTopChange.bind(this);
        this.session.addEventListener("changeScrollTop", this.$onScrollTopChange);

        this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
        this.session.addEventListener("changeScrollLeft", this.$onScrollLeftChange);

        this.selection = session.getSelection();
        this.selection.addEventListener("changeCursor", this.$onCursorChange);

        this.$onSelectionChange = this.onSelectionChange.bind(this);
        this.selection.addEventListener("changeSelection", this.$onSelectionChange);

        this.onChangeMode();

        this.$blockScrolling += 1;
        this.onCursorChange();
        this.$blockScrolling -= 1;

        this.onScrollTopChange();
        this.onScrollLeftChange();
        this.onSelectionChange();
        this.onChangeFrontMarker();
        this.onChangeBackMarker();
        this.onChangeBreakpoint();
        this.onChangeAnnotation();
        this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
        this.renderer.updateFull();

        this._emit("changeSession", {
            session: session,
            oldSession: oldSession
        });
    };

    this.getSession = function() {
        return this.session;
    };

    this.getSelection = function() {
        return this.selection;
    };

    this.resize = function() {
        this.renderer.onResize();
    };

    this.setTheme = function(theme) {
        this.renderer.setTheme(theme);
    };

    this.getTheme = function() {
        return this.renderer.getTheme();
    };

    this.setStyle = function(style) {
        this.renderer.setStyle(style);
    };

    this.unsetStyle = function(style) {
        this.renderer.unsetStyle(style);
    };

    this.setFontSize = function(size) {
        this.container.style.fontSize = size;
        this.renderer.updateFontSize();
    };

    this.$highlightBrackets = function() {
        if (this.session.$bracketHighlight) {
            this.session.removeMarker(this.session.$bracketHighlight);
            this.session.$bracketHighlight = null;
        }

        if (this.$highlightPending) {
            return;
        }

        // perform highlight async to not block the browser during navigation
        var self = this;
        this.$highlightPending = true;
        setTimeout(function() {
            self.$highlightPending = false;

            var pos = self.session.findMatchingBracket(self.getCursorPosition());
            if (pos) {
                var range = new Range(pos.row, pos.column, pos.row, pos.column+1);
                self.session.$bracketHighlight = self.session.addMarker(range, "ace_bracket", "text");
            }
        }, 10);
    };

    this.focus = function() {
        // Safari needs the timeout
        // iOS and Firefox need it called immediately
        // to be on the save side we do both
        var _self = this;
        setTimeout(function() {
            _self.textInput.focus();
        });
        this.textInput.focus();
    };

    this.isFocused = function() {
        return this.textInput.isFocused();
    };

    this.blur = function() {
        this.textInput.blur();
    };

    this.onFocus = function() {
        this.renderer.showCursor();
        this.renderer.visualizeFocus();
        this._emit("focus");
    };

    this.onBlur = function() {
        this.renderer.hideCursor();
        this.renderer.visualizeBlur();
        this._emit("blur");
    };

    this.onDocumentChange = function(e) {
        var delta = e.data;
        var range = delta.range;
        var lastRow;

        if (range.start.row == range.end.row && delta.action != "insertLines" && delta.action != "removeLines")
            lastRow = range.end.row;
        else
            lastRow = Infinity;
        this.renderer.updateLines(range.start.row, lastRow);

        this._emit("change", e);

        // update cursor because tab characters can influence the cursor position
        this.onCursorChange();
    };

    this.onTokenizerUpdate = function(e) {
        var rows = e.data;
        this.renderer.updateLines(rows.first, rows.last);
    };

    this.onScrollTopChange = function() {
        this.renderer.scrollToY(this.session.getScrollTop());
    };

    this.onScrollLeftChange = function() {
        this.renderer.scrollToX(this.session.getScrollLeft());
    };

    this.onCursorChange = function() {
        this.renderer.updateCursor();

        if (!this.$blockScrolling) {
            this.renderer.scrollCursorIntoView();
        }

        // move text input over the cursor
        // this is required for iOS and IME
        this.renderer.moveTextAreaToCursor(this.textInput.getElement());

        this.$highlightBrackets();
        this.$updateHighlightActiveLine();
    };

    this.$updateHighlightActiveLine = function() {
        var session = this.getSession();

        if (session.$highlightLineMarker) {
            session.removeMarker(session.$highlightLineMarker);
        }
        session.$highlightLineMarker = null;

        if (this.getHighlightActiveLine() && (this.getSelectionStyle() != "line" || !this.selection.isMultiLine())) {
            var cursor = this.getCursorPosition(),
                foldLine = this.session.getFoldLine(cursor.row);
            var range;
            if (foldLine) {
                range = new Range(foldLine.start.row, 0, foldLine.end.row + 1, 0);
            } else {
                range = new Range(cursor.row, 0, cursor.row+1, 0);
            }
            session.$highlightLineMarker = session.addMarker(range, "ace_active_line", "background");
        }
    };

    this.onSelectionChange = function(e) {
        var session = this.getSession();

        if (session.$selectionMarker) {
            session.removeMarker(session.$selectionMarker);
        }
        session.$selectionMarker = null;

        if (!this.selection.isEmpty()) {
            var range = this.selection.getRange();
            var style = this.getSelectionStyle();
            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
        } else {
            this.$updateHighlightActiveLine();
        }

        if (this.$highlightSelectedWord)
            this.session.getMode().highlightSelection(this);
    };

    this.onChangeFrontMarker = function() {
        this.renderer.updateFrontMarkers();
    };

    this.onChangeBackMarker = function() {
        this.renderer.updateBackMarkers();
    };

    this.onChangeBreakpoint = function() {
        this.renderer.setBreakpoints(this.session.getBreakpoints());
    };

    this.onChangeAnnotation = function() {
        this.renderer.setAnnotations(this.session.getAnnotations());
    };

    this.onChangeMode = function() {
        this.renderer.updateText();
    };

    this.onChangeWrapLimit = function() {
        this.renderer.updateFull();
    };

    this.onChangeWrapMode = function() {
        this.renderer.onResize(true);
    };

    this.onChangeFold = function() {
        // Update the active line marker as due to folding changes the current
        // line range on the screen might have changed.
        this.$updateHighlightActiveLine();
        // TODO: This might be too much updating. Okay for now.
        this.renderer.updateFull();
    };

    this.getCopyText = function() {
        var text = "";
        if (!this.selection.isEmpty())
            text = this.session.getTextRange(this.getSelectionRange());

        this._emit("copy", text);
        return text;
    };

    this.onCut = function() {
        if (this.$readOnly)
            return;

        var range = this.getSelectionRange();
        this._emit("cut", range);

        if (!this.selection.isEmpty()) {
            this.session.remove(range);
            this.clearSelection();
        }
    };

    this.insert = function(text) {
        var session = this.session;
        var mode = session.getMode();

        var cursor = this.getCursorPosition();

        if (this.getBehavioursEnabled()) {
            // Get a transform if the current mode wants one.
            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
            if (transform)
                text = transform.text;
        }

        text = text.replace("\t", this.session.getTabString());

        // remove selected text
        if (!this.selection.isEmpty()) {
            cursor = this.session.remove(this.getSelectionRange());
            this.clearSelection();
        }
        else if (this.session.getOverwrite()) {
            var range = new Range.fromPoints(cursor, cursor);
            range.end.column += text.length;
            this.session.remove(range);
        }

        this.clearSelection();

        var start = cursor.column;
        var lineState = session.getState(cursor.row);
        var shouldOutdent = mode.checkOutdent(lineState, session.getLine(cursor.row), text);
        var line = session.getLine(cursor.row);
        var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
        var end = session.insert(cursor, text);

        if (transform && transform.selection) {
            if (transform.selection.length == 2) { // Transform relative to the current column
                this.selection.setSelectionRange(
                    new Range(cursor.row, start + transform.selection[0],
                              cursor.row, start + transform.selection[1]));
            } else { // Transform relative to the current row.
                this.selection.setSelectionRange(
                    new Range(cursor.row + transform.selection[0],
                              transform.selection[1],
                              cursor.row + transform.selection[2],
                              transform.selection[3]));
            }
        }

        var lineState = session.getState(cursor.row);

        // TODO disabled multiline auto indent
        // possibly doing the indent before inserting the text
        // if (cursor.row !== end.row) {
        if (session.getDocument().isNewLine(text)) {
            this.moveCursorTo(cursor.row+1, 0);

            var size = session.getTabSize();
            var minIndent = Number.MAX_VALUE;

            for (var row = cursor.row + 1; row <= end.row; ++row) {
                var indent = 0;

                line = session.getLine(row);
                for (var i = 0; i < line.length; ++i)
                    if (line.charAt(i) == '\t')
                        indent += size;
                    else if (line.charAt(i) == ' ')
                        indent += 1;
                    else
                        break;
                if (/[^\s]/.test(line))
                    minIndent = Math.min(indent, minIndent);
            }

            for (var row = cursor.row + 1; row <= end.row; ++row) {
                var outdent = minIndent;

                line = session.getLine(row);
                for (var i = 0; i < line.length && outdent > 0; ++i)
                    if (line.charAt(i) == '\t')
                        outdent -= size;
                    else if (line.charAt(i) == ' ')
                        outdent -= 1;
                session.remove(new Range(row, 0, row, i));
            }
            session.indentRows(cursor.row + 1, end.row, lineIndent);
        }
        if (shouldOutdent)
            mode.autoOutdent(lineState, session, cursor.row);
    };

    this.onTextInput = function(text, pasted) {
        if (pasted)
            this._emit("paste", text);

        this.keyBinding.onTextInput(text, pasted);
    };

    this.onCommandKey = function(e, hashId, keyCode) {
        this.keyBinding.onCommandKey(e, hashId, keyCode);
    };

    this.setOverwrite = function(overwrite) {
        this.session.setOverwrite(overwrite);
    };

    this.getOverwrite = function() {
        return this.session.getOverwrite();
    };

    this.toggleOverwrite = function() {
        this.session.toggleOverwrite();
    };

    this.setScrollSpeed = function(speed) {
        this.$mouseHandler.setScrollSpeed(speed);
    };

    this.getScrollSpeed = function() {
        return this.$mouseHandler.getScrollSpeed();
    };

    this.setDragDelay = function(dragDelay) {
        this.$mouseHandler.setDragDelay(dragDelay);
    };

    this.getDragDelay = function() {
        return this.$mouseHandler.getDragDelay();
    };

    this.$selectionStyle = "line";
    this.setSelectionStyle = function(style) {
        if (this.$selectionStyle == style) return;

        this.$selectionStyle = style;
        this.onSelectionChange();
        this._emit("changeSelectionStyle", {data: style});
    };

    this.getSelectionStyle = function() {
        return this.$selectionStyle;
    };

    this.$highlightActiveLine = true;
    this.setHighlightActiveLine = function(shouldHighlight) {
        if (this.$highlightActiveLine == shouldHighlight) return;

        this.$highlightActiveLine = shouldHighlight;
        this.$updateHighlightActiveLine();
    };

    this.getHighlightActiveLine = function() {
        return this.$highlightActiveLine;
    };

    this.$highlightSelectedWord = true;
    this.setHighlightSelectedWord = function(shouldHighlight) {
        if (this.$highlightSelectedWord == shouldHighlight)
            return;

        this.$highlightSelectedWord = shouldHighlight;
        if (shouldHighlight)
            this.session.getMode().highlightSelection(this);
        else
            this.session.getMode().clearSelectionHighlight(this);
    };

    this.getHighlightSelectedWord = function() {
        return this.$highlightSelectedWord;
    };

    this.setShowInvisibles = function(showInvisibles) {
        if (this.getShowInvisibles() == showInvisibles)
            return;

        this.renderer.setShowInvisibles(showInvisibles);
    };

    this.getShowInvisibles = function() {
        return this.renderer.getShowInvisibles();
    };

    this.setShowPrintMargin = function(showPrintMargin) {
        this.renderer.setShowPrintMargin(showPrintMargin);
    };

    this.getShowPrintMargin = function() {
        return this.renderer.getShowPrintMargin();
    };

    this.setPrintMarginColumn = function(showPrintMargin) {
        this.renderer.setPrintMarginColumn(showPrintMargin);
    };

    this.getPrintMarginColumn = function() {
        return this.renderer.getPrintMarginColumn();
    };

    this.$readOnly = false;
    this.setReadOnly = function(readOnly) {
        this.$readOnly = readOnly;
    };

    this.getReadOnly = function() {
        return this.$readOnly;
    };

    this.$modeBehaviours = true;
    this.setBehavioursEnabled = function (enabled) {
        this.$modeBehaviours = enabled;
    };

    this.getBehavioursEnabled = function () {
        return this.$modeBehaviours;
    };

    this.setShowFoldWidgets = function(show) {
        var gutter = this.renderer.$gutterLayer;
        if (gutter.getShowFoldWidgets() == show)
            return;

        this.renderer.$gutterLayer.setShowFoldWidgets(show);
        this.$showFoldWidgets = show;
        this.renderer.updateFull();
    };
    
    this.getShowFoldWidgets = function() {
        return this.renderer.$gutterLayer.getShowFoldWidgets();
    };

    this.remove = function(dir) {
        if (this.selection.isEmpty()){
            if(dir == "left")
                this.selection.selectLeft();
            else
                this.selection.selectRight();
        }

        var range = this.getSelectionRange();
        if (this.getBehavioursEnabled()) {
            var session = this.session;
            var state = session.getState(range.start.row);
            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);
            if (new_range)
                range = new_range;
        }

        this.session.remove(range);
        this.clearSelection();
    };

    this.removeWordRight = function() {
        if (this.selection.isEmpty())
            this.selection.selectWordRight();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };

    this.removeWordLeft = function() {
        if (this.selection.isEmpty())
            this.selection.selectWordLeft();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };

    this.removeToLineStart = function() {
        if (this.selection.isEmpty())
            this.selection.selectLineStart();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };

    this.removeToLineEnd = function() {
        if (this.selection.isEmpty())
            this.selection.selectLineEnd();

        var range = this.getSelectionRange();
        if (range.start.column == range.end.column && range.start.row == range.end.row) {
            range.end.column = 0;
            range.end.row++;
        }

        this.session.remove(range);
        this.clearSelection();
    };

    this.splitLine = function() {
        if (!this.selection.isEmpty()) {
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        }

        var cursor = this.getCursorPosition();
        this.insert("\n");
        this.moveCursorToPosition(cursor);
    };

    this.transposeLetters = function() {
        if (!this.selection.isEmpty()) {
            return;
        }

        var cursor = this.getCursorPosition();
        var column = cursor.column;
        if (column === 0)
            return;

        var line = this.session.getLine(cursor.row);
        var swap, range;
        if (column < line.length) {
            swap = line.charAt(column) + line.charAt(column-1);
            range = new Range(cursor.row, column-1, cursor.row, column+1);
        }
        else {
            swap = line.charAt(column-1) + line.charAt(column-2);
            range = new Range(cursor.row, column-2, cursor.row, column);
        }
        this.session.replace(range, swap);
    };

    this.toLowerCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toLowerCase());
        this.selection.setSelectionRange(originalRange);
    };

    this.toUpperCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toUpperCase());
        this.selection.setSelectionRange(originalRange);
    };

    this.indent = function() {
        var session = this.session;
        var range = this.getSelectionRange();

        if (range.start.row < range.end.row || range.start.column < range.end.column) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, "\t");
        } else {
            var indentString;

            if (this.session.getUseSoftTabs()) {
                var size        = session.getTabSize(),
                    position    = this.getCursorPosition(),
                    column      = session.documentToScreenColumn(position.row, position.column),
                    count       = (size - column % size);

                indentString = lang.stringRepeat(" ", count);
            } else
                indentString = "\t";
            return this.insert(indentString);
        }
    };

    this.blockOutdent = function() {
        var selection = this.session.getSelection();
        this.session.outdentRows(selection.getRange());
    };

    this.toggleCommentLines = function() {
        var state = this.session.getState(this.getCursorPosition().row);
        var rows = this.$getSelectedRows();
        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
    };

    this.removeLines = function() {
        var rows = this.$getSelectedRows();
        var range;
        if (rows.first === 0 || rows.last+1 < this.session.getLength())
            range = new Range(rows.first, 0, rows.last+1, 0);
        else
            range = new Range(
                rows.first-1, this.session.getLine(rows.first-1).length,
                rows.last, this.session.getLine(rows.last).length
            );
        this.session.remove(range);
        this.clearSelection();
    };

    this.moveLinesDown = function() {
        this.$moveLines(function(firstRow, lastRow) {
            return this.session.moveLinesDown(firstRow, lastRow);
        });
    };

    this.moveLinesUp = function() {
        this.$moveLines(function(firstRow, lastRow) {
            return this.session.moveLinesUp(firstRow, lastRow);
        });
    };

    this.moveText = function(range, toPosition) {
        if (this.$readOnly)
            return null;

        return this.session.moveText(range, toPosition);
    };

    this.copyLinesUp = function() {
        this.$moveLines(function(firstRow, lastRow) {
            this.session.duplicateLines(firstRow, lastRow);
            return 0;
        });
    };

    this.copyLinesDown = function() {
        this.$moveLines(function(firstRow, lastRow) {
            return this.session.duplicateLines(firstRow, lastRow);
        });
    };


    this.$moveLines = function(mover) {
        var rows = this.$getSelectedRows();
        var selection = this.selection;
        if (!selection.isMultiLine()) {
            var range = selection.getRange();
            var reverse = selection.isBackwards();
        }

        var linesMoved = mover.call(this, rows.first, rows.last);

        if (range) {
            range.start.row += linesMoved;
            range.end.row += linesMoved;
            selection.setSelectionRange(range, reverse);
        } 
        else {
            selection.setSelectionAnchor(rows.last+linesMoved+1, 0);
            selection.$moveSelection(function() {
                selection.moveCursorTo(rows.first+linesMoved, 0);
            });
        }
    };

    this.$getSelectedRows = function() {
        var range = this.getSelectionRange().collapseRows();

        return {
            first: range.start.row,
            last: range.end.row
        };
    };

    this.onCompositionStart = function(text) {
        this.renderer.showComposition(this.getCursorPosition());
    };

    this.onCompositionUpdate = function(text) {
        this.renderer.setCompositionText(text);
    };

    this.onCompositionEnd = function() {
        this.renderer.hideComposition();
    };

    this.getFirstVisibleRow = function() {
        return this.renderer.getFirstVisibleRow();
    };

    this.getLastVisibleRow = function() {
        return this.renderer.getLastVisibleRow();
    };

    this.isRowVisible = function(row) {
        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
    };

    this.isRowFullyVisible = function(row) {
        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
    };

    this.$getVisibleRowCount = function() {
        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
    };

    this.$getPageDownRow = function() {
        return this.renderer.getScrollBottomRow();
    };

    this.$getPageUpRow = function() {
        var firstRow = this.renderer.getScrollTopRow();
        var lastRow = this.renderer.getScrollBottomRow();

        return firstRow - (lastRow - firstRow);
    };

    this.selectPageDown = function() {
        var row = this.$getPageDownRow() + Math.floor(this.$getVisibleRowCount() / 2);

        this.scrollPageDown();

        var selection = this.getSelection();
        var leadScreenPos = this.session.documentToScreenPosition(selection.getSelectionLead());
        var dest = this.session.screenToDocumentPosition(row, leadScreenPos.column);
        selection.selectTo(dest.row, dest.column);
    };

    this.selectPageUp = function() {
        var visibleRows = this.renderer.getScrollTopRow() - this.renderer.getScrollBottomRow();
        var row = this.$getPageUpRow() + Math.round(visibleRows / 2);

        this.scrollPageUp();

        var selection = this.getSelection();
        var leadScreenPos = this.session.documentToScreenPosition(selection.getSelectionLead());
        var dest = this.session.screenToDocumentPosition(row, leadScreenPos.column);
        selection.selectTo(dest.row, dest.column);
    };

    this.gotoPageDown = function() {
        var row = this.$getPageDownRow();
        var column = this.getCursorPositionScreen().column;

        this.scrollToRow(row);
        this.getSelection().moveCursorToScreen(row, column);
    };

    this.gotoPageUp = function() {
        var row = this.$getPageUpRow();
        var column = this.getCursorPositionScreen().column;

       this.scrollToRow(row);
       this.getSelection().moveCursorToScreen(row, column);
    };

    this.scrollPageDown = function() {
        this.scrollToRow(this.$getPageDownRow());
    };

    this.scrollPageUp = function() {
        this.renderer.scrollToRow(this.$getPageUpRow());
    };

    this.scrollToRow = function(row) {
        this.renderer.scrollToRow(row);
    };

    this.scrollToLine = function(line, center) {
        this.renderer.scrollToLine(line, center);
    };

    this.centerSelection = function() {
        var range = this.getSelectionRange();
        var line = Math.floor(range.start.row + (range.end.row - range.start.row) / 2);
        this.renderer.scrollToLine(line, true);
    };

    this.getCursorPosition = function() {
        return this.selection.getCursor();
    };

    this.getCursorPositionScreen = function() {
        return this.session.documentToScreenPosition(this.getCursorPosition());
    };

    this.getSelectionRange = function() {
        return this.selection.getRange();
    };


    this.selectAll = function() {
        this.$blockScrolling += 1;
        this.selection.selectAll();
        this.$blockScrolling -= 1;
    };

    this.clearSelection = function() {
        this.selection.clearSelection();
    };

    this.moveCursorTo = function(row, column) {
        this.selection.moveCursorTo(row, column);
    };

    this.moveCursorToPosition = function(pos) {
        this.selection.moveCursorToPosition(pos);
    };

    this.jumpToMatching = function() {
        var cursor = this.getCursorPosition();
        var pos = this.session.findMatchingBracket(cursor);
        if (!pos) {
            cursor.column += 1;
            pos = this.session.findMatchingBracket(cursor);
        }
        if (!pos) {
            cursor.column -= 2;
            pos = this.session.findMatchingBracket(cursor);
        }
        
        if (pos) {
            this.clearSelection();
            this.moveCursorTo(pos.row, pos.column);
        }
    };
    
    this.gotoLine = function(lineNumber, column) {
        this.selection.clearSelection();
        this.session.unfold({row: lineNumber - 1, column: column || 0});

        this.$blockScrolling += 1;
        this.moveCursorTo(lineNumber-1, column || 0);
        this.$blockScrolling -= 1;
        if (!this.isRowFullyVisible(this.getCursorPosition().row))
            this.scrollToLine(lineNumber, true);
    };

    this.navigateTo = function(row, column) {
        this.clearSelection();
        this.moveCursorTo(row, column);
    };

    this.navigateUp = function(times) {
        this.selection.clearSelection();
        times = times || 1;
        this.selection.moveCursorBy(-times, 0);
    };

    this.navigateDown = function(times) {
        this.selection.clearSelection();
        times = times || 1;
        this.selection.moveCursorBy(times, 0);
    };

    this.navigateLeft = function(times) {
        if (!this.selection.isEmpty()) {
            var selectionStart = this.getSelectionRange().start;
            this.moveCursorToPosition(selectionStart);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorLeft();
            }
        }
        this.clearSelection();
    };

    this.navigateRight = function(times) {
        if (!this.selection.isEmpty()) {
            var selectionEnd = this.getSelectionRange().end;
            this.moveCursorToPosition(selectionEnd);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorRight();
            }
        }
        this.clearSelection();
    };

    this.navigateLineStart = function() {
        this.selection.moveCursorLineStart();
        this.clearSelection();
    };

    this.navigateLineEnd = function() {
        this.selection.moveCursorLineEnd();
        this.clearSelection();
    };

    this.navigateFileEnd = function() {
        this.selection.moveCursorFileEnd();
        this.clearSelection();
    };

    this.navigateFileStart = function() {
        this.selection.moveCursorFileStart();
        this.clearSelection();
    };

    this.navigateWordRight = function() {
        this.selection.moveCursorWordRight();
        this.clearSelection();
    };

    this.navigateWordLeft = function() {
        this.selection.moveCursorWordLeft();
        this.clearSelection();
    };

    this.replace = function(replacement, options) {
        if (options)
            this.$search.set(options);

        var range = this.$search.find(this.session);
        if (!range)
            return;

        this.$tryReplace(range, replacement);
        if (range !== null)
            this.selection.setSelectionRange(range);
    };

    this.replaceAll = function(replacement, options) {
        if (options) {
            this.$search.set(options);
        }

        var ranges = this.$search.findAll(this.session);
        if (!ranges.length)
            return;

        var selection = this.getSelectionRange();
        this.clearSelection();
        this.selection.moveCursorTo(0, 0);

        this.$blockScrolling += 1;
        for (var i = ranges.length - 1; i >= 0; --i)
            this.$tryReplace(ranges[i], replacement);

        this.selection.setSelectionRange(selection);
        this.$blockScrolling -= 1;
    };

    this.$tryReplace = function(range, replacement) {
        var input = this.session.getTextRange(range);
        replacement = this.$search.replace(input, replacement);
        if (replacement !== null) {
            range.end = this.session.replace(range, replacement);
            return range;
        } else {
            return null;
        }
    };

    this.getLastSearchOptions = function() {
        return this.$search.getOptions();
    };

    this.find = function(needle, options) {
        this.clearSelection();
        options = options || {};
        options.needle = needle;
        this.$search.set(options);
        this.$find();
    };

    this.findNext = function(options) {
        options = options || {};
        if (typeof options.backwards == "undefined")
            options.backwards = false;
        this.$search.set(options);
        this.$find();
    };

    this.findPrevious = function(options) {
        options = options || {};
        if (typeof options.backwards == "undefined")
            options.backwards = true;
        this.$search.set(options);
        this.$find();
    };

    this.$find = function(backwards) {
        if (!this.selection.isEmpty())
            this.$search.set({needle: this.session.getTextRange(this.getSelectionRange())});

        if (typeof backwards != "undefined")
            this.$search.set({backwards: backwards});

        var range = this.$search.find(this.session);
        if (range) {
            this.session.unfold(range);
            this.selection.setSelectionRange(range); // this scrolls selection into view
        }
    };

    this.undo = function() {
        this.session.getUndoManager().undo();
    };

    this.redo = function() {
        this.session.getUndoManager().redo();
    };

    this.destroy = function() {
        this.renderer.destroy();
    };

}).call(Editor.prototype);


exports.Editor = Editor;
});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/lib/lang', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

exports.stringReverse = function(string) {
    return string.split("").reverse().join("");
};

exports.stringRepeat = function (string, count) {
     return new Array(count + 1).join(string);
};

var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;

exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, '');
};

exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, '');
};

exports.copyObject = function(obj) {
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};

exports.copyArray = function(array){
    var copy = [];
    for (var i=0, l=array.length; i<l; i++) {
        if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject( array[i] );
        else 
            copy[i] = array[i];
    }
    return copy;
};

exports.deepCopy = function (obj) {
    if (typeof obj != "object") {
        return obj;
    }
    
    var copy = obj.constructor();
    for (var key in obj) {
        if (typeof obj[key] == "object") {
            copy[key] = this.deepCopy(obj[key]);
        } else {
            copy[key] = obj[key];
        }
    }
    return copy;
};

exports.arrayToMap = function(arr) {
    var map = {};
    for (var i=0; i<arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;

};

/**
 * splice out of 'array' anything that === 'value'
 */
exports.arrayRemove = function(array, value) {
  for (var i = 0; i <= array.length; i++) {
    if (value === array[i]) {
      array.splice(i, 1);
    }
  }
};

exports.escapeRegExp = function(str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
};

exports.deferredCall = function(fcn) {

    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var deferred = function(timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };

    deferred.schedule = deferred;

    deferred.call = function() {
        this.cancel();
        fcn();
        return deferred;
    };

    deferred.cancel = function() {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };

    return deferred;
};

});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Mihai Sucan <mihai DOT sucan AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/keyboard/textinput', ['require', 'exports', 'module' , 'ace/lib/event', 'ace/lib/useragent', 'ace/lib/dom'], function(require, exports, module) {
"use strict";

var event = require("../lib/event");
var useragent = require("../lib/useragent");
var dom = require("../lib/dom");

var TextInput = function(parentNode, host) {

    var text = dom.createElement("textarea");
    if (useragent.isTouchPad)
        text.setAttribute("x-palm-disable-auto-cap", true);
        
    text.style.left = "-10000px";
    text.style.position = "fixed";
    parentNode.insertBefore(text, parentNode.firstChild);

    var PLACEHOLDER = String.fromCharCode(0);
    sendText();

    var inCompostion = false;
    var copied = false;
    var pasted = false;
    var tempStyle = '';

    function select() {
        try {
            text.select();
        } catch (e) {}
    }

    function sendText(valueToSend) {
        if (!copied) {
            var value = valueToSend || text.value;
            if (value) {
                if (value.charCodeAt(value.length-1) == PLACEHOLDER.charCodeAt(0)) {
                    value = value.slice(0, -1);
                    if (value)
                        host.onTextInput(value, pasted);
                }
                else {
                    host.onTextInput(value, pasted);
                }

                // If editor is no longer focused we quit immediately, since
                // it means that something else is in charge now.
                if (!isFocused())
                    return false;
            }
        }

        copied = false;
        pasted = false;

        // Safari doesn't fire copy events if no text is selected
        text.value = PLACEHOLDER;
        select();
    }

    var onTextInput = function(e) {
        setTimeout(function () {
            if (!inCompostion)
                sendText(e.data);                
        }, 0);
    };
    
    var onPropertyChange = function(e) {
        if (useragent.isOldIE && text.value.charCodeAt(0) > 128) return;
        setTimeout(function() {
            if (!inCompostion)
                sendText();
        }, 0);
    };

    var onCompositionStart = function(e) {
        inCompostion = true;
        host.onCompositionStart();
        if (!useragent.isGecko) setTimeout(onCompositionUpdate, 0);
    };

    var onCompositionUpdate = function() {
        if (!inCompostion) return;
        host.onCompositionUpdate(text.value);
    };

    var onCompositionEnd = function(e) {
        inCompostion = false;
        host.onCompositionEnd();
    };

    var onCopy = function(e) {
        copied = true;
        var copyText = host.getCopyText();
        if(copyText)
            text.value = copyText;
        else
            e.preventDefault();
        select();
        setTimeout(function () {
            sendText();
        }, 0);
    };
    
    var onCut = function(e) {
        copied = true;
        var copyText = host.getCopyText();
        if(copyText) {
            text.value = copyText;
            host.onCut();
        } else
            e.preventDefault();
        select();
        setTimeout(function () {
            sendText();
        }, 0);
    };

    event.addCommandKeyListener(text, host.onCommandKey.bind(host));
    if (useragent.isOldIE) {
        var keytable = { 13:1, 27:1 };
        event.addListener(text, "keyup", function (e) {
            if (inCompostion && (!text.value || keytable[e.keyCode]))
                setTimeout(onCompositionEnd, 0);
            if ((text.value.charCodeAt(0)|0) < 129) {
                return;
            }
            inCompostion ? onCompositionUpdate() : onCompositionStart();
        });
    }
    
    if ("onpropertychange" in text && !("oninput" in text))
        event.addListener(text, "propertychange", onPropertyChange);
    else
        event.addListener(text, "input", onTextInput);
    
    event.addListener(text, "paste", function(e) {
        // Mark that the next input text comes from past.
        pasted = true;
        // Some browsers support the event.clipboardData API. Use this to get
        // the pasted content which increases speed if pasting a lot of lines.
        if (e.clipboardData && e.clipboardData.getData) {
            sendText(e.clipboardData.getData("text/plain"));
            e.preventDefault();
        } 
        else {
            // If a browser doesn't support any of the things above, use the regular
            // method to detect the pasted input.
            onPropertyChange();
        }
    });

    if ("onbeforecopy" in text && typeof clipboardData !== "undefined") {
        event.addListener(text, "beforecopy", function(e) {
            var copyText = host.getCopyText();
            if (copyText)
                clipboardData.setData("Text", copyText);
            else
                e.preventDefault();
        });
        event.addListener(parentNode, "keydown", function(e) {
            if (e.ctrlKey && e.keyCode == 88) {
                var copyText = host.getCopyText();
                if (copyText) {
                    clipboardData.setData("Text", copyText);
                    host.onCut();
                }
                event.preventDefault(e);
            }
        });
    }
    else {
        event.addListener(text, "copy", onCopy);
        event.addListener(text, "cut", onCut);
    }

    event.addListener(text, "compositionstart", onCompositionStart);
    if (useragent.isGecko) {
        event.addListener(text, "text", onCompositionUpdate);
    }
    if (useragent.isWebKit) {
        event.addListener(text, "keyup", onCompositionUpdate);
    }
    event.addListener(text, "compositionend", onCompositionEnd);

    event.addListener(text, "blur", function() {
        host.onBlur();
    });

    event.addListener(text, "focus", function() {
        host.onFocus();
        select();
    });

    this.focus = function() {
        host.onFocus();
        select();
        text.focus();
    };

    this.blur = function() {
        text.blur();
    };

    function isFocused() {
        return document.activeElement === text;
    }
    this.isFocused = isFocused;

    this.getElement = function() {
        return text;
    };

    this.onContextMenu = function(mousePos, isEmpty){
        if (mousePos) {
            if (!tempStyle)
                tempStyle = text.style.cssText;
                
            text.style.cssText = 
                'position:fixed; z-index:1000;' +
                'left:' + (mousePos.x - 2) + 'px; top:' + (mousePos.y - 2) + 'px;';

        }
        if (isEmpty)
            text.value='';
    };

    this.onContextMenuClose = function(){
        setTimeout(function () {
            if (tempStyle) {
                text.style.cssText = tempStyle;
                tempStyle = '';
            }
            sendText();
        }, 0);
    };
};

exports.TextInput = TextInput;
});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Mihai Sucan <mihai DOT sucan AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/mouse/mouse_handler', ['require', 'exports', 'module' , 'ace/lib/event', 'ace/mouse/default_handlers', 'ace/mouse/default_gutter_handler', 'ace/mouse/mouse_event'], function(require, exports, module) {
"use strict";

var event = require("../lib/event");
var DefaultHandlers = require("./default_handlers").DefaultHandlers;
var DefaultGutterHandler = require("./default_gutter_handler").GutterHandler;
var MouseEvent = require("./mouse_event").MouseEvent;

var MouseHandler = function(editor) {
    this.editor = editor;
    
    new DefaultHandlers(editor);
    new DefaultGutterHandler(editor);
    
    event.addListener(editor.container, "mousedown", function(e) {
        editor.focus();
        return event.preventDefault(e);
    });
    event.addListener(editor.container, "selectstart", function(e) {
        return event.preventDefault(e);
    });

    var mouseTarget = editor.renderer.getMouseEventTarget();
    event.addListener(mouseTarget, "mousedown", this.onMouseEvent.bind(this, "mousedown"));
    event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
    event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
    event.addMultiMouseDownListener(mouseTarget, 0, 2, 500, this.onMouseEvent.bind(this, "dblclick"));
    event.addMultiMouseDownListener(mouseTarget, 0, 3, 600, this.onMouseEvent.bind(this, "tripleclick"));
    event.addMultiMouseDownListener(mouseTarget, 0, 4, 600, this.onMouseEvent.bind(this, "quadclick"));
    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
    
    var gutterEl = editor.renderer.$gutter;
    event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
    event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
    event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
    event.addListener(gutterEl, "mousemove", this.onMouseMove.bind(this, "gutter"));
};

(function() {

    this.$scrollSpeed = 1;
    this.setScrollSpeed = function(speed) {
        this.$scrollSpeed = speed;
    };

    this.getScrollSpeed = function() {
        return this.$scrollSpeed;
    };

    this.onMouseEvent = function(name, e) {
        this.editor._emit(name, new MouseEvent(e, this.editor));
    };
    
    this.$dragDelay = 250;
    this.setDragDelay = function(dragDelay) {
        this.$dragDelay = dragDelay;
    };

    this.getDragDelay = function() {
        return this.$dragDelay;
    };

    this.onMouseMove = function(name, e) {
        // optimization, because mousemove doesn't have a default handler.
        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
        if (!listeners || !listeners.length)
            return;

        this.editor._emit(name, new MouseEvent(e, this.editor));
    };

    this.onMouseWheel = function(name, e) {
        var mouseEvent = new MouseEvent(e, this.editor);
        mouseEvent.speed = this.$scrollSpeed * 2;
        mouseEvent.wheelX = e.wheelX;
        mouseEvent.wheelY = e.wheelY;
        
        this.editor._emit(name, mouseEvent);
    };

}).call(MouseHandler.prototype);

exports.MouseHandler = MouseHandler;
});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Mike de Boer <mike AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/mouse/default_handlers', ['require', 'exports', 'module' , 'ace/lib/event', 'ace/lib/dom', 'ace/lib/browser_focus'], function(require, exports, module) {
"use strict";

var event = require("../lib/event");
var dom = require("../lib/dom");
var BrowserFocus = require("../lib/browser_focus").BrowserFocus;

var STATE_UNKNOWN = 0;
var STATE_SELECT = 1;
var STATE_DRAG = 2;

var DRAG_OFFSET = 5; // pixels

function DefaultHandlers(editor) {
    this.editor = editor;
    this.$clickSelection = null;
    this.browserFocus = new BrowserFocus();

    editor.setDefaultHandler("mousedown", this.onMouseDown.bind(this));
    editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(this));
    editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(this));
    editor.setDefaultHandler("quadclick", this.onQuadClick.bind(this));
    editor.setDefaultHandler("mousewheel", this.onScroll.bind(this));
}

(function() {
    
    this.onMouseDown = function(ev) {
        var inSelection = ev.inSelection();
        var pageX = ev.pageX;
        var pageY = ev.pageY;
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        var _self = this;
        
        var selectionRange = editor.getSelectionRange();
        var selectionEmpty = selectionRange.isEmpty();
        var state = STATE_UNKNOWN;
        
        // if this click caused the editor to be focused should not clear the
        // selection
        if (
            inSelection && (
                !this.browserFocus.isFocused()
                || new Date().getTime() - this.browserFocus.lastFocus < 20
                || !editor.isFocused()
            )
        ) {
            editor.focus();
            return;
        }

        var button = ev.getButton();
        if (button !== 0) {
            if (selectionEmpty) {
                editor.moveCursorToPosition(pos);
            }
            if (button == 2) {
                editor.textInput.onContextMenu({x: ev.clientX, y: ev.clientY}, selectionEmpty);
                event.capture(editor.container, function(){}, editor.textInput.onContextMenuClose);
            }
            return;
        }

        if (!inSelection) {
            // Directly pick STATE_SELECT, since the user is not clicking inside
            // a selection.
            onStartSelect(pos);
        }

        var mousePageX = pageX, mousePageY = pageY;
        var mousedownTime = (new Date()).getTime();
        var dragCursor, dragRange, dragSelectionMarker;

        var onMouseSelection = function(e) {
            mousePageX = event.getDocumentX(e);
            mousePageY = event.getDocumentY(e);
        };

        var onMouseSelectionEnd = function(e) {
            clearInterval(timerId);
            if (state == STATE_UNKNOWN)
                onStartSelect(pos);
            else if (state == STATE_DRAG)
                onMouseDragSelectionEnd(e);

            _self.$clickSelection = null;
            state = STATE_UNKNOWN;
        };

        var onMouseDragSelectionEnd = function(e) {
            dom.removeCssClass(editor.container, "ace_dragging");
            editor.session.removeMarker(dragSelectionMarker);

            if (!editor.$mouseHandler.$clickSelection) {
                if (!dragCursor) {
                    editor.moveCursorToPosition(pos);
                    editor.selection.clearSelection(pos.row, pos.column);
                }
            }

            if (!dragCursor)
                return;

            if (dragRange.contains(dragCursor.row, dragCursor.column)) {
                dragCursor = null;
                return;
            }

            editor.clearSelection();
            if (e && (e.ctrlKey || e.altKey)) {
                var session = editor.session;
                var newRange = session.insert(dragCursor, session.getTextRange(dragRange));
            } else {
                var newRange = editor.moveText(dragRange, dragCursor);
            }
            if (!newRange) {
                dragCursor = null;
                return;
            }

            editor.selection.setSelectionRange(newRange);
        };

        var onSelectionInterval = function() {
            if (state == STATE_UNKNOWN) {
                var distance = calcDistance(pageX, pageY, mousePageX, mousePageY);
                var time = (new Date()).getTime();

                if (distance > DRAG_OFFSET) {
                    state = STATE_SELECT;
                    var cursor = editor.renderer.screenToTextCoordinates(mousePageX, mousePageY);
                    cursor.row = Math.max(0, Math.min(cursor.row, editor.session.getLength()-1));
                    onStartSelect(cursor);
                }
                else if ((time - mousedownTime) > editor.getDragDelay()) {
                    state = STATE_DRAG;
                    dragRange = editor.getSelectionRange();
                    var style = editor.getSelectionStyle();
                    dragSelectionMarker = editor.session.addMarker(dragRange, "ace_selection", style);
                    editor.clearSelection();
                    dom.addCssClass(editor.container, "ace_dragging");
                }

            }

            if (state == STATE_DRAG)
                onDragSelectionInterval();
            else if (state == STATE_SELECT)
                onUpdateSelectionInterval();
        };

        function onStartSelect(pos) {
            if (ev.getShiftKey()) {
                editor.selection.selectToPosition(pos);
            }
            else {
                if (!_self.$clickSelection) {
                    editor.moveCursorToPosition(pos);
                    editor.selection.clearSelection(pos.row, pos.column);
                }
            }
            state = STATE_SELECT;
        }

        var onUpdateSelectionInterval = function() {
            var anchor;
            var cursor = editor.renderer.screenToTextCoordinates(mousePageX, mousePageY);
            cursor.row = Math.max(0, Math.min(cursor.row, editor.session.getLength()-1));

            if (_self.$clickSelection) {
                if (_self.$clickSelection.contains(cursor.row, cursor.column)) {
                    editor.selection.setSelectionRange(_self.$clickSelection);
                }
                else {
                    if (_self.$clickSelection.compare(cursor.row, cursor.column) == -1) {
                        anchor = _self.$clickSelection.end;
                    }
                    else {
                        anchor = _self.$clickSelection.start;
                    }
                    editor.selection.setSelectionAnchor(anchor.row, anchor.column);
                    editor.selection.selectToPosition(cursor);
                }
            }
            else {
                editor.selection.selectToPosition(cursor);
            }

            editor.renderer.scrollCursorIntoView();
        };

        var onDragSelectionInterval = function() {
            dragCursor = editor.renderer.screenToTextCoordinates(mousePageX, mousePageY);
            dragCursor.row = Math.max(0, Math.min(dragCursor.row, editor.session.getLength() - 1));

            editor.moveCursorToPosition(dragCursor);
        };

        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
        var timerId = setInterval(onSelectionInterval, 20);

        return ev.preventDefault();
    };
    
    this.onDoubleClick = function(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        
        editor.moveCursorToPosition(pos);
        editor.selection.selectWord();
        this.$clickSelection = editor.getSelectionRange();
    };
    
    this.onTripleClick = function(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        
        editor.moveCursorToPosition(pos);
        editor.selection.selectLine();
        this.$clickSelection = editor.getSelectionRange();
    };
    
    this.onQuadClick = function(ev) {
        var editor = this.editor;
        
        editor.selectAll();
        this.$clickSelection = editor.getSelectionRange();
    };
    
    this.onScroll = function(ev) {
        var editor = this.editor;
        
        editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
        if (editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed))
            return ev.preventDefault();
    };
    
}).call(DefaultHandlers.prototype);

exports.DefaultHandlers = DefaultHandlers;

function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Irakli Gozalishvili <rfobic@gmail.com> (http://jeditoolkit.com)
 *      Julian Viereck <julian.viereck@gmail.com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/lib/browser_focus', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/event', 'ace/lib/event_emitter'], function(require, exports, module) {
"use strict";

var oop = require("./oop");
var event = require("./event");
var EventEmitter = require("./event_emitter").EventEmitter;

/**
 * This class keeps track of the focus state of the given window.
 * Focus changes for example when the user switches a browser tab,
 * goes to the location bar or switches to another application.
 */ 
var BrowserFocus = function(win) {
    win = win || window;
    
    this.lastFocus = new Date().getTime();
    this._isFocused = true;
    
    var _self = this;

    // IE < 9 supports focusin and focusout events
    if ("onfocusin" in win.document) {
        event.addListener(win.document, "focusin", function(e) {
            _self._setFocused(true);
        });

        event.addListener(win.document, "focusout", function(e) {
            _self._setFocused(!!e.toElement);
        });
    }
    else {
        event.addListener(win, "blur", function(e) {
            _self._setFocused(false);
        });

        event.addListener(win, "focus", function(e) {
            _self._setFocused(true);
        });
    }
};

(function(){

    oop.implement(this, EventEmitter);
    
    this.isFocused = function() {
        return this._isFocused;
    };
    
    this._setFocused = function(isFocused) {
        if (this._isFocused == isFocused)
            return;
            
        if (isFocused)
            this.lastFocus = new Date().getTime();
            
        this._isFocused = isFocused;
        this._emit("changeFocus");
    };

}).call(BrowserFocus.prototype);


exports.BrowserFocus = BrowserFocus;
});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Irakli Gozalishvili <rfobic@gmail.com> (http://jeditoolkit.com)
 *      Mike de Boer <mike AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/lib/event_emitter', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

var EventEmitter = {};

EventEmitter._emit =
EventEmitter._dispatchEvent = function(eventName, e) {
    this._eventRegistry = this._eventRegistry || {};
    this._defaultHandlers = this._defaultHandlers || {};

    var listeners = this._eventRegistry[eventName] || [];
    var defaultHandler = this._defaultHandlers[eventName];
    if (!listeners.length && !defaultHandler)
        return;

    e = e || {};
    e.type = eventName;
    
    if (!e.stopPropagation) {
        e.stopPropagation = function() {
            this.propagationStopped = true;
        };
    }
    
    if (!e.preventDefault) {
        e.preventDefault = function() {
            this.defaultPrevented = true;
        };
    }

    for (var i=0; i<listeners.length; i++) {
        listeners[i](e);
        if (e.propagationStopped)
            break;
    }
    
    if (defaultHandler && !e.defaultPrevented)
        defaultHandler(e);
};

EventEmitter.setDefaultHandler = function(eventName, callback) {
    this._defaultHandlers = this._defaultHandlers || {};
    
    if (this._defaultHandlers[eventName])
        throw new Error("The default handler for '" + eventName + "' is already set");
        
    this._defaultHandlers[eventName] = callback;
};

EventEmitter.on =
EventEmitter.addEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        var listeners = this._eventRegistry[eventName] = [];

    if (listeners.indexOf(callback) == -1)
        listeners.push(callback);
};

EventEmitter.removeListener =
EventEmitter.removeEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        return;

    var index = listeners.indexOf(callback);
    if (index !== -1)
        listeners.splice(index, 1);
};

EventEmitter.removeAllListeners = function(eventName) {
    if (this._eventRegistry) this._eventRegistry[eventName] = [];
};

exports.EventEmitter = EventEmitter;

});/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/mouse/default_gutter_handler', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

function GutterHandler(editor) {
    editor.setDefaultHandler("gutterclick", function(e) {
        var row = e.getDocumentPosition().row;
        var selection = editor.session.selection;
        
        selection.moveCursorTo(row, 0);
        selection.selectLine();
    });
}

exports.GutterHandler = GutterHandler;

});/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/mouse/mouse_event', ['require', 'exports', 'module' , 'ace/lib/event'], function(require, exports, module) {
"use strict";

var event = require("../lib/event");

/**
 * Custom Ace mouse event
 */
var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
    this.domEvent = domEvent;
    this.editor = editor;
    
    this.pageX = event.getDocumentX(domEvent);
    this.pageY = event.getDocumentY(domEvent);
    
    this.clientX = domEvent.clientX;
    this.clientY = domEvent.clientY;

    this.$pos = null;
    this.$inSelection = null;
    
    this.propagationStopped = false;
    this.defaultPrevented = false;
};

(function() {  
    
    this.stopPropagation = function() {
        event.stopPropagation(this.domEvent);
        this.propagationStopped = true;
    };
    
    this.preventDefault = function() {
        event.preventDefault(this.domEvent);
        this.defaultPrevented = true;
    };
    
    this.stop = function() {
        this.stopPropagation();
        this.preventDefault();
    };

    /**
     * Get the document position below the mouse cursor
     * 
     * @return {Object} 'row' and 'column' of the document position
     */
    this.getDocumentPosition = function() {
        if (this.$pos)
            return this.$pos;
            
        var pageX = event.getDocumentX(this.domEvent);
        var pageY = event.getDocumentY(this.domEvent);
        this.$pos = this.editor.renderer.screenToTextCoordinates(pageX, pageY);
        this.$pos.row = Math.max(0, Math.min(this.$pos.row, this.editor.session.getLength()-1));
        return this.$pos;
    };
    
    /**
     * Check if the mouse cursor is inside of the text selection
     * 
     * @return {Boolean} whether the mouse cursor is inside of the selection
     */
    this.inSelection = function() {
        if (this.$inSelection !== null)
            return this.$inSelection;
            
        var editor = this.editor;
        
        if (editor.getReadOnly()) {
            this.$inSelection = false;
        }
        else {
            var selectionRange = editor.getSelectionRange();
            if (selectionRange.isEmpty())
                this.$inSelection = false;
            else {
                var pos = this.getDocumentPosition();
                this.$inSelection = selectionRange.contains(pos.row, pos.column);
            }
        }
        return this.$inSelection;
    };
    
    /**
     * Get the clicked mouse button
     * 
     * @return {Number} 0 for left button, 1 for middle button, 2 for right button
     */
    this.getButton = function() {
        return event.getButton(this.domEvent);
    };
    
    /**
     * @return {Boolean} whether the shift key was pressed when the event was emitted
     */
    this.getShiftKey = function() {
        return this.domEvent.shiftKey;
    };
    
    this.getAccelKey = function() {
        return this.domEvent.ctrlKey || this.domEvent.metaKey ;
    };
    
}).call(MouseEvent.prototype);

});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/mouse/fold_handler', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

function FoldHandler(editor) {
    
    editor.on("click", function(e) {
        var position = e.getDocumentPosition();
        var session = editor.session;
        
        // If the user dclicked on a fold, then expand it.
        var fold = session.getFoldAt(position.row, position.column, 1);
        if (fold) {
            if (e.getAccelKey())
                session.removeFold(fold);
            else
                session.expandFold(fold);
                
            e.stop();
        }
    });
    
    editor.on("gutterclick", function(e) {
        if (e.domEvent.target.className.indexOf("ace_fold-widget") != -1) {
            var row = e.getDocumentPosition().row;
            editor.session.onFoldWidgetClick(row, e.domEvent);
            e.stop();
        }
    });
}

exports.FoldHandler = FoldHandler;

});/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Julian Viereck <julian.viereck@gmail.com>
 *      Harutyun Amirjanyan <amirjanyan@gmail.com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/keyboard/keybinding', ['require', 'exports', 'module' , 'ace/lib/keys', 'ace/lib/event', 'ace/commands/default_commands'], function(require, exports, module) {
"use strict";

var keyUtil  = require("../lib/keys");
var event = require("../lib/event");
require("../commands/default_commands");

var KeyBinding = function(editor) {
    this.$editor = editor;
    this.$data = { };
    this.$handlers = [this];
};

(function() {
    this.setKeyboardHandler = function(keyboardHandler) {
        if (this.$handlers[this.$handlers.length - 1] == keyboardHandler)
            return;
        this.$data = { };
        this.$handlers = keyboardHandler ? [this, keyboardHandler] : [this];
    };

    this.addKeyboardHandler = function(keyboardHandler) {
        this.removeKeyboardHandler(keyboardHandler);
        this.$handlers.push(keyboardHandler);
    };

    this.removeKeyboardHandler = function(keyboardHandler) {
        var i = this.$handlers.indexOf(keyboardHandler);
        if (i == -1)
            return false;
        this.$handlers.splice(i, 1);
        return true;
    };

    this.getKeyboardHandler = function() {
        return this.$handlers[this.$handlers.length - 1];
    };

    this.$callKeyboardHandlers = function (hashId, keyString, keyCode, e) {
        var toExecute;
        for (var i = this.$handlers.length; i--;) {
            toExecute = this.$handlers[i].handleKeyboard(
                this.$data, hashId, keyString, keyCode, e
            );
            if (toExecute && toExecute.command)
                break;
        }

        if (!toExecute || !toExecute.command)
            return false;

        var success = false;
        var commands = this.$editor.commands;

        // allow keyboardHandler to consume keys
        if (toExecute.command != "null")
            success = commands.exec(toExecute.command, this.$editor, toExecute.args);
        else
            success = true;

        if (success && e)
            event.stopEvent(e);

        return success;
    };

    this.handleKeyboard = function(data, hashId, keyString) {
        return {
            command: this.$editor.commands.findKeyCommand(hashId, keyString)
        };
    };

    this.onCommandKey = function(e, hashId, keyCode) {
        var keyString = keyUtil.keyCodeToString(keyCode);
        this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
    };

    this.onTextInput = function(text, pasted) {
        var success = false;
        if (!pasted && text.length == 1)
            success = this.$callKeyboardHandlers(0, text);
        if (!success)
            this.$editor.commands.exec("insertstring", this.$editor, text);
    };

}).call(KeyBinding.prototype);

exports.KeyBinding = KeyBinding;
});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Julian Viereck <julian.viereck@gmail.com>
 *      Mihai Sucan <mihai.sucan@gmail.com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/commands/default_commands', ['require', 'exports', 'module' , 'ace/lib/lang'], function(require, exports, module) {
"use strict";

var lang = require("../lib/lang");

function bindKey(win, mac) {
    return {
        win: win,
        mac: mac
    };
}

exports.commands = [{
    name: "selectall",
    bindKey: bindKey("Ctrl-A", "Command-A"),
    exec: function(editor) { editor.selectAll(); },
    readOnly: true
}, {
    name: "centerselection",
    bindKey: bindKey(null, "Ctrl-L"),
    exec: function(editor) { editor.centerSelection(); },
    readOnly: true
}, {
    name: "gotoline",
    bindKey: bindKey("Ctrl-L", "Command-L"),
    exec: function(editor) {
        var line = parseInt(prompt("Enter line number:"), 10);
        if (!isNaN(line)) {
            editor.gotoLine(line);
        }
    },
    readOnly: true
}, {
    name: "fold",
    bindKey: bindKey("Alt-L", "Alt-L"),
    exec: function(editor) { editor.session.toggleFold(false); },
    readOnly: true
}, {
    name: "unfold",
    bindKey: bindKey("Alt-Shift-L", "Alt-Shift-L"),
    exec: function(editor) { editor.session.toggleFold(true); },
    readOnly: true
}, {
    name: "foldall",
    bindKey: bindKey("Alt-0", "Alt-0"),
    exec: function(editor) { editor.session.foldAll(); },
    readOnly: true
}, {
    name: "unfoldall",
    bindKey: bindKey("Alt-Shift-0", "Alt-Shift-0"),
    exec: function(editor) { editor.session.unfold(); },
    readOnly: true
}, {
    name: "findnext",
    bindKey: bindKey("Ctrl-K", "Command-G"),
    exec: function(editor) { editor.findNext(); },
    readOnly: true
}, {
    name: "findprevious",
    bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
    exec: function(editor) { editor.findPrevious(); },
    readOnly: true
}, {
    name: "find",
    bindKey: bindKey("Ctrl-F", "Command-F"),
    exec: function(editor) {
        var needle = prompt("Find:", editor.getCopyText());
        editor.find(needle);
    },
    readOnly: true
}, {
    name: "overwrite",
    bindKey: bindKey("Insert", "Insert"),
    exec: function(editor) { editor.toggleOverwrite(); },
    readOnly: true
}, {
    name: "selecttostart",
    bindKey: bindKey("Ctrl-Shift-Home|Alt-Shift-Up", "Command-Shift-Up"),
    exec: function(editor) { editor.getSelection().selectFileStart(); },
    readOnly: true
}, {
    name: "gotostart",
    bindKey: bindKey("Ctrl-Home|Ctrl-Up", "Command-Home|Command-Up"),
    exec: function(editor) { editor.navigateFileStart(); },
    readOnly: true
}, {
    name: "selectup",
    bindKey: bindKey("Shift-Up", "Shift-Up"),
    exec: function(editor) { editor.getSelection().selectUp(); },
    readOnly: true
}, {
    name: "golineup",
    bindKey: bindKey("Up", "Up|Ctrl-P"),
    exec: function(editor, args) { editor.navigateUp(args.times); },
    readOnly: true
}, {
    name: "selecttoend",
    bindKey: bindKey("Ctrl-Shift-End|Alt-Shift-Down", "Command-Shift-Down"),
    exec: function(editor) { editor.getSelection().selectFileEnd(); },
    readOnly: true
}, {
    name: "gotoend",
    bindKey: bindKey("Ctrl-End|Ctrl-Down", "Command-End|Command-Down"),
    exec: function(editor) { editor.navigateFileEnd(); },
    readOnly: true
}, {
    name: "selectdown",
    bindKey: bindKey("Shift-Down", "Shift-Down"),
    exec: function(editor) { editor.getSelection().selectDown(); },
    readOnly: true
}, {
    name: "golinedown",
    bindKey: bindKey("Down", "Down|Ctrl-N"),
    exec: function(editor, args) { editor.navigateDown(args.times); },
    readOnly: true
}, {
    name: "selectwordleft",
    bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
    exec: function(editor) { editor.getSelection().selectWordLeft(); },
    readOnly: true
}, {
    name: "gotowordleft",
    bindKey: bindKey("Ctrl-Left", "Option-Left"),
    exec: function(editor) { editor.navigateWordLeft(); },
    readOnly: true
}, {
    name: "selecttolinestart",
    bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left"),
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    readOnly: true
}, {
    name: "gotolinestart",
    bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
    exec: function(editor) { editor.navigateLineStart(); },
    readOnly: true
}, {
    name: "selectleft",
    bindKey: bindKey("Shift-Left", "Shift-Left"),
    exec: function(editor) { editor.getSelection().selectLeft(); },
    readOnly: true
}, {
    name: "gotoleft",
    bindKey: bindKey("Left", "Left|Ctrl-B"),
    exec: function(editor, args) { editor.navigateLeft(args.times); },
    readOnly: true
}, {
    name: "selectwordright",
    bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
    exec: function(editor) { editor.getSelection().selectWordRight(); },
    readOnly: true
}, {
    name: "gotowordright",
    bindKey: bindKey("Ctrl-Right", "Option-Right"),
    exec: function(editor) { editor.navigateWordRight(); },
    readOnly: true
}, {
    name: "selecttolineend",
    bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right"),
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    readOnly: true
}, {
    name: "gotolineend",
    bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
    exec: function(editor) { editor.navigateLineEnd(); },
    readOnly: true
}, {
    name: "selectright",
    bindKey: bindKey("Shift-Right", "Shift-Right"),
    exec: function(editor) { editor.getSelection().selectRight(); },
    readOnly: true
}, {
    name: "gotoright",
    bindKey: bindKey("Right", "Right|Ctrl-F"),
    exec: function(editor, args) { editor.navigateRight(args.times); },
    readOnly: true
}, {
    name: "selectpagedown",
    bindKey: bindKey("Shift-PageDown", "Shift-PageDown"),
    exec: function(editor) { editor.selectPageDown(); },
    readOnly: true
}, {
    name: "pagedown",
    bindKey: bindKey(null, "PageDown"),
    exec: function(editor) { editor.scrollPageDown(); },
    readOnly: true
}, {
    name: "gotopagedown",
    bindKey: bindKey("PageDown", "Option-PageDown|Ctrl-V"),
    exec: function(editor) { editor.gotoPageDown(); },
    readOnly: true
}, {
    name: "selectpageup",
    bindKey: bindKey("Shift-PageUp", "Shift-PageUp"),
    exec: function(editor) { editor.selectPageUp(); },
    readOnly: true
}, {
    name: "pageup",
    bindKey: bindKey(null, "PageUp"),
    exec: function(editor) { editor.scrollPageUp(); },
    readOnly: true
}, {
    name: "gotopageup",
    bindKey: bindKey("PageUp", "Option-PageUp"),
    exec: function(editor) { editor.gotoPageUp(); },
    readOnly: true
}, {
    name: "selectlinestart",
    bindKey: bindKey("Shift-Home", "Shift-Home"),
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    readOnly: true
}, {
    name: "selectlineend",
    bindKey: bindKey("Shift-End", "Shift-End"),
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    readOnly: true
}, {
    name: "togglerecording",
    bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
    exec: function(editor) { editor.commands.toggleRecording(); },
    readOnly: true
}, {
    name: "replaymacro",
    bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
    exec: function(editor) { editor.commands.replay(editor); },
    readOnly: true
}, {
    name: "jumptomatching",
    bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
    exec: function(editor) { editor.jumpToMatching(); },
    readOnly: true
}, 

// commands disabled in readOnly mode
{
    name: "removeline",
    bindKey: bindKey("Ctrl-D", "Command-D"),
    exec: function(editor) { editor.removeLines(); }
}, {
    name: "togglecomment",
    bindKey: bindKey("Ctrl-7", "Command-7"),
    exec: function(editor) { editor.toggleCommentLines(); }
}, {
    name: "replace",
    bindKey: bindKey("Ctrl-R", "Command-Option-F"),
    exec: function(editor) {
        var needle = prompt("Find:", editor.getCopyText());
        if (!needle)
            return;
        var replacement = prompt("Replacement:");
        if (!replacement)
            return;
        editor.replace(replacement, {needle: needle});
    }
}, {
    name: "replaceall",
    bindKey: bindKey("Ctrl-Shift-R", "Command-Shift-Option-F"),
    exec: function(editor) {
        var needle = prompt("Find:");
        if (!needle)
            return;
        var replacement = prompt("Replacement:");
        if (!replacement)
            return;
        editor.replaceAll(replacement, {needle: needle});
    }
}, {
    name: "undo",
    bindKey: bindKey("Ctrl-Z", "Command-Z"),
    exec: function(editor) { editor.undo(); }
}, {
    name: "redo",
    bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
    exec: function(editor) { editor.redo(); }
}, {
    name: "copylinesup",
    bindKey: bindKey("Ctrl-Alt-Up", "Command-Option-Up"),
    exec: function(editor) { editor.copyLinesUp(); }
}, {
    name: "movelinesup",
    bindKey: bindKey("Alt-Up", "Option-Up"),
    exec: function(editor) { editor.moveLinesUp(); }
}, {
    name: "copylinesdown",
    bindKey: bindKey("Ctrl-Alt-Down", "Command-Option-Down"),
    exec: function(editor) { editor.copyLinesDown(); }
}, {
    name: "movelinesdown",
    bindKey: bindKey("Alt-Down", "Option-Down"),
    exec: function(editor) { editor.moveLinesDown(); }
}, {
    name: "del",
    bindKey: bindKey("Delete", "Delete|Ctrl-D"),
    exec: function(editor) { editor.remove("right"); }
}, {
    name: "backspace",
    bindKey: bindKey(
        "Ctrl-Backspace|Command-Backspace|Option-Backspace|Shift-Backspace|Backspace",
        "Ctrl-Backspace|Command-Backspace|Shift-Backspace|Backspace|Ctrl-H"
    ),
    exec: function(editor) { editor.remove("left"); }
}, {
    name: "removetolinestart",
    bindKey: bindKey("Alt-Backspace", "Option-Backspace"),
    exec: function(editor) { editor.removeToLineStart(); }
}, {
    name: "removetolineend",
    bindKey: bindKey("Alt-Delete", "Ctrl-K"),
    exec: function(editor) { editor.removeToLineEnd(); }
}, {
    name: "removewordleft",
    bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
    exec: function(editor) { editor.removeWordLeft(); }
}, {
    name: "removewordright",
    bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
    exec: function(editor) { editor.removeWordRight(); }
}, {
    name: "outdent",
    bindKey: bindKey("Shift-Tab", "Shift-Tab"),
    exec: function(editor) { editor.blockOutdent(); }
}, {
    name: "indent",
    bindKey: bindKey("Tab", "Tab"),
    exec: function(editor) { editor.indent(); }
}, {
    name: "insertstring",
    exec: function(editor, str) { editor.insert(str); }
}, {
    name: "inserttext",
    exec: function(editor, args) {
        editor.insert(lang.stringRepeat(args.text  || "", args.times || 1));
    }
}, {
    name: "splitline",
    bindKey: bindKey(null, "Ctrl-O"),
    exec: function(editor) { editor.splitLine(); }
}, {
    name: "transposeletters",
    bindKey: bindKey("Ctrl-T", "Ctrl-T"),
    exec: function(editor) { editor.transposeLetters(); }
}, {
    name: "touppercase",
    bindKey: bindKey("Ctrl-U", "Ctrl-U"),
    exec: function(editor) { editor.toUpperCase(); }
}, {
    name: "tolowercase",
    bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
    exec: function(editor) { editor.toLowerCase(); }
}];

});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Mihai Sucan <mihai DOT sucan AT gmail DOT com>
 *      Julian Viereck <julian DOT viereck AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/edit_session', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/lang', 'ace/lib/event_emitter', 'ace/selection', 'ace/mode/text', 'ace/range', 'ace/document', 'ace/background_tokenizer', 'ace/edit_session/folding', 'ace/edit_session/bracket_match'], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var lang = require("./lib/lang");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Selection = require("./selection").Selection;
var TextMode = require("./mode/text").Mode;
var Range = require("./range").Range;
var Document = require("./document").Document;
var BackgroundTokenizer = require("./background_tokenizer").BackgroundTokenizer;

var EditSession = function(text, mode) {
    this.$modified = true;
    this.$breakpoints = [];
    this.$frontMarkers = {};
    this.$backMarkers = {};
    this.$markerId = 1;
    this.$rowCache = [];
    this.$wrapData = [];
    this.$foldData = [];
    this.$undoSelect = true;
    this.$foldData.toString = function() {
        var str = "";
        this.forEach(function(foldLine) {
            str += "\n" + foldLine.toString();
        });
        return str;
    }

    if (text instanceof Document) {
        this.setDocument(text);
    } else {
        this.setDocument(new Document(text));
    }

    this.selection = new Selection(this);
    if (mode)
        this.setMode(mode);
    else
        this.setMode(new TextMode());
};


(function() {

    oop.implement(this, EventEmitter);

    this.setDocument = function(doc) {
        if (this.doc)
            throw new Error("Document is already set");

        this.doc = doc;
        doc.on("change", this.onChange.bind(this));
        this.on("changeFold", this.onChangeFold.bind(this));

        if (this.bgTokenizer) {
            this.bgTokenizer.setDocument(this.getDocument());
            this.bgTokenizer.start(0);
        }
    };

    this.getDocument = function() {
        return this.doc;
    };

    this.$resetRowCache = function(row) {
        if (row == 0) {
            this.$rowCache = [];
            return;
        }
        var rowCache = this.$rowCache;
        for (var i = 0; i < rowCache.length; i++) {
            if (rowCache[i].docRow >= row) {
                rowCache.splice(i, rowCache.length);
                return;
            }
        }
    };

    this.onChangeFold = function(e) {
        var fold = e.data;
        this.$resetRowCache(fold.start.row);
    };

    this.onChange = function(e) {
        var delta = e.data;
        this.$modified = true;

        this.$resetRowCache(delta.range.start.row);

        var removedFolds = this.$updateInternalDataOnChange(e);
        if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
            this.$deltasDoc.push(delta);
            if (removedFolds && removedFolds.length != 0) {
                this.$deltasFold.push({
                    action: "removeFolds",
                    folds:  removedFolds
                });
            }

            this.$informUndoManager.schedule();
        }

        this.bgTokenizer.start(delta.range.start.row);
        this._emit("change", e);
    };

    this.setValue = function(text) {
        this.doc.setValue(text);
        this.selection.moveCursorTo(0, 0);
        this.selection.clearSelection();

        this.$resetRowCache(0);
        this.$deltas = [];
        this.$deltasDoc = [];
        this.$deltasFold = [];
        this.getUndoManager().reset();
    };

    this.getValue =
    this.toString = function() {
        return this.doc.getValue();
    };

    this.getSelection = function() {
        return this.selection;
    };

    this.getState = function(row) {
        return this.bgTokenizer.getState(row);
    };

    this.getTokens = function(firstRow, lastRow) {
        return this.bgTokenizer.getTokens(firstRow, lastRow);
    };

    this.getTokenAt = function(row, column) {
        var tokens = this.bgTokenizer.getTokens(row, row)[0].tokens;
        var token, c = 0;
        if (column == null) {
            i = tokens.length - 1;
            c = this.getLine(row).length;
        } else {
            for (var i = 0; i < tokens.length; i++) {
                c += tokens[i].value.length;
                if (c >= column)
                    break;
            }
        }
        token = tokens[i];
        if (!token)
            return null;
        token.index = i;
        token.start = c - token.value.length;
        return token;
    };

    this.setUndoManager = function(undoManager) {
        this.$undoManager = undoManager;
        this.$resetRowCache(0);
        this.$deltas = [];
        this.$deltasDoc = [];
        this.$deltasFold = [];

        if (this.$informUndoManager)
            this.$informUndoManager.cancel();

        if (undoManager) {
            var self = this;
            this.$syncInformUndoManager = function() {
                self.$informUndoManager.cancel();

                if (self.$deltasFold.length) {
                    self.$deltas.push({
                        group: "fold",
                        deltas: self.$deltasFold
                    });
                    self.$deltasFold = [];
                }

                if (self.$deltasDoc.length) {
                    self.$deltas.push({
                        group: "doc",
                        deltas: self.$deltasDoc
                    });
                    self.$deltasDoc = [];
                }

                if (self.$deltas.length > 0) {
                    undoManager.execute({
                        action: "aceupdate",
                        args: [self.$deltas, self]
                    });
                }

                self.$deltas = [];
            }
            this.$informUndoManager =
                lang.deferredCall(this.$syncInformUndoManager);
        }
    };

    this.$defaultUndoManager = {
        undo: function() {},
        redo: function() {},
        reset: function() {}
    };

    this.getUndoManager = function() {
        return this.$undoManager || this.$defaultUndoManager;
    },

    this.getTabString = function() {
        if (this.getUseSoftTabs()) {
            return lang.stringRepeat(" ", this.getTabSize());
        } else {
            return "\t";
        }
    };

    this.$useSoftTabs = true;
    this.setUseSoftTabs = function(useSoftTabs) {
        if (this.$useSoftTabs === useSoftTabs) return;

        this.$useSoftTabs = useSoftTabs;
    };

    this.getUseSoftTabs = function() {
        return this.$useSoftTabs;
    };

    this.$tabSize = 4;
    this.setTabSize = function(tabSize) {
        if (isNaN(tabSize) || this.$tabSize === tabSize) return;

        this.$modified = true;
        this.$tabSize = tabSize;
        this._emit("changeTabSize");
    };

    this.getTabSize = function() {
        return this.$tabSize;
    };

    this.isTabStop = function(position) {
        return this.$useSoftTabs && (position.column % this.$tabSize == 0);
    };

    this.$overwrite = false;
    this.setOverwrite = function(overwrite) {
        if (this.$overwrite == overwrite) return;

        this.$overwrite = overwrite;
        this._emit("changeOverwrite");
    };

    this.getOverwrite = function() {
        return this.$overwrite;
    };

    this.toggleOverwrite = function() {
        this.setOverwrite(!this.$overwrite);
    };

    this.getBreakpoints = function() {
        return this.$breakpoints;
    };

    this.setBreakpoints = function(rows) {
        this.$breakpoints = [];
        for (var i=0; i<rows.length; i++) {
            this.$breakpoints[rows[i]] = true;
        }
        this._emit("changeBreakpoint", {});
    };

    this.clearBreakpoints = function() {
        this.$breakpoints = [];
        this._emit("changeBreakpoint", {});
    };

    this.setBreakpoint = function(row) {
        this.$breakpoints[row] = true;
        this._emit("changeBreakpoint", {});
    };

    this.clearBreakpoint = function(row) {
        delete this.$breakpoints[row];
        this._emit("changeBreakpoint", {});
    };

    this.getBreakpoints = function() {
        return this.$breakpoints;
    };

    this.addMarker = function(range, clazz, type, inFront) {
        var id = this.$markerId++;

        var marker = {
            range : range,
            type : type || "line",
            renderer: typeof type == "function" ? type : null,
            clazz : clazz,
            inFront: !!inFront
        }

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._emit("changeFrontMarker")
        } else {
            this.$backMarkers[id] = marker;
            this._emit("changeBackMarker")
        }

        return id;
    };

    this.removeMarker = function(markerId) {
        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
        if (!marker)
            return;

        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
        if (marker) {
            delete (markers[markerId]);
            this._emit(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
        }
    };

    this.getMarkers = function(inFront) {
        return inFront ? this.$frontMarkers : this.$backMarkers;
    };

    /**
     * Error:
     *  {
     *    row: 12,
     *    column: 2, //can be undefined
     *    text: "Missing argument",
     *    type: "error" // or "warning" or "info"
     *  }
     */
    this.setAnnotations = function(annotations) {
        this.$annotations = {};
        for (var i=0; i<annotations.length; i++) {
            var annotation = annotations[i];
            var row = annotation.row;
            if (this.$annotations[row])
                this.$annotations[row].push(annotation);
            else
                this.$annotations[row] = [annotation];
        }
        this._emit("changeAnnotation", {});
    };

    this.getAnnotations = function() {
        return this.$annotations || {};
    };

    this.clearAnnotations = function() {
        this.$annotations = {};
        this._emit("changeAnnotation", {});
    };

    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r?\n)/m);
        if (match) {
            this.$autoNewLine = match[1];
        } else {
            this.$autoNewLine = "\n";
        }
    };

    this.getWordRange = function(row, column) {
        var line = this.getLine(row);

        var inToken = false;
        if (column > 0) {
            inToken = !!line.charAt(column - 1).match(this.tokenRe);
        }

        if (!inToken) {
            inToken = !!line.charAt(column).match(this.tokenRe);
        }

        var re = inToken ? this.tokenRe : this.nonTokenRe;

        var start = column;
        if (start > 0) {
            do {
                start--;
            }
            while (start >= 0 && line.charAt(start).match(re));
            start++;
        }

        var end = column;
        while (end < line.length && line.charAt(end).match(re)) {
            end++;
        }

        return new Range(row, start, row, end);
    };

    // Gets the range of a word including its right whitespace
    this.getAWordRange = function(row, column) {
        var wordRange = this.getWordRange(row, column);
        var line = this.getLine(wordRange.end.row);

        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
            wordRange.end.column += 1;
        }
        return wordRange;
    };

    this.setNewLineMode = function(newLineMode) {
        this.doc.setNewLineMode(newLineMode);
    };

    this.getNewLineMode = function() {
        return this.doc.getNewLineMode();
    };

    this.$useWorker = true;
    this.setUseWorker = function(useWorker) {
        if (this.$useWorker == useWorker)
            return;

        this.$useWorker = useWorker;

        this.$stopWorker();
        if (useWorker)
            this.$startWorker();
    };

    this.getUseWorker = function() {
        return this.$useWorker;
    };

    this.onReloadTokenizer = function(e) {
        var rows = e.data;
        this.bgTokenizer.start(rows.first);
        this._emit("tokenizerUpdate", e);
    };

    this.$mode = null;
    this.setMode = function(mode) {
        if (this.$mode === mode) return;
        this.$mode = mode;

        this.$stopWorker();

        if (this.$useWorker)
            this.$startWorker();

        var tokenizer = mode.getTokenizer();

        if(tokenizer.addEventListener !== undefined) {
            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
            tokenizer.addEventListener("update", onReloadTokenizer);
        }

        if (!this.bgTokenizer) {
            this.bgTokenizer = new BackgroundTokenizer(tokenizer);
            var _self = this;
            this.bgTokenizer.addEventListener("update", function(e) {
                _self._emit("tokenizerUpdate", e);
            });
        } else {
            this.bgTokenizer.setTokenizer(tokenizer);
        }

        this.bgTokenizer.setDocument(this.getDocument());
        this.bgTokenizer.start(0);

        this.tokenRe = mode.tokenRe;
        this.nonTokenRe = mode.nonTokenRe;

        this.$setFolding(mode.foldingRules);

        this._emit("changeMode");
    };

    this.$stopWorker = function() {
        if (this.$worker)
            this.$worker.terminate();

        this.$worker = null;
    };

    this.$startWorker = function() {
        if (typeof Worker !== "undefined" && !require.noWorker) {
            try {
                this.$worker = this.$mode.createWorker(this);
            } catch (e) {
                console.log("Could not load worker");
                console.log(e);
                this.$worker = null;
            }
        }
        else
            this.$worker = null;
    };

    this.getMode = function() {
        return this.$mode;
    };
    
    this.$scrollTop = 0;
    this.setScrollTop = function(scrollTop) {
        scrollTop = Math.round(Math.max(0, scrollTop));
        if (this.$scrollTop === scrollTop)
            return;

        this.$scrollTop = scrollTop;
        this._emit("changeScrollTop", scrollTop);
    };

    this.getScrollTop = function() {
        return this.$scrollTop;
    };
    
    this.$scrollLeft = 0;
    this.setScrollLeft = function(scrollLeft) {
        scrollLeft = Math.round(Math.max(0, scrollLeft));
        if (this.$scrollLeft === scrollLeft)
            return;

        this.$scrollLeft = scrollLeft;
        this._emit("changeScrollLeft", scrollLeft);
    };

    this.getScrollLeft = function() {
        return this.$scrollLeft;
    };

    this.getWidth = function() {
        this.$computeWidth();
        return this.width;
    };

    this.getScreenWidth = function() {
        this.$computeWidth();
        return this.screenWidth;
    };

    this.$computeWidth = function(force) {
        if (this.$modified || force) {
            this.$modified = false;

            var lines = this.doc.getAllLines();
            var longestLine = 0;
            var longestScreenLine = 0;

            for ( var i = 0; i < lines.length; i++) {
                var foldLine = this.getFoldLine(i),
                    line, len;

                line = lines[i];
                if (foldLine) {
                    var end = foldLine.range.end;
                    line = this.getFoldDisplayLine(foldLine);
                    // Continue after the foldLine.end.row. All the lines in
                    // between are folded.
                    i = end.row;
                }
                len = line.length;
                longestLine = Math.max(longestLine, len);
                if (!this.$useWrapMode) {
                    longestScreenLine = Math.max(
                        longestScreenLine,
                        this.$getStringScreenWidth(line)[0]
                    );
                }
            }
            this.width = longestLine;

            if (this.$useWrapMode) {
                this.screenWidth = this.$wrapLimit;
            } else {
                this.screenWidth = longestScreenLine;
            }
        }
    };

    /**
     * Get a verbatim copy of the given line as it is in the document
     */
    this.getLine = function(row) {
        return this.doc.getLine(row);
    };

    this.getLines = function(firstRow, lastRow) {
        return this.doc.getLines(firstRow, lastRow);
    };

    this.getLength = function() {
        return this.doc.getLength();
    };

    this.getTextRange = function(range) {
        return this.doc.getTextRange(range);
    };

    this.insert = function(position, text) {
        return this.doc.insert(position, text);
    };

    this.remove = function(range) {
        return this.doc.remove(range);
    };

    this.undoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        var lastUndoRange = null;
        for (var i = deltas.length - 1; i != -1; i--) {
            var delta = deltas[i];
            if (delta.group == "doc") {
                this.doc.revertDeltas(delta.deltas);
                lastUndoRange =
                    this.$getUndoSelection(delta.deltas, true, lastUndoRange);
            } else {
                delta.deltas.forEach(function(foldDelta) {
                    this.addFolds(foldDelta.folds);
                }, this);
            }
        }
        this.$fromUndo = false;
        lastUndoRange &&
            this.$undoSelect &&
            !dontSelect &&
            this.selection.setSelectionRange(lastUndoRange);
        return lastUndoRange;
    };

    this.redoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        var lastUndoRange = null;
        for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (delta.group == "doc") {
                this.doc.applyDeltas(delta.deltas);
                lastUndoRange =
                    this.$getUndoSelection(delta.deltas, false, lastUndoRange);
            }
        }
        this.$fromUndo = false;
        lastUndoRange &&
            this.$undoSelect &&
            !dontSelect &&
            this.selection.setSelectionRange(lastUndoRange);
        return lastUndoRange;
    };
    
    this.setUndoSelect = function(enable) {
        this.$undoSelect = enable;
    };

    this.$getUndoSelection = function(deltas, isUndo, lastUndoRange) {
        function isInsert(delta) {
            var insert =
                delta.action == "insertText" || delta.action == "insertLines";
            return isUndo ? !insert : insert;
        }

        var delta = deltas[0];
        var range, point;
        var lastDeltaIsInsert = false;
        if (isInsert(delta)) {
            range = delta.range.clone();
            lastDeltaIsInsert = true;
        } else {
            range = Range.fromPoints(delta.range.start, delta.range.start);
            lastDeltaIsInsert = false;
        }

        for (var i = 1; i < deltas.length; i++) {
            delta = deltas[i];
            if (isInsert(delta)) {
                point = delta.range.start;
                if (range.compare(point.row, point.column) == -1) {
                    range.setStart(delta.range.start);
                }
                point = delta.range.end;
                if (range.compare(point.row, point.column) == 1) {
                    range.setEnd(delta.range.end);
                }
                lastDeltaIsInsert = true;
            } else {
                point = delta.range.start;
                if (range.compare(point.row, point.column) == -1) {
                    range =
                        Range.fromPoints(delta.range.start, delta.range.start);
                }
                lastDeltaIsInsert = false;
            }
        }

        // Check if this range and the last undo range has something in common.
        // If true, merge the ranges.
        if (lastUndoRange != null) {
            var cmp = lastUndoRange.compareRange(range);
            if (cmp == 1) {
                range.setStart(lastUndoRange.start);
            } else if (cmp == -1) {
                range.setEnd(lastUndoRange.end);
            }
        }

        return range;
    },

    this.replace = function(range, text) {
        return this.doc.replace(range, text);
    };

    /**
     * Move a range of text from the given range to the given position.
     *
     * @param fromRange {Range} The range of text you want moved within the
     * document.
     * @param toPosition {Object} The location (row and column) where you want
     * to move the text to.
     * @return {Range} The new range where the text was moved to.
     */
    this.moveText = function(fromRange, toPosition) {
        var text = this.getTextRange(fromRange);
        this.remove(fromRange);

        var toRow = toPosition.row;
        var toColumn = toPosition.column;

        // Make sure to update the insert location, when text is removed in
        // front of the chosen point of insertion.
        if (!fromRange.isMultiLine() && fromRange.start.row == toRow &&
            fromRange.end.column < toColumn)
            toColumn -= text.length;

        if (fromRange.isMultiLine() && fromRange.end.row < toRow) {
            var lines = this.doc.$split(text);
            toRow -= lines.length - 1;
        }

        var endRow = toRow + fromRange.end.row - fromRange.start.row;
        var endColumn = fromRange.isMultiLine() ?
                        fromRange.end.column :
                        toColumn + fromRange.end.column - fromRange.start.column;

        var toRange = new Range(toRow, toColumn, endRow, endColumn);

        this.insert(toRange.start, text);

        return toRange;
    };

    this.indentRows = function(startRow, endRow, indentString) {
        indentString = indentString.replace(/\t/g, this.getTabString());
        for (var row=startRow; row<=endRow; row++)
            this.insert({row: row, column:0}, indentString);
    };

    this.outdentRows = function (range) {
        var rowRange = range.collapseRows();
        var deleteRange = new Range(0, 0, 0, 0);
        var size = this.getTabSize();

        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
            var line = this.getLine(i);

            deleteRange.start.row = i;
            deleteRange.end.row = i;
            for (var j = 0; j < size; ++j)
                if (line.charAt(j) != ' ')
                    break;
            if (j < size && line.charAt(j) == '\t') {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
            } else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
            }
            this.remove(deleteRange);
        }
    };

    this.moveLinesUp = function(firstRow, lastRow) {
        if (firstRow <= 0) return 0;

        var removed = this.doc.removeLines(firstRow, lastRow);
        this.doc.insertLines(firstRow - 1, removed);
        return -1;
    };

    this.moveLinesDown = function(firstRow, lastRow) {
        if (lastRow >= this.doc.getLength()-1) return 0;

        var removed = this.doc.removeLines(firstRow, lastRow);
        this.doc.insertLines(firstRow+1, removed);
        return 1;
    };

    this.duplicateLines = function(firstRow, lastRow) {
        var firstRow = this.$clipRowToDocument(firstRow);
        var lastRow = this.$clipRowToDocument(lastRow);

        var lines = this.getLines(firstRow, lastRow);
        this.doc.insertLines(firstRow, lines);

        var addedRows = lastRow - firstRow + 1;
        return addedRows;
    };

    this.$clipRowToDocument = function(row) {
        return Math.max(0, Math.min(row, this.doc.getLength()-1));
    };

    this.$clipColumnToRow = function(row, column) {
        if (column < 0)
            return 0;
        return Math.min(this.doc.getLine(row).length, column);
    };

    this.$clipPositionToDocument = function(row, column) {
        column = Math.max(0, column);

        if (row < 0) {
            row = 0;
            column = 0;
        } else {
            var len = this.doc.getLength();
            if (row >= len) {
                row = len - 1;
                column = this.doc.getLine(len-1).length;
            } else {
                column = Math.min(this.doc.getLine(row).length, column);
            }
        }

        return {
            row: row,
            column: column
        };
    };

    this.$clipRangeToDocument = function(range) {
        if (range.start.row < 0) {
            range.start.row = 0;
            range.start.column = 0
        } else {
            range.start.column = this.$clipColumnToRow(
                range.start.row,
                range.start.column
            );
        }
        
        var len = this.doc.getLength() - 1;
        if (range.end.row > len) {
            range.end.row = len;
            range.end.column = this.doc.getLine(len).length;
        } else {
            range.end.column = this.$clipColumnToRow(
                range.end.row,
                range.end.column
            );
        }
        return range;
    };

    // WRAPMODE
    this.$wrapLimit = 80;
    this.$useWrapMode = false;
    this.$wrapLimitRange = {
        min : null,
        max : null
    };

    this.setUseWrapMode = function(useWrapMode) {
        if (useWrapMode != this.$useWrapMode) {
            this.$useWrapMode = useWrapMode;
            this.$modified = true;
            this.$resetRowCache(0);

            // If wrapMode is activaed, the wrapData array has to be initialized.
            if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = [];
                for (var i = 0; i < len; i++) {
                    this.$wrapData.push([]);
                }
                this.$updateWrapData(0, len - 1);
            }

            this._emit("changeWrapMode");
        }
    };

    this.getUseWrapMode = function() {
        return this.$useWrapMode;
    };

    // Allow the wrap limit to move freely between min and max. Either
    // parameter can be null to allow the wrap limit to be unconstrained
    // in that direction. Or set both parameters to the same number to pin
    // the limit to that value.
    this.setWrapLimitRange = function(min, max) {
        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
            this.$wrapLimitRange.min = min;
            this.$wrapLimitRange.max = max;
            this.$modified = true;
            // This will force a recalculation of the wrap limit
            this._emit("changeWrapMode");
        }
    };

    // This should generally only be called by the renderer when a resize
    // is detected.
    this.adjustWrapLimit = function(desiredLimit) {
        var wrapLimit = this.$constrainWrapLimit(desiredLimit);
        if (wrapLimit != this.$wrapLimit && wrapLimit > 0) {
            this.$wrapLimit = wrapLimit;
            this.$modified = true;
            if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0)
                this._emit("changeWrapLimit");
            }
            return true;
        }
        return false;
    };

    this.$constrainWrapLimit = function(wrapLimit) {
        var min = this.$wrapLimitRange.min;
        if (min)
            wrapLimit = Math.max(min, wrapLimit);

        var max = this.$wrapLimitRange.max;
        if (max)
            wrapLimit = Math.min(max, wrapLimit);

        // What would a limit of 0 even mean?
        return Math.max(1, wrapLimit);
    };

    this.getWrapLimit = function() {
        return this.$wrapLimit;
    };

    this.getWrapLimitRange = function() {
        // Avoid unexpected mutation by returning a copy
        return {
            min : this.$wrapLimitRange.min,
            max : this.$wrapLimitRange.max
        };
    };

    this.$updateInternalDataOnChange = function(e) {
        var useWrapMode = this.$useWrapMode;
        var len;
        var action = e.data.action;
        var firstRow = e.data.range.start.row;
        var lastRow = e.data.range.end.row;
        var start = e.data.range.start;
        var end = e.data.range.end;
        var removedFolds = null;

        if (action.indexOf("Lines") != -1) {
            if (action == "insertLines") {
                lastRow = firstRow + (e.data.lines.length);
            } else {
                lastRow = firstRow;
            }
            len = e.data.lines ? e.data.lines.length : lastRow - firstRow;
        } else {
            len = lastRow - firstRow;
        }

        if (len != 0) {
            if (action.indexOf("remove") != -1) {
                useWrapMode && this.$wrapData.splice(firstRow, len);

                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(e.data.range);
                this.removeFolds(removedFolds);

                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                    foldLine.shiftRow(-len);

                    var foldLineBefore = this.getFoldLine(firstRow);
                    if (foldLineBefore && foldLineBefore !== foldLine) {
                        foldLineBefore.merge(foldLine);
                        foldLine = foldLineBefore;
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= end.row) {
                        foldLine.shiftRow(-len);
                    }
                }

                lastRow = firstRow;
            } else {
                var args;
                if (useWrapMode) {
                    args = [firstRow, 0];
                    for (var i = 0; i < len; i++) args.push([]);
                    this.$wrapData.splice.apply(this.$wrapData, args);
                }

                // If some new line is added inside of a foldLine, then split
                // the fold line up.
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                    var cmp = foldLine.range.compareInside(start.row, start.column)
                    // Inside of the foldLine range. Need to split stuff up.
                    if (cmp == 0) {
                        foldLine = foldLine.split(start.row, start.column);
                        foldLine.shiftRow(len);
                        foldLine.addRemoveChars(
                            lastRow, 0, end.column - start.column);
                    } else
                    // Infront of the foldLine but same row. Need to shift column.
                    if (cmp == -1) {
                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                        foldLine.shiftRow(len);
                    }
                    // Nothing to do if the insert is after the foldLine.
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= firstRow) {
                        foldLine.shiftRow(len);
                    }
                }
            }
        } else {
            // Realign folds. E.g. if you add some new chars before a fold, the
            // fold should "move" to the right.
            len = Math.abs(e.data.range.start.column - e.data.range.end.column);
            if (action.indexOf("remove") != -1) {
                // Get all the folds in the change range and remove them.
                removedFolds = this.getFoldsInRange(e.data.range);
                this.removeFolds(removedFolds);

                len = -len;
            }
            var foldLine = this.getFoldLine(firstRow);
            if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
            }
        }

        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
            console.error("doc.getLength() and $wrapData.length have to be the same!");
        }

        useWrapMode && this.$updateWrapData(firstRow, lastRow);

        return removedFolds;
    };

    this.$updateWrapData = function(firstRow, lastRow) {
        var lines = this.doc.getAllLines();
        var tabSize = this.getTabSize();
        var wrapData = this.$wrapData;
        var wrapLimit = this.$wrapLimit;
        var tokens;
        var foldLine;

        var row = firstRow;
        lastRow = Math.min(lastRow, lines.length - 1);
        while (row <= lastRow) {
            foldLine = this.getFoldLine(row, foldLine);
            if (!foldLine) {
                tokens = this.$getDisplayTokens(lang.stringTrimRight(lines[row]));
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row ++;
            } else {
                tokens = [];
                foldLine.walk(
                    function(placeholder, row, column, lastColumn) {
                        var walkTokens;
                        if (placeholder) {
                            walkTokens = this.$getDisplayTokens(
                                            placeholder, tokens.length);
                            walkTokens[0] = PLACEHOLDER_START;
                            for (var i = 1; i < walkTokens.length; i++) {
                                walkTokens[i] = PLACEHOLDER_BODY;
                            }
                        } else {
                            walkTokens = this.$getDisplayTokens(
                                lines[row].substring(lastColumn, column),
                                tokens.length);
                        }
                        tokens = tokens.concat(walkTokens);
                    }.bind(this),
                    foldLine.end.row,
                    lines[foldLine.end.row].length + 1
                );
                // Remove spaces/tabs from the back of the token array.
                while (tokens.length != 0 && tokens[tokens.length - 1] >= SPACE)
                    tokens.pop();

                wrapData[foldLine.start.row]
                    = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
            }
        }
    };

    // "Tokens"
    var CHAR = 1,
        CHAR_EXT = 2,
        PLACEHOLDER_START = 3,
        PLACEHOLDER_BODY =  4,
        PUNCTUATION = 9,
        SPACE = 10,
        TAB = 11,
        TAB_SPACE = 12;

    this.$computeWrapSplits = function(tokens, wrapLimit) {
        if (tokens.length == 0) {
            return [];
        }

        var splits = [];
        var displayLength = tokens.length;
        var lastSplit = 0, lastDocSplit = 0;

        function addSplit(screenPos) {
            var displayed = tokens.slice(lastSplit, screenPos);

            // The document size is the current size - the extra width for tabs
            // and multipleWidth characters.
            var len = displayed.length;
            displayed.join("").
                // Get all the TAB_SPACEs.
                replace(/12/g, function() {
                    len -= 1;
                }).
                // Get all the CHAR_EXT/multipleWidth characters.
                replace(/2/g, function() {
                    len -= 1;
                });

            lastDocSplit += len;
            splits.push(lastDocSplit);
            lastSplit = screenPos;
        }

        while (displayLength - lastSplit > wrapLimit) {
            // This is, where the split should be.
            var split = lastSplit + wrapLimit;

            // If there is a space or tab at this split position, then making
            // a split is simple.
            if (tokens[split] >= SPACE) {
                // Include all following spaces + tabs in this split as well.
                while (tokens[split] >= SPACE) {
                    split ++;
                }
                addSplit(split);
                continue;
            }

            // === ELSE ===
            // Check if split is inside of a placeholder. Placeholder are
            // not splitable. Therefore, seek the beginning of the placeholder
            // and try to place the split beofre the placeholder's start.
            if (tokens[split] == PLACEHOLDER_START
                || tokens[split] == PLACEHOLDER_BODY)
            {
                // Seek the start of the placeholder and do the split
                // before the placeholder. By definition there always
                // a PLACEHOLDER_START between split and lastSplit.
                for (split; split != lastSplit - 1; split--) {
                    if (tokens[split] == PLACEHOLDER_START) {
                        // split++; << No incremental here as we want to
                        //  have the position before the Placeholder.
                        break;
                    }
                }

                // If the PLACEHOLDER_START is not the index of the
                // last split, then we can do the split
                if (split > lastSplit) {
                    addSplit(split);
                    continue;
                }

                // If the PLACEHOLDER_START IS the index of the last
                // split, then we have to place the split after the
                // placeholder. So, let's seek for the end of the placeholder.
                split = lastSplit + wrapLimit;
                for (split; split < tokens.length; split++) {
                    if (tokens[split] != PLACEHOLDER_BODY)
                    {
                        break;
                    }
                }

                // If spilt == tokens.length, then the placeholder is the last
                // thing in the line and adding a new split doesn't make sense.
                if (split == tokens.length) {
                    break;  // Breaks the while-loop.
                }

                // Finally, add the split...
                addSplit(split);
                continue;
            }

            // === ELSE ===
            // Search for the first non space/tab/placeholder/punctuation token backwards.
            var minSplit = Math.max(split - 10, lastSplit - 1);
            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split --;
            }
            while (split > minSplit && tokens[split] == PUNCTUATION) {
                split --;
            }
            // If we found one, then add the split.
            if (split > minSplit) {
                addSplit(++split);
                continue;
            }

            // === ELSE ===
            split = lastSplit + wrapLimit;
            // The split is inside of a CHAR or CHAR_EXT token and no space
            // around -> force a split.
            addSplit(split);
        }
        return splits;
    }

    /**
     * @param
     *   offset: The offset in screenColumn at which position str starts.
     *           Important for calculating the realTabSize.
     */
    this.$getDisplayTokens = function(str, offset) {
        var arr = [];
        var tabSize;
        offset = offset || 0;

        for (var i = 0; i < str.length; i++) {
            var c = str.charCodeAt(i);
            // Tab
            if (c == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n < tabSize; n++) {
                    arr.push(TAB_SPACE);
                }
            }
            // Space
            else if (c == 32) {
                arr.push(SPACE);
            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {
                arr.push(PUNCTUATION);
            }
            // full width characters
            else if (c >= 0x1100 && isFullWidth(c)) {
                arr.push(CHAR, CHAR_EXT);
            } else {
                arr.push(CHAR);
            }
        }
        return arr;
    }

    /**
     * Calculates the width of the a string on the screen while assuming that
     * the string starts at the first column on the screen.
     *
     * @param string str String to calculate the screen width of
     * @return array
     *      [0]: number of columns for str on screen.
     *      [1]: docColumn position that was read until (useful with screenColumn)
     */
    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
        if (maxScreenColumn == 0) {
            return [0, 0];
        }
        if (maxScreenColumn == null) {
            maxScreenColumn = screenColumn +
                str.length * Math.max(this.getTabSize(), 2);
        }
        screenColumn = screenColumn || 0;

        var c, column;
        for (column = 0; column < str.length; column++) {
            c = str.charCodeAt(column);
            // tab
            if (c == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
            }
            // full width characters
            else if (c >= 0x1100 && isFullWidth(c)) {
                screenColumn += 2;
            } else {
                screenColumn += 1;
            }
            if (screenColumn > maxScreenColumn) {
                break
            }
        }

        return [screenColumn, column];
    }

    /**
     * Returns the number of rows required to render this row on the screen
     */
    this.getRowLength = function(row) {
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1;
        } else {
            return this.$wrapData[row].length + 1;
        }
    }

    /**
     * Returns the height in pixels required to render this row on the screen
     **/
    this.getRowHeight = function(config, row) {
        return this.getRowLength(row) * config.lineHeight;
    }

    this.getScreenLastRowColumn = function(screenRow) {
        //return this.screenToDocumentColumn(screenRow, Number.MAX_VALUE / 10)
        return this.documentToScreenColumn(screenRow, this.doc.getLine(screenRow).length);
    };

    this.getDocumentLastRowColumn = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.getScreenLastRowColumn(screenRow);
    };

    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
    };

    this.getRowSplitData = function(row) {
        if (!this.$useWrapMode) {
            return undefined;
        } else {
            return this.$wrapData[row];
        }
    };

    /**
     * Returns the width of a tab character at screenColumn.
     */
    this.getScreenTabSize = function(screenColumn) {
        return this.$tabSize - screenColumn % this.$tabSize;
    };

    this.screenToDocumentRow = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).row;
    };

    this.screenToDocumentColumn = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).column;
    };

    this.screenToDocumentPosition = function(screenRow, screenColumn) {
        if (screenRow < 0) {
            return {
                row: 0,
                column: 0
            }
        }

        var line;
        var docRow = 0;
        var docColumn = 0;
        var column;
        var row = 0;
        var rowLength = 0;

        var rowCache = this.$rowCache;
        for (var i = 0; i < rowCache.length; i++) {
            if (rowCache[i].screenRow < screenRow) {
                row = rowCache[i].screenRow;
                docRow = rowCache[i].docRow;
            }
            else {
                break;
            }
        }
        var doCache = !rowCache.length || i == rowCache.length;

        var maxRow = this.getLength() - 1;
        var foldLine = this.getNextFoldLine(docRow);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (row <= screenRow) {
            rowLength = this.getRowLength(docRow);
            if (row + rowLength - 1 >= screenRow || docRow >= maxRow) {
                break;
            } else {
                row += rowLength;
                docRow++;
                if (docRow > foldStart) {
                    docRow = foldLine.end.row+1;
                    foldLine = this.getNextFoldLine(docRow, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
            }
            if (doCache) {
                rowCache.push({
                    docRow: docRow,
                    screenRow: row
                });
            }
        }

        if (foldLine && foldLine.start.row <= docRow) {
            line = this.getFoldDisplayLine(foldLine);
            docRow = foldLine.start.row;
        } else if (row + rowLength <= screenRow || docRow > maxRow) {
            // clip at the end of the document
            return {
                row: maxRow,
                column: this.getLine(maxRow).length
            }
        } else {
            line = this.getLine(docRow);
            foldLine = null;
        }

        if (this.$useWrapMode) {
            var splits = this.$wrapData[docRow];
            if (splits) {
                column = splits[screenRow - row];
                if(screenRow > row && splits.length) {
                    docColumn = splits[screenRow - row - 1] || splits[splits.length - 1];
                    line = line.substring(docColumn);
                }
            }
        }

        docColumn += this.$getStringScreenWidth(line, screenColumn)[1];

        // Need to do some clamping action here.
        if (this.$useWrapMode) {
            if (docColumn >= column) {
                // We remove one character at the end such that the docColumn
                // position returned is not associated to the next row on the
                // screen.
                docColumn = column - 1;
            }
        } else {
            docColumn = Math.min(docColumn, line.length);
        }

        if (foldLine) {
            return foldLine.idxToPosition(docColumn);
        }

        return {
            row: docRow,
            column: docColumn
        }
    };

    this.documentToScreenPosition = function(docRow, docColumn) {
        // Normalize the passed in arguments.
        if (typeof docColumn === "undefined")
            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
        else
            pos = this.$clipPositionToDocument(docRow, docColumn);

        docRow = pos.row;
        docColumn = pos.column;

        var wrapData;
        // Special case in wrapMode if the doc is at the end of the document.
        if (this.$useWrapMode) {
            wrapData = this.$wrapData;
            if (docRow > wrapData.length - 1) {
                return {
                    row: this.getScreenLength(),
                    column: wrapData.length == 0
                        ? 0
                        : (wrapData[wrapData.length - 1].length - 1)
                };
            }
        }

        var screenRow = 0;
        var foldStartRow = null;
        var fold = null;

        // Clamp the docRow position in case it's inside of a folded block.
        fold = this.getFoldAt(docRow, docColumn, 1);
        if (fold) {
            docRow = fold.start.row;
            docColumn = fold.start.column;
        }

        var rowEnd, row = 0;
        var rowCache = this.$rowCache;

        for (var i = 0; i < rowCache.length; i++) {
            if (rowCache[i].docRow < docRow) {
                screenRow = rowCache[i].screenRow;
                row = rowCache[i].docRow;
            } else {
                break;
            }
        }
        var doCache = !rowCache.length || i == rowCache.length;

        var foldLine = this.getNextFoldLine(row);
        var foldStart = foldLine ?foldLine.start.row :Infinity;

        while (row < docRow) {
            if (row >= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd > docRow)
                    break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ?foldLine.start.row :Infinity;
            }
            else {
                rowEnd = row + 1;
            }

            screenRow += this.getRowLength(row);
            row = rowEnd;

            if (doCache) {
                rowCache.push({
                    docRow: row,
                    screenRow: screenRow
                });
            }
        }

        // Calculate the text line that is displayed in docRow on the screen.
        var textLine = "";
        // Check if the final row we want to reach is inside of a fold.
        if (foldLine && row >= foldStart) {
            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
            foldStartRow = foldLine.start.row;
        } else {
            textLine = this.getLine(docRow).substring(0, docColumn);
            foldStartRow = docRow;
        }
        // Clamp textLine if in wrapMode.
        if (this.$useWrapMode) {
            var wrapRow = wrapData[foldStartRow];
            var screenRowOffset = 0;
            while (textLine.length >= wrapRow[screenRowOffset]) {
                screenRow ++;
                screenRowOffset++;
            }
            textLine = textLine.substring(
                wrapRow[screenRowOffset - 1] || 0, textLine.length
            );
        }

        return {
            row: screenRow,
            column: this.$getStringScreenWidth(textLine)[0]
        };
    };

    this.documentToScreenColumn = function(row, docColumn) {
        return this.documentToScreenPosition(row, docColumn).column;
    };

    this.documentToScreenRow = function(docRow, docColumn) {
        return this.documentToScreenPosition(docRow, docColumn).row;
    };

    this.getScreenLength = function() {
        var screenRows = 0;
        var fold = null;
        if (!this.$useWrapMode) {
            screenRows = this.getLength();

            // Remove the folded lines again.
            var foldData = this.$foldData;
            for (var i = 0; i < foldData.length; i++) {
                fold = foldData[i];
                screenRows -= fold.end.row - fold.start.row;
            }
        } else {
            var lastRow = this.$wrapData.length;
            var row = 0, i = 0;
            var fold = this.$foldData[i++];
            var foldStart = fold ? fold.start.row :Infinity;

            while (row < lastRow) {
                screenRows += this.$wrapData[row].length + 1;
                row ++;
                if (row > foldStart) {
                    row = fold.end.row+1;
                    fold = this.$foldData[i++];
                    foldStart = fold ?fold.start.row :Infinity;
                }
            }
        }

        return screenRows;
    }

    // For every keystroke this gets called once per char in the whole doc!!
    // Wouldn't hurt to make it a bit faster for c >= 0x1100
    function isFullWidth(c) {
        if (c < 0x1100)
            return false;
        return c >= 0x1100 && c <= 0x115F ||
               c >= 0x11A3 && c <= 0x11A7 ||
               c >= 0x11FA && c <= 0x11FF ||
               c >= 0x2329 && c <= 0x232A ||
               c >= 0x2E80 && c <= 0x2E99 ||
               c >= 0x2E9B && c <= 0x2EF3 ||
               c >= 0x2F00 && c <= 0x2FD5 ||
               c >= 0x2FF0 && c <= 0x2FFB ||
               c >= 0x3000 && c <= 0x303E ||
               c >= 0x3041 && c <= 0x3096 ||
               c >= 0x3099 && c <= 0x30FF ||
               c >= 0x3105 && c <= 0x312D ||
               c >= 0x3131 && c <= 0x318E ||
               c >= 0x3190 && c <= 0x31BA ||
               c >= 0x31C0 && c <= 0x31E3 ||
               c >= 0x31F0 && c <= 0x321E ||
               c >= 0x3220 && c <= 0x3247 ||
               c >= 0x3250 && c <= 0x32FE ||
               c >= 0x3300 && c <= 0x4DBF ||
               c >= 0x4E00 && c <= 0xA48C ||
               c >= 0xA490 && c <= 0xA4C6 ||
               c >= 0xA960 && c <= 0xA97C ||
               c >= 0xAC00 && c <= 0xD7A3 ||
               c >= 0xD7B0 && c <= 0xD7C6 ||
               c >= 0xD7CB && c <= 0xD7FB ||
               c >= 0xF900 && c <= 0xFAFF ||
               c >= 0xFE10 && c <= 0xFE19 ||
               c >= 0xFE30 && c <= 0xFE52 ||
               c >= 0xFE54 && c <= 0xFE66 ||
               c >= 0xFE68 && c <= 0xFE6B ||
               c >= 0xFF01 && c <= 0xFF60 ||
               c >= 0xFFE0 && c <= 0xFFE6;
    };

}).call(EditSession.prototype);

require("./edit_session/folding").Folding.call(EditSession.prototype);
require("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);

exports.EditSession = EditSession;
});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Julian Viereck <julian.viereck@gmail.com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/selection', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/lang', 'ace/lib/event_emitter', 'ace/range'], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var lang = require("./lib/lang");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;

/**
 * Keeps cursor position and the text selection of an edit session.
 *
 * The row/columns used in the selection are in document coordinates
 * representing ths coordinates as thez appear in the document
 * before applying soft wrap and folding.
 */
var Selection = function(session) {
    this.session = session;
    this.doc = session.getDocument();

    this.clearSelection();
    this.selectionLead = this.doc.createAnchor(0, 0);
    this.selectionAnchor = this.doc.createAnchor(0, 0);

    var _self = this;
    this.selectionLead.on("change", function(e) {
        _self._emit("changeCursor");
        if (!_self.$isEmpty)
            _self._emit("changeSelection");
        if (!_self.$preventUpdateDesiredColumnOnChange && e.old.column != e.value.column)
            _self.$updateDesiredColumn();
    });

    this.selectionAnchor.on("change", function() {
        if (!_self.$isEmpty)
            _self._emit("changeSelection");
    });
};

(function() {

    oop.implement(this, EventEmitter);

    this.isEmpty = function() {
        return (this.$isEmpty || (
            this.selectionAnchor.row == this.selectionLead.row &&
            this.selectionAnchor.column == this.selectionLead.column
        ));
    };

    this.isMultiLine = function() {
        if (this.isEmpty()) {
            return false;
        }

        return this.getRange().isMultiLine();
    };

    this.getCursor = function() {
        return this.selectionLead.getPosition();
    };

    this.setSelectionAnchor = function(row, column) {
        this.selectionAnchor.setPosition(row, column);

        if (this.$isEmpty) {
            this.$isEmpty = false;
            this._emit("changeSelection");
        }
    };

    this.getSelectionAnchor = function() {
        if (this.$isEmpty)
            return this.getSelectionLead()
        else
            return this.selectionAnchor.getPosition();
    };

    this.getSelectionLead = function() {
        return this.selectionLead.getPosition();
    };

    this.shiftSelection = function(columns) {
        if (this.$isEmpty) {
            this.moveCursorTo(this.selectionLead.row, this.selectionLead.column + columns);
            return;
        };

        var anchor = this.getSelectionAnchor();
        var lead = this.getSelectionLead();

        var isBackwards = this.isBackwards();

        if (!isBackwards || anchor.column !== 0)
            this.setSelectionAnchor(anchor.row, anchor.column + columns);

        if (isBackwards || lead.column !== 0) {
            this.$moveSelection(function() {
                this.moveCursorTo(lead.row, lead.column + columns);
            });
        }
    };

    this.isBackwards = function() {
        var anchor = this.selectionAnchor;
        var lead = this.selectionLead;
        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
    };

    this.getRange = function() {
        var anchor = this.selectionAnchor;
        var lead = this.selectionLead;

        if (this.isEmpty())
            return Range.fromPoints(lead, lead);

        if (this.isBackwards()) {
            return Range.fromPoints(lead, anchor);
        }
        else {
            return Range.fromPoints(anchor, lead);
        }
    };

    this.clearSelection = function() {
        if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit("changeSelection");
        }
    };

    this.selectAll = function() {
        var lastRow = this.doc.getLength() - 1;
        this.setSelectionAnchor(lastRow, this.doc.getLine(lastRow).length);
        this.moveCursorTo(0, 0);
    };

    this.setSelectionRange = function(range, reverse) {
        if (reverse) {
            this.setSelectionAnchor(range.end.row, range.end.column);
            this.selectTo(range.start.row, range.start.column);
        } else {
            this.setSelectionAnchor(range.start.row, range.start.column);
            this.selectTo(range.end.row, range.end.column);
        }
        this.$updateDesiredColumn();
    };

    this.$updateDesiredColumn = function() {
        var cursor = this.getCursor();
        this.$desiredColumn = this.session.documentToScreenColumn(cursor.row, cursor.column);
    };

    this.$moveSelection = function(mover) {
        var lead = this.selectionLead;
        if (this.$isEmpty)
            this.setSelectionAnchor(lead.row, lead.column);

        mover.call(this);
    };

    this.selectTo = function(row, column) {
        this.$moveSelection(function() {
            this.moveCursorTo(row, column);
        });
    };

    this.selectToPosition = function(pos) {
        this.$moveSelection(function() {
            this.moveCursorToPosition(pos);
        });
    };

    this.selectUp = function() {
        this.$moveSelection(this.moveCursorUp);
    };

    this.selectDown = function() {
        this.$moveSelection(this.moveCursorDown);
    };

    this.selectRight = function() {
        this.$moveSelection(this.moveCursorRight);
    };

    this.selectLeft = function() {
        this.$moveSelection(this.moveCursorLeft);
    };

    this.selectLineStart = function() {
        this.$moveSelection(this.moveCursorLineStart);
    };

    this.selectLineEnd = function() {
        this.$moveSelection(this.moveCursorLineEnd);
    };

    this.selectFileEnd = function() {
        this.$moveSelection(this.moveCursorFileEnd);
    };

    this.selectFileStart = function() {
        this.$moveSelection(this.moveCursorFileStart);
    };

    this.selectWordRight = function() {
        this.$moveSelection(this.moveCursorWordRight);
    };

    this.selectWordLeft = function() {
        this.$moveSelection(this.moveCursorWordLeft);
    };

    this.selectWord = function() {
        var cursor = this.getCursor();
        var range  = this.session.getWordRange(cursor.row, cursor.column);
        this.setSelectionRange(range);
    };

    // Selects a word including its right whitespace
    this.selectAWord = function() {
        var cursor = this.getCursor();
        var range = this.session.getAWordRange(cursor.row, cursor.column);
        this.setSelectionRange(range);
    };

    this.selectLine = function() {
        var rowStart = this.selectionLead.row;
        var rowEnd;

        var foldLine = this.session.getFoldLine(rowStart);
        if (foldLine) {
            rowStart = foldLine.start.row;
            rowEnd = foldLine.end.row;
        } else {
            rowEnd = rowStart;
        }
        this.setSelectionAnchor(rowStart, 0);
        this.$moveSelection(function() {
            this.moveCursorTo(rowEnd + 1, 0);
        });
    };

    this.moveCursorUp = function() {
        this.moveCursorBy(-1, 0);
    };

    this.moveCursorDown = function() {
        this.moveCursorBy(1, 0);
    };

    this.moveCursorLeft = function() {
        var cursor = this.selectionLead.getPosition(),
            fold;

        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
        } else if (cursor.column == 0) {
            // cursor is a line (start
            if (cursor.row > 0) {
                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column-tabSize, cursor.column).split(" ").length-1 == tabSize)
                this.moveCursorBy(0, -tabSize);
            else
                this.moveCursorBy(0, -1);
        }
    };

    this.moveCursorRight = function() {
        var cursor = this.selectionLead.getPosition(),
            fold;
        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
            this.moveCursorTo(fold.end.row, fold.end.column);
        }
        else if (this.selectionLead.column == this.doc.getLine(this.selectionLead.row).length) {
            if (this.selectionLead.row < this.doc.getLength() - 1) {
                this.moveCursorTo(this.selectionLead.row + 1, 0);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            var cursor = this.selectionLead;
            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column+tabSize).split(" ").length-1 == tabSize)
                this.moveCursorBy(0, tabSize);
            else
                this.moveCursorBy(0, 1);
        }
    };

    this.moveCursorLineStart = function() {
        var row = this.selectionLead.row;
        var column = this.selectionLead.column;
        var screenRow = this.session.documentToScreenRow(row, column);

        // Determ the doc-position of the first character at the screen line.
        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);

        // Determ the line
        var beforeCursor = this.session.getDisplayLine(
            row, null,
            firstColumnPosition.row, firstColumnPosition.column
        );

        var leadingSpace = beforeCursor.match(/^\s*/);
        if (leadingSpace[0].length == column) {
            this.moveCursorTo(
                firstColumnPosition.row, firstColumnPosition.column
            );
        }
        else {
            this.moveCursorTo(
                firstColumnPosition.row,
                firstColumnPosition.column + leadingSpace[0].length
            );
        }
    };

    this.moveCursorLineEnd = function() {
        var lead = this.selectionLead;
        var lastRowColumnPosition =
            this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
        this.moveCursorTo(
            lastRowColumnPosition.row,
            lastRowColumnPosition.column
        );
    };

    this.moveCursorFileEnd = function() {
        var row = this.doc.getLength() - 1;
        var column = this.doc.getLine(row).length;
        this.moveCursorTo(row, column);
    };

    this.moveCursorFileStart = function() {
        this.moveCursorTo(0, 0);
    };

    this.moveCursorWordRight = function() {
        var row = this.selectionLead.row;
        var column = this.selectionLead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        var match;
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;

        // skip folds
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            this.moveCursorTo(fold.end.row, fold.end.column);
            return;
        }
        
        // first skip space
        if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
            column += this.session.nonTokenRe.lastIndex;
            this.session.nonTokenRe.lastIndex = 0;
            rightOfCursor = line.substring(column);
        }
        
        // if at line end proceed with next line
        if (column >= line.length) {
            this.moveCursorTo(row, line.length);
            this.moveCursorRight();
            if (row < this.doc.getLength() - 1)
                this.moveCursorWordRight();
            return;
        }
        
        // advance to the end of the next token
        if (match = this.session.tokenRe.exec(rightOfCursor)) {
            column += this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    };

    this.moveCursorWordLeft = function() {
        var row = this.selectionLead.row;
        var column = this.selectionLead.column;

        // skip folds
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
            return;
        }

        var str = this.session.getFoldStringAt(row, column, -1);
        if (str == null) {
            str = this.doc.getLine(row).substring(0, column)
        }
        
        var leftOfCursor = lang.stringReverse(str);
        var match;
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        
        // skip whitespace
        if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
            column -= this.session.nonTokenRe.lastIndex;
            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
            this.session.nonTokenRe.lastIndex = 0;
        }
        
        // if at begin of the line proceed in line above
        if (column <= 0) {
            this.moveCursorTo(row, 0);
            this.moveCursorLeft();
            if (row > 0)
                this.moveCursorWordLeft();
            return;
        }

        // move to the begin of the word
        if (match = this.session.tokenRe.exec(leftOfCursor)) {
            column -= this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    };

    this.moveCursorBy = function(rows, chars) {
        var screenPos = this.session.documentToScreenPosition(
            this.selectionLead.row,
            this.selectionLead.column
        );

        var screenCol = (chars === 0 && this.$desiredColumn) || screenPos.column;
        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenCol);

        // move the cursor and update the desired column
        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
    };

    this.moveCursorToPosition = function(position) {
        this.moveCursorTo(position.row, position.column);
    };

    this.moveCursorTo = function(row, column, preventUpdateDesiredColumn) {
        // Ensure the row/column is not inside of a fold.
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            row = fold.start.row;
            column = fold.start.column;
        }

        this.$preventUpdateDesiredColumnOnChange = true;
        this.selectionLead.setPosition(row, column);
        this.$preventUpdateDesiredColumnOnChange = false;

        if (!preventUpdateDesiredColumn)
            this.$updateDesiredColumn(this.selectionLead.column);
    };

    this.moveCursorToScreen = function(row, column, preventUpdateDesiredColumn) {
        var pos = this.session.screenToDocumentPosition(row, column);
        row = pos.row;
        column = pos.column;
        this.moveCursorTo(row, column, preventUpdateDesiredColumn);
    };

}).call(Selection.prototype);

exports.Selection = Selection;
});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/range', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

var Range = function(startRow, startColumn, endRow, endColumn) {
    this.start = {
        row: startRow,
        column: startColumn
    };

    this.end = {
        row: endRow,
        column: endColumn
    };
};

(function() {
    this.isEequal = function(range) {
        return this.start.row == range.start.row &&
            this.end.row == range.end.row &&
            this.start.column == range.start.column &&
            this.end.column == range.end.column
    };

    this.toString = function() {
        return ("Range: [" + this.start.row + "/" + this.start.column +
            "] -> [" + this.end.row + "/" + this.end.column + "]");
    };

    this.contains = function(row, column) {
        return this.compare(row, column) == 0;
    };

    /**
     * Compares this range (A) with another range (B), where B is the passed in
     * range.
     *
     * Return values:
     *  -2: (B) is infront of (A) and doesn't intersect with (A)
     *  -1: (B) begins before (A) but ends inside of (A)
     *   0: (B) is completly inside of (A) OR (A) is complety inside of (B)
     *  +1: (B) begins inside of (A) but ends outside of (A)
     *  +2: (B) is after (A) and doesn't intersect with (A)
     *
     *  42: FTW state: (B) ends in (A) but starts outside of (A)
     */
    this.compareRange = function(range) {
        var cmp,
            end = range.end,
            start = range.start;

        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            } else if (cmp == 0) {
                return 1;
            } else {
                return 0;
            }
        } else if (cmp == -1) {
            return -2;
        } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            } else if (cmp == 1) {
                return 42;
            } else {
                return 0;
            }
        }
    }

    this.comparePoint = function(p) {
        return this.compare(p.row, p.column);
    }

    this.containsRange = function(range) {
        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    }

    this.isEnd = function(row, column) {
        return this.end.row == row && this.end.column == column;
    }

    this.isStart = function(row, column) {
        return this.start.row == row && this.start.column == column;
    }

    this.setStart = function(row, column) {
        if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
        } else {
            this.start.row = row;
            this.start.column = column;
        }
    }

    this.setEnd = function(row, column) {
        if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
        } else {
            this.end.row = row;
            this.end.column = column;
        }
    }

    this.inside = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    }

    this.insideStart = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    }

    this.insideEnd = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    }

    this.compare = function(row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
            };
        }

        if (row < this.start.row)
            return -1;

        if (row > this.end.row)
            return 1;

        if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;

        if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;

        return 0;
    };

    /**
     * Like .compare(), but if isStart is true, return -1;
     */
    this.compareStart = function(row, column) {
        if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    }

    /**
     * Like .compare(), but if isEnd is true, return 1;
     */
    this.compareEnd = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else {
            return this.compare(row, column);
        }
    }

    this.compareInside = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    }

    this.clipRows = function(firstRow, lastRow) {
        if (this.end.row > lastRow) {
            var end = {
                row: lastRow+1,
                column: 0
            };
        }

        if (this.start.row > lastRow) {
            var start = {
                row: lastRow+1,
                column: 0
            };
        }

        if (this.start.row < firstRow) {
            var start = {
                row: firstRow,
                column: 0
            };
        }

        if (this.end.row < firstRow) {
            var end = {
                row: firstRow,
                column: 0
            };
        }
        return Range.fromPoints(start || this.start, end || this.end);
    };

    this.extend = function(row, column) {
        var cmp = this.compare(row, column);

        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = {row: row, column: column};
        else
            var end = {row: row, column: column};

        return Range.fromPoints(start || this.start, end || this.end);
    };

    this.isEmpty = function() {
        return (this.start.row == this.end.row && this.start.column == this.end.column);
    };

    this.isMultiLine = function() {
        return (this.start.row !== this.end.row);
    };

    this.clone = function() {
        return Range.fromPoints(this.start, this.end);
    };

    this.collapseRows = function() {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0)
        else
            return new Range(this.start.row, 0, this.end.row, 0)
    };

    this.toScreenRange = function(session) {
        var screenPosStart =
            session.documentToScreenPosition(this.start);
        var screenPosEnd =
            session.documentToScreenPosition(this.end);

        return new Range(
            screenPosStart.row, screenPosStart.column,
            screenPosEnd.row, screenPosEnd.column
        );
    };

}).call(Range.prototype);


Range.fromPoints = function(start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};

exports.Range = Range;
});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Mihai Sucan <mihai DOT sucan AT gmail DOT com>
 *      Chris Spencer <chris.ag.spencer AT googlemail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/mode/text', ['require', 'exports', 'module' , 'ace/tokenizer', 'ace/mode/text_highlight_rules', 'ace/mode/behaviour', 'ace/unicode'], function(require, exports, module) {
"use strict";

var Tokenizer = require("../tokenizer").Tokenizer;
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var Behaviour = require("./behaviour").Behaviour;
var unicode = require("../unicode");

var Mode = function() {
    this.$tokenizer = new Tokenizer(new TextHighlightRules().getRules());
    this.$behaviour = new Behaviour();
};

(function() {

    this.tokenRe = new RegExp("^["
        + unicode.packages.L
        + unicode.packages.Mn + unicode.packages.Mc
        + unicode.packages.Nd
        + unicode.packages.Pc + "\\$_]+", "g"
    );
    
    this.nonTokenRe = new RegExp("^(?:[^"
        + unicode.packages.L
        + unicode.packages.Mn + unicode.packages.Mc
        + unicode.packages.Nd
        + unicode.packages.Pc + "\\$_]|\s])+", "g"
    );

    this.getTokenizer = function() {
        return this.$tokenizer;
    };

    this.toggleCommentLines = function(state, doc, startRow, endRow) {
    };

    this.getNextLineIndent = function(state, line, tab) {
        return "";
    };

    this.checkOutdent = function(state, line, input) {
        return false;
    };

    this.autoOutdent = function(state, doc, row) {
    };

    this.$getIndent = function(line) {
        var match = line.match(/^(\s+)/);
        if (match) {
            return match[1];
        }

        return "";
    };
    
    this.createWorker = function(session) {
        return null;
    };

    this.highlightSelection = function(editor) {
        var session = editor.session;
        if (!session.$selectionOccurrences)
            session.$selectionOccurrences = [];

        if (session.$selectionOccurrences.length)
            this.clearSelectionHighlight(editor);

        var selection = editor.getSelectionRange();
        if (selection.isEmpty() || selection.isMultiLine())
            return;

        var startOuter = selection.start.column - 1;
        var endOuter = selection.end.column + 1;
        var line = session.getLine(selection.start.row);
        var lineCols = line.length;
        var needle = line.substring(Math.max(startOuter, 0),
                                    Math.min(endOuter, lineCols));

        // Make sure the outer characters are not part of the word.
        if ((startOuter >= 0 && /^[\w\d]/.test(needle)) ||
            (endOuter <= lineCols && /[\w\d]$/.test(needle)))
            return;

        needle = line.substring(selection.start.column, selection.end.column);
        if (!/^[\w\d]+$/.test(needle))
            return;

        var cursor = editor.getCursorPosition();

        var newOptions = {
            wrap: true,
            wholeWord: true,
            caseSensitive: true,
            needle: needle
        };

        var currentOptions = editor.$search.getOptions();
        editor.$search.set(newOptions);

        var ranges = editor.$search.findAll(session);
        ranges.forEach(function(range) {
            if (!range.contains(cursor.row, cursor.column)) {
                var marker = session.addMarker(range, "ace_selected_word", "text");
                session.$selectionOccurrences.push(marker);
            }
        });

        editor.$search.set(currentOptions);
    };

    this.clearSelectionHighlight = function(editor) {
        if (!editor.session.$selectionOccurrences)
            return;

        editor.session.$selectionOccurrences.forEach(function(marker) {
            editor.session.removeMarker(marker);
        });

        editor.session.$selectionOccurrences = [];
    };
    
    this.createModeDelegates = function (mapping) {
        if (!this.$embeds) {
            return;
        }
        this.$modes = {};
        for (var i = 0; i < this.$embeds.length; i++) {
            if (mapping[this.$embeds[i]]) {
                this.$modes[this.$embeds[i]] = new mapping[this.$embeds[i]]();
            }
        }
        
        var delegations = ['toggleCommentLines', 'getNextLineIndent', 'checkOutdent', 'autoOutdent', 'transformAction'];

        for (var i = 0; i < delegations.length; i++) {
            (function(scope) {
              var functionName = delegations[i];
              var defaultHandler = scope[functionName];
              scope[delegations[i]] = function() {
                  return this.$delegator(functionName, arguments, defaultHandler);
              }
            } (this));
        }
    }
    
    this.$delegator = function(method, args, defaultHandler) {
        var state = args[0];
        
        for (var i = 0; i < this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]]) continue;
            
            var split = state.split(this.$embeds[i]);
            if (!split[0] && split[1]) {
                args[0] = split[1];
                var mode = this.$modes[this.$embeds[i]];
                return mode[method].apply(mode, args);
            }
        }
        var ret = defaultHandler.apply(this, args);
        return defaultHandler ? ret : undefined;
    };
    
    this.transformAction = function(state, action, editor, session, param) {
        if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
                if (behaviours[key][action]) {
                    var ret = behaviours[key][action].apply(this, arguments);
                    if (ret) {
                        return ret;
                    }
                }
            }
        }
    }
    
}).call(Mode.prototype);

exports.Mode = Mode;
});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/tokenizer', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

var Tokenizer = function(rules, flag) {
    flag = flag ? "g" + flag : "g";
    this.rules = rules;

    this.regExps = {};
    this.matchMappings = {};
    for ( var key in this.rules) {
        var rule = this.rules[key];
        var state = rule;
        var ruleRegExps = [];
        var matchTotal = 0;
        var mapping = this.matchMappings[key] = {};
        
        for ( var i = 0; i < state.length; i++) {
            // Count number of matching groups. 2 extra groups from the full match
            // And the catch-all on the end (used to force a match);
            var matchcount = new RegExp("(?:(" + state[i].regex + ")|(.))").exec("a").length - 2;
        
            // Replace any backreferences and offset appropriately.
            var adjustedregex = state[i].regex.replace(/\\([0-9]+)/g, function (match, digit) {
                return "\\" + (parseInt(digit, 10) + matchTotal + 1);
            });
            
            mapping[matchTotal] = {
                rule: i,
                len: matchcount
            };
            matchTotal += matchcount;
            
            ruleRegExps.push(adjustedregex);
        }

        this.regExps[key] = new RegExp("(?:(" + ruleRegExps.join(")|(") + ")|(.))", flag);
    }
};

(function() {

    this.getLineTokens = function(line, startState) {
        var currentState = startState;
        var state = this.rules[currentState];
        var mapping = this.matchMappings[currentState];
        var re = this.regExps[currentState];
        re.lastIndex = 0;
        
        var match, tokens = [];
        
        var lastIndex = 0;
        
        var token = {
            type: null,
            value: ""
        };
        
        while (match = re.exec(line)) {
            var type = "text";
            var rule = null;
            var value = [match[0]];

            for (var i = 0; i < match.length-2; i++) {
                if (match[i + 1] !== undefined) {
                    rule = state[mapping[i].rule];
                    
                    if (mapping[i].len > 1) {
                        value = match.slice(i+2, i+1+mapping[i].len);
                    }
                    
                    // compute token type
                    if (typeof rule.token == "function")
                        type = rule.token.apply(this, value);
                    else
                        type = rule.token;

                    var next = rule.next;                    
                    if (next && next !== currentState) {
                        currentState = next;
                        state = this.rules[currentState];
                        mapping = this.matchMappings[currentState];
                        lastIndex = re.lastIndex;

                        re = this.regExps[currentState];
                        re.lastIndex = lastIndex;
                    }
                    break;
                }
            }

            if (value[0]) {
                if (typeof type == "string") {
                    value = [value.join("")];
                    type = [type];
                }
                for (var i = 0; i < value.length; i++) {
                    if ((!rule || rule.merge || type[i] === "text") && token.type === type[i]) {
                        token.value += value[i];
                    } else {
                        if (token.type) {
                            tokens.push(token);
                        }
                    
                        token = {
                            type: type[i],
                            value: value[i]
                        };
                    }
                }
            }
            
            if (lastIndex == line.length)
                break;
            
            lastIndex = re.lastIndex;
        }

        if (token.type)
            tokens.push(token);

        return {
            tokens : tokens,
            state : currentState
        };
    };

}).call(Tokenizer.prototype);

exports.Tokenizer = Tokenizer;
});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/mode/text_highlight_rules', ['require', 'exports', 'module' , 'ace/lib/lang'], function(require, exports, module) {
"use strict";

var lang = require("../lib/lang");

var TextHighlightRules = function() {

    // regexp must not have capturing parentheses
    // regexps are ordered -> the first match is used

    this.$rules = {
        "start" : [{
            token : "empty_line",
            regex : '^$'
        }, {
            token : "text",
            regex : ".+"
        }]
    };
};

(function() {

    this.addRules = function(rules, prefix) {
        for (var key in rules) {
            var state = rules[key];
            for (var i=0; i<state.length; i++) {
                var rule = state[i];
                if (rule.next) {
                    rule.next = prefix + rule.next;
                } else {
                    rule.next = prefix + key;
                }
            }
            this.$rules[prefix + key] = state;
        }
    };

    this.getRules = function() {
        return this.$rules;
    };
    
    this.embedRules = function (HighlightRules, prefix, escapeRules, states) {
        var embedRules = new HighlightRules().getRules();
        if (states) {
            for (var i = 0; i < states.length; i++) {
                states[i] = prefix + states[i];
            }
        } else {
            states = [];
            for (var key in embedRules) {
                states.push(prefix + key);
            }
        }
        this.addRules(embedRules, prefix);
        
        for (var i = 0; i < states.length; i++) {
            Array.prototype.unshift.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
        }
        
        if (!this.$embeds) {
            this.$embeds = [];
        }
        this.$embeds.push(prefix);
    }
    
    this.getEmbeds = function() {
        return this.$embeds;
    }

}).call(TextHighlightRules.prototype);

exports.TextHighlightRules = TextHighlightRules;
});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Chris Spencer <chris.ag.spencer AT googlemail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/mode/behaviour', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

var Behaviour = function() {
   this.$behaviours = {};
};

(function () {

    this.add = function (name, action, callback) {
        switch (undefined) {
          case this.$behaviours:
              this.$behaviours = {};
          case this.$behaviours[name]:
              this.$behaviours[name] = {};
        }
        this.$behaviours[name][action] = callback;
    }
    
    this.addBehaviours = function (behaviours) {
        for (var key in behaviours) {
            for (var action in behaviours[key]) {
                this.add(key, action, behaviours[key][action]);
            }
        }
    }
    
    this.remove = function (name) {
        if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
        }
    }
    
    this.inherit = function (mode, filter) {
        if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter);
        } else {
            var behaviours = mode.getBehaviours(filter);
        }
        this.addBehaviours(behaviours);
    }
    
    this.getBehaviours = function (filter) {
        if (!filter) {
            return this.$behaviours;
        } else {
            var ret = {}
            for (var i = 0; i < filter.length; i++) {
                if (this.$behaviours[filter[i]]) {
                    ret[filter[i]] = this.$behaviours[filter[i]];
                }
            }
            return ret;
        }
    }

}).call(Behaviour.prototype);

exports.Behaviour = Behaviour;
});define('ace/unicode', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

/*
XRegExp Unicode plugin pack: Categories 1.0
(c) 2010 Steven Levithan
MIT License
<http://xregexp.com>
Uses the Unicode 5.2 character database

This package for the XRegExp Unicode plugin enables the following Unicode categories (aka properties):

L - Letter (the top-level Letter category is included in the Unicode plugin base script)
    Ll - Lowercase letter
    Lu - Uppercase letter
    Lt - Titlecase letter
    Lm - Modifier letter
    Lo - Letter without case
M - Mark
    Mn - Non-spacing mark
    Mc - Spacing combining mark
    Me - Enclosing mark
N - Number
    Nd - Decimal digit
    Nl - Letter number
    No -  Other number
P - Punctuation
    Pd - Dash punctuation
    Ps - Open punctuation
    Pe - Close punctuation
    Pi - Initial punctuation
    Pf - Final punctuation
    Pc - Connector punctuation
    Po - Other punctuation
S - Symbol
    Sm - Math symbol
    Sc - Currency symbol
    Sk - Modifier symbol
    So - Other symbol
Z - Separator
    Zs - Space separator
    Zl - Line separator
    Zp - Paragraph separator
C - Other
    Cc - Control
    Cf - Format
    Co - Private use
    Cs - Surrogate
    Cn - Unassigned

Example usage:

    \p{N}
    \p{Cn}
*/


// will be populated by addUnicodePackage
exports.packages = {};

addUnicodePackage({
    L:  "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
    Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
    Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
    Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
    Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
    Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
    M:  "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
    Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
    Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
    Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
    N:  "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
    Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
    Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
    No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
    P:  "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
    Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
    Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
    Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
    Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
    Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
    Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
    Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
    S:  "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
    Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
    Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
    Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
    So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
    Z:  "002000A01680180E2000-200A20282029202F205F3000",
    Zs: "002000A01680180E2000-200A202F205F3000",
    Zl: "2028",
    Zp: "2029",
    C:  "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
    Cc: "0000-001F007F-009F",
    Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
    Co: "E000-F8FF",
    Cs: "D800-DFFF",
    Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
});

function addUnicodePackage (pack) {
    var codePoint = /\w{4}/g;
    for (var name in pack)
        exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
};

});/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/document', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/event_emitter', 'ace/range', 'ace/anchor'], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;
var Anchor = require("./anchor").Anchor;

var Document = function(text) {
    this.$lines = [];

    if (Array.isArray(text)) {
        this.insertLines(0, text);
    }
    // There has to be one line at least in the document. If you pass an empty
    // string to the insert function, nothing will happen. Workaround.
    else if (text.length == 0) {
        this.$lines = [""];
    } else {
        this.insert({row: 0, column:0}, text);
    }
};

(function() {

    oop.implement(this, EventEmitter);

    this.setValue = function(text) {
        var len = this.getLength();
        this.remove(new Range(0, 0, len, this.getLine(len-1).length));
        this.insert({row: 0, column:0}, text);
    };

    this.getValue = function() {
        return this.getAllLines().join(this.getNewLineCharacter());
    };

    this.createAnchor = function(row, column) {
        return new Anchor(this, row, column);
    };

    // check for IE split bug
    if ("aaa".split(/a/).length == 0)
        this.$split = function(text) {
            return text.replace(/\r\n|\r/g, "\n").split("\n");
        }
    else
        this.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
        };


    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        if (match) {
            this.$autoNewLine = match[1];
        } else {
            this.$autoNewLine = "\n";
        }
    };

    this.getNewLineCharacter = function() {
      switch (this.$newLineMode) {
          case "windows":
              return "\r\n";

          case "unix":
              return "\n";

          case "auto":
              return this.$autoNewLine;
      }
    };

    this.$autoNewLine = "\n";
    this.$newLineMode = "auto";
    this.setNewLineMode = function(newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;

        this.$newLineMode = newLineMode;
    };

    this.getNewLineMode = function() {
        return this.$newLineMode;
    };

    this.isNewLine = function(text) {
        return (text == "\r\n" || text == "\r" || text == "\n");
    };

    /**
     * Get a verbatim copy of the given line as it is in the document
     */
    this.getLine = function(row) {
        return this.$lines[row] || "";
    };

    this.getLines = function(firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    };

    /**
     * Returns all lines in the document as string array. Warning: The caller
     * should not modify this array!
     */
    this.getAllLines = function() {
        return this.getLines(0, this.getLength());
    };

    this.getLength = function() {
        return this.$lines.length;
    };

    this.getTextRange = function(range) {
        if (range.start.row == range.end.row) {
            return this.$lines[range.start.row].substring(range.start.column,
                                                         range.end.column);
        }
        else {
            var lines = [];
            lines.push(this.$lines[range.start.row].substring(range.start.column));
            lines.push.apply(lines, this.getLines(range.start.row+1, range.end.row-1));
            lines.push(this.$lines[range.end.row].substring(0, range.end.column));
            return lines.join(this.getNewLineCharacter());
        }
    };

    this.$clipPosition = function(position) {
        var length = this.getLength();
        if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length-1).length;
        }
        return position;
    };

    this.insert = function(position, text) {
        if (!text || text.length === 0)
            return position;

        position = this.$clipPosition(position);

        if (this.getLength() <= 1)
            this.$detectNewLine(text);

        var lines = this.$split(text);
        var firstLine = lines.splice(0, 1)[0];
        var lastLine = lines.length == 0 ? null : lines.splice(lines.length - 1, 1)[0];

        position = this.insertInLine(position, firstLine);
        if (lastLine !== null) {
            position = this.insertNewLine(position); // terminate first line
            position = this.insertLines(position.row, lines);
            position = this.insertInLine(position, lastLine || "");
        }
        return position;
    };

    this.insertLines = function(row, lines) {
        if (lines.length == 0)
            return {row: row, column: 0};

        var args = [row, 0];
        args.push.apply(args, lines);
        this.$lines.splice.apply(this.$lines, args);

        var range = new Range(row, 0, row + lines.length, 0);
        var delta = {
            action: "insertLines",
            range: range,
            lines: lines
        };
        this._emit("change", { data: delta });
        return range.end;
    };

    this.insertNewLine = function(position) {
        position = this.$clipPosition(position);
        var line = this.$lines[position.row] || "";

        this.$lines[position.row] = line.substring(0, position.column);
        this.$lines.splice(position.row + 1, 0, line.substring(position.column, line.length));

        var end = {
            row : position.row + 1,
            column : 0
        };

        var delta = {
            action: "insertText",
            range: Range.fromPoints(position, end),
            text: this.getNewLineCharacter()
        };
        this._emit("change", { data: delta });

        return end;
    };

    this.insertInLine = function(position, text) {
        if (text.length == 0)
            return position;

        var line = this.$lines[position.row] || "";

        this.$lines[position.row] = line.substring(0, position.column) + text
                + line.substring(position.column);

        var end = {
            row : position.row,
            column : position.column + text.length
        };

        var delta = {
            action: "insertText",
            range: Range.fromPoints(position, end),
            text: text
        };
        this._emit("change", { data: delta });

        return end;
    };

    this.remove = function(range) {
        // clip to document
        range.start = this.$clipPosition(range.start);
        range.end = this.$clipPosition(range.end);

        if (range.isEmpty())
            return range.start;

        var firstRow = range.start.row;
        var lastRow = range.end.row;

        if (range.isMultiLine()) {
            var firstFullRow = range.start.column == 0 ? firstRow : firstRow + 1;
            var lastFullRow = lastRow - 1;

            if (range.end.column > 0)
                this.removeInLine(lastRow, 0, range.end.column);

            if (lastFullRow >= firstFullRow)
                this.removeLines(firstFullRow, lastFullRow);

            if (firstFullRow != firstRow) {
                this.removeInLine(firstRow, range.start.column, this.getLine(firstRow).length);
                this.removeNewLine(range.start.row);
            }
        }
        else {
            this.removeInLine(firstRow, range.start.column, range.end.column);
        }
        return range.start;
    };

    this.removeInLine = function(row, startColumn, endColumn) {
        if (startColumn == endColumn)
            return;

        var range = new Range(row, startColumn, row, endColumn);
        var line = this.getLine(row);
        var removed = line.substring(startColumn, endColumn);
        var newLine = line.substring(0, startColumn) + line.substring(endColumn, line.length);
        this.$lines.splice(row, 1, newLine);

        var delta = {
            action: "removeText",
            range: range,
            text: removed
        };
        this._emit("change", { data: delta });
        return range.start;
    };

    /**
     * Removes a range of full lines
     *
     * @param firstRow {Integer} The first row to be removed
     * @param lastRow {Integer} The last row to be removed
     * @return {String[]} The removed lines
     */
    this.removeLines = function(firstRow, lastRow) {
        var range = new Range(firstRow, 0, lastRow + 1, 0);
        var removed = this.$lines.splice(firstRow, lastRow - firstRow + 1);

        var delta = {
            action: "removeLines",
            range: range,
            nl: this.getNewLineCharacter(),
            lines: removed
        };
        this._emit("change", { data: delta });
        return removed;
    };

    this.removeNewLine = function(row) {
        var firstLine = this.getLine(row);
        var secondLine = this.getLine(row+1);

        var range = new Range(row, firstLine.length, row+1, 0);
        var line = firstLine + secondLine;

        this.$lines.splice(row, 2, line);

        var delta = {
            action: "removeText",
            range: range,
            text: this.getNewLineCharacter()
        };
        this._emit("change", { data: delta });
    };

    this.replace = function(range, text) {
        if (text.length == 0 && range.isEmpty())
            return range.start;

        // Shortcut: If the text we want to insert is the same as it is already
        // in the document, we don't have to replace anything.
        if (text == this.getTextRange(range))
            return range.end;

        this.remove(range);
        if (text) {
            var end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }

        return end;
    };

    this.applyDeltas = function(deltas) {
        for (var i=0; i<deltas.length; i++) {
            var delta = deltas[i];
            var range = Range.fromPoints(delta.range.start, delta.range.end);

            if (delta.action == "insertLines")
                this.insertLines(range.start.row, delta.lines);
            else if (delta.action == "insertText")
                this.insert(range.start, delta.text);
            else if (delta.action == "removeLines")
                this.removeLines(range.start.row, range.end.row - 1);
            else if (delta.action == "removeText")
                this.remove(range);
        }
    };

    this.revertDeltas = function(deltas) {
        for (var i=deltas.length-1; i>=0; i--) {
            var delta = deltas[i];

            var range = Range.fromPoints(delta.range.start, delta.range.end);

            if (delta.action == "insertLines")
                this.removeLines(range.start.row, range.end.row - 1);
            else if (delta.action == "insertText")
                this.remove(range);
            else if (delta.action == "removeLines")
                this.insertLines(range.start.row, delta.lines);
            else if (delta.action == "removeText")
                this.insert(range.start, delta.text);
        }
    };

}).call(Document.prototype);

exports.Document = Document;
});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/anchor', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/event_emitter'], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;

/**
 * An Anchor is a floating pointer in the document. Whenever text is inserted or
 * deleted before the cursor, the position of the cursor is updated
 */
var Anchor = exports.Anchor = function(doc, row, column) {
    this.document = doc;
    
    if (typeof column == "undefined")
        this.setPosition(row.row, row.column);
    else
        this.setPosition(row, column);

    this.$onChange = this.onChange.bind(this);
    doc.on("change", this.$onChange);
};

(function() {

    oop.implement(this, EventEmitter);
    
    this.getPosition = function() {
        return this.$clipPositionToDocument(this.row, this.column);
    };
    
    this.getDocument = function() {
        return this.document;
    };
    
    this.onChange = function(e) {
        var delta = e.data;
        var range = delta.range;
            
        if (range.start.row == range.end.row && range.start.row != this.row)
            return;
            
        if (range.start.row > this.row)
            return;
            
        if (range.start.row == this.row && range.start.column > this.column)
            return;
    
        var row = this.row;
        var column = this.column;
        
        if (delta.action === "insertText") {
            if (range.start.row === row && range.start.column <= column) {
                if (range.start.row === range.end.row) {
                    column += range.end.column - range.start.column;
                }
                else {
                    column -= range.start.column;
                    row += range.end.row - range.start.row;
                }
            }
            else if (range.start.row !== range.end.row && range.start.row < row) {
                row += range.end.row - range.start.row;
            }
        } else if (delta.action === "insertLines") {
            if (range.start.row <= row) {
                row += range.end.row - range.start.row;
            }
        }
        else if (delta.action == "removeText") {
            if (range.start.row == row && range.start.column < column) {
                if (range.end.column >= column)
                    column = range.start.column;
                else
                    column = Math.max(0, column - (range.end.column - range.start.column));
                
            } else if (range.start.row !== range.end.row && range.start.row < row) {
                if (range.end.row == row) {
                    column = Math.max(0, column - range.end.column) + range.start.column;
                }
                row -= (range.end.row - range.start.row);
            }
            else if (range.end.row == row) {
                row -= range.end.row - range.start.row;
                column = Math.max(0, column - range.end.column) + range.start.column;
            }
        } else if (delta.action == "removeLines") {
            if (range.start.row <= row) {
                if (range.end.row <= row)
                    row -= range.end.row - range.start.row;
                else {
                    row = range.start.row;
                    column = 0;
                }
            }
        }

        this.setPosition(row, column, true);
    };

    this.setPosition = function(row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        }
        else {
            pos = this.$clipPositionToDocument(row, column);
        }
        
        if (this.row == pos.row && this.column == pos.column)
            return;
            
        var old = {
            row: this.row,
            column: this.column
        };
        
        this.row = pos.row;
        this.column = pos.column;
        this._emit("change", {
            old: old,
            value: pos
        });
    };
    
    this.detach = function() {
        this.document.removeEventListener("change", this.$onChange);
    };
    
    this.$clipPositionToDocument = function(row, column) {
        var pos = {};
    
        if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }
        
        if (column < 0)
            pos.column = 0;
            
        return pos;
    };
    
}).call(Anchor.prototype);

});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/background_tokenizer', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/event_emitter'], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;

var BackgroundTokenizer = function(tokenizer, editor) {
    this.running = false;    
    this.lines = [];
    this.currentLine = 0;
    this.tokenizer = tokenizer;

    var self = this;

    this.$worker = function() {
        if (!self.running) { return; }

        var workerStart = new Date();
        var startLine = self.currentLine;
        var doc = self.doc;

        var processedLines = 0;

        var len = doc.getLength();
        while (self.currentLine < len) {
            self.lines[self.currentLine] = self.$tokenizeRows(self.currentLine, self.currentLine)[0];
            self.currentLine++;

            // only check every 5 lines
            processedLines += 1;
            if ((processedLines % 5 == 0) && (new Date() - workerStart) > 20) {
                self.fireUpdateEvent(startLine, self.currentLine-1);
                self.running = setTimeout(self.$worker, 20);
                return;
            }
        }

        self.running = false;

        self.fireUpdateEvent(startLine, len - 1);
    };
};

(function(){

    oop.implement(this, EventEmitter);

    this.setTokenizer = function(tokenizer) {
        this.tokenizer = tokenizer;
        this.lines = [];

        this.start(0);
    };

    this.setDocument = function(doc) {
        this.doc = doc;
        this.lines = [];

        this.stop();
    };

    this.fireUpdateEvent = function(firstRow, lastRow) {
        var data = {
            first: firstRow,
            last: lastRow
        };
        this._emit("update", {data: data});
    };

    this.start = function(startRow) {
        this.currentLine = Math.min(startRow || 0, this.currentLine,
                                    this.doc.getLength());

        // remove all cached items below this line
        this.lines.splice(this.currentLine, this.lines.length);

        this.stop();
        // pretty long delay to prevent the tokenizer from interfering with the user
        this.running = setTimeout(this.$worker, 700);
    };

    this.stop = function() {
        if (this.running)
            clearTimeout(this.running);
        this.running = false;
    };

    this.getTokens = function(firstRow, lastRow) {
        return this.$tokenizeRows(firstRow, lastRow);
    };

    this.getState = function(row) {
        return this.$tokenizeRows(row, row)[0].state;
    };

    this.$tokenizeRows = function(firstRow, lastRow) {
        if (!this.doc || isNaN(firstRow) || isNaN(lastRow))
            return [{'state':'start','tokens':[]}];
            
        var rows = [];

        // determine start state
        var state = "start";
        var doCache = false;
        if (firstRow > 0 && this.lines[firstRow - 1]) {
            state = this.lines[firstRow - 1].state;
            doCache = true;
        } else if (firstRow == 0) {
            state = "start";
            doCache = true;
        } else if (this.lines.length > 0) {
            // Guess that we haven't changed state.
            state = this.lines[this.lines.length-1].state;
        }

        var lines = this.doc.getLines(firstRow, lastRow);
        for (var row=firstRow; row<=lastRow; row++) {
            if (!this.lines[row]) {
                var tokens = this.tokenizer.getLineTokens(lines[row-firstRow] || "", state);
                var state = tokens.state;
                rows.push(tokens);

                if (doCache) {
                    this.lines[row] = tokens;
                }
            }
            else {
                var tokens = this.lines[row];
                state = tokens.state;
                rows.push(tokens);
            }
        }
        return rows;
    };

}).call(BackgroundTokenizer.prototype);

exports.BackgroundTokenizer = BackgroundTokenizer;
});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Julian Viereck <julian DOT viereck AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/edit_session/folding', ['require', 'exports', 'module' , 'ace/range', 'ace/edit_session/fold_line', 'ace/edit_session/fold', 'ace/token_iterator'], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;
var FoldLine = require("./fold_line").FoldLine;
var Fold = require("./fold").Fold;
var TokenIterator = require("../token_iterator").TokenIterator;

function Folding() {
    /**
     * Looks up a fold at a given row/column. Possible values for side:
     *   -1: ignore a fold if fold.start = row/column
     *   +1: ignore a fold if fold.end = row/column
     */
    this.getFoldAt = function(row, column, side) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine)
            return null;

        var folds = foldLine.folds;
        for (var i = 0; i < folds.length; i++) {
            var fold = folds[i];
            if (fold.range.contains(row, column)) {
                if (side == 1 && fold.range.isEnd(row, column)) {
                    continue;
                } else if (side == -1 && fold.range.isStart(row, column)) {
                    continue;
                }
                return fold;
            }
        }
    };

    /**
     * Returns all folds in the given range. Note, that this will return folds
     *
     */
    this.getFoldsInRange = function(range) {
        range = range.clone();
        var start = range.start;
        var end = range.end;
        var foldLines = this.$foldData;
        var foundFolds = [];

        start.column += 1;
        end.column -= 1;

        for (var i = 0; i < foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
                // Range is before foldLine. No intersection. This means,
                // there might be other foldLines that intersect.
                continue;
            }
            else if (cmp == -2) {
                // Range is after foldLine. There can't be any other foldLines then,
                // so let's give up.
                break;
            }

            var folds = foldLines[i].folds;
            for (var j = 0; j < folds.length; j++) {
                var fold = folds[j];
                cmp = fold.range.compareRange(range);
                if (cmp == -2) {
                    break;
                } else if (cmp == 2) {
                    continue;
                } else
                // WTF-state: Can happen due to -1/+1 to start/end column.
                if (cmp == 42) {
                    break;
                }
                foundFolds.push(fold);
            }
        }
        return foundFolds;
    };
    
    /**
     * Returns all folds in the document
     */
    this.getAllFolds = function() {
        var folds = [];
        var foldLines = this.$foldData;
        
        function addFold(fold) {
            folds.push(fold);
            if (!fold.subFolds)
                return;
                
            for (var i = 0; i < fold.subFolds.length; i++)
                addFold(fold.subFolds[i]);
        }
        
        for (var i = 0; i < foldLines.length; i++)
            for (var j = 0; j < foldLines[i].folds.length; j++)
                addFold(foldLines[i].folds[j]);

        return folds;
    };

    /**
     * Returns the string between folds at the given position.
     * E.g.
     *  foo<fold>b|ar<fold>wolrd -> "bar"
     *  foo<fold>bar<fold>wol|rd -> "world"
     *  foo<fold>bar<fo|ld>wolrd -> <null>
     *
     * where | means the position of row/column
     *
     * The trim option determs if the return string should be trimed according
     * to the "side" passed with the trim value:
     *
     * E.g.
     *  foo<fold>b|ar<fold>wolrd -trim=-1> "b"
     *  foo<fold>bar<fold>wol|rd -trim=+1> "rld"
     *  fo|o<fold>bar<fold>wolrd -trim=00> "foo"
     */
    this.getFoldStringAt = function(row, column, trim, foldLine) {
        foldLine = foldLine || this.getFoldLine(row);
        if (!foldLine)
            return null;

        var lastFold = {
            end: { column: 0 }
        };
        // TODO: Refactor to use getNextFoldTo function.
        var str, fold;
        for (var i = 0; i < foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                str = this
                    .getLine(fold.start.row)
                    .substring(lastFold.end.column, fold.start.column);
                break;
            }
            else if (cmp === 0) {
                return null;
            }
            lastFold = fold;
        }
        if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);

        if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
        else if (trim == 1)
            return str.substring(column - lastFold.end.column);
        else
            return str;
    };

    this.getFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                return foldLine;
            } else if (foldLine.end.row > docRow) {
                return null;
            }
        }
        return null;
    };

    // returns the fold which starts after or contains docRow
    this.getNextFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row >= docRow) {
                return foldLine;
            }
        }
        return null;
    };

    this.getFoldedRowCount = function(first, last) {
        var foldData = this.$foldData, rowCount = last-first+1;
        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i],
                end = foldLine.end.row,
                start = foldLine.start.row;
            if (end >= last) {
                if(start < last) {
                    if(start >= first)
                        rowCount -= last-start;
                    else
                        rowCount = 0;//in one fold
                }
                break;
            } else if(end >= first){
                if (start >= first) //fold inside range
                    rowCount -=  end-start;
                else
                    rowCount -=  end-first+1;
            }
        }
        return rowCount;
    };

    this.$addFoldLine = function(foldLine) {
        this.$foldData.push(foldLine);
        this.$foldData.sort(function(a, b) {
            return a.start.row - b.start.row;
        });
        return foldLine;
    };

    /**
     * Adds a new fold.
     *
     * @returns
     *      The new created Fold object or an existing fold object in case the
     *      passed in range fits an existing fold exactly.
     */
    this.addFold = function(placeholder, range) {
        var foldData = this.$foldData;
        var added = false;
        var fold;
        
        if (placeholder instanceof Fold)
            fold = placeholder;
        else
            fold = new Fold(range, placeholder);

        this.$clipRangeToDocument(fold.range);

        var startRow = fold.start.row;
        var startColumn = fold.start.column;
        var endRow = fold.end.row;
        var endColumn = fold.end.column;

        // --- Some checking ---
        if (fold.placeholder.length < 2)
            throw "Placeholder has to be at least 2 characters";

        if (startRow == endRow && endColumn - startColumn < 2)
            throw "The range has to be at least 2 characters width";

        var startFold = this.getFoldAt(startRow, startColumn, 1);
        var endFold = this.getFoldAt(endRow, endColumn, -1);
        if (startFold && endFold == startFold)
            return startFold.addSubFold(fold);

        if (
            (startFold && !startFold.range.isStart(startRow, startColumn))
            || (endFold && !endFold.range.isEnd(endRow, endColumn))
        ) {
            throw "A fold can't intersect already existing fold" + fold.range + startFold.range;
        }

        // Check if there are folds in the range we create the new fold for.
        var folds = this.getFoldsInRange(fold.range);
        if (folds.length > 0) {
            // Remove the folds from fold data.
            this.removeFolds(folds);
            // Add the removed folds as subfolds on the new fold.
            fold.subFolds = folds;
        }

        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
                foldLine.addFold(fold);
                added = true;
                break;
            }
            else if (startRow == foldLine.end.row) {
                foldLine.addFold(fold);
                added = true;
                if (!fold.sameRow) {
                    // Check if we might have to merge two FoldLines.
                    var foldLineNext = foldData[i + 1];
                    if (foldLineNext && foldLineNext.start.row == endRow) {
                        // We need to merge!
                        foldLine.merge(foldLineNext);
                        break;
                    }
                }
                break;
            }
            else if (endRow <= foldLine.start.row) {
                break;
            }
        }

        if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

        if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);

        // Notify that fold data has changed.
        this.$modified = true;
        this._emit("changeFold", { data: fold });

        return fold;
    };

    this.addFolds = function(folds) {
        folds.forEach(function(fold) {
            this.addFold(fold);
        }, this);
    };

    this.removeFold = function(fold) {
        var foldLine = fold.foldLine;
        var startRow = foldLine.start.row;
        var endRow = foldLine.end.row;

        var foldLines = this.$foldData;
        var folds = foldLine.folds;
        // Simple case where there is only one fold in the FoldLine such that
        // the entire fold line can get removed directly.
        if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
        } else
        // If the fold is the last fold of the foldLine, just remove it.
        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
        } else
        // If the fold is the first fold of the foldLine, just remove it.
        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
        } else
        // We know there are more then 2 folds and the fold is not at the edge.
        // This means, the fold is somewhere in between.
        //
        // If the fold is in one row, we just can remove it.
        if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
        } else
        // The fold goes over more then one row. This means remvoing this fold
        // will cause the fold line to get splitted up. newFoldLine is the second part
        {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
        }

        if (this.$useWrapMode) {
            this.$updateWrapData(startRow, endRow);
        }

        // Notify that fold data has changed.
        this.$modified = true;
        this._emit("changeFold", { data: fold });
    };

    this.removeFolds = function(folds) {
        // We need to clone the folds array passed in as it might be the folds
        // array of a fold line and as we call this.removeFold(fold), folds
        // are removed from folds and changes the current index.
        var cloneFolds = [];
        for (var i = 0; i < folds.length; i++) {
            cloneFolds.push(folds[i]);
        }

        cloneFolds.forEach(function(fold) {
            this.removeFold(fold);
        }, this);
        this.$modified = true;
    };

    this.expandFold = function(fold) {
        this.removeFold(fold);
        fold.subFolds.forEach(function(fold) {
            this.addFold(fold);
        }, this);
        fold.subFolds = [];
    };

    this.expandFolds = function(folds) {
        folds.forEach(function(fold) {
            this.expandFold(fold);
        }, this);
    };

    this.unfold = function(location, expandInner) {
        var range, folds;
        if (location == null)
            range = new Range(0, 0, this.getLength(), 0);
        else if (typeof location == "number")
            range = new Range(location, 0, location, this.getLine(location).length);
        else if ("row" in location)
            range = Range.fromPoints(location, location);
        else
            range = location;

        folds = this.getFoldsInRange(range);
        if (expandInner) {
            this.removeFolds(folds);
        } else {
            // TODO: might need to remove and add folds in one go instead of using
            // expandFolds several times.
            while (folds.length) {
                this.expandFolds(folds);
                folds = this.getFoldsInRange(range);
            }
        }
    };

    /**
     * Checks if a given documentRow is folded. This is true if there are some
     * folded parts such that some parts of the line is still visible.
     **/
    this.isRowFolded = function(docRow, startFoldRow) {
        return !!this.getFoldLine(docRow, startFoldRow);
    };

    this.getRowFoldEnd = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return (foldLine
            ? foldLine.end.row
            : docRow);
    };

    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
        if (startRow == null) {
            startRow = foldLine.start.row;
            startColumn = 0;
        }

        if (endRow == null) {
            endRow = foldLine.end.row;
            endColumn = this.getLine(endRow).length;
        }

        // Build the textline using the FoldLine walker.
        var doc = this.doc;
        var textLine = "";

        foldLine.walk(function(placeholder, row, column, lastColumn) {
            if (row < startRow) {
                return;
            } else if (row == startRow) {
                if (column < startColumn) {
                    return;
                }
                lastColumn = Math.max(startColumn, lastColumn);
            }
            if (placeholder) {
                textLine += placeholder;
            } else {
                textLine += doc.getLine(row).substring(lastColumn, column);
            }
        }.bind(this), endRow, endColumn);
        return textLine;
    };

    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
        var foldLine = this.getFoldLine(row);

        if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
        } else {
            return this.getFoldDisplayLine(
                foldLine, row, endColumn, startRow, startColumn);
        }
    };

    this.$cloneFoldData = function() {
        var fd = [];
        fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold) {
                return fold.clone();
            });
            return new FoldLine(fd, folds);
        });

        return fd;
    };

    this.toggleFold = function(tryToUnfold) {
        var selection = this.selection;
        var range = selection.getRange();
        var fold;
        var bracketPos;

        if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);

            if (fold) {
                this.expandFold(fold);
                return;
            }
            else if (bracketPos = this.findMatchingBracket(cursor)) {
                if (range.comparePoint(bracketPos) == 1) {
                    range.end = bracketPos;
                } 
                else {
                    range.start = bracketPos;
                    range.start.column++;
                    range.end.column--;
                }
            }
            else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
                if (range.comparePoint(bracketPos) == 1)
                    range.end = bracketPos;
                else
                    range.start = bracketPos;

                range.start.column++;
            }
            else {
                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
        } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
                this.expandFolds(folds);
                return;
            } 
            else if (folds.length == 1 ) {
                fold = folds[0];
            }
        }

        if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);

        if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
        }

        var placeholder = "...";
        if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if(placeholder.length < 4)
                return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
        }

        this.addFold(placeholder, range);
    };

    this.getCommentFoldRange = function(row, column) {
        var iterator = new TokenIterator(this, row, column);
        var token = iterator.getCurrentToken();
        if (token && /^comment|string/.test(token.type)) {
            var range = new Range();
            var re = new RegExp(token.type.replace(/\..*/, "\\."));
            do {
                token = iterator.stepBackward();
            } while(token && re.test(token.type));

            iterator.stepForward();
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + 2;

            iterator = new TokenIterator(this, row, column);

            do {
                token = iterator.stepForward();
            } while(token && re.test(token.type));
            
            token = iterator.stepBackward();

            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn() + token.value.length;
            return range;
        }
    };

    this.foldAll = function(startRow, endRow) {
        var foldWidgets = this.foldWidgets;
        endRow = endRow || this.getLength();
        for (var row = startRow || 0; row < endRow; row++) {
            if (foldWidgets[row] == null)
                foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
                continue;

            var range = this.getFoldWidgetRange(row);
            // sometimes range can be incompatible with existing fold
            // wouldn't it be better for addFold to return null istead of throwing?
            if (range && range.end.row < endRow) try {
                this.addFold("...", range);
            } catch(e) {}
        }
    };
    
    this.$foldStyles = {
        "manual": 1,
        "markbegin": 1,
        "markbeginend": 1
    };
    this.$foldStyle = "markbegin";
    this.setFoldStyle = function(style) {
        if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
        
        if (this.$foldStyle == style)
            return;

        this.$foldStyle = style;
        
        if (style == "manual")
            this.unfold();
        
        // reset folding
        var mode = this.$foldMode;
        this.$setFolding(null);
        this.$setFolding(mode);
    };

    // structured folding
    this.$setFolding = function(foldMode) {
        if (this.$foldMode == foldMode)
            return;
            
        this.$foldMode = foldMode;
        
        this.removeListener('change', this.$updateFoldWidgets);
        this._emit("changeAnnotation");
        
        if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
        }
        
        this.foldWidgets = [];
        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
        
        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
        this.on('change', this.$updateFoldWidgets);
        
    };

    this.onFoldWidgetClick = function(row, e) {
        var type = this.getFoldWidget(row);
        var line = this.getLine(row);
        var onlySubfolds = e.shiftKey;
        var addSubfolds = onlySubfolds || e.ctrlKey || e.altKey || e.metaKey;
        var fold;

        if (type == "end")
            fold = this.getFoldAt(row, 0, -1);
        else
            fold = this.getFoldAt(row, line.length, 1);

        if (fold) {
            if (addSubfolds)
                this.removeFold(fold);
            else
                this.expandFold(fold);
            return;
        }

        var range = this.getFoldWidgetRange(row);
        if (range) {
            // sometimes singleline folds can be missed by the code above
            if (!range.isMultiLine()) {
                fold = this.getFoldAt(range.start.row, range.start.column, 1);
                if (fold && range.isEequal(fold.range)) {
                    this.removeFold(fold);
                    return;
                }
            }
            
            if (!onlySubfolds)
                this.addFold("...", range);

            if (addSubfolds)
                this.foldAll(range.start.row + 1, range.end.row);
        } else {
            if (addSubfolds)
                this.foldAll(row + 1, this.getLength());
            e.target.className += " invalid"
        }
    };
    
    this.updateFoldWidgets = function(e) {
        var delta = e.data;
        var range = delta.range;
        var firstRow = range.start.row;
        var len = range.end.row - firstRow;

        if (len === 0) {
            this.foldWidgets[firstRow] = null;
        } else if (delta.action == "removeText" || delta.action == "removeLines") {
            this.foldWidgets.splice(firstRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
        }
    };

}

exports.Folding = Folding;

});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Julian Viereck <julian DOT viereck AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/edit_session/fold_line', ['require', 'exports', 'module' , 'ace/range'], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;

/**
 * If an array is passed in, the folds are expected to be sorted already.
 */
function FoldLine(foldData, folds) {
    this.foldData = foldData;
    if (Array.isArray(folds)) {
        this.folds = folds;
    } else {
        folds = this.folds = [ folds ];
    }

    var last = folds[folds.length - 1]
    this.range = new Range(folds[0].start.row, folds[0].start.column,
                           last.end.row, last.end.column);
    this.start = this.range.start;
    this.end   = this.range.end;

    this.folds.forEach(function(fold) {
        fold.setFoldLine(this);
    }, this);
}

(function() {
    /**
     * Note: This doesn't update wrapData!
     */
    this.shiftRow = function(shift) {
        this.start.row += shift;
        this.end.row += shift;
        this.folds.forEach(function(fold) {
            fold.start.row += shift;
            fold.end.row += shift;
        });
    }

    this.addFold = function(fold) {
        if (fold.sameRow) {
            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                throw "Can't add a fold to this FoldLine as it has no connection";
            }
            this.folds.push(fold);
            this.folds.sort(function(a, b) {
                return -a.range.compareEnd(b.start.row, b.start.column);
            });
            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                this.end.row = fold.end.row;
                this.end.column =  fold.end.column;
            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
            }
        } else if (fold.start.row == this.end.row) {
            this.folds.push(fold);
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
        } else if (fold.end.row == this.start.row) {
            this.folds.unshift(fold);
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
        } else {
            throw "Trying to add fold to FoldRow that doesn't have a matching row";
        }
        fold.foldLine = this;
    }

    this.containsRow = function(row) {
        return row >= this.start.row && row <= this.end.row;
    }

    this.walk = function(callback, endRow, endColumn) {
        var lastEnd = 0,
            folds = this.folds,
            fold,
            comp, stop, isNewRow = true;

        if (endRow == null) {
            endRow = this.end.row;
            endColumn = this.end.column;
        }

        for (var i = 0; i < folds.length; i++) {
            fold = folds[i];

            comp = fold.range.compareStart(endRow, endColumn);
            // This fold is after the endRow/Column.
            if (comp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
            }

            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);

            // If the user requested to stop the walk or endRow/endColumn is
            // inside of this fold (comp == 0), then end here.
            if (stop || comp == 0) {
                return;
            }

            // Note the new lastEnd might not be on the same line. However,
            // it's the callback's job to recognize this.
            isNewRow = !fold.sameRow;
            lastEnd = fold.end.column;
        }
        callback(null, endRow, endColumn, lastEnd, isNewRow);
    }

    this.getNextFoldTo = function(row, column) {
        var fold, cmp;
        for (var i = 0; i < this.folds.length; i++) {
            fold = this.folds[i];
            cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                return {
                    fold: fold,
                    kind: "after"
                };
            } else if (cmp == 0) {
                return {
                    fold: fold,
                    kind: "inside"
                }
            }
        }
        return null;
    }

    this.addRemoveChars = function(row, column, len) {
        var ret = this.getNextFoldTo(row, column),
            fold, folds;
        if (ret) {
            fold = ret.fold;
            if (ret.kind == "inside"
                && fold.start.column != column
                && fold.start.row != row)
            {
                throw "Moving characters inside of a fold should never be reached";
            } else if (fold.start.row == row) {
                folds = this.folds;
                var i = folds.indexOf(fold);
                if (i == 0) {
                    this.start.column += len;
                }
                for (i; i < folds.length; i++) {
                    fold = folds[i];
                    fold.start.column += len;
                    if (!fold.sameRow) {
                        return;
                    }
                    fold.end.column += len;
                }
                this.end.column += len;
            }
        }
    }

    this.split = function(row, column) {
        var fold = this.getNextFoldTo(row, column).fold,
            folds = this.folds;
        var foldData = this.foldData;

        if (!fold) {
            return null;
        }
        var i = folds.indexOf(fold);
        var foldBefore = folds[i - 1];
        this.end.row = foldBefore.end.row;
        this.end.column = foldBefore.end.column;

        // Remove the folds after row/column and create a new FoldLine
        // containing these removed folds.
        folds = folds.splice(i, folds.length - i);

        var newFoldLine = new FoldLine(foldData, folds);
        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
        return newFoldLine;
    }

    this.merge = function(foldLineNext) {
        var folds = foldLineNext.folds;
        for (var i = 0; i < folds.length; i++) {
            this.addFold(folds[i]);
        }
        // Remove the foldLineNext - no longer needed, as
        // it's merged now with foldLineNext.
        var foldData = this.foldData;
        foldData.splice(foldData.indexOf(foldLineNext), 1);
    }

    this.toString = function() {
        var ret = [this.range.toString() + ": [" ];

        this.folds.forEach(function(fold) {
            ret.push("  " + fold.toString());
        });
        ret.push("]")
        return ret.join("\n");
    }

    this.idxToPosition = function(idx) {
        var lastFoldEndColumn = 0;
        var fold;

        for (var i = 0; i < this.folds.length; i++) {
            var fold = this.folds[i];

            idx -= fold.start.column - lastFoldEndColumn;
            if (idx < 0) {
                return {
                    row: fold.start.row,
                    column: fold.start.column + idx
                };
            }

            idx -= fold.placeholder.length;
            if (idx < 0) {
                return fold.start;
            }

            lastFoldEndColumn = fold.end.column;
        }

        return {
            row: this.end.row,
            column: this.end.column + idx
        };
    }
}).call(FoldLine.prototype);

exports.FoldLine = FoldLine;
});/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Julian Viereck <julian DOT viereck AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/edit_session/fold', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

/**
 * Simple fold-data struct.
 **/
var Fold = exports.Fold = function(range, placeholder) {
    this.foldLine = null;
    this.placeholder = placeholder;
    this.range = range;
    this.start = range.start;
    this.end = range.end;

    this.sameRow = range.start.row == range.end.row;
    this.subFolds = [];
};

(function() {

    this.toString = function() {
        return '"' + this.placeholder + '" ' + this.range.toString();
    };

    this.setFoldLine = function(foldLine) {
        this.foldLine = foldLine;
        this.subFolds.forEach(function(fold) {
            fold.setFoldLine(foldLine);
        });
    };

    this.clone = function() {
        var range = this.range.clone();
        var fold = new Fold(range, this.placeholder);
        this.subFolds.forEach(function(subFold) {
            fold.subFolds.push(subFold.clone());
        });
        return fold;
    };

    this.addSubFold = function(fold) {
        if (this.range.isEequal(fold))
            return this;

        if (!this.range.containsRange(fold))
            throw "A fold can't intersect already existing fold" + fold.range + this.range;

        var row = fold.range.start.row, column = fold.range.start.column;
        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
            cmp = this.subFolds[i].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        var afterStart = this.subFolds[i];

        if (cmp == 0)
            return afterStart.addSubFold(fold)

        // cmp == -1
        var row = fold.range.end.row, column = fold.range.end.column;
        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
            cmp = this.subFolds[j].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        var afterEnd = this.subFolds[j];

        if (cmp == 0)
            throw "A fold can't intersect already existing fold" + fold.range + this.range;

        var consumedFolds = this.subFolds.splice(i, j - i, fold)
        fold.setFoldLine(this.foldLine);

        return fold;
    }

}).call(Fold.prototype);

});/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/token_iterator', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

var TokenIterator = function(session, initialRow, initialColumn) {
    this.$session = session;
    this.$row = initialRow;
    this.$rowTokens = session.getTokens(initialRow, initialRow)[0].tokens;

    var token = session.getTokenAt(initialRow, initialColumn);
    this.$tokenIndex = token ? token.index : -1;
};

(function() {
    
    this.stepBackward = function() {
        this.$tokenIndex -= 1;
        
        while (this.$tokenIndex < 0) {
            this.$row -= 1;
            if (this.$row < 0) {
                this.$row = 0;
                return null;
            }
                
            this.$rowTokens = this.$session.getTokens(this.$row, this.$row)[0].tokens;
            this.$tokenIndex = this.$rowTokens.length - 1;
        }
            
        return this.$rowTokens[this.$tokenIndex];
    };
    
    this.stepForward = function() {
        var rowCount = this.$session.getLength();
        this.$tokenIndex += 1;
        
        while (this.$tokenIndex >= this.$rowTokens.length) {
            this.$row += 1;
            if (this.$row >= rowCount) {
                this.$row = rowCount - 1;
                return null;
            }

            this.$rowTokens = this.$session.getTokens(this.$row, this.$row)[0].tokens;
            this.$tokenIndex = 0;
        }
            
        return this.$rowTokens[this.$tokenIndex];
    };
    
    this.getCurrentToken = function () {
        return this.$rowTokens[this.$tokenIndex];
    };
    
    this.getCurrentTokenRow = function () {
        return this.$row;
    };
    
    this.getCurrentTokenColumn = function() {
        var rowTokens = this.$rowTokens;
        var tokenIndex = this.$tokenIndex;
        
        // If a column was cached by EditSession.getTokenAt, then use it
        var column = rowTokens[tokenIndex].start;
        if (column !== undefined)
            return column;
            
        column = 0;
        while (tokenIndex > 0) {
            tokenIndex -= 1;
            column += rowTokens[tokenIndex].value.length;
        }
        
        return column;  
    };
            
}).call(TokenIterator.prototype);

exports.TokenIterator = TokenIterator;
});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/edit_session/bracket_match', ['require', 'exports', 'module' , 'ace/token_iterator'], function(require, exports, module) {
"use strict";

var TokenIterator = require("../token_iterator").TokenIterator;

function BracketMatch() {

    this.findMatchingBracket = function(position) {
        if (position.column == 0) return null;

        var charBeforeCursor = this.getLine(position.row).charAt(position.column-1);
        if (charBeforeCursor == "") return null;

        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
        if (!match) {
            return null;
        }

        if (match[1]) {
            return this.$findClosingBracket(match[1], position);
        } else {
            return this.$findOpeningBracket(match[2], position);
        }
    };

    this.$brackets = {
        ")": "(",
        "(": ")",
        "]": "[",
        "[": "]",
        "{": "}",
        "}": "{"
    };

    this.$findOpeningBracket = function(bracket, position) {
        var openBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token) return null;
        
        // token.type contains a period-delimited list of token identifiers
        // (e.g.: "constant.numeric" or "paren.lparen").  Create a pattern that
        // matches any token containing the same identifiers or a subset.  In
        // addition, if token.type includes "rparen", then also match "lparen".
        // So if type.token is "paren.rparen", then typeRe will match "lparen.paren".
        var typeRe = new RegExp("(\\.?" +
            token.type.replace(".", "|").replace("rparen", "lparen|rparen") + ")+");
        
        // Start searching in token, just before the character at position.column
        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
        var value = token.value;
        
        while (true) {
        
            while (valueIndex >= 0) {
                var chr = value.charAt(valueIndex);
                if (chr == openBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex -= 1;
            }

            // Scan backward through the document, looking for the next token
            // whose type matches typeRe
            do {
                token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;
                
            value = token.value;
            valueIndex = value.length - 1;
        }
        
        return null;
    };

    this.$findClosingBracket = function(bracket, position) {
        var closingBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token) return null;

        // token.type contains a period-delimited list of token identifiers
        // (e.g.: "constant.numeric" or "paren.lparen").  Create a pattern that
        // matches any token containing the same identifiers or a subset.  In
        // addition, if token.type includes "lparen", then also match "rparen".
        // So if type.token is "lparen.paren", then typeRe will match "paren.rparen".
        var typeRe = new RegExp("(\\.?" +
            token.type.replace(".", "|").replace("lparen", "lparen|rparen") + ")+");

        // Start searching in token, after the character at position.column
        var valueIndex = position.column - iterator.getCurrentTokenColumn();

        while (true) {

            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
                var chr = value.charAt(valueIndex);
                if (chr == closingBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex += 1;
            }

            // Scan forward through the document, looking for the next token
            // whose type matches typeRe
            do {
                token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;

            valueIndex = 0;
        }
        
        return null;
    };
}
exports.BracketMatch = BracketMatch;

});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Mihai Sucan <mihai DOT sucan AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/search', ['require', 'exports', 'module' , 'ace/lib/lang', 'ace/lib/oop', 'ace/range'], function(require, exports, module) {
"use strict";

var lang = require("./lib/lang");
var oop = require("./lib/oop");
var Range = require("./range").Range;

var Search = function() {
    this.$options = {
        needle: "",
        backwards: false,
        wrap: false,
        caseSensitive: false,
        wholeWord: false,
        scope: Search.ALL,
        regExp: false
    };
};

Search.ALL = 1;
Search.SELECTION = 2;

(function() {

    this.set = function(options) {
        oop.mixin(this.$options, options);
        return this;
    };
    
    this.getOptions = function() {
        return lang.copyObject(this.$options);
    };

    this.find = function(session) {
        if (!this.$options.needle)
            return null;

        if (this.$options.backwards) {
            var iterator = this.$backwardMatchIterator(session);
        } else {
            iterator = this.$forwardMatchIterator(session);
        }

        var firstRange = null;
        iterator.forEach(function(range) {
            firstRange = range;
            return true;
        });

        return firstRange;
    };

    this.findAll = function(session) {
        var options = this.$options;
        if (!options.needle)
            return [];

        if (options.backwards) {
            var iterator = this.$backwardMatchIterator(session);
        } else {
            iterator = this.$forwardMatchIterator(session);
        }

        var ignoreCursor = !options.start && options.wrap && options.scope == Search.ALL;
        if (ignoreCursor)
            options.start = {row: 0, column: 0};

        var ranges = [];
        iterator.forEach(function(range) {
            ranges.push(range);
        });

        if (ignoreCursor)
            options.start = null;

        return ranges;
    };

    this.replace = function(input, replacement) {
        var re = this.$assembleRegExp();
        var match = re.exec(input);
        if (match && match[0].length == input.length) {
            if (this.$options.regExp) {
                return input.replace(re, replacement);
            } else {
                return replacement;
            }
        } else {
            return null;
        }
    };

    this.$forwardMatchIterator = function(session) {
        var re = this.$assembleRegExp();
        var self = this;

        return {
            forEach: function(callback) {
                self.$forwardLineIterator(session).forEach(function(line, startIndex, row) {
                    if (startIndex) {
                        line = line.substring(startIndex);
                    }

                    var matches = [];

                    line.replace(re, function(str) {
                        var offset = arguments[arguments.length-2];
                        matches.push({
                            str: str,
                            offset: startIndex + offset
                        });
                        return str;
                    });

                    for (var i=0; i<matches.length; i++) {
                        var match = matches[i];
                        var range = self.$rangeFromMatch(row, match.offset, match.str.length);
                        if (callback(range))
                            return true;
                    }

                });
            }
        };
    };

    this.$backwardMatchIterator = function(session) {
        var re = this.$assembleRegExp();
        var self = this;

        return {
            forEach: function(callback) {
                self.$backwardLineIterator(session).forEach(function(line, startIndex, row) {
                    if (startIndex) {
                        line = line.substring(startIndex);
                    }

                    var matches = [];

                    line.replace(re, function(str, offset) {
                        matches.push({
                            str: str,
                            offset: startIndex + offset
                        });
                        return str;
                    });

                    for (var i=matches.length-1; i>= 0; i--) {
                        var match = matches[i];
                        var range = self.$rangeFromMatch(row, match.offset, match.str.length);
                        if (callback(range))
                            return true;
                    }
                });
            }
        };
    };

    this.$rangeFromMatch = function(row, column, length) {
        return new Range(row, column, row, column+length);
    };

    this.$assembleRegExp = function() {
        if (this.$options.regExp) {
            var needle = this.$options.needle;
        } else {
            needle = lang.escapeRegExp(this.$options.needle);
        }

        if (this.$options.wholeWord) {
            needle = "\\b" + needle + "\\b";
        }

        var modifier = "g";
        if (!this.$options.caseSensitive) {
            modifier += "i";
        }

        var re = new RegExp(needle, modifier);
        return re;
    };

    this.$forwardLineIterator = function(session) {
        var searchSelection = this.$options.scope == Search.SELECTION;

        var range = this.$options.range || session.getSelection().getRange();
        var start = this.$options.start || range[searchSelection ? "start" : "end"];

        var firstRow = searchSelection ? range.start.row : 0;
        var firstColumn = searchSelection ? range.start.column : 0;
        var lastRow = searchSelection ? range.end.row : session.getLength() - 1;

        var wrap = this.$options.wrap;
        var inWrap = false;

        function getLine(row) {
            var line = session.getLine(row);
            if (searchSelection && row == range.end.row) {
                line = line.substring(0, range.end.column);
            }
            if (inWrap && row == start.row) {
                line = line.substring(0, start.column);
            }
            return line;
        }

        return {
            forEach: function(callback) {
                var row = start.row;

                var line = getLine(row);
                var startIndex = start.column;

                var stop = false;
                inWrap = false;

                while (!callback(line, startIndex, row)) {

                    if (stop) {
                        return;
                    }

                    row++;
                    startIndex = 0;

                    if (row > lastRow) {
                        if (wrap) {
                            row = firstRow;
                            startIndex = firstColumn;
                            inWrap = true;
                        } else {
                            return;
                        }
                    }

                    if (row == start.row)
                        stop = true;

                    line = getLine(row);
                }
            }
        };
    };

    this.$backwardLineIterator = function(session) {
        var searchSelection = this.$options.scope == Search.SELECTION;

        var range = this.$options.range || session.getSelection().getRange();
        var start = this.$options.start || range[searchSelection ? "end" : "start"];

        var firstRow = searchSelection ? range.start.row : 0;
        var firstColumn = searchSelection ? range.start.column : 0;
        var lastRow = searchSelection ? range.end.row : session.getLength() - 1;

        var wrap = this.$options.wrap;

        return {
            forEach : function(callback) {
                var row = start.row;

                var line = session.getLine(row).substring(0, start.column);
                var startIndex = 0;
                var stop = false;
                var inWrap = false;

                while (!callback(line, startIndex, row)) {

                    if (stop)
                        return;

                    row--;
                    startIndex = 0;

                    if (row < firstRow) {
                        if (wrap) {
                            row = lastRow;
                            inWrap = true;
                        } else {
                            return;
                        }
                    }

                    if (row == start.row)
                        stop = true;

                    line = session.getLine(row);
                    if (searchSelection) {
                        if (row == firstRow)
                            startIndex = firstColumn;
                        else if (row == lastRow)
                            line = line.substring(0, range.end.column);
                    }

                    if (inWrap && row == start.row)
                        startIndex = start.column;
                }
            }
        };
    };

}).call(Search.prototype);

exports.Search = Search;
});
define('ace/commands/command_manager', ['require', 'exports', 'module' , 'ace/lib/keys'], function(require, exports, module) {
"use strict";

var keyUtil = require("../lib/keys");

var CommandManager = function(platform, commands) {
    if (typeof platform !== "string")
        throw new TypeError("'platform' argument must be either 'mac' or 'win'");

    this.platform = platform;
    this.commands = {};
    this.commmandKeyBinding = {};

    if (commands)
        commands.forEach(this.addCommand, this);
};

(function() {

    this.addCommand = function(command) {
        if (this.commands[command.name])
            this.removeCommand(command);

        this.commands[command.name] = command;

        if (command.bindKey) {
            this._buildKeyHash(command);
        }
    };

    this.removeCommand = function(command) {
        var name = (typeof command === 'string' ? command : command.name);
        command = this.commands[name];
        delete this.commands[name];

        // exaustive search is brute force but since removeCommand is
        // not a performance critical operation this should be OK
        var ckb = this.commmandKeyBinding;
        for (var hashId in ckb) {
            for (var key in ckb[hashId]) {
                if (ckb[hashId][key] == command)
                    delete ckb[hashId][key];
            }
        }
    };

    this.addCommands = function(commands) {
        Object.keys(commands).forEach(function(name) {
            var command = commands[name];
            if (typeof command === "string")
                return this.bindKey(command, name);

            if (typeof command === "function")
                command = { exec: command };

            if (!command.name)
                command.name = name;

            this.addCommand(command);
        }, this);
    };

    this.removeCommands = function(commands) {
        Object.keys(commands).forEach(function(name) {
            this.removeCommand(commands[name]);
        }, this);
    };

    this.bindKey = function(key, command) {
        if(!key)
            return;

        var ckb = this.commmandKeyBinding;
        key.split("|").forEach(function(keyPart) {
            var binding = parseKeys(keyPart, command);
            var hashId = binding.hashId;
            (ckb[hashId] || (ckb[hashId] = {}))[binding.key] = command;
        });
    };

    this.bindKeys = function(keyList) {
        Object.keys(keyList).forEach(function(key) {
            this.bindKey(key, keyList[key]);
        }, this);
    };

    this._buildKeyHash = function(command) {
        var binding = command.bindKey;
        if (!binding)
            return;

        var key = typeof binding == "string" ? binding: binding[this.platform];
        this.bindKey(key, command);
    }

    function parseKeys(keys, val, ret) {
        var key;
        var hashId = 0;
        var parts = splitSafe(keys);

        for (var i=0, l = parts.length; i < l; i++) {
            if (keyUtil.KEY_MODS[parts[i]])
                hashId = hashId | keyUtil.KEY_MODS[parts[i]];
            else
                key = parts[i] || "-"; //when empty, the splitSafe removed a '-'
        }

        return {
            key: key,
            hashId: hashId
        }
    }

    function splitSafe(s, separator) {
        return (s.toLowerCase()
            .trim()
            .split(new RegExp("[\\s ]*\\-[\\s ]*", "g"), 999));
    }

    this.findKeyCommand = function findKeyCommand(hashId, textOrKey) {
        // Convert keyCode to the string representation.
        if (typeof textOrKey == "number") {
            textOrKey = keyUtil.keyCodeToString(textOrKey);
        }

        var ckbr = this.commmandKeyBinding;
        return ckbr[hashId] && ckbr[hashId][textOrKey.toLowerCase()];
    }

    this.exec = function(command, editor, args) {
        if (typeof command === 'string')
            command = this.commands[command];

        if (!command)
            return false;

        if (editor && editor.$readOnly && !command.readOnly)
            return false;

        command.exec(editor, args || {});
        return true;
    };

    this.toggleRecording = function() {
        if (this.$inReplay)
            return;
        if (this.recording) {
            this.macro.pop();
            this.exec = this.normal_exec;

            if (!this.macro.length)
                this.macro = this.oldMacro;

            return this.recording = false;
        }
        this.oldMacro = this.macro;
        this.macro = [];
        this.normal_exec = this.exec;
        this.exec = function(command, editor, args) {
            this.macro.push([command, args]);
            return this.normal_exec(command, editor, args);
        };
        return this.recording = true;
    };

    this.replay = function(editor) {
        if (this.$inReplay || !this.macro)
            return;

        if (this.recording)
            return this.toggleRecording();

        try {
            this.$inReplay = true;
            this.macro.forEach(function(x) {
                if (typeof x == "string")
                    this.exec(x, editor);
                else
                    this.exec(x[0], editor, x[1]);
            }, this)
        } finally {
            this.$inReplay = false;
        }
    };

    this.trimMacro = function(m) {
        return m.map(function(x){
            if (typeof x[0] != "string")
                x[0] = x[0].name;
            if (!x[1])
                x = x[0];
            return x
        })
    }

}).call(CommandManager.prototype);

exports.CommandManager = CommandManager;

});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Mihai Sucan <mihai DOT sucan AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/undomanager', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

var UndoManager = function() {
    this.reset();
};

(function() {

    this.execute = function(options) {
        var deltas = options.args[0];
        this.$doc  = options.args[1];
        this.$undoStack.push(deltas);
        this.$redoStack = [];
    };

    this.undo = function(dontSelect) {
        var deltas = this.$undoStack.pop();
        var undoSelectionRange = null;
        if (deltas) {
            undoSelectionRange =
                this.$doc.undoChanges(deltas, dontSelect);
            this.$redoStack.push(deltas);
        }
        return undoSelectionRange;
    };

    this.redo = function(dontSelect) {
        var deltas = this.$redoStack.pop();
        var redoSelectionRange = null;
        if (deltas) {
            redoSelectionRange =
                this.$doc.redoChanges(deltas, dontSelect);
            this.$undoStack.push(deltas);
        }
        return redoSelectionRange;
    };

    this.reset = function() {
        this.$undoStack = [];
        this.$redoStack = [];
    };

    this.hasUndo = function() {
        return this.$undoStack.length > 0;
    };

    this.hasRedo = function() {
        return this.$redoStack.length > 0;
    };

}).call(UndoManager.prototype);

exports.UndoManager = UndoManager;
});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian@ajax.org>
 *      Irakli Gozalishvili <rfobic@gmail.com> (http://jeditoolkit.com)
 *      Julian Viereck <julian.viereck@gmail.com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/virtual_renderer', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/dom', 'ace/lib/event', 'ace/lib/useragent', 'ace/layer/gutter', 'ace/layer/marker', 'ace/layer/text', 'ace/layer/cursor', 'ace/scrollbar', 'ace/renderloop', 'ace/lib/event_emitter', 'text!ace/css/editor.css'], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var dom = require("./lib/dom");
var event = require("./lib/event");
var useragent = require("./lib/useragent");
var GutterLayer = require("./layer/gutter").Gutter;
var MarkerLayer = require("./layer/marker").Marker;
var TextLayer = require("./layer/text").Text;
var CursorLayer = require("./layer/cursor").Cursor;
var ScrollBar = require("./scrollbar").ScrollBar;
var RenderLoop = require("./renderloop").RenderLoop;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var editorCss = require("text!./css/editor.css");

dom.importCssString(editorCss, "ace_editor");

var VirtualRenderer = function(container, theme) {
    var _self = this;
    
    this.container = container;

    // TODO: this breaks rendering in Cloud9 with multiple ace instances
//    // Imports CSS once per DOM document ('ace_editor' serves as an identifier).
//    dom.importCssString(editorCss, "ace_editor", container.ownerDocument);
    
    dom.addCssClass(container, "ace_editor");

    this.setTheme(theme);

    this.$gutter = dom.createElement("div");
    this.$gutter.className = "ace_gutter";
    this.container.appendChild(this.$gutter);

    this.scroller = dom.createElement("div");
    this.scroller.className = "ace_scroller";
    this.container.appendChild(this.scroller);

    this.content = dom.createElement("div");
    this.content.className = "ace_content";
    this.scroller.appendChild(this.content);

    this.$gutterLayer = new GutterLayer(this.$gutter);
    this.$gutterLayer.on("changeGutterWidth", this.onResize.bind(this, true));    
    
    this.$markerBack = new MarkerLayer(this.content);

    var textLayer = this.$textLayer = new TextLayer(this.content);
    this.canvas = textLayer.element;

    this.$markerFront = new MarkerLayer(this.content);

    this.characterWidth = textLayer.getCharacterWidth();
    this.lineHeight = textLayer.getLineHeight();

    this.$cursorLayer = new CursorLayer(this.content);
    this.$cursorPadding = 8;

    // Indicates whether the horizontal scrollbar is visible
    this.$horizScroll = true;
    this.$horizScrollAlwaysVisible = true;

    this.scrollBar = new ScrollBar(container);
    this.scrollBar.addEventListener("scroll", function(e) {
        _self.session.setScrollTop(e.data);
    });

    this.scrollTop = 0;
    this.scrollLeft = 0;
    
    event.addListener(this.scroller, "scroll", function() {
        var scrollLeft = _self.scroller.scrollLeft;
        _self.scrollLeft = scrollLeft;
        _self.session.setScrollLeft(scrollLeft);
    });

    this.cursorPos = {
        row : 0,
        column : 0
    };

    this.$textLayer.addEventListener("changeCharacterSize", function() {
        _self.characterWidth = textLayer.getCharacterWidth();
        _self.lineHeight = textLayer.getLineHeight();
        _self.$updatePrintMargin();
        _self.onResize(true);

        _self.$loop.schedule(_self.CHANGE_FULL);
    });

    this.$size = {
        width: 0,
        height: 0,
        scrollerHeight: 0,
        scrollerWidth: 0
    };

    this.layerConfig = {
        width : 1,
        padding : 0,
        firstRow : 0,
        firstRowScreen: 0,
        lastRow : 0,
        lineHeight : 1,
        characterWidth : 1,
        minHeight : 1,
        maxHeight : 1,
        offset : 0,
        height : 1
    };

    this.$loop = new RenderLoop(
        this.$renderChanges.bind(this),
        this.container.ownerDocument.defaultView
    );
    this.$loop.schedule(this.CHANGE_FULL);

    this.setPadding(4);
    this.$updatePrintMargin();
};

(function() {
    this.showGutter = true;

    this.CHANGE_CURSOR = 1;
    this.CHANGE_MARKER = 2;
    this.CHANGE_GUTTER = 4;
    this.CHANGE_SCROLL = 8;
    this.CHANGE_LINES = 16;
    this.CHANGE_TEXT = 32;
    this.CHANGE_SIZE = 64;
    this.CHANGE_MARKER_BACK = 128;
    this.CHANGE_MARKER_FRONT = 256;
    this.CHANGE_FULL = 512;
    this.CHANGE_H_SCROLL = 1024;

    oop.implement(this, EventEmitter);

    this.setSession = function(session) {
        this.session = session;
        this.$cursorLayer.setSession(session);
        this.$markerBack.setSession(session);
        this.$markerFront.setSession(session);
        this.$gutterLayer.setSession(session);
        this.$textLayer.setSession(session);
        this.$loop.schedule(this.CHANGE_FULL);
    };

    /**
     * Triggers partial update of the text layer
     */
    this.updateLines = function(firstRow, lastRow) {
        if (lastRow === undefined)
            lastRow = Infinity;

        if (!this.$changedLines) {
            this.$changedLines = {
                firstRow: firstRow,
                lastRow: lastRow
            };
        }
        else {
            if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;

            if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
        }

        this.$loop.schedule(this.CHANGE_LINES);
    };

    /**
     * Triggers full update of the text layer
     */
    this.updateText = function() {
        this.$loop.schedule(this.CHANGE_TEXT);
    };

    /**
     * Triggers a full update of all layers
     */
    this.updateFull = function() {
        this.$loop.schedule(this.CHANGE_FULL);
    };

    this.updateFontSize = function() {
        this.$textLayer.checkForSizeChanges();
    };

    /**
     * Triggers resize of the editor
     */
    this.onResize = function(force) {
        var changes = this.CHANGE_SIZE;
        var size = this.$size;

        var height = dom.getInnerHeight(this.container);
        if (force || size.height != height) {
            size.height = height;

            this.scroller.style.height = height + "px";
            size.scrollerHeight = this.scroller.clientHeight;
            this.scrollBar.setHeight(size.scrollerHeight);

            if (this.session) {
                this.session.setScrollTop(this.getScrollTop());
                changes = changes | this.CHANGE_FULL;
            }
        }

        var width = dom.getInnerWidth(this.container);
        if (force || size.width != width) {
            size.width = width;

            var gutterWidth = this.showGutter ? this.$gutter.offsetWidth : 0;
            this.scroller.style.left = gutterWidth + "px";
            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBar.getWidth());
            this.scroller.style.width = size.scrollerWidth + "px";

            if (this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
                changes = changes | this.CHANGE_FULL;
        }

        this.$loop.schedule(changes);
    };

    this.adjustWrapLimit = function() {
        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
        var limit = Math.floor(availableWidth / this.characterWidth);
        return this.session.adjustWrapLimit(limit);
    };

    this.setShowInvisibles = function(showInvisibles) {
        if (this.$textLayer.setShowInvisibles(showInvisibles))
            this.$loop.schedule(this.CHANGE_TEXT);
    };

    this.getShowInvisibles = function() {
        return this.$textLayer.showInvisibles;
    };

    this.$showPrintMargin = true;
    this.setShowPrintMargin = function(showPrintMargin) {
        this.$showPrintMargin = showPrintMargin;
        this.$updatePrintMargin();
    };

    this.getShowPrintMargin = function() {
        return this.$showPrintMargin;
    };

    this.$printMarginColumn = 80;
    this.setPrintMarginColumn = function(showPrintMargin) {
        this.$printMarginColumn = showPrintMargin;
        this.$updatePrintMargin();
    };

    this.getPrintMarginColumn = function() {
        return this.$printMarginColumn;
    };

    this.getShowGutter = function(){
        return this.showGutter;
    };

    this.setShowGutter = function(show){
        if(this.showGutter === show)
            return;
        this.$gutter.style.display = show ? "block" : "none";
        this.showGutter = show;
        this.onResize(true);
    };

    this.$updatePrintMargin = function() {
        var containerEl;

        if (!this.$showPrintMargin && !this.$printMarginEl)
            return;

        if (!this.$printMarginEl) {
            containerEl = dom.createElement("div");
            containerEl.className = "ace_print_margin_layer";
            this.$printMarginEl = dom.createElement("div");
            this.$printMarginEl.className = "ace_print_margin";
            containerEl.appendChild(this.$printMarginEl);
            this.content.insertBefore(containerEl, this.$textLayer.element);
        }

        var style = this.$printMarginEl.style;
        style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + "px";
        style.visibility = this.$showPrintMargin ? "visible" : "hidden";
    };

    this.getContainerElement = function() {
        return this.container;
    };

    this.getMouseEventTarget = function() {
        return this.content;
    };

    this.getTextAreaContainer = function() {
        return this.container;
    };

    this.moveTextAreaToCursor = function(textarea) {
        // in IE the native cursor always shines through
        // this persists in IE9
        if (useragent.isIE)
            return;
        
        if (this.layerConfig.lastRow === 0)
            return;

        var pos = this.$cursorLayer.getPixelPosition();
        if (!pos)
            return;

        var bounds = this.content.getBoundingClientRect();
        var offset = this.layerConfig.offset;

        textarea.style.left = (bounds.left + pos.left) + "px";
        textarea.style.top = (bounds.top + pos.top - this.scrollTop + offset) + "px";
    };

    this.getFirstVisibleRow = function() {
        return this.layerConfig.firstRow;
    };

    this.getFirstFullyVisibleRow = function() {
        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
    };

    this.getLastFullyVisibleRow = function() {
        var flint = Math.floor((this.layerConfig.height + this.layerConfig.offset) / this.layerConfig.lineHeight);
        return this.layerConfig.firstRow - 1 + flint;
    };

    this.getLastVisibleRow = function() {
        return this.layerConfig.lastRow;
    };

    this.$padding = null;
    this.setPadding = function(padding) {
        this.$padding = padding;
        this.$textLayer.setPadding(padding);
        this.$cursorLayer.setPadding(padding);
        this.$markerFront.setPadding(padding);
        this.$markerBack.setPadding(padding);
        this.$loop.schedule(this.CHANGE_FULL);
        this.$updatePrintMargin();
    };

    this.getHScrollBarAlwaysVisible = function() {
        return this.$horizScrollAlwaysVisible;
    };

    this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
        if (this.$horizScrollAlwaysVisible != alwaysVisible) {
            this.$horizScrollAlwaysVisible = alwaysVisible;
            if (!this.$horizScrollAlwaysVisible || !this.$horizScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        }
    };

    this.$updateScrollBar = function() {
        this.scrollBar.setInnerHeight(this.layerConfig.maxHeight);
        this.scrollBar.setScrollTop(this.scrollTop);
    };

    this.$renderChanges = function(changes) {
        if (!changes || !this.session || !this.container.offsetWidth)
            return;

        // text, scrolling and resize changes can cause the view port size to change
        if (changes & this.CHANGE_FULL ||
            changes & this.CHANGE_SIZE ||
            changes & this.CHANGE_TEXT ||
            changes & this.CHANGE_LINES ||
            changes & this.CHANGE_SCROLL
        )
            this.$computeLayerConfig();

        // horizontal scrolling
        if (changes & this.CHANGE_H_SCROLL) {
            this.scroller.scrollLeft = this.scrollLeft;
            
            // read the value after writing it since the value might get clipped
            var scrollLeft = this.scroller.scrollLeft;
            this.scrollLeft = scrollLeft;
            this.session.setScrollLeft(scrollLeft);
        }
        
        // full
        if (changes & this.CHANGE_FULL) {
            this.$textLayer.checkForSizeChanges();
            // update scrollbar first to not lose scroll position when gutter calls resize
            this.$updateScrollBar();
            this.$textLayer.update(this.layerConfig);
            if (this.showGutter)
                this.$gutterLayer.update(this.layerConfig);
            this.$markerBack.update(this.layerConfig);
            this.$markerFront.update(this.layerConfig);
            this.$cursorLayer.update(this.layerConfig);
            return;
        }

        // scrolling
        if (changes & this.CHANGE_SCROLL) {
            this.$updateScrollBar();
            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                this.$textLayer.update(this.layerConfig);
            else
                this.$textLayer.scrollLines(this.layerConfig);

            if (this.showGutter)
                this.$gutterLayer.update(this.layerConfig);
            this.$markerBack.update(this.layerConfig);
            this.$markerFront.update(this.layerConfig);
            this.$cursorLayer.update(this.layerConfig);
            return;
        }

        if (changes & this.CHANGE_TEXT) {
            this.$textLayer.update(this.layerConfig);
            if (this.showGutter)
                this.$gutterLayer.update(this.layerConfig);
        }
        else if (changes & this.CHANGE_LINES) {
            if (this.$updateLines()) {
                this.$updateScrollBar();
                if (this.showGutter)
                    this.$gutterLayer.update(this.layerConfig);
            }
        } else if (changes & this.CHANGE_GUTTER) {
            if (this.showGutter)
                this.$gutterLayer.update(this.layerConfig);
        }

        if (changes & this.CHANGE_CURSOR)
            this.$cursorLayer.update(this.layerConfig);

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
            this.$markerFront.update(this.layerConfig);
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
            this.$markerBack.update(this.layerConfig);
        }

        if (changes & this.CHANGE_SIZE)
            this.$updateScrollBar();
    };

    this.$computeLayerConfig = function() {
        var session = this.session;

        var offset = this.scrollTop % this.lineHeight;
        var minHeight = this.$size.scrollerHeight + this.lineHeight;

        var longestLine = this.$getLongestLine();

        var horizScroll = this.$horizScrollAlwaysVisible || this.$size.scrollerWidth - longestLine < 0;
        var horizScrollChanged = this.$horizScroll !== horizScroll;
        this.$horizScroll = horizScroll;
        if (horizScrollChanged) {
            this.scroller.style.overflowX = horizScroll ? "scroll" : "hidden";
            // when we hide scrollbar scroll event isn't emited
            // leaving session with wrong scrollLeft value
            if (!horizScroll)
                this.session.setScrollLeft(0);
        }
        var maxHeight = this.session.getScreenLength() * this.lineHeight;
        this.session.setScrollTop(Math.max(0, Math.min(this.scrollTop, maxHeight - this.$size.scrollerHeight)));

        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
        var lastRow = firstRow + lineCount;

        // Map lines on the screen to lines in the document.
        var firstRowScreen, firstRowHeight;
        var lineHeight = { lineHeight: this.lineHeight };
        firstRow = session.screenToDocumentRow(firstRow, 0);

        // Check if firstRow is inside of a foldLine. If true, then use the first
        // row of the foldLine.
        var foldLine = session.getFoldLine(firstRow);
        if (foldLine) {
            firstRow = foldLine.start.row;
        }

        firstRowScreen = session.documentToScreenRow(firstRow, 0);
        firstRowHeight = session.getRowHeight(lineHeight, firstRow);

        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
        minHeight = this.$size.scrollerHeight + session.getRowHeight(lineHeight, lastRow)+
                                                firstRowHeight;

        offset = this.scrollTop - firstRowScreen * this.lineHeight;

        this.layerConfig = {
            width : longestLine,
            padding : this.$padding,
            firstRow : firstRow,
            firstRowScreen: firstRowScreen,
            lastRow : lastRow,
            lineHeight : this.lineHeight,
            characterWidth : this.characterWidth,
            minHeight : minHeight,
            maxHeight : maxHeight,
            offset : offset,
            height : this.$size.scrollerHeight
        };

        // For debugging.
        // console.log(JSON.stringify(this.layerConfig));

        this.$gutterLayer.element.style.marginTop = (-offset) + "px";
        this.content.style.marginTop = (-offset) + "px";
        this.content.style.width = longestLine + 2 * this.$padding + "px";
        this.content.style.height = minHeight + "px";

        // Horizontal scrollbar visibility may have changed, which changes
        // the client height of the scroller
        if (horizScrollChanged)
            this.onResize(true);
    };

    this.$updateLines = function() {
        var firstRow = this.$changedLines.firstRow;
        var lastRow = this.$changedLines.lastRow;
        this.$changedLines = null;

        var layerConfig = this.layerConfig;

        // if the update changes the width of the document do a full redraw
        if (layerConfig.width != this.$getLongestLine())
            return this.$textLayer.update(layerConfig);

        if (firstRow > layerConfig.lastRow + 1) { return; }
        if (lastRow < layerConfig.firstRow) { return; }

        // if the last row is unknown -> redraw everything
        if (lastRow === Infinity) {
            if (this.showGutter)
                this.$gutterLayer.update(layerConfig);
            this.$textLayer.update(layerConfig);
            return;
        }

        // else update only the changed rows
        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
        return true;
    };

    this.$getLongestLine = function() {
        var charCount = this.session.getScreenWidth();
        if (this.$textLayer.showInvisibles)
            charCount += 1;

        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
    };

    this.updateFrontMarkers = function() {
        this.$markerFront.setMarkers(this.session.getMarkers(true));
        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
    };

    this.updateBackMarkers = function() {
        this.$markerBack.setMarkers(this.session.getMarkers());
        this.$loop.schedule(this.CHANGE_MARKER_BACK);
    };

    this.addGutterDecoration = function(row, className){
        this.$gutterLayer.addGutterDecoration(row, className);
        this.$loop.schedule(this.CHANGE_GUTTER);
    };

    this.removeGutterDecoration = function(row, className){
        this.$gutterLayer.removeGutterDecoration(row, className);
        this.$loop.schedule(this.CHANGE_GUTTER);
    };

    this.setBreakpoints = function(rows) {
        this.$gutterLayer.setBreakpoints(rows);
        this.$loop.schedule(this.CHANGE_GUTTER);
    };

    this.setAnnotations = function(annotations) {
        this.$gutterLayer.setAnnotations(annotations);
        this.$loop.schedule(this.CHANGE_GUTTER);
    };

    this.updateCursor = function() {
        this.$loop.schedule(this.CHANGE_CURSOR);
    };

    this.hideCursor = function() {
        this.$cursorLayer.hideCursor();
    };

    this.showCursor = function() {
        this.$cursorLayer.showCursor();
    };

    this.scrollCursorIntoView = function() {
        // the editor is not visible
        if (this.$size.scrollerHeight === 0)
            return;

        var pos = this.$cursorLayer.getPixelPosition();

        var left = pos.left;
        var top = pos.top;

        if (this.scrollTop > top) {
            this.session.setScrollTop(top);
        }

        if (this.scrollTop + this.$size.scrollerHeight < top + this.lineHeight) {
            this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
        }

        var scrollLeft = this.scrollLeft;

        if (scrollLeft > left) {
            if (left < this.$padding + 2 * this.layerConfig.characterWidth)
                left = 0;
            this.session.setScrollLeft(left);
        }

        if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
        }
    };

    this.getScrollTop = function() {
        return this.session.getScrollTop();
    };

    this.getScrollLeft = function() {
        return this.session.getScrollLeft();
    };

    this.getScrollTopRow = function() {
        return this.scrollTop / this.lineHeight;
    };

    this.getScrollBottomRow = function() {
        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
    };

    this.scrollToRow = function(row) {
        this.session.setScrollTop(row * this.lineHeight);
    };

    this.scrollToLine = function(line, center) {
        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
        var offset = pos.top;
        if (center)
            offset -= this.$size.scrollerHeight / 2;

        this.session.setScrollTop(offset);
    };

    this.scrollToY = function(scrollTop) {
        // after calling scrollBar.setScrollTop
        // scrollbar sends us event with same scrollTop. ignore it
        if (this.scrollTop !== scrollTop) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollTop = scrollTop;
        }
    };

    this.scrollToX = function(scrollLeft) {
        if (scrollLeft <= this.$padding)
            scrollLeft = 0;

        if (this.scrollLeft !== scrollLeft)
            this.scrollLeft = scrollLeft;
        this.$loop.schedule(this.CHANGE_H_SCROLL);
    };

    this.scrollBy = function(deltaX, deltaY) {
        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
    };

    this.isScrollableBy = function(deltaX, deltaY) {
        if (deltaY < 0 && this.session.getScrollTop() > 0)
           return true;
        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight < this.layerConfig.maxHeight)
           return true;
        // todo: handle horizontal scrolling
    };

    this.screenToTextCoordinates = function(pageX, pageY) {
        var canvasPos = this.scroller.getBoundingClientRect();

        var col = Math.round(
            (pageX + this.scrollLeft - canvasPos.left - this.$padding - dom.getPageScrollLeft()) / this.characterWidth
        );
        var row = Math.floor(
            (pageY + this.scrollTop - canvasPos.top - dom.getPageScrollTop()) / this.lineHeight
        );

        return this.session.screenToDocumentPosition(row, Math.max(col, 0));
    };

    this.textToScreenCoordinates = function(row, column) {
        var canvasPos = this.scroller.getBoundingClientRect();
        var pos = this.session.documentToScreenPosition(row, column);

        var x = this.$padding + Math.round(pos.column * this.characterWidth);
        var y = pos.row * this.lineHeight;

        return {
            pageX: canvasPos.left + x - this.scrollLeft,
            pageY: canvasPos.top + y - this.scrollTop
        };
    };

    this.visualizeFocus = function() {
        dom.addCssClass(this.container, "ace_focus");
    };

    this.visualizeBlur = function() {
        dom.removeCssClass(this.container, "ace_focus");
    };

    this.showComposition = function(position) {
        if (!this.$composition) {
            this.$composition = dom.createElement("div");
            this.$composition.className = "ace_composition";
            this.content.appendChild(this.$composition);
        }

        this.$composition.innerHTML = "&#160;";

        var pos = this.$cursorLayer.getPixelPosition();
        var style = this.$composition.style;
        style.top = pos.top + "px";
        style.left = (pos.left + this.$padding) + "px";
        style.height = this.lineHeight + "px";

        this.hideCursor();
    };

    this.setCompositionText = function(text) {
        dom.setInnerText(this.$composition, text);
    };

    this.hideComposition = function() {
        this.showCursor();

        if (!this.$composition)
            return;

        var style = this.$composition.style;
        style.top = "-10000px";
        style.left = "-10000px";
    };

    this.setTheme = function(theme) {
        var _self = this;

        this.$themeValue = theme;
        if (!theme || typeof theme == "string") {
            theme = theme || "ace/theme/textmate";
            require([theme], function(theme) {
                afterLoad(theme);
            });
        } else {
            afterLoad(theme);
        }

        function afterLoad(theme) {
            dom.importCssString(
                theme.cssText,
                theme.cssClass,
                _self.container.ownerDocument
            );

            if (_self.$theme)
                dom.removeCssClass(_self.container, _self.$theme);

            _self.$theme = theme ? theme.cssClass : null;

            if (_self.$theme)
                dom.addCssClass(_self.container, _self.$theme);

            if (theme && theme.isDark)
                dom.addCssClass(_self.container, "ace_dark");
            else
                dom.removeCssClass(_self.container, "ace_dark");

            // force re-measure of the gutter width
            if (_self.$size) {
                _self.$size.width = 0;
                _self.onResize();
            }
        }
    };

    this.getTheme = function() {
        return this.$themeValue;
    };

    // Methods allows to add / remove CSS classnames to the editor element.
    // This feature can be used by plug-ins to provide a visual indication of
    // a certain mode that editor is in.

    this.setStyle = function setStyle(style) {
      dom.addCssClass(this.container, style);
    };

    this.unsetStyle = function unsetStyle(style) {
      dom.removeCssClass(this.container, style);
    };

    this.destroy = function() {
        this.$textLayer.destroy();
        this.$cursorLayer.destroy();
    };

}).call(VirtualRenderer.prototype);

exports.VirtualRenderer = VirtualRenderer;
});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Julian Viereck <julian DOT viereck AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/layer/gutter', ['require', 'exports', 'module' , 'ace/lib/dom', 'ace/lib/oop', 'ace/lib/event_emitter'], function(require, exports, module) {
"use strict";

var dom = require("../lib/dom");
var oop = require("../lib/oop");
var EventEmitter = require("../lib/event_emitter").EventEmitter;

var Gutter = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_gutter-layer";
    parentEl.appendChild(this.element);
    this.setShowFoldWidgets(this.$showFoldWidgets);
    
    this.gutterWidth = 0;

    this.$breakpoints = [];
    this.$annotations = [];
    this.$decorations = [];
};

(function() {

    oop.implement(this, EventEmitter);
    
    this.setSession = function(session) {
        this.session = session;
    };

    this.addGutterDecoration = function(row, className){
        if (!this.$decorations[row])
            this.$decorations[row] = "";
        this.$decorations[row] += " ace_" + className;
    };

    this.removeGutterDecoration = function(row, className){
        this.$decorations[row] = this.$decorations[row].replace(" ace_" + className, "");
    };

    this.setBreakpoints = function(rows) {
        this.$breakpoints = rows.concat();
    };

    this.setAnnotations = function(annotations) {
        // iterate over sparse array
        this.$annotations = [];
        for (var row in annotations) if (annotations.hasOwnProperty(row)) {
            var rowAnnotations = annotations[row];
            if (!rowAnnotations)
                continue;

            var rowInfo = this.$annotations[row] = {
                text: []
            };
            for (var i=0; i<rowAnnotations.length; i++) {
                var annotation = rowAnnotations[i];
                var annoText = annotation.text.replace(/"/g, "&quot;").replace(/'/g, "&#8217;").replace(/</, "&lt;");
                if (rowInfo.text.indexOf(annoText) === -1)
                    rowInfo.text.push(annoText);
                var type = annotation.type;
                if (type == "error")
                    rowInfo.className = "ace_error";
                else if (type == "warning" && rowInfo.className != "ace_error")
                    rowInfo.className = "ace_warning";
                else if (type == "info" && (!rowInfo.className))
                    rowInfo.className = "ace_info";
            }
        }
    };

    this.update = function(config) {
        this.$config = config;

        var emptyAnno = {className: "", text: []};
        var html = [];
        var i = config.firstRow;
        var lastRow = config.lastRow;
        var fold = this.session.getNextFoldLine(i);
        var foldStart = fold ? fold.start.row : Infinity;
        var foldWidgets = this.$showFoldWidgets && this.session.foldWidgets;

        while (true) {
            if(i > foldStart) {
                i = fold.end.row + 1;
                fold = this.session.getNextFoldLine(i, fold);
                foldStart = fold ?fold.start.row :Infinity;
            }
            if(i > lastRow)
                break;

            var annotation = this.$annotations[i] || emptyAnno;
            html.push("<div class='ace_gutter-cell",
                this.$decorations[i] || "",
                this.$breakpoints[i] ? " ace_breakpoint " : " ",
                annotation.className,
                "' title='", annotation.text.join("\n"),
                "' style='height:", config.lineHeight, "px;'>", (i+1));

            if (foldWidgets) {
                var c = foldWidgets[i];
                // check if cached value is invalidated and we need to recompute
                if (c == null)
                    c = foldWidgets[i] = this.session.getFoldWidget(i);
                if (c)
                    html.push(
                        "<span class='ace_fold-widget ", c,
                        c == "start" && i == foldStart && i < fold.end.row ? " closed" : " open",
                        "'></span>"
                    );
            }

            var wrappedRowLength = this.session.getRowLength(i) - 1;
            while (wrappedRowLength--) {
                html.push("</div><div class='ace_gutter-cell' style='height:", config.lineHeight, "px'>\xA6");
            }

            html.push("</div>");

            i++;
        }
        this.element = dom.setInnerHtml(this.element, html.join(""));
        this.element.style.height = config.minHeight + "px";
        
        var gutterWidth = this.element.offsetWidth;
        if (gutterWidth !== this.gutterWidth) {
            this.gutterWidth = gutterWidth;
            this._emit("changeGutterWidth", gutterWidth);
        }
    };

    this.$showFoldWidgets = true;
    this.setShowFoldWidgets = function(show) {
        if (show)
            dom.addCssClass(this.element, "ace_folding-enabled");
        else
            dom.removeCssClass(this.element, "ace_folding-enabled");

        this.$showFoldWidgets = show;
    };
    
    this.getShowFoldWidgets = function() {
        return this.$showFoldWidgets;
    };

}).call(Gutter.prototype);

exports.Gutter = Gutter;

});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Julian Viereck <julian.viereck@gmail.com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/layer/marker', ['require', 'exports', 'module' , 'ace/range', 'ace/lib/dom'], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;
var dom = require("../lib/dom");

var Marker = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_marker-layer";
    parentEl.appendChild(this.element);
};

(function() {

    this.$padding = 0;

    this.setPadding = function(padding) {
        this.$padding = padding;
    };
    this.setSession = function(session) {
        this.session = session;
    };
    
    this.setMarkers = function(markers) {
        this.markers = markers;
    };

    this.update = function(config) {
        var config = config || this.config;
        if (!config)
            return;

        this.config = config;


        var html = [];
        for ( var key in this.markers) {
            var marker = this.markers[key];

            var range = marker.range.clipRows(config.firstRow, config.lastRow);
            if (range.isEmpty()) continue;

            range = range.toScreenRange(this.session);
            if (marker.renderer) {
                var top = this.$getTop(range.start.row, config);
                var left = Math.round(
                    this.$padding + range.start.column * config.characterWidth
                );
                marker.renderer(html, range, left, top, config);
            }
            else if (range.isMultiLine()) {
                if (marker.type == "text") {
                    this.drawTextMarker(html, range, marker.clazz, config);
                } else {
                    this.drawMultiLineMarker(
                        html, range, marker.clazz, config,
                        marker.type
                    );
                }
            }
            else {
                this.drawSingleLineMarker(
                    html, range, marker.clazz, config,
                    null, marker.type
                );
            }
        }
        this.element = dom.setInnerHtml(this.element, html.join(""));
    };

    this.$getTop = function(row, layerConfig) {
        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
    };

    /**
     * Draws a marker, which spans a range of text in a single line
     */ 
    this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig) {
        // selection start
        var row = range.start.row;

        var lineRange = new Range(
            row, range.start.column,
            row, this.session.getScreenLastRowColumn(row)
        );
        this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 1, "text");

        // selection end
        row = range.end.row;
        lineRange = new Range(row, 0, row, range.end.column);
        this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 0, "text");

        for (row = range.start.row + 1; row < range.end.row; row++) {
            lineRange.start.row = row;
            lineRange.end.row = row;
            lineRange.end.column = this.session.getScreenLastRowColumn(row);
            this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 1, "text");
        }
    };

    /**
     * Draws a multi line marker, where lines span the full width
     */
     this.drawMultiLineMarker = function(stringBuilder, range, clazz, layerConfig, type) {
        var padding = type === "background" ? 0 : this.$padding;
        var layerWidth = layerConfig.width + 2 * this.$padding - padding;
        // from selection start to the end of the line
        var height = layerConfig.lineHeight;
        var width = Math.round(layerWidth - (range.start.column * layerConfig.characterWidth));
        var top = this.$getTop(range.start.row, layerConfig);
        var left = Math.round(
            padding + range.start.column * layerConfig.characterWidth
        );

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "width:", width, "px;",
            "top:", top, "px;",
            "left:", left, "px;'></div>"
        );

        // from start of the last line to the selection end
        top = this.$getTop(range.end.row, layerConfig);
        width = Math.round(range.end.column * layerConfig.characterWidth);

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "width:", width, "px;",
            "top:", top, "px;",
            "left:", padding, "px;'></div>"
        );

        // all the complete lines
        height = (range.end.row - range.start.row - 1) * layerConfig.lineHeight;
        if (height < 0)
            return;
        top = this.$getTop(range.start.row + 1, layerConfig);

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "width:", layerWidth, "px;",
            "top:", top, "px;",
            "left:", padding, "px;'></div>"
        );
    };

    /**
     * Draws a marker which covers one single full line
     */
    this.drawSingleLineMarker = function(stringBuilder, range, clazz, layerConfig, extraLength, type) {
        var padding = type === "background" ? 0 : this.$padding;
        var height = layerConfig.lineHeight;

        if (type === "background")
            var width = layerConfig.width;
        else
            width = Math.round((range.end.column + (extraLength || 0) - range.start.column) * layerConfig.characterWidth);

        var top = this.$getTop(range.start.row, layerConfig);
        var left = Math.round(
            padding + range.start.column * layerConfig.characterWidth
        );

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "width:", width, "px;",
            "top:", top, "px;",
            "left:", left,"px;'></div>"
        );
    };

}).call(Marker.prototype);

exports.Marker = Marker;

});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Julian Viereck <julian DOT viereck AT gmail DOT com>
 *      Mihai Sucan <mihai.sucan@gmail.com>
 *      Irakli Gozalishvili <rfobic@gmail.com> (http://jeditoolkit.com)
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/layer/text', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/dom', 'ace/lib/lang', 'ace/lib/useragent', 'ace/lib/event_emitter'], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var dom = require("../lib/dom");
var lang = require("../lib/lang");
var useragent = require("../lib/useragent");
var EventEmitter = require("../lib/event_emitter").EventEmitter;

var Text = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_text-layer";
    parentEl.appendChild(this.element);

    this.$characterSize = this.$measureSizes() || {width: 0, height: 0};
    this.$pollSizeChanges();
};

(function() {

    oop.implement(this, EventEmitter);

    this.EOF_CHAR = "\xB6"; //"&para;";
    this.EOL_CHAR = "\xAC"; //"&not;";
    this.TAB_CHAR = "\u2192"; //"&rarr;";
    this.SPACE_CHAR = "\xB7"; //"&middot;";
    this.$padding = 0;

    this.setPadding = function(padding) {
        this.$padding = padding;
        this.element.style.padding = "0 " + padding + "px";
    };

    this.getLineHeight = function() {
        return this.$characterSize.height || 1;
    };

    this.getCharacterWidth = function() {
        return this.$characterSize.width || 1;
    };

    this.checkForSizeChanges = function() {
        var size = this.$measureSizes();
        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
            this.$characterSize = size;
            this._emit("changeCharacterSize", {data: size});
        }
    };

    this.$pollSizeChanges = function() {
        var self = this;
        this.$pollSizeChangesTimer = setInterval(function() {
            self.checkForSizeChanges();
        }, 500);
    };

    this.$fontStyles = {
        fontFamily : 1,
        fontSize : 1,
        fontWeight : 1,
        fontStyle : 1,
        lineHeight : 1
    };

    this.$measureSizes = function() {
        var n = 1000;
        if (!this.$measureNode) {
            var measureNode = this.$measureNode = dom.createElement("div");
            var style = measureNode.style;

            style.width = style.height = "auto";
            style.left = style.top = (-n * 40)  + "px";

            style.visibility = "hidden";
            style.position = "absolute";
            style.overflow = "visible";
            style.whiteSpace = "nowrap";

            // in FF 3.6 monospace fonts can have a fixed sub pixel width.
            // that's why we have to measure many characters
            // Note: characterWidth can be a float!
            measureNode.innerHTML = lang.stringRepeat("Xy", n);

            if (this.element.ownerDocument.body) {
                this.element.ownerDocument.body.appendChild(measureNode);
            } else {
                var container = this.element.parentNode;
                while (!dom.hasCssClass(container, "ace_editor"))
                    container = container.parentNode;
                container.appendChild(measureNode);
            }

        }
        
        // Size and width can be null if the editor is not visible or
        // detached from the document
        if (!this.element.offsetWidth)
            return null;

        var style = this.$measureNode.style;
        var computedStyle = dom.computedStyle(this.element);
        for (var prop in this.$fontStyles)
            style[prop] = computedStyle[prop];

        var size = {
            height: this.$measureNode.offsetHeight,
            width: this.$measureNode.offsetWidth / (n * 2)
        };

        // Size and width can be null if the editor is not visible or
        // detached from the document
        if (size.width == 0 && size.height == 0)
            return null;

        return size;
    };

    this.setSession = function(session) {
        this.session = session;
    };

    this.showInvisibles = false;
    this.setShowInvisibles = function(showInvisibles) {
        if (this.showInvisibles == showInvisibles)
            return false;

        this.showInvisibles = showInvisibles;
        return true;
    };

    this.$tabStrings = [];
    this.$computeTabString = function() {
        var tabSize = this.session.getTabSize();
        var tabStr = this.$tabStrings = [0];
        for (var i = 1; i < tabSize + 1; i++) {
            if (this.showInvisibles) {
                tabStr.push("<span class='ace_invisible'>"
                    + this.TAB_CHAR
                    + new Array(i).join("&#160;")
                    + "</span>");
            } else {
                tabStr.push(new Array(i+1).join("&#160;"));
            }
        }

    };

    this.updateLines = function(config, firstRow, lastRow) {
        this.$computeTabString();
        // Due to wrap line changes there can be new lines if e.g.
        // the line to updated wrapped in the meantime.
        if (this.config.lastRow != config.lastRow ||
            this.config.firstRow != config.firstRow) {
            this.scrollLines(config);
        }
        this.config = config;

        var first = Math.max(firstRow, config.firstRow);
        var last = Math.min(lastRow, config.lastRow);

        var lineElements = this.element.childNodes;
        var lineElementsIdx = 0;

        for (var row = config.firstRow; row < first; row++) {
            var foldLine = this.session.getFoldLine(row);
            if (foldLine) {
                if (foldLine.containsRow(first)) {
                    first = foldLine.start.row;
                    break;
                } else {
                    row = foldLine.end.row;
                }
            }
            lineElementsIdx ++;
        }

        for (var i=first; i<=last; i++) {
            var lineElement = lineElements[lineElementsIdx++];
            if (!lineElement)
                continue;

            var html = [];
            var tokens = this.session.getTokens(i, i);
            this.$renderLine(html, i, tokens[0].tokens, !this.$useLineGroups());
            lineElement = dom.setInnerHtml(lineElement, html.join(""));

            i = this.session.getRowFoldEnd(i);
        }
    };

    this.scrollLines = function(config) {
        this.$computeTabString();
        var oldConfig = this.config;
        this.config = config;

        if (!oldConfig || oldConfig.lastRow < config.firstRow)
            return this.update(config);

        if (config.lastRow < oldConfig.firstRow)
            return this.update(config);

        var el = this.element;
        if (oldConfig.firstRow < config.firstRow)
            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
                el.removeChild(el.firstChild);

        if (oldConfig.lastRow > config.lastRow)
            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)
                el.removeChild(el.lastChild);

        if (config.firstRow < oldConfig.firstRow) {
            var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
            if (el.firstChild)
                el.insertBefore(fragment, el.firstChild);
            else
                el.appendChild(fragment);
        }

        if (config.lastRow > oldConfig.lastRow) {
            var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
            el.appendChild(fragment);
        }
    };

    this.$renderLinesFragment = function(config, firstRow, lastRow) {
        var fragment = this.element.ownerDocument.createDocumentFragment(),
            row = firstRow,
            fold = this.session.getNextFoldLine(row),
            foldStart = fold ?fold.start.row :Infinity;

        while (true) {
            if (row > foldStart) {
                row = fold.end.row+1;
                fold = this.session.getNextFoldLine(row, fold);
                foldStart = fold ?fold.start.row :Infinity;
            }
            if (row > lastRow)
                break;

            var container = dom.createElement("div");

            var html = [];
            // Get the tokens per line as there might be some lines in between
            // beeing folded.
            // OPTIMIZE: If there is a long block of unfolded lines, just make
            // this call once for that big block of unfolded lines.
            var tokens = this.session.getTokens(row, row);
            if (tokens.length == 1)
                this.$renderLine(html, row, tokens[0].tokens, false);

            // don't use setInnerHtml since we are working with an empty DIV
            container.innerHTML = html.join("");
            if (this.$useLineGroups()) {
                container.className = 'ace_line_group';
                fragment.appendChild(container);
            } else {
                var lines = container.childNodes
                while(lines.length)
                    fragment.appendChild(lines[0]);
            }

            row++;
        }
        return fragment;
    };

    this.update = function(config) {
        this.$computeTabString();
        this.config = config;

        var html = [];
        var firstRow = config.firstRow, lastRow = config.lastRow;

        var row = firstRow,
            fold = this.session.getNextFoldLine(row),
            foldStart = fold ?fold.start.row :Infinity;

        while (true) {
            if (row > foldStart) {
                row = fold.end.row+1;
                fold = this.session.getNextFoldLine(row, fold);
                foldStart = fold ?fold.start.row :Infinity;
            }
            if (row > lastRow)
                break;

            if (this.$useLineGroups())
                html.push("<div class='ace_line_group'>")

            // Get the tokens per line as there might be some lines in between
            // beeing folded.
            // OPTIMIZE: If there is a long block of unfolded lines, just make
            // this call once for that big block of unfolded lines.
            var tokens = this.session.getTokens(row, row);
            if (tokens.length == 1)
                this.$renderLine(html, row, tokens[0].tokens, false);

            if (this.$useLineGroups())
                html.push("</div>"); // end the line group

            row++;
        }
        this.element = dom.setInnerHtml(this.element, html.join(""));
    };

    this.$textToken = {
        "text": true,
        "rparen": true,
        "lparen": true
    };

    this.$renderToken = function(stringBuilder, screenColumn, token, value) {        
        var self = this;
        var replaceReg = /\t|&|<|( +)|([\v\f \u00a0\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u3000])|[\u1100-\u115F]|[\u11A3-\u11A7]|[\u11FA-\u11FF]|[\u2329-\u232A]|[\u2E80-\u2E99]|[\u2E9B-\u2EF3]|[\u2F00-\u2FD5]|[\u2FF0-\u2FFB]|[\u3000-\u303E]|[\u3041-\u3096]|[\u3099-\u30FF]|[\u3105-\u312D]|[\u3131-\u318E]|[\u3190-\u31BA]|[\u31C0-\u31E3]|[\u31F0-\u321E]|[\u3220-\u3247]|[\u3250-\u32FE]|[\u3300-\u4DBF]|[\u4E00-\uA48C]|[\uA490-\uA4C6]|[\uA960-\uA97C]|[\uAC00-\uD7A3]|[\uD7B0-\uD7C6]|[\uD7CB-\uD7FB]|[\uF900-\uFAFF]|[\uFE10-\uFE19]|[\uFE30-\uFE52]|[\uFE54-\uFE66]|[\uFE68-\uFE6B]|[\uFF01-\uFF60]|[\uFFE0-\uFFE6]/g;
        var replaceFunc = function(c, a, b, tabIdx, idx4) {
            if (c.charCodeAt(0) == 32) {
                return new Array(c.length+1).join("&#160;");
            } else if (c == "\t") {
                var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
                screenColumn += tabSize - 1;
                return self.$tabStrings[tabSize];
            } else if (c == "&") {
                if (useragent.isOldGecko)
                    return "&";
                else
                    return "&amp;";
            } else if (c == "<") {
                return "&lt;";
            } else if (c == "\u3000") {
                // U+3000 is both invisible AND full-width, so must be handled uniquely
                var classToUse = self.showInvisibles ? "ace_cjk ace_invisible" : "ace_cjk";
                var space = self.showInvisibles ? self.SPACE_CHAR : "";
                screenColumn += 1;
                return "<span class='" + classToUse + "' style='width:" +
                    (self.config.characterWidth * 2) +
                    "px'>" + space + "</span>";
            } else if (c.match(/[\v\f \u00a0\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u3000]/)) {
                if (self.showInvisibles) {
                    var space = new Array(c.length+1).join(self.SPACE_CHAR);
                    return "<span class='ace_invisible'>" + space + "</span>";
                } else {
                    return "&#160;";
                }
            } else {
                screenColumn += 1;
                return "<span class='ace_cjk' style='width:" +
                    (self.config.characterWidth * 2) +
                    "px'>" + c + "</span>";
            }
        };

        var output = value.replace(replaceReg, replaceFunc);

        if (!this.$textToken[token.type]) {
            var classes = "ace_" + token.type.replace(/\./g, " ace_");
            var style = "";
            if (token.type == "fold")
                style = " style='width:" + (token.value.length * this.config.characterWidth) + "px;' ";
            stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
        }
        else {
            stringBuilder.push(output);
        }
        return screenColumn + value.length;
    };

    this.$renderLineCore = function(stringBuilder, lastRow, tokens, splits, onlyContents) {
        var chars = 0;
        var split = 0;
        var splitChars;
        var screenColumn = 0;
        var self = this;

        if (!splits || splits.length == 0)
            splitChars = Number.MAX_VALUE;
        else
            splitChars = splits[0];

        if (!onlyContents) {
            stringBuilder.push("<div class='ace_line' style='height:",
                this.config.lineHeight, "px",
                "'>"
            );
        }
        
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;

            if (chars + value.length < splitChars) {
                screenColumn = self.$renderToken(
                    stringBuilder, screenColumn, token, value
                );
                chars += value.length;
            }
            else {
                while (chars + value.length >= splitChars) {
                    screenColumn = self.$renderToken(
                        stringBuilder, screenColumn, 
                        token, value.substring(0, splitChars - chars)
                    );
                    value = value.substring(splitChars - chars);
                    chars = splitChars;
                    
                    if (!onlyContents) {
                        stringBuilder.push("</div>",
                            "<div class='ace_line' style='height:",
                            this.config.lineHeight, "px",
                            "'>"
                        );
                    }

                    split ++;
                    screenColumn = 0;
                    splitChars = splits[split] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                    chars += value.length;
                    screenColumn = self.$renderToken(
                        stringBuilder, screenColumn, token, value
                    );
                }
            }
        }

        if (this.showInvisibles) {
            if (lastRow !== this.session.getLength() - 1)
                stringBuilder.push("<span class='ace_invisible'>" + this.EOL_CHAR + "</span>");
            else
                stringBuilder.push("<span class='ace_invisible'>" + this.EOF_CHAR + "</span>");
        }
        if (!onlyContents)
            stringBuilder.push("</div>");
    };

    this.$renderLine = function(stringBuilder, row, tokens, onlyContents) {
        // Check if the line to render is folded or not. If not, things are
        // simple, otherwise, we need to fake some things...
        if (!this.session.isRowFolded(row)) {
            var splits = this.session.getRowSplitData(row);
            this.$renderLineCore(stringBuilder, row, tokens, splits, onlyContents);
        } else {
            this.$renderFoldLine(stringBuilder, row, tokens, onlyContents);
        }
    };

    this.$renderFoldLine = function(stringBuilder, row, tokens, onlyContents) {
        var session = this.session,
            foldLine = session.getFoldLine(row),
            renderTokens = [];

        function addTokens(tokens, from, to) {
            var idx = 0, col = 0;
            while ((col + tokens[idx].value.length) < from) {
                col += tokens[idx].value.length;
                idx++;

                if (idx == tokens.length) {
                    return;
                }
            }
            if (col != from) {
                var value = tokens[idx].value.substring(from - col);
                // Check if the token value is longer then the from...to spacing.
                if (value.length > (to - from)) {
                    value = value.substring(0, to - from);
                }

                renderTokens.push({
                    type: tokens[idx].type,
                    value: value
                });

                col = from + value.length;
                idx += 1;
            }

            while (col < to) {
                var value = tokens[idx].value;
                if (value.length + col > to) {
                    value = value.substring(0, to - col);
                }
                renderTokens.push({
                    type: tokens[idx].type,
                    value: value
                });
                col += value.length;
                idx += 1;
            }
        }

        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
            if (placeholder) {
               renderTokens.push({
                    type: "fold",
                    value: placeholder
                });
            } else {
                if (isNewRow) {
                   tokens = this.session.getTokens(row, row)[0].tokens;
                }
                if (tokens.length != 0) {
                    addTokens(tokens, lastColumn, column);
                }
            }
        }.bind(this), foldLine.end.row, this.session.getLine(foldLine.end.row).length);

        // TODO: Build a fake splits array!
        var splits = this.session.$useWrapMode?this.session.$wrapData[row]:null;
        this.$renderLineCore(stringBuilder, row, renderTokens, splits, onlyContents);
    };
    
    this.$useLineGroups = function() {
        // For the updateLines function to work correctly, it's important that the
        // child nodes of this.element correspond on a 1-to-1 basis to rows in the 
        // document (as distinct from lines on the screen). For sessions that are
        // wrapped, this means we need to add a layer to the node hierarchy (tagged
        // with the class name ace_line_group).
        return this.session.getUseWrapMode();
    };

    this.destroy = function() {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.$measureNode)
            this.$measureNode.parentNode.removeChild(this.$measureNode);
        delete this.$measureNode;
    };

}).call(Text.prototype);

exports.Text = Text;

});
/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Julian Viereck <julian.viereck@gmail.com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/layer/cursor', ['require', 'exports', 'module' , 'ace/lib/dom'], function(require, exports, module) {
"use strict";

var dom = require("../lib/dom");

var Cursor = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_cursor-layer";
    parentEl.appendChild(this.element);

    this.cursor = dom.createElement("div");
    this.cursor.className = "ace_cursor ace_hidden";
    this.element.appendChild(this.cursor);

    this.isVisible = false;
};

(function() {

    this.$padding = 0;
    this.setPadding = function(padding) {
        this.$padding = padding;
    };

    this.setSession = function(session) {
        this.session = session;
    };

    this.hideCursor = function() {
        this.isVisible = false;
        dom.addCssClass(this.cursor, "ace_hidden");
        clearInterval(this.blinkId);
    };

    this.showCursor = function() {
        this.isVisible = true;
        dom.removeCssClass(this.cursor, "ace_hidden");
        this.cursor.style.visibility = "visible";
        this.restartTimer();
    };

    this.restartTimer = function() {
        clearInterval(this.blinkId);
        if (!this.isVisible) {
            return;
        }

        var cursor = this.cursor;
        this.blinkId = setInterval(function() {
            cursor.style.visibility = "hidden";
            setTimeout(function() {
                cursor.style.visibility = "visible";
            }, 400);
        }, 1000);
    };

    this.getPixelPosition = function(position, onScreen) {
        if (!this.config || !this.session) {
            return {
                left : 0,
                top : 0
            };
        }

        if (!position)
            position = this.session.selection.getCursor();
        var pos = this.session.documentToScreenPosition(position);
        var cursorLeft = Math.round(this.$padding +
                                    pos.column * this.config.characterWidth);
        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
            this.config.lineHeight;

        return {
            left : cursorLeft,
            top : cursorTop
        };
    };

    this.update = function(config) {
        this.config = config;

        this.pixelPos = this.getPixelPosition(null, true);

        this.cursor.style.left = this.pixelPos.left + "px";
        this.cursor.style.top =  this.pixelPos.top + "px";
        this.cursor.style.width = config.characterWidth + "px";
        this.cursor.style.height = config.lineHeight + "px";

        var overwrite = this.session.getOverwrite()
        if (overwrite != this.overwrite) {
            this.overwrite = overwrite;
            if (overwrite)
                dom.addCssClass(this.cursor, "ace_overwrite");
            else
                dom.removeCssClass(this.cursor, "ace_overwrite");
        }

        this.restartTimer();
    };

    this.destroy = function() {
        clearInterval(this.blinkId);
    }

}).call(Cursor.prototype);

exports.Cursor = Cursor;

});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Irakli Gozalishvili <rfobic@gmail.com> (http://jeditoolkit.com)
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/scrollbar', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/dom', 'ace/lib/event', 'ace/lib/event_emitter'], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var dom = require("./lib/dom");
var event = require("./lib/event");
var EventEmitter = require("./lib/event_emitter").EventEmitter;

var ScrollBar = function(parent) {
    this.element = dom.createElement("div");
    this.element.className = "ace_sb";

    this.inner = dom.createElement("div");
    this.element.appendChild(this.inner);

    parent.appendChild(this.element);

    // in OSX lion the scrollbars appear to have no width. In this case resize
    // the to show the scrollbar but still pretend that the scrollbar has a width
    // of 0px
    // in Firefox 6+ scrollbar is hidden if element has the same width as scrollbar
    // make element a little bit wider to retain scrollbar when page is zoomed 
    this.width = dom.scrollbarWidth(parent.ownerDocument);
    this.element.style.width = (this.width || 15) + 5 + "px";

    event.addListener(this.element, "scroll", this.onScroll.bind(this));
};

(function() {
    oop.implement(this, EventEmitter);

    this.onScroll = function() {
        this._emit("scroll", {data: this.element.scrollTop});
    };

    this.getWidth = function() {
        return this.width;
    };

    this.setHeight = function(height) {
        this.element.style.height = height + "px";
    };

    this.setInnerHeight = function(height) {
        this.inner.style.height = height + "px";
    };

    this.setScrollTop = function(scrollTop) {
        this.element.scrollTop = scrollTop;
    };

}).call(ScrollBar.prototype);

exports.ScrollBar = ScrollBar;
});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Irakli Gozalishvili <rfobic@gmail.com> (http://jeditoolkit.com)
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/renderloop', ['require', 'exports', 'module' , 'ace/lib/event'], function(require, exports, module) {
"use strict";

var event = require("./lib/event");

var RenderLoop = function(onRender, win) {
    this.onRender = onRender;
    this.pending = false;
    this.changes = 0;
    this.window = win || window;
};

(function() {

    this.schedule = function(change) {
        //this.onRender(change);
        //return;
        this.changes = this.changes | change;
        if (!this.pending) {
            this.pending = true;
            var _self = this;
            event.nextTick(function() {
                _self.pending = false;
                var changes;
                while (changes = _self.changes) {
                    _self.changes = 0;
                    _self.onRender(changes);
                }
            }, this.window);
        }
    };

}).call(RenderLoop.prototype);

exports.RenderLoop = RenderLoop;
});
define("text!ace/css/editor.css", [], "@import url(//fonts.googleapis.com/css?family=Droid+Sans+Mono);\n" +
  "\n" +
  "\n" +
  ".ace_editor {\n" +
  "    position: absolute;\n" +
  "    overflow: hidden;\n" +
  "    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Droid Sans Mono', 'Consolas', monospace;\n" +
  "    font-size: 12px;\n" +
  "}\n" +
  "\n" +
  ".ace_scroller {\n" +
  "    position: absolute;\n" +
  "    overflow-x: scroll;\n" +
  "    overflow-y: hidden;\n" +
  "}\n" +
  "\n" +
  ".ace_content {\n" +
  "    position: absolute;\n" +
  "    box-sizing: border-box;\n" +
  "    -moz-box-sizing: border-box;\n" +
  "    -webkit-box-sizing: border-box;\n" +
  "    cursor: text;\n" +
  "}\n" +
  "\n" +
  ".ace_composition {\n" +
  "    position: absolute;\n" +
  "    background: #555;\n" +
  "    color: #DDD;\n" +
  "    z-index: 4;\n" +
  "}\n" +
  "\n" +
  ".ace_gutter {\n" +
  "    position: absolute;\n" +
  "    overflow : hidden;\n" +
  "    height: 100%;\n" +
  "    width: auto;\n" +
  "    cursor: default;\n" +
  "}\n" +
  "\n" +
  ".ace_gutter-cell {\n" +
  "    padding-left: 19px;\n" +
  "    padding-right: 6px;\n" +
  "}\n" +
  "\n" +
  ".ace_gutter-cell.ace_error {\n" +
  "    background-image: url(\"data:image/gif,GIF89a%10%00%10%00%D5%00%00%F5or%F5%87%88%F5nr%F4ns%EBmq%F5z%7F%DDJT%DEKS%DFOW%F1Yc%F2ah%CE(7%CE)8%D18E%DD%40M%F2KZ%EBU%60%F4%60m%DCir%C8%16(%C8%19*%CE%255%F1%3FR%F1%3FS%E6%AB%B5%CA%5DI%CEn%5E%F7%A2%9A%C9G%3E%E0a%5B%F7%89%85%F5yy%F6%82%80%ED%82%80%FF%BF%BF%E3%C4%C4%FF%FF%FF%FF%FF%FF%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00!%F9%04%01%00%00%25%00%2C%00%00%00%00%10%00%10%00%00%06p%C0%92pH%2C%1A%8F%C8%D2H%93%E1d4%23%E4%88%D3%09mB%1DN%B48%F5%90%40%60%92G%5B%94%20%3E%22%D2%87%24%FA%20%24%C5%06A%00%20%B1%07%02B%A38%89X.v%17%82%11%13q%10%0Fi%24%0F%8B%10%7BD%12%0Ei%09%92%09%0EpD%18%15%24%0A%9Ci%05%0C%18F%18%0B%07%04%01%04%06%A0H%18%12%0D%14%0D%12%A1I%B3%B4%B5IA%00%3B\");\n" +
  "    background-repeat: no-repeat;\n" +
  "    background-position: 2px center;\n" +
  "}\n" +
  "\n" +
  ".ace_gutter-cell.ace_warning {\n" +
  "    background-image: url(\"data:image/gif,GIF89a%10%00%10%00%D5%00%00%FF%DBr%FF%DE%81%FF%E2%8D%FF%E2%8F%FF%E4%96%FF%E3%97%FF%E5%9D%FF%E6%9E%FF%EE%C1%FF%C8Z%FF%CDk%FF%D0s%FF%D4%81%FF%D5%82%FF%D5%83%FF%DC%97%FF%DE%9D%FF%E7%B8%FF%CCl%7BQ%13%80U%15%82W%16%81U%16%89%5B%18%87%5B%18%8C%5E%1A%94d%1D%C5%83-%C9%87%2F%C6%84.%C6%85.%CD%8B2%C9%871%CB%8A3%CD%8B5%DC%98%3F%DF%9BB%E0%9CC%E1%A5U%CB%871%CF%8B5%D1%8D6%DB%97%40%DF%9AB%DD%99B%E3%B0p%E7%CC%AE%FF%FF%FF%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00!%F9%04%01%00%00%2F%00%2C%00%00%00%00%10%00%10%00%00%06a%C0%97pH%2C%1A%8FH%A1%ABTr%25%87%2B%04%82%F4%7C%B9X%91%08%CB%99%1C!%26%13%84*iJ9(%15G%CA%84%14%01%1A%97%0C%03%80%3A%9A%3E%81%84%3E%11%08%B1%8B%20%02%12%0F%18%1A%0F%0A%03'F%1C%04%0B%10%16%18%10%0B%05%1CF%1D-%06%07%9A%9A-%1EG%1B%A0%A1%A0U%A4%A5%A6BA%00%3B\");\n" +
  "    background-repeat: no-repeat;\n" +
  "    background-position: 2px center;\n" +
  "}\n" +
  "\n" +
  ".ace_gutter-cell.ace_info {\n" +
  "    background-image: url(\"data:image/gif;base64,R0lGODlhEAAQAMQAAAAAAEFBQVJSUl5eXmRkZGtra39/f4WFhYmJiZGRkaampry8vMPDw8zMzNXV1dzc3OTk5Orq6vDw8P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAkAABQALAAAAAAQABAAAAUuICWOZGmeaBml5XGwFCQSBGyXRSAwtqQIiRuiwIM5BoYVbEFIyGCQoeJGrVptIQA7\");\n" +
  "    background-repeat: no-repeat;\n" +
  "    background-position: 2px center;\n" +
  "}\n" +
  "\n" +
  ".ace_editor .ace_sb {\n" +
  "    position: absolute;\n" +
  "    overflow-x: hidden;\n" +
  "    overflow-y: scroll;\n" +
  "    right: 0;\n" +
  "}\n" +
  "\n" +
  ".ace_editor .ace_sb div {\n" +
  "    position: absolute;\n" +
  "    width: 1px;\n" +
  "    left: 0;\n" +
  "}\n" +
  "\n" +
  ".ace_editor .ace_print_margin_layer {\n" +
  "    z-index: 0;\n" +
  "    position: absolute;\n" +
  "    overflow: hidden;\n" +
  "    margin: 0;\n" +
  "    left: 0;\n" +
  "    height: 100%;\n" +
  "    width: 100%;\n" +
  "}\n" +
  "\n" +
  ".ace_editor .ace_print_margin {\n" +
  "    position: absolute;\n" +
  "    height: 100%;\n" +
  "}\n" +
  "\n" +
  ".ace_editor textarea {\n" +
  "    position: fixed;\n" +
  "    z-index: 0;\n" +
  "    width: 10px;\n" +
  "    height: 30px;\n" +
  "    opacity: 0;\n" +
  "    background: transparent;\n" +
  "    appearance: none;\n" +
  "    -moz-appearance: none;\n" +
  "    border: none;\n" +
  "    resize: none;\n" +
  "    outline: none;\n" +
  "    overflow: hidden;\n" +
  "}\n" +
  "\n" +
  ".ace_layer {\n" +
  "    z-index: 1;\n" +
  "    position: absolute;\n" +
  "    overflow: hidden;\n" +
  "    white-space: nowrap;\n" +
  "    height: 100%;\n" +
  "    width: 100%;\n" +
  "    box-sizing: border-box;\n" +
  "    -moz-box-sizing: border-box;\n" +
  "    -webkit-box-sizing: border-box;\n" +
  "    /* setting pointer-events: auto; on node under the mouse, which changes\n" +
  "        during scroll, will break mouse wheel scrolling in Safari */\n" +
  "    pointer-events: none;\n" +
  "}\n" +
  "\n" +
  ".ace_gutter .ace_layer {\n" +
  "    position: relative;\n" +
  "    min-width: 40px;\n" +
  "    text-align: right;\n" +
  "    pointer-events: auto;\n" +
  "}\n" +
  "\n" +
  ".ace_text-layer {\n" +
  "    color: black;\n" +
  "}\n" +
  "\n" +
  ".ace_cjk {\n" +
  "    display: inline-block;\n" +
  "    text-align: center;\n" +
  "}\n" +
  "\n" +
  ".ace_cursor-layer {\n" +
  "    z-index: 4;\n" +
  "}\n" +
  "\n" +
  ".ace_cursor {\n" +
  "    z-index: 4;\n" +
  "    position: absolute;\n" +
  "}\n" +
  "\n" +
  ".ace_cursor.ace_hidden {\n" +
  "    opacity: 0.2;\n" +
  "}\n" +
  "\n" +
  ".ace_line {\n" +
  "    white-space: nowrap;\n" +
  "}\n" +
  "\n" +
  ".ace_marker-layer .ace_step {\n" +
  "    position: absolute;\n" +
  "    z-index: 3;\n" +
  "}\n" +
  "\n" +
  ".ace_marker-layer .ace_selection {\n" +
  "    position: absolute;\n" +
  "    z-index: 4;\n" +
  "}\n" +
  "\n" +
  ".ace_marker-layer .ace_bracket {\n" +
  "    position: absolute;\n" +
  "    z-index: 5;\n" +
  "}\n" +
  "\n" +
  ".ace_marker-layer .ace_active_line {\n" +
  "    position: absolute;\n" +
  "    z-index: 2;\n" +
  "}\n" +
  "\n" +
  ".ace_marker-layer .ace_selected_word {\n" +
  "    position: absolute;\n" +
  "    z-index: 6;\n" +
  "    box-sizing: border-box;\n" +
  "    -moz-box-sizing: border-box;\n" +
  "    -webkit-box-sizing: border-box;\n" +
  "}\n" +
  "\n" +
  ".ace_line .ace_fold {\n" +
  "    box-sizing: border-box;\n" +
  "    -moz-box-sizing: border-box;\n" +
  "    -webkit-box-sizing: border-box;\n" +
  "    \n" +
  "    display: inline-block;\n" +
  "    height: 11px;\n" +
  "    margin-top: -2px;\n" +
  "    vertical-align: middle;\n" +
  "\n" +
  "    background-image: \n" +
  "        url(\"data:image/png,%89PNG%0D%0A%1A%0A%00%00%00%0DIHDR%00%00%00%11%00%00%00%09%08%06%00%00%00%D4%E8%C7%0C%00%00%03%1EiCCPICC%20Profile%00%00x%01%85T%DFk%D3P%14%FE%DAe%9D%B0%E1%8B%3Ag%11%09%3Eh%91ndStC%9C%B6kW%BA%CDZ%EA6%B7!H%9B%A6m%5C%9A%C6%24%ED~%B0%07%D9%8Bo%3A%C5w%F1%07%3E%F9%07%0C%D9%83o%7B%92%0D%C6%14a%F8%AC%88%22L%F6%22%B3%9E%9B4M'S%03%B9%F7%BB%DF%F9%EE9'%E7%E4%5E%A0%F9qZ%D3%14%2F%0F%14USO%C5%C2%FC%C4%E4%14%DF%F2%01%5E%1CC%2B%FChM%8B%86%16J%26G%40%0F%D3%B2y%EF%B3%F3%0E%1E%C6lt%EEo%DF%AB%FEc%D5%9A%95%0C%11%F0%1C%20%BE%945%C4%22%E1Y%A0i%5C%D4t%13%E0%D6%89%EF%9D15%C2%CDLsX%A7%04%09%1Fg8oc%81%E1%8C%8D%23%96f45%40%9A%09%C2%07%C5B%3AK%B8%408%98i%E0%F3%0D%D8%CE%81%14%E4'%26%A9%92.%8B%3C%ABER%2F%E5dE%B2%0C%F6%F0%1Fs%83%F2_%B0%A8%94%E9%9B%AD%E7%10%8Dm%9A%19N%D1%7C%8A%DE%1F9%7Dp%8C%E6%00%D5%C1%3F_%18%BDA%B8%9DpX6%E3%A35~B%CD%24%AE%11%26%BD%E7%EEti%98%EDe%9A%97Y)%12%25%1C%24%BCbT%AE3li%E6%0B%03%89%9A%E6%D3%ED%F4P%92%B0%9F4%BF43Y%F3%E3%EDP%95%04%EB1%C5%F5%F6KF%F4%BA%BD%D7%DB%91%93%07%E35%3E%A7)%D6%7F%40%FE%BD%F7%F5r%8A%E5y%92%F0%EB%B4%1E%8D%D5%F4%5B%92%3AV%DB%DB%E4%CD%A6%23%C3%C4wQ%3F%03HB%82%8E%1Cd(%E0%91B%0Ca%9Ac%C4%AA%F8L%16%19%22J%A4%D2itTy%B28%D6%3B(%93%96%ED%1CGx%C9_%0E%B8%5E%16%F5%5B%B2%B8%F6%E0%FB%9E%DD%25%D7%8E%BC%15%85%C5%B7%A3%D8Q%ED%B5%81%E9%BA%B2%13%9A%1B%7Fua%A5%A3n%E17%B9%E5%9B%1Bm%AB%0B%08Q%FE%8A%E5%B1H%5Ee%CAO%82Q%D7u6%E6%90S%97%FCu%0B%CF2%94%EE%25v%12X%0C%BA%AC%F0%5E%F8*l%0AO%85%17%C2%97%BF%D4%C8%CE%DE%AD%11%CB%80q%2C%3E%AB%9ES%CD%C6%EC%25%D2L%D2%EBd%B8%BF%8A%F5B%C6%18%F9%901CZ%9D%BE%24M%9C%8A9%F2%DAP%0B'%06w%82%EB%E6%E2%5C%2F%D7%07%9E%BB%CC%5D%E1%FA%B9%08%AD.r%23%8E%C2%17%F5E%7C!%F0%BE3%BE%3E_%B7o%88a%A7%DB%BE%D3d%EB%A31Z%EB%BB%D3%91%BA%A2%B1z%94%8F%DB'%F6%3D%8E%AA%13%19%B2%B1%BE%B1~V%08%2B%B4%A2cjJ%B3tO%00%03%25mN%97%F3%05%93%EF%11%84%0B%7C%88%AE-%89%8F%ABbW%90O%2B%0Ao%99%0C%5E%97%0CI%AFH%D9.%B0%3B%8F%ED%03%B6S%D6%5D%E6i_s9%F3*p%E9%1B%FD%C3%EB.7U%06%5E%19%C0%D1s.%17%A03u%E4%09%B0%7C%5E%2C%EB%15%DB%1F%3C%9E%B7%80%91%3B%DBc%AD%3Dma%BA%8B%3EV%AB%DBt.%5B%1E%01%BB%0F%AB%D5%9F%CF%AA%D5%DD%E7%E4%7F%0Bx%A3%FC%06%A9%23%0A%D6%C2%A1_2%00%00%00%09pHYs%00%00%0B%13%00%00%0B%13%01%00%9A%9C%18%00%00%00%B5IDAT(%15%A5%91%3D%0E%02!%10%85ac%E1%05%D6%CE%D6%C6%CE%D2%E8%ED%CD%DE%C0%C6%D6N.%E0V%F8%3D%9Ca%891XH%C2%BE%D9y%3F%90!%E6%9C%C3%BFk%E5%011%C6-%F5%C8N%04%DF%BD%FF%89%DFt%83DN%60%3E%F3%AB%A0%DE%1A%5Dg%BE%10Q%97%1B%40%9C%A8o%10%8F%5E%828%B4%1B%60%87%F6%02%26%85%1Ch%1E%C1%2B%5Bk%FF%86%EE%B7j%09%9A%DA%9B%ACe%A3%F9%EC%DA!9%B4%D5%A6%81%86%86%98%CC%3C%5B%40%FA%81%B3%E9%CB%23%94%C16Azo%05%D4%E1%C1%95a%3B%8A'%A0%E8%CC%17%22%85%1D%BA%00%A2%FA%DC%0A%94%D1%D1%8D%8B%3A%84%17B%C7%60%1A%25Z%FC%8D%00%00%00%00IEND%AEB%60%82\"),\n" +
  "        url(\"data:image/png,%89PNG%0D%0A%1A%0A%00%00%00%0DIHDR%00%00%00%05%00%00%007%08%06%00%00%00%C4%DD%80C%00%00%03%1EiCCPICC%20Profile%00%00x%01%85T%DFk%D3P%14%FE%DAe%9D%B0%E1%8B%3Ag%11%09%3Eh%91ndStC%9C%B6kW%BA%CDZ%EA6%B7!H%9B%A6m%5C%9A%C6%24%ED~%B0%07%D9%8Bo%3A%C5w%F1%07%3E%F9%07%0C%D9%83o%7B%92%0D%C6%14a%F8%AC%88%22L%F6%22%B3%9E%9B4M'S%03%B9%F7%BB%DF%F9%EE9'%E7%E4%5E%A0%F9qZ%D3%14%2F%0F%14USO%C5%C2%FC%C4%E4%14%DF%F2%01%5E%1CC%2B%FChM%8B%86%16J%26G%40%0F%D3%B2y%EF%B3%F3%0E%1E%C6lt%EEo%DF%AB%FEc%D5%9A%95%0C%11%F0%1C%20%BE%945%C4%22%E1Y%A0i%5C%D4t%13%E0%D6%89%EF%9D15%C2%CDLsX%A7%04%09%1Fg8oc%81%E1%8C%8D%23%96f45%40%9A%09%C2%07%C5B%3AK%B8%408%98i%E0%F3%0D%D8%CE%81%14%E4'%26%A9%92.%8B%3C%ABER%2F%E5dE%B2%0C%F6%F0%1Fs%83%F2_%B0%A8%94%E9%9B%AD%E7%10%8Dm%9A%19N%D1%7C%8A%DE%1F9%7Dp%8C%E6%00%D5%C1%3F_%18%BDA%B8%9DpX6%E3%A35~B%CD%24%AE%11%26%BD%E7%EEti%98%EDe%9A%97Y)%12%25%1C%24%BCbT%AE3li%E6%0B%03%89%9A%E6%D3%ED%F4P%92%B0%9F4%BF43Y%F3%E3%EDP%95%04%EB1%C5%F5%F6KF%F4%BA%BD%D7%DB%91%93%07%E35%3E%A7)%D6%7F%40%FE%BD%F7%F5r%8A%E5y%92%F0%EB%B4%1E%8D%D5%F4%5B%92%3AV%DB%DB%E4%CD%A6%23%C3%C4wQ%3F%03HB%82%8E%1Cd(%E0%91B%0Ca%9Ac%C4%AA%F8L%16%19%22J%A4%D2itTy%B28%D6%3B(%93%96%ED%1CGx%C9_%0E%B8%5E%16%F5%5B%B2%B8%F6%E0%FB%9E%DD%25%D7%8E%BC%15%85%C5%B7%A3%D8Q%ED%B5%81%E9%BA%B2%13%9A%1B%7Fua%A5%A3n%E17%B9%E5%9B%1Bm%AB%0B%08Q%FE%8A%E5%B1H%5Ee%CAO%82Q%D7u6%E6%90S%97%FCu%0B%CF2%94%EE%25v%12X%0C%BA%AC%F0%5E%F8*l%0AO%85%17%C2%97%BF%D4%C8%CE%DE%AD%11%CB%80q%2C%3E%AB%9ES%CD%C6%EC%25%D2L%D2%EBd%B8%BF%8A%F5B%C6%18%F9%901CZ%9D%BE%24M%9C%8A9%F2%DAP%0B'%06w%82%EB%E6%E2%5C%2F%D7%07%9E%BB%CC%5D%E1%FA%B9%08%AD.r%23%8E%C2%17%F5E%7C!%F0%BE3%BE%3E_%B7o%88a%A7%DB%BE%D3d%EB%A31Z%EB%BB%D3%91%BA%A2%B1z%94%8F%DB'%F6%3D%8E%AA%13%19%B2%B1%BE%B1~V%08%2B%B4%A2cjJ%B3tO%00%03%25mN%97%F3%05%93%EF%11%84%0B%7C%88%AE-%89%8F%ABbW%90O%2B%0Ao%99%0C%5E%97%0CI%AFH%D9.%B0%3B%8F%ED%03%B6S%D6%5D%E6i_s9%F3*p%E9%1B%FD%C3%EB.7U%06%5E%19%C0%D1s.%17%A03u%E4%09%B0%7C%5E%2C%EB%15%DB%1F%3C%9E%B7%80%91%3B%DBc%AD%3Dma%BA%8B%3EV%AB%DBt.%5B%1E%01%BB%0F%AB%D5%9F%CF%AA%D5%DD%E7%E4%7F%0Bx%A3%FC%06%A9%23%0A%D6%C2%A1_2%00%00%00%09pHYs%00%00%0B%13%00%00%0B%13%01%00%9A%9C%18%00%00%00%3AIDAT8%11c%FC%FF%FF%7F%18%03%1A%60%01%F2%3F%A0%891%80%04%FF%11-%F8%17%9BJ%E2%05%B1ZD%81v%26t%E7%80%F8%A3%82h%A12%1A%20%A3%01%02%0F%01%BA%25%06%00%19%C0%0D%AEF%D5%3ES%00%00%00%00IEND%AEB%60%82\");\n" +
  "    background-repeat: no-repeat, repeat-x;\n" +
  "    background-position: center center, top left;\n" +
  "    color: transparent;\n" +
  "\n" +
  "    border: 1px solid black;\n" +
  "    -moz-border-radius: 2px;\n" +
  "    -webkit-border-radius: 2px;\n" +
  "    border-radius: 2px;\n" +
  "    \n" +
  "    cursor: pointer;\n" +
  "    pointer-events: auto;\n" +
  "}\n" +
  "\n" +
  ".ace_dark .ace_fold {\n" +
  "}\n" +
  "\n" +
  ".ace_fold:hover{\n" +
  "    background-image: \n" +
  "        url(\"data:image/png,%89PNG%0D%0A%1A%0A%00%00%00%0DIHDR%00%00%00%11%00%00%00%09%08%06%00%00%00%D4%E8%C7%0C%00%00%03%1EiCCPICC%20Profile%00%00x%01%85T%DFk%D3P%14%FE%DAe%9D%B0%E1%8B%3Ag%11%09%3Eh%91ndStC%9C%B6kW%BA%CDZ%EA6%B7!H%9B%A6m%5C%9A%C6%24%ED~%B0%07%D9%8Bo%3A%C5w%F1%07%3E%F9%07%0C%D9%83o%7B%92%0D%C6%14a%F8%AC%88%22L%F6%22%B3%9E%9B4M'S%03%B9%F7%BB%DF%F9%EE9'%E7%E4%5E%A0%F9qZ%D3%14%2F%0F%14USO%C5%C2%FC%C4%E4%14%DF%F2%01%5E%1CC%2B%FChM%8B%86%16J%26G%40%0F%D3%B2y%EF%B3%F3%0E%1E%C6lt%EEo%DF%AB%FEc%D5%9A%95%0C%11%F0%1C%20%BE%945%C4%22%E1Y%A0i%5C%D4t%13%E0%D6%89%EF%9D15%C2%CDLsX%A7%04%09%1Fg8oc%81%E1%8C%8D%23%96f45%40%9A%09%C2%07%C5B%3AK%B8%408%98i%E0%F3%0D%D8%CE%81%14%E4'%26%A9%92.%8B%3C%ABER%2F%E5dE%B2%0C%F6%F0%1Fs%83%F2_%B0%A8%94%E9%9B%AD%E7%10%8Dm%9A%19N%D1%7C%8A%DE%1F9%7Dp%8C%E6%00%D5%C1%3F_%18%BDA%B8%9DpX6%E3%A35~B%CD%24%AE%11%26%BD%E7%EEti%98%EDe%9A%97Y)%12%25%1C%24%BCbT%AE3li%E6%0B%03%89%9A%E6%D3%ED%F4P%92%B0%9F4%BF43Y%F3%E3%EDP%95%04%EB1%C5%F5%F6KF%F4%BA%BD%D7%DB%91%93%07%E35%3E%A7)%D6%7F%40%FE%BD%F7%F5r%8A%E5y%92%F0%EB%B4%1E%8D%D5%F4%5B%92%3AV%DB%DB%E4%CD%A6%23%C3%C4wQ%3F%03HB%82%8E%1Cd(%E0%91B%0Ca%9Ac%C4%AA%F8L%16%19%22J%A4%D2itTy%B28%D6%3B(%93%96%ED%1CGx%C9_%0E%B8%5E%16%F5%5B%B2%B8%F6%E0%FB%9E%DD%25%D7%8E%BC%15%85%C5%B7%A3%D8Q%ED%B5%81%E9%BA%B2%13%9A%1B%7Fua%A5%A3n%E17%B9%E5%9B%1Bm%AB%0B%08Q%FE%8A%E5%B1H%5Ee%CAO%82Q%D7u6%E6%90S%97%FCu%0B%CF2%94%EE%25v%12X%0C%BA%AC%F0%5E%F8*l%0AO%85%17%C2%97%BF%D4%C8%CE%DE%AD%11%CB%80q%2C%3E%AB%9ES%CD%C6%EC%25%D2L%D2%EBd%B8%BF%8A%F5B%C6%18%F9%901CZ%9D%BE%24M%9C%8A9%F2%DAP%0B'%06w%82%EB%E6%E2%5C%2F%D7%07%9E%BB%CC%5D%E1%FA%B9%08%AD.r%23%8E%C2%17%F5E%7C!%F0%BE3%BE%3E_%B7o%88a%A7%DB%BE%D3d%EB%A31Z%EB%BB%D3%91%BA%A2%B1z%94%8F%DB'%F6%3D%8E%AA%13%19%B2%B1%BE%B1~V%08%2B%B4%A2cjJ%B3tO%00%03%25mN%97%F3%05%93%EF%11%84%0B%7C%88%AE-%89%8F%ABbW%90O%2B%0Ao%99%0C%5E%97%0CI%AFH%D9.%B0%3B%8F%ED%03%B6S%D6%5D%E6i_s9%F3*p%E9%1B%FD%C3%EB.7U%06%5E%19%C0%D1s.%17%A03u%E4%09%B0%7C%5E%2C%EB%15%DB%1F%3C%9E%B7%80%91%3B%DBc%AD%3Dma%BA%8B%3EV%AB%DBt.%5B%1E%01%BB%0F%AB%D5%9F%CF%AA%D5%DD%E7%E4%7F%0Bx%A3%FC%06%A9%23%0A%D6%C2%A1_2%00%00%00%09pHYs%00%00%0B%13%00%00%0B%13%01%00%9A%9C%18%00%00%00%B5IDAT(%15%A5%91%3D%0E%02!%10%85ac%E1%05%D6%CE%D6%C6%CE%D2%E8%ED%CD%DE%C0%C6%D6N.%E0V%F8%3D%9Ca%891XH%C2%BE%D9y%3F%90!%E6%9C%C3%BFk%E5%011%C6-%F5%C8N%04%DF%BD%FF%89%DFt%83DN%60%3E%F3%AB%A0%DE%1A%5Dg%BE%10Q%97%1B%40%9C%A8o%10%8F%5E%828%B4%1B%60%87%F6%02%26%85%1Ch%1E%C1%2B%5Bk%FF%86%EE%B7j%09%9A%DA%9B%ACe%A3%F9%EC%DA!9%B4%D5%A6%81%86%86%98%CC%3C%5B%40%FA%81%B3%E9%CB%23%94%C16Azo%05%D4%E1%C1%95a%3B%8A'%A0%E8%CC%17%22%85%1D%BA%00%A2%FA%DC%0A%94%D1%D1%8D%8B%3A%84%17B%C7%60%1A%25Z%FC%8D%00%00%00%00IEND%AEB%60%82\"),\n" +
  "        url(\"data:image/png,%89PNG%0D%0A%1A%0A%00%00%00%0DIHDR%00%00%00%05%00%00%007%08%06%00%00%00%C4%DD%80C%00%00%03%1EiCCPICC%20Profile%00%00x%01%85T%DFk%D3P%14%FE%DAe%9D%B0%E1%8B%3Ag%11%09%3Eh%91ndStC%9C%B6kW%BA%CDZ%EA6%B7!H%9B%A6m%5C%9A%C6%24%ED~%B0%07%D9%8Bo%3A%C5w%F1%07%3E%F9%07%0C%D9%83o%7B%92%0D%C6%14a%F8%AC%88%22L%F6%22%B3%9E%9B4M'S%03%B9%F7%BB%DF%F9%EE9'%E7%E4%5E%A0%F9qZ%D3%14%2F%0F%14USO%C5%C2%FC%C4%E4%14%DF%F2%01%5E%1CC%2B%FChM%8B%86%16J%26G%40%0F%D3%B2y%EF%B3%F3%0E%1E%C6lt%EEo%DF%AB%FEc%D5%9A%95%0C%11%F0%1C%20%BE%945%C4%22%E1Y%A0i%5C%D4t%13%E0%D6%89%EF%9D15%C2%CDLsX%A7%04%09%1Fg8oc%81%E1%8C%8D%23%96f45%40%9A%09%C2%07%C5B%3AK%B8%408%98i%E0%F3%0D%D8%CE%81%14%E4'%26%A9%92.%8B%3C%ABER%2F%E5dE%B2%0C%F6%F0%1Fs%83%F2_%B0%A8%94%E9%9B%AD%E7%10%8Dm%9A%19N%D1%7C%8A%DE%1F9%7Dp%8C%E6%00%D5%C1%3F_%18%BDA%B8%9DpX6%E3%A35~B%CD%24%AE%11%26%BD%E7%EEti%98%EDe%9A%97Y)%12%25%1C%24%BCbT%AE3li%E6%0B%03%89%9A%E6%D3%ED%F4P%92%B0%9F4%BF43Y%F3%E3%EDP%95%04%EB1%C5%F5%F6KF%F4%BA%BD%D7%DB%91%93%07%E35%3E%A7)%D6%7F%40%FE%BD%F7%F5r%8A%E5y%92%F0%EB%B4%1E%8D%D5%F4%5B%92%3AV%DB%DB%E4%CD%A6%23%C3%C4wQ%3F%03HB%82%8E%1Cd(%E0%91B%0Ca%9Ac%C4%AA%F8L%16%19%22J%A4%D2itTy%B28%D6%3B(%93%96%ED%1CGx%C9_%0E%B8%5E%16%F5%5B%B2%B8%F6%E0%FB%9E%DD%25%D7%8E%BC%15%85%C5%B7%A3%D8Q%ED%B5%81%E9%BA%B2%13%9A%1B%7Fua%A5%A3n%E17%B9%E5%9B%1Bm%AB%0B%08Q%FE%8A%E5%B1H%5Ee%CAO%82Q%D7u6%E6%90S%97%FCu%0B%CF2%94%EE%25v%12X%0C%BA%AC%F0%5E%F8*l%0AO%85%17%C2%97%BF%D4%C8%CE%DE%AD%11%CB%80q%2C%3E%AB%9ES%CD%C6%EC%25%D2L%D2%EBd%B8%BF%8A%F5B%C6%18%F9%901CZ%9D%BE%24M%9C%8A9%F2%DAP%0B'%06w%82%EB%E6%E2%5C%2F%D7%07%9E%BB%CC%5D%E1%FA%B9%08%AD.r%23%8E%C2%17%F5E%7C!%F0%BE3%BE%3E_%B7o%88a%A7%DB%BE%D3d%EB%A31Z%EB%BB%D3%91%BA%A2%B1z%94%8F%DB'%F6%3D%8E%AA%13%19%B2%B1%BE%B1~V%08%2B%B4%A2cjJ%B3tO%00%03%25mN%97%F3%05%93%EF%11%84%0B%7C%88%AE-%89%8F%ABbW%90O%2B%0Ao%99%0C%5E%97%0CI%AFH%D9.%B0%3B%8F%ED%03%B6S%D6%5D%E6i_s9%F3*p%E9%1B%FD%C3%EB.7U%06%5E%19%C0%D1s.%17%A03u%E4%09%B0%7C%5E%2C%EB%15%DB%1F%3C%9E%B7%80%91%3B%DBc%AD%3Dma%BA%8B%3EV%AB%DBt.%5B%1E%01%BB%0F%AB%D5%9F%CF%AA%D5%DD%E7%E4%7F%0Bx%A3%FC%06%A9%23%0A%D6%C2%A1_2%00%00%00%09pHYs%00%00%0B%13%00%00%0B%13%01%00%9A%9C%18%00%00%003IDAT8%11c%FC%FF%FF%7F%3E%03%1A%60%01%F2%3F%A3%891%80%04%FFQ%26%F8w%C0%B43%A1%DB%0C%E2%8F%0A%A2%85%CAh%80%8C%06%08%3C%04%E8%96%18%00%A3S%0D%CD%CF%D8%C1%9D%00%00%00%00IEND%AEB%60%82\");\n" +
  "    background-repeat: no-repeat, repeat-x;\n" +
  "    background-position: center center, top left;\n" +
  "}\n" +
  "\n" +
  ".ace_dragging .ace_content {\n" +
  "    cursor: move;\n" +
  "}\n" +
  "\n" +
  ".ace_folding-enabled > .ace_gutter-cell {\n" +
  "    padding-right: 13px;\n" +
  "}\n" +
  "\n" +
  ".ace_fold-widget {\n" +
  "    box-sizing: border-box;\n" +
  "    -moz-box-sizing: border-box;\n" +
  "    -webkit-box-sizing: border-box;\n" +
  "\n" +
  "    margin: 0 -12px 1px 1px;\n" +
  "    display: inline-block;\n" +
  "    height: 14px;\n" +
  "    width: 11px;\n" +
  "    vertical-align: text-bottom;\n" +
  "    \n" +
  "    background-image: url(\"data:image/png,%89PNG%0D%0A%1A%0A%00%00%00%0DIHDR%00%00%00%05%00%00%00%05%08%06%00%00%00%8Do%26%E5%00%00%004IDATx%DAe%8A%B1%0D%000%0C%C2%F2%2CK%96%BC%D0%8F9%81%88H%E9%D0%0E%96%C0%10%92%3E%02%80%5E%82%E4%A9*-%EEsw%C8%CC%11%EE%96w%D8%DC%E9*Eh%0C%151(%00%00%00%00IEND%AEB%60%82\");\n" +
  "    background-repeat: no-repeat;\n" +
  "    background-position: center 5px;\n" +
  "\n" +
  "    border-radius: 3px;\n" +
  "}\n" +
  "\n" +
  ".ace_fold-widget.end {\n" +
  "    background-image: url(\"data:image/png,%89PNG%0D%0A%1A%0A%00%00%00%0DIHDR%00%00%00%05%00%00%00%05%08%06%00%00%00%8Do%26%E5%00%00%004IDATx%DAm%C7%C1%09%000%08C%D1%8C%ECE%C8E(%8E%EC%02)%1EZJ%F1%C1'%04%07I%E1%E5%EE%CAL%F5%A2%99%99%22%E2%D6%1FU%B5%FE0%D9x%A7%26Wz5%0E%D5%00%00%00%00IEND%AEB%60%82\");\n" +
  "}\n" +
  "\n" +
  ".ace_fold-widget.closed {\n" +
  "    background-image: url(\"data:image/png,%89PNG%0D%0A%1A%0A%00%00%00%0DIHDR%00%00%00%03%00%00%00%06%08%06%00%00%00%06%E5%24%0C%00%00%009IDATx%DA5%CA%C1%09%000%08%03%C0%AC*(%3E%04%C1%0D%BA%B1%23%A4Uh%E0%20%81%C0%CC%F8%82%81%AA%A2%AArGfr%88%08%11%11%1C%DD%7D%E0%EE%5B%F6%F6%CB%B8%05Q%2F%E9tai%D9%00%00%00%00IEND%AEB%60%82\");\n" +
  "}\n" +
  "\n" +
  ".ace_fold-widget:hover {\n" +
  "    border: 1px solid rgba(0, 0, 0, 0.3);\n" +
  "    background-color: rgba(255, 255, 255, 0.2);\n" +
  "    -moz-box-shadow:inset 0 1px 1px rgba(255, 255, 255, 0.7);\n" +
  "    -moz-box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\n" +
  "    -webkit-box-shadow:inset 0 1px 1px rgba(255, 255, 255, 0.7);\n" +
  "    -webkit-box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\n" +
  "    box-shadow:inset 0 1px 1px rgba(255, 255, 255, 0.7);\n" +
  "    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\n" +
  "    background-position: center 4px;\n" +
  "}\n" +
  "\n" +
  ".ace_fold-widget:active {\n" +
  "    border: 1px solid rgba(0, 0, 0, 0.4);\n" +
  "    background-color: rgba(0, 0, 0, 0.05);\n" +
  "    -moz-box-shadow:inset 0 1px 1px rgba(255, 255, 255);\n" +
  "    -moz-box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\n" +
  "    -webkit-box-shadow:inset 0 1px 1px rgba(255, 255, 255);\n" +
  "    -webkit-box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\n" +
  "    box-shadow:inset 0 1px 1px rgba(255, 255, 255);\n" +
  "    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\n" +
  "}\n" +
  "\n" +
  ".ace_fold-widget.invalid {\n" +
  "    background-color: #FFB4B4;\n" +
  "    border-color: #DE5555;\n" +
  "}\n" +
  "");

define('ace/worker/worker', ['require', 'exports', 'module' ], function(require, exports, module) {
"no use strict";

var console = {
    log: function(msg) {
        postMessage({type: "log", data: msg});
    }
};
var window = {
    console: console
};

var normalizeModule = function(parentId, moduleName) {
    // normalize plugin requires
    if (moduleName.indexOf("!") !== -1) {
        var chunks = moduleName.split("!");
        return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
    }
    // normalize relative requires
    if (moduleName.charAt(0) == ".") {
        var base = parentId.split("/").slice(0, -1).join("/");
        var moduleName = base + "/" + moduleName;
        
        while(moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            var moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
        }
    }
    
    return moduleName;
};

var require = function(parentId, id) {
    var id = normalizeModule(parentId, id);
    
    var module = require.modules[id];
    if (module) {
        if (!module.initialized) {
            module.exports = module.factory().exports;
            module.initialized = true;
        }
        return module.exports;
    }
    
    var chunks = id.split("/");
    chunks[0] = require.tlns[chunks[0]] || chunks[0];
    var path = chunks.join("/") + ".js";
    
    require.id = id;
    importScripts(path);
    return require(parentId, id);    
};

require.modules = {};
require.tlns = {};

var define = function(id, deps, factory) {
    if (arguments.length == 2) {
        factory = deps;
    } else if (arguments.length == 1) {
        factory = id;
        id = require.id;
    }

    if (id.indexOf("text!") === 0) 
        return;
    
    var req = function(deps, factory) {
        return require(id, deps, factory);
    };

    require.modules[id] = {
        factory: function() {
            var module = {
                exports: {}
            };
            var returnExports = factory(req, module.exports, module);
            if (returnExports)
                module.exports = returnExports;
            return module;
        }
    };
};

function initBaseUrls(topLevelNamespaces) {
    require.tlns = topLevelNamespaces;
}

function initSender() {

    var EventEmitter = require(null, "ace/lib/event_emitter").EventEmitter;
    var oop = require(null, "ace/lib/oop");
    
    var Sender = function() {};
    
    (function() {
        
        oop.implement(this, EventEmitter);
                
        this.callback = function(data, callbackId) {
            postMessage({
                type: "call",
                id: callbackId,
                data: data
            });
        };
    
        this.emit = function(name, data) {
            postMessage({
                type: "event",
                name: name,
                data: data
            });
        };
        
    }).call(Sender.prototype);
    
    return new Sender();
}

var main;
var sender;

onmessage = function(e) {
    var msg = e.data;
    if (msg.command) {
        main[msg.command].apply(main, msg.args);
    }
    else if (msg.init) {        
        initBaseUrls(msg.tlns);
        require(null, "ace/lib/fixoldbrowsers");
        sender = initSender();
        var clazz = require(null, msg.module)[msg.classname];
        main = new clazz(sender);
    } 
    else if (msg.event && sender) {
        sender._emit(msg.event, msg.data);
    }
};
});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/worker/worker_client', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/event_emitter'], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var EventEmitter = require("../lib/event_emitter").EventEmitter;

var WorkerClient = function(topLevelNamespaces, packagedJs, mod, classname) {

    this.changeListener = this.changeListener.bind(this);

    if (module.packaged) {
        var base = this.$guessBasePath();
        this.$worker = new Worker(base + packagedJs);
    }
    else {
        var workerUrl = this.$normalizePath(require.nameToUrl("ace/worker/worker", null, "_"));
        this.$worker = new Worker(workerUrl);

        var tlns = {};
        for (var i=0; i<topLevelNamespaces.length; i++) {
            var ns = topLevelNamespaces[i];
            var path = this.$normalizePath(require.nameToUrl(ns, null, "_").replace(/.js$/, ""));

            tlns[ns] = path;
        }
    }

    this.$worker.postMessage({
        init : true,
        tlns: tlns,
        module: mod,
        classname: classname
    });

    this.callbackId = 1;
    this.callbacks = {};

    var _self = this;
    this.$worker.onerror = function(e) {
        window.console && console.log && console.log(e);
        throw e;
    };
    this.$worker.onmessage = function(e) {
        var msg = e.data;
        switch(msg.type) {
            case "log":
                window.console && console.log && console.log(msg.data);
                break;

            case "event":
                _self._emit(msg.name, {data: msg.data});
                break;

            case "call":
                var callback = _self.callbacks[msg.id];
                if (callback) {
                    callback(msg.data);
                    delete _self.callbacks[msg.id];
                }
                break;
        }
    };
};

(function(){

    oop.implement(this, EventEmitter);

    this.$normalizePath = function(path) {
        path = path.replace(/^[a-z]+:\/\/[^\/]+/, ""); // Remove domain name and rebuild it
        path = location.protocol + "//" + location.host
            // paths starting with a slash are relative to the root (host)
            + (path.charAt(0) == "/" ? "" : location.pathname.replace(/\/[^\/]*$/, ""))
            + "/" + path.replace(/^[\/]+/, "");
        return path;
    };

    this.$guessBasePath = function() {
        if (define.aceBaseUrl)
            return define.aceBaseUrl;

        var scripts = document.getElementsByTagName("script");
        for (var i=0; i<scripts.length; i++) {
            var script = scripts[i];

            var base = script.getAttribute("data-ace-base");
            if (base)
                return base.replace(/\/*$/, "/");

            var src = script.src || script.getAttribute("src");
            if (!src) {
                continue;
            }
            var m = src.match(/^(?:(.*\/)ace\.js|(.*\/)ace(-uncompressed)?(-noconflict)?\.js)(?:\?|$)/);
            if (m)
                return m[1] || m[2];
        }
        return "";
    };

    this.terminate = function() {
        this._emit("terminate", {});
        this.$worker.terminate();
        this.$worker = null;
        this.$doc.removeEventListener("change", this.changeListener);
        this.$doc = null;
    };

    this.send = function(cmd, args) {
        this.$worker.postMessage({command: cmd, args: args});
    };

    this.call = function(cmd, args, callback) {
        if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
        }
        this.send(cmd, args);
    };

    this.emit = function(event, data) {
        try {
            // firefox refuses to clone objects which have function properties
            // TODO: cleanup event
            this.$worker.postMessage({event: event, data: {data: data.data}});
        }
        catch(ex) {}
    };

    this.attachToDocument = function(doc) {
        if(this.$doc)
            this.terminate();

        this.$doc = doc;
        this.call("setValue", [doc.getValue()]);
        doc.on("change", this.changeListener);
    };

    this.changeListener = function(e) {
        e.range = {
            start: e.data.range.start,
            end: e.data.range.end
        };
        this.emit("change", e);
    };

}).call(WorkerClient.prototype);

exports.WorkerClient = WorkerClient;

});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Skywriter.
 *
 * The Initial Developer of the Original Code is
 * Mozilla.
 * Portions created by the Initial Developer are Copyright (C) 2009
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Fabian Jakobs <fabian AT ajax DOT org>
 *   Julian Viereck (julian.viereck@gmail.com)
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/keyboard/hash_handler', ['require', 'exports', 'module' , 'ace/lib/keys'], function(require, exports, module) {
"use strict";

var keyUtil  = require("../lib/keys");

function HashHandler(config) {
    this.setConfig(config);
}

(function() {
    function splitSafe(s, separator, limit, bLowerCase) {
        return (bLowerCase && s.toLowerCase() || s)
            .replace(/(?:^\s+|\n|\s+$)/g, "")
            .split(new RegExp("[\\s ]*" + separator + "[\\s ]*", "g"), limit || 999);
    }

    function parseKeys(keys, val, ret) {
        var key,
            hashId = 0,
            parts  = splitSafe(keys, "\\-", null, true),
            i      = 0,
            l      = parts.length;

        for (; i < l; ++i) {
            if (keyUtil.KEY_MODS[parts[i]])
                hashId = hashId | keyUtil.KEY_MODS[parts[i]];
            else
                key = parts[i] || "-"; //when empty, the splitSafe removed a '-'
        }

        (ret[hashId] || (ret[hashId] = {}))[key] = val;
        return ret;
    }

    function objectReverse(obj, keySplit) {
        var i, j, l, key,
            ret = {};
        for (i in obj) {
            key = obj[i];
            if (keySplit && typeof key == "string") {
                key = key.split(keySplit);
                for (j = 0, l = key.length; j < l; ++j)
                    parseKeys.call(this, key[j], i, ret);
            }
            else {
                parseKeys.call(this, key, i, ret);
            }
        }
        return ret;
    }

    this.setConfig = function(config) {
        this.$config = config;
        if (typeof this.$config.reverse == "undefined")
            this.$config.reverse = objectReverse.call(this, this.$config, "|");
    };

    /**
     * This function is called by keyBinding.
     */
    this.handleKeyboard = function(data, hashId, textOrKey, keyCode) {
        // Figure out if a commandKey was pressed or just some text was insert.
        if (hashId != 0 || keyCode != 0) {
            return {
                command: (this.$config.reverse[hashId] || {})[textOrKey]
            }
        } else {
            return {
                command: "inserttext",
                args: {
                    text: textOrKey
                }
            }
        }
    }
}).call(HashHandler.prototype)

exports.HashHandler = HashHandler;
});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Skywriter.
 *
 * The Initial Developer of the Original Code is
 * Mozilla.
 * Portions created by the Initial Developer are Copyright (C) 2009
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Julian Viereck (julian.viereck@gmail.com)
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/keyboard/state_handler', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

// If you're developing a new keymapping and want to get an idea what's going
// on, then enable debugging.
var DEBUG = false;

function StateHandler(keymapping) {
    this.keymapping = this.$buildKeymappingRegex(keymapping);
}

StateHandler.prototype = {
    /**
     * Build the RegExp from the keymapping as RegExp can't stored directly
     * in the metadata JSON and as the RegExp used to match the keys/buffer
     * need to be adapted.
     */
    $buildKeymappingRegex: function(keymapping) {
        for (var state in keymapping) {
            this.$buildBindingsRegex(keymapping[state]);
        }
        return keymapping;
    },

    $buildBindingsRegex: function(bindings) {
        // Escape a given Regex string.
        bindings.forEach(function(binding) {
            if (binding.key) {
                binding.key = new RegExp('^' + binding.key + '$');
            } else if (Array.isArray(binding.regex)) {
                if (!('key' in binding))
                  binding.key = new RegExp('^' + binding.regex[1] + '$');
                binding.regex = new RegExp(binding.regex.join('') + '$');
            } else if (binding.regex) {
                binding.regex = new RegExp(binding.regex + '$');
            }
        });
    },

    $composeBuffer: function(data, hashId, key, e) {
        // Initialize the data object.
        if (data.state == null || data.buffer == null) {
            data.state = "start";
            data.buffer = "";
        }

        var keyArray = [];
        if (hashId & 1) keyArray.push("ctrl");
        if (hashId & 8) keyArray.push("command");
        if (hashId & 2) keyArray.push("option");
        if (hashId & 4) keyArray.push("shift");
        if (key)        keyArray.push(key);

        var symbolicName = keyArray.join("-");
        var bufferToUse = data.buffer + symbolicName;

        // Don't add the symbolic name to the key buffer if the alt_ key is
        // part of the symbolic name. If it starts with alt_, this means
        // that the user hit an alt keycombo and there will be a single,
        // new character detected after this event, which then will be
        // added to the buffer (e.g. alt_j will result in ∆).
        //
        // We test for 2 and not for & 2 as we only want to exclude the case where
        // the option key is pressed alone.
        if (hashId != 2) {
            data.buffer = bufferToUse;
        }

        var bufferObj = {
            bufferToUse: bufferToUse,
            symbolicName: symbolicName,
        };

        if (e) {
            bufferObj.keyIdentifier = e.keyIdentifier
        }

        return bufferObj;
    },

    $find: function(data, buffer, symbolicName, hashId, key, keyIdentifier) {
        // Holds the command to execute and the args if a command matched.
        var result = {};

        // Loop over all the bindings of the keymap until a match is found.
        this.keymapping[data.state].some(function(binding) {
            var match;

            // Check if the key matches.
            if (binding.key && !binding.key.test(symbolicName)) {
                return false;
            }

            // Check if the regex matches.
            if (binding.regex && !(match = binding.regex.exec(buffer))) {
                return false;
            }

            // Check if the match function matches.
            if (binding.match && !binding.match(buffer, hashId, key, symbolicName, keyIdentifier)) {
                return false;
            }

            // Check for disallowed matches.
            if (binding.disallowMatches) {
                for (var i = 0; i < binding.disallowMatches.length; i++) {
                    if (!!match[binding.disallowMatches[i]]) {
                        return false;
                    }
                }
            }

            // If there is a command to execute, then figure out the
            // command and the arguments.
            if (binding.exec) {
                result.command = binding.exec;

                // Build the arguments.
                if (binding.params) {
                    var value;
                    result.args = {};
                    binding.params.forEach(function(param) {
                        if (param.match != null && match != null) {
                            value = match[param.match] || param.defaultValue;
                        } else {
                            value = param.defaultValue;
                        }

                        if (param.type === 'number') {
                            value = parseInt(value);
                        }

                        result.args[param.name] = value;
                    });
                }
                data.buffer = "";
            }

            // Handle the 'then' property.
            if (binding.then) {
                data.state = binding.then;
                data.buffer = "";
            }

            // If no command is set, then execute the "null" fake command.
            if (result.command == null) {
                result.command = "null";
            }

            if (DEBUG) {
                console.log("KeyboardStateMapper#find", binding);
            }
            return true;
        });

        if (result.command) {
            return result;
        } else {
            data.buffer = "";
            return false;
        }
    },

    /**
     * This function is called by keyBinding.
     */
    handleKeyboard: function(data, hashId, key, keyCode, e) {
        // If we pressed any command key but no other key, then ignore the input.
        // Otherwise "shift-" is added to the buffer, and later on "shift-g"
        // which results in "shift-shift-g" which doesn't make sense.
        if (hashId != 0 && (key == "" || key == String.fromCharCode(0))) {
            return null;
        }

        // Compute the current value of the keyboard input buffer.
        var r = this.$composeBuffer(data, hashId, key, e);
        var buffer = r.bufferToUse;
        var symbolicName = r.symbolicName;
        var keyId = r.keyIdentifier;

        r = this.$find(data, buffer, symbolicName, hashId, key, keyId);
        if (DEBUG) {
            console.log("KeyboardStateMapper#match", buffer, symbolicName, r);
        }

        return r;
    }
}

/**
 * This is a useful matching function and therefore is defined here so that
 * users of KeyboardStateMapper can use it.
 *
 * @return boolean
 *          If no command key (Command|Option|Shift|Ctrl) is pressed, it
 *          returns true. If the only the Shift key is pressed + a character
 *          true is returned as well. Otherwise, false is returned.
 *          Summing up, the function returns true whenever the user typed
 *          a normal character on the keyboard and no shortcut.
 */
exports.matchCharacterOnly = function(buffer, hashId, key, symbolicName) {
    // If no command keys are pressed, then catch the input.
    if (hashId == 0) {
        return true;
    }
    // If only the shift key is pressed and a character key, then
    // catch that input as well.
    else if ((hashId == 4) && key.length == 1) {
        return true;
    }
    // Otherwise, we let the input got through.
    else {
        return false;
    }
};

exports.StateHandler = StateHandler;
});
/**
 * based on code from:
 * 
 * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
define('ace/lib/net', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

exports.get = function (url, callback) {
    var xhr = exports.createXhr();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function (evt) {
        //Do not explicitly handle errors, those should be
        //visible via console output in the browser.
        if (xhr.readyState === 4) {
            callback(xhr.responseText);
        }
    };
    xhr.send(null);
};

var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];

exports.createXhr = function() {
    //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
    var xhr, i, progId;
    if (typeof XMLHttpRequest !== "undefined") {
        return new XMLHttpRequest();
    } else {
        for (i = 0; i < 3; i++) {
            progId = progIds[i];
            try {
                xhr = new ActiveXObject(progId);
            } catch (e) {}

            if (xhr) {
                progIds = [progId];  // so faster next time
                break;
            }
        }
    }

    if (!xhr) {
        throw new Error("createXhr(): XMLHttpRequest not available");
    }

    return xhr;
};

exports.loadScript = function(path, callback) {
    var head = document.getElementsByTagName('head')[0];
    var s = document.createElement('script');

    s.src = path;
    head.appendChild(s);
    
    s.onload = callback;
};

});/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Zef Hemel <zef@c9.io>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
define('ace/placeholder', ['require', 'exports', 'module' , 'ace/range', 'ace/lib/event_emitter', 'ace/lib/oop'], function(require, exports, module) {
"use strict";

var Range = require('./range').Range;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var oop = require("./lib/oop");

var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
    var _self = this;
    this.length = length;
    this.session = session;
    this.doc = session.getDocument();
    this.mainClass = mainClass;
    this.othersClass = othersClass;
    this.$onUpdate = this.onUpdate.bind(this);
    this.doc.on("change", this.$onUpdate);
    this.$others = others;
    
    this.$onCursorChange = function() {
        setTimeout(function() {
            _self.onCursorChange();
        });
    };
    
    this.$pos = pos;
    // Used for reset
    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
    this.$undoStackDepth =  undoStack.length;
    this.setup();

    session.selection.on("changeCursor", this.$onCursorChange);
};

(function() {

    oop.implement(this, EventEmitter);

    this.setup = function() {
        var _self = this;
        var doc = this.doc;
        var session = this.session;
        var pos = this.$pos;

        this.pos = doc.createAnchor(pos.row, pos.column);
        this.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
        this.pos.on("change", function(event) {
            session.removeMarker(_self.markerId);
            _self.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column+_self.length), _self.mainClass, null, false);
        });
        this.others = [];
        this.$others.forEach(function(other) {
            var anchor = doc.createAnchor(other.row, other.column);
            _self.others.push(anchor);
        });
        session.setUndoSelect(false);
    };
    
    this.showOtherMarkers = function() {
        if(this.othersActive) return;
        var session = this.session;
        var _self = this;
        this.othersActive = true;
        this.others.forEach(function(anchor) {
            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
            anchor.on("change", function(event) {
                session.removeMarker(anchor.markerId);
                anchor.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column+_self.length), _self.othersClass, null, false);
            });
        });
    };
    
    this.hideOtherMarkers = function() {
        if(!this.othersActive) return;
        this.othersActive = false;
        for (var i = 0; i < this.others.length; i++) {
            this.session.removeMarker(this.others[i].markerId);
        }
    };

    this.onUpdate = function(event) {
        var delta = event.data;
        var range = delta.range;
        if(range.start.row !== range.end.row) return;
        if(range.start.row !== this.pos.row) return;
        if (this.$updating) return;
        this.$updating = true;
        var lengthDiff = delta.action === "insertText" ? range.end.column - range.start.column : range.start.column - range.end.column;
        
        if(range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1) {
            var distanceFromStart = range.start.column - this.pos.column;
            this.length += lengthDiff;
            if(!this.session.$fromUndo) {
                if(delta.action === "insertText") {
                    for (var i = this.others.length - 1; i >= 0; i--) {
                        var otherPos = this.others[i];
                        var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                        if(otherPos.row === range.start.row && range.start.column < otherPos.column)
                            newPos.column += lengthDiff;
                        this.doc.insert(newPos, delta.text);
                    }
                } else if(delta.action === "removeText") {
                    for (var i = this.others.length - 1; i >= 0; i--) {
                        var otherPos = this.others[i];
                        var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                        if(otherPos.row === range.start.row && range.start.column < otherPos.column)
                            newPos.column += lengthDiff;
                        this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                    }
                }
                // Special case: insert in beginning
                if(range.start.column === this.pos.column && delta.action === "insertText") {
                    setTimeout(function() {
                        this.pos.setPosition(this.pos.row, this.pos.column - lengthDiff);
                        for (var i = 0; i < this.others.length; i++) {
                            var other = this.others[i];
                            var newPos = {row: other.row, column: other.column - lengthDiff};
                            if(other.row === range.start.row && range.start.column < other.column)
                                newPos.column += lengthDiff;
                            other.setPosition(newPos.row, newPos.column);
                        }
                    }.bind(this), 0);
                }
                else if(range.start.column === this.pos.column && delta.action === "removeText") {
                    setTimeout(function() {
                        for (var i = 0; i < this.others.length; i++) {
                            var other = this.others[i];
                            if(other.row === range.start.row && range.start.column < other.column) {
                                other.setPosition(other.row, other.column - lengthDiff);
                            }
                        }
                    }.bind(this), 0);
                }
            }
            this.pos._emit("change", {value: this.pos});
            for (var i = 0; i < this.others.length; i++) {
                this.others[i]._emit("change", {value: this.others[i]});
            }
        }
        this.$updating = false;
    };
    
    this.onCursorChange = function(event) {
        if (this.$updating) return;
        var pos = this.session.selection.getCursor();
        if(pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
            this.showOtherMarkers();
            this._emit("cursorEnter", event);
        } else {
            this.hideOtherMarkers();
            this._emit("cursorLeave", event);
        }
    };
    
    this.detach = function() {
        this.session.removeMarker(this.markerId);
        this.hideOtherMarkers();
        this.doc.removeEventListener("change", this.$onUpdate);
        this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
        this.pos.detach();
        for (var i = 0; i < this.others.length; i++) {
            this.others[i].detach();
        }
        this.session.setUndoSelect(true);
    };
    
    this.cancel = function() {
        if(this.$undoStackDepth === -1)
            throw Error("Canceling placeholders only supported with undo manager attached to session.");
        var undoManager = this.session.getUndoManager();
        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
        for (var i = 0; i < undosRequired; i++) {
            undoManager.undo(true);
        }
    };
}).call(PlaceHolder.prototype);


exports.PlaceHolder = PlaceHolder;
});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/theme/textmate', ['require', 'exports', 'module' , 'ace/lib/dom'], function(require, exports, module) {
"use strict";

exports.isDark = false;
exports.cssClass = "ace-tm";
exports.cssText = ".ace-tm .ace_editor {\
  border: 2px solid rgb(159, 159, 159);\
}\
\
.ace-tm .ace_editor.ace_focus {\
  border: 2px solid #327fbd;\
}\
\
.ace-tm .ace_gutter {\
  background: #e8e8e8;\
  color: #333;\
}\
\
.ace-tm .ace_print_margin {\
  width: 1px;\
  background: #e8e8e8;\
}\
\
.ace-tm .ace_fold {\
    background-color: #6B72E6;\
}\
\
.ace-tm .ace_text-layer {\
  cursor: text;\
}\
\
.ace-tm .ace_cursor {\
  border-left: 2px solid black;\
}\
\
.ace-tm .ace_cursor.ace_overwrite {\
  border-left: 0px;\
  border-bottom: 1px solid black;\
}\
        \
.ace-tm .ace_line .ace_invisible {\
  color: rgb(191, 191, 191);\
}\
\
.ace-tm .ace_line .ace_storage,\
.ace-tm .ace_line .ace_keyword {\
  color: blue;\
}\
\
.ace-tm .ace_line .ace_constant.ace_buildin {\
  color: rgb(88, 72, 246);\
}\
\
.ace-tm .ace_line .ace_constant.ace_language {\
  color: rgb(88, 92, 246);\
}\
\
.ace-tm .ace_line .ace_constant.ace_library {\
  color: rgb(6, 150, 14);\
}\
\
.ace-tm .ace_line .ace_invalid {\
  background-color: rgb(153, 0, 0);\
  color: white;\
}\
\
.ace-tm .ace_line .ace_support.ace_function {\
  color: rgb(60, 76, 114);\
}\
\
.ace-tm .ace_line .ace_support.ace_constant {\
  color: rgb(6, 150, 14);\
}\
\
.ace-tm .ace_line .ace_support.ace_type,\
.ace-tm .ace_line .ace_support.ace_class {\
  color: rgb(109, 121, 222);\
}\
\
.ace-tm .ace_line .ace_keyword.ace_operator {\
  color: rgb(104, 118, 135);\
}\
\
.ace-tm .ace_line .ace_string {\
  color: rgb(3, 106, 7);\
}\
\
.ace-tm .ace_line .ace_comment {\
  color: rgb(76, 136, 107);\
}\
\
.ace-tm .ace_line .ace_comment.ace_doc {\
  color: rgb(0, 102, 255);\
}\
\
.ace-tm .ace_line .ace_comment.ace_doc.ace_tag {\
  color: rgb(128, 159, 191);\
}\
\
.ace-tm .ace_line .ace_constant.ace_numeric {\
  color: rgb(0, 0, 205);\
}\
\
.ace-tm .ace_line .ace_variable {\
  color: rgb(49, 132, 149);\
}\
\
.ace-tm .ace_line .ace_xml_pe {\
  color: rgb(104, 104, 91);\
}\
\
.ace-tm .ace_entity.ace_name.ace_function {\
  color: #0000A2;\
}\
\
.ace-tm .ace_markup.ace_markupine {\
    text-decoration:underline;\
}\
\
.ace-tm .ace_markup.ace_heading {\
  color: rgb(12, 7, 255);\
}\
\
.ace-tm .ace_markup.ace_list {\
  color:rgb(185, 6, 144);\
}\
\
.ace-tm .ace_marker-layer .ace_selection {\
  background: rgb(181, 213, 255);\
}\
\
.ace-tm .ace_marker-layer .ace_step {\
  background: rgb(252, 255, 0);\
}\
\
.ace-tm .ace_marker-layer .ace_stack {\
  background: rgb(164, 229, 101);\
}\
\
.ace-tm .ace_marker-layer .ace_bracket {\
  margin: -1px 0 0 -1px;\
  border: 1px solid rgb(192, 192, 192);\
}\
\
.ace-tm .ace_marker-layer .ace_active_line {\
  background: rgba(0, 0, 0, 0.07);\
}\
\
.ace-tm .ace_marker-layer .ace_selected_word {\
  background: rgb(250, 250, 255);\
  border: 1px solid rgb(200, 200, 250);\
}\
\
.ace-tm .ace_meta.ace_tag {\
  color:rgb(28, 2, 255);\
}\
\
.ace-tm .ace_string.ace_regex {\
  color: rgb(255, 0, 0)\
}";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass);
});
;
            (function() {
                window.require(["ace/ace"], function(a) {
                    if (!window.ace)
                        window.ace = {};
                    for (var key in a) if (a.hasOwnProperty(key))
                        ace[key] = a[key];
                });
            })();
        

(function () {
/**
 * Document object for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
define('core/document',['require','exports','module'],function(require, exports, module) {

var Document = function(node, docValue){
    this.$init();
    
    this.getNode = function(){
        return node;
    };
    
    this.setNode = function(newNode) {
        this.dispatchEvent("setnode", {node: newNode});
        return (node = newNode);
    };
    
    this.hasValue = function(){
        return this.getValue() !== undefined;
    };
    
    this.setValue = function(value){
        this.setProperty("value", value);
        docValue = value;
    };

    this.getValue = function(){
        return (this.hasEventListener("retrievevalue") 
            ? this.dispatchEvent("retrievevalue", {value: docValue})
            : docValue);
    };
};
Document.prototype = new apf.Class();

module.exports = Document;

});
/**
 * Ajax.org Code Editor (ACE)
 *
 * @copyright 2010, Ajax.org Services B.V.
 * @license LGPLv3 <http://www.gnu.org/licenses/lgpl-3.0.txt>
 * @author Fabian Jakobs <fabian AT ajax DOT org>
 */

define('debug/Breakpoint',['require','exports','module'],function(require, exports, module) {
"use strict";

var Breakpoint = module.exports = function(source, line, column, dbg) {
    this.source = source;
    this.line = line;
    this.column = column || 0;

    this.enabled = true;
    this.condition = "";
    this.ignoreCount = 0;
    
    if (dbg) {
        this.$dbg = dbg;
        this.state = "connected";
        this.$listen();
    }
    else
        this.state = "initialized";
};

(function() {

    this.attach = function(dbg, callback) {
        var self = this;

        if (this.state !== "initialized")
            throw new Error("Already attached");

        this.$dbg = dbg;
        this.state = "connecting";

        this.$listen();
        dbg.setbreakpoint("script", self.source, self.line, self.column, self.enabled, self.condition, self.ignoreCount, function(body) {
            self.state = "connected";
            self.$id = body.breakpoint;
            self.line = body.line;
            callback(self);
        });
    };

    this.$listen = function() {
        var self = this;
        this.$onbreak = function(e) {
            if (self.state !== "connected")
                return;

            // TODO: how will this ever work??
            //if (e.data.breakpoints.indexOf(self.$id) !== -1)
            //    self.$dbg.emit("break");
        };
        this.$dbg.on("break", this.$onbreak);
    };

    this.clear = function(callback) {
        if (this.state !== "connected")
            throw new Error("Not connected!");

        var self = this;
        this.$dbg.clearbreakpoint(this.$id, function() {
            this.$id = null;
            this.$dbg = null;
            this.state = "initialized";
            callback && callback(self);
        });
    };

    this.setEnabled = function(enabled) {
      this.enabled = enabled;
    };

    this.setCondition = function(condition) {
        this.condition = condition;
    };

    this.setIgnoreCount = function(ignoreCount) {
        this.ignoreCount = ignoreCount;
    };

    this.flush = function(callback) {
        if (this.state !== "connected")
            throw new Error("Not connected");

        this.$dbg.changeBreakpoint(this.$id, this.enabled, this.condition, this.ignoreCount, callback);
    };

    this.destroy = function() {
        dbg.removeListener("break", this.$onbreak);
    };

}).call(Breakpoint.prototype);

Breakpoint.fromJson = function(breakpoint, dbg) {
    if (breakpoint.type != "scriptName")
        throw new Error("unsupported breakpoint type: " + breakpoint.type);

    var bp = new Breakpoint(breakpoint.script_name, breakpoint.line, breakpoint.column, dbg);
    bp.condition = breakpoint.condition || "";
    bp.ignoreCount = breakpoint.ignoreCount || 0;
    bp.enabled = breakpoint.active;
    bp.$id = breakpoint.number;
    return bp;
};

});
/**
 * lib-v8debug - A V8 Debugger wrapper
 *
 * @copyright 2010, Ajax.org Services B.V.
 * @license LGPLv3 <http://www.gnu.org/licenses/lgpl-3.0.txt>
 * @author Fabian Jakobs <fabian AT ajax DOT org>
 * @author Mike de Boer <mike AT ajax DOT org>
 */

define('debug/util',['require','exports','module'],function(require, exports, module) {
"use strict";

exports.inherits = (function() {
    var tempCtor = function() {};
    return function(ctor, superCtor) {
        tempCtor.prototype = superCtor.prototype;
        ctor.super_ = superCtor.prototype;
        ctor.prototype = new tempCtor();
        ctor.prototype.constructor = ctor;
    }
}());

exports.mixin = function(obj, mixin) {
    for (var key in mixin)
        obj[key] = mixin[key];
};

exports.implement = function(proto, mixin) {
    exports.mixin(proto, mixin);
};

var EventEmitter = {};

EventEmitter._emit =
EventEmitter.emit =
EventEmitter._dispatchEvent = function(eventName, e) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners || !listeners.length)
        return;

    var e = e || {};
    e.type = eventName;

    for (var i = 0, l = listeners.length; i < l; i++)
        listeners[i](e);
};

EventEmitter.on =
EventEmitter.addEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        var listeners = this._eventRegistry[eventName] = [];

    if (listeners.indexOf(callback) == -1)
        listeners.push(callback);
};

EventEmitter.removeListener =
EventEmitter.removeEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
      return;

    var index = listeners.indexOf(callback);
    if (index !== -1)
        listeners.splice(index, 1);
};

EventEmitter.removeAllListeners = function(eventName) {
    if (this._eventRegistry)
        this._eventRegistry[eventName] = [];
};

exports.EventEmitter = EventEmitter;

});

/**
 * Ajax.org Code Editor (ACE)
 *
 * @copyright 2010, Ajax.org Services B.V.
 * @license LGPLv3 <http://www.gnu.org/licenses/lgpl-3.0.txt>
 * @author Fabian Jakobs <fabian AT ajax DOT org>
 */

define('debug/ChromeDebugMessageStream',['require','exports','module','./util'],function(require, exports, module) {
"use strict";

var Util = require("./util");
var EventEmitter = Util.EventEmitter;

var ChromeDebugMessageStream = module.exports = function(socket) {
    this.$socket = socket;
};

(function() {

    Util.implement(this, EventEmitter);

    this.$received = "";

    this.connect = function() {
        var socket = this.$socket;
        var self = this;
        socket.on("connect", function() {
            self.$onconnect();
        });
        socket.on("data", function(data) {
            self.$onhandshake(data);
        });
        socket.connect();
    };

    this.sendRequest = function(message) {
        //console.log("> Sent to Chrome:\n", message.stringify());
        this.$socket.send(message.stringify());
    };

    this.$onconnect = function() {
        this.$socket.send(this.MSG_HANDSHAKE);
    };

    this.$onhandshake = function(data) {
        this.$received += data;
        //this.$socket.clearBuffer();

        if (this.$received.length < this.MSG_HANDSHAKE.length)
            return;

        if (this.$received.indexOf(this.MSG_HANDSHAKE) !== 0) {
            this.$socket.removeAllListeners("data");
            return this.$onerror();
        }

        this.$received = this.$received.substring(this.MSG_HANDSHAKE.length);
        this.$socket.removeAllListeners("data");
        this.$reader = new MessageReader(this.$socket, this.$onMessage.bind(this));

        this.emit("connect");
    };

    this.$onMessage = function(messageText) {
        var self = this;
        setTimeout(function() {
            //console.log("> Received from Chrome:\n", messageText);
            var response = new DevToolsMessage.fromString(messageText);
            self.emit("message", {data: response});
        }, 0);
    };

    this.$onerror = function() {
        this.emit("error");
    };

    this.MSG_HANDSHAKE = "ChromeDevToolsHandshake\r\n";

}).call(ChromeDebugMessageStream.prototype);

});
/**
 * lib-v8debug - A V8 Debugger wrapper
 *
 * @copyright 2010, Ajax.org Services B.V.
 * @license LGPLv3 <http://www.gnu.org/licenses/lgpl-3.0.txt>
 * @author Fabian Jakobs <fabian AT ajax DOT org>
 */

define('debug/WSChromeDebugMessageStream',['require','exports','module','./util'],function(require, exports, module) {
"use strict";

var Util = require("./util");
var EventEmitter = Util.EventEmitter;

var WSChromeDebugMessageStream = module.exports = function(socket) {
    this.$socket = socket;
    this.$attached = false;
};

(function() {

    Util.implement(this, EventEmitter);

    this.$received = "";

    this.connect = function() {
        if (this.$attached)
            return;

        var self = this;

        this.$socket.on("message", function(e) {
            var message;
            try {
                message = JSON.parse(data);
            }
            catch(e) {
                return _self.$onerror();
            }

            if (message.type == "chrome-debug-ready") {
                self._dispatchEvent("connect");
            }
            else {
                var response = new DevToolsMessage.fromString(e.body);
                self._dispatchEvent("message", {data: response});
            }
        });
    };

    this.sendRequest = function(message) {
        //console.log("> Sent to Chrome:\n", message.stringify());
        var command = {
            command: "debugChrome",
            message: message.stringify()
        };
        this.$socket.send(JSON.stringify(message));
    };

    this.$onerror = function() {
        this.$dispatchEvent("error");
    };

}).call(WSChromeDebugMessageStream.prototype);

});
/**
 * Ajax.org Code Editor (ACE)
 *
 * @copyright 2010, Ajax.org Services B.V.
 * @license LGPLv3 <http://www.gnu.org/licenses/lgpl-3.0.txt>
 * @author Fabian Jakobs <fabian AT ajax DOT org>
 */

define('debug/DevToolsMessage',['require','exports','module'],function(require, exports, module) {
"use strict";

var DevToolsMessage = module.exports = function(headers, content) {
    this.$headers = {};
    this.$content = "";

    if (headers)
        this.$headers = headers;
    if (content)
        this.setContent(content);
};

(function() {

    this.setContent = function(content) {
        this.$content = content.toString();
    };

    this.getContent = function() {
        return this.$content;
    };

    this.setHeader = function(name, value) {
        this.$headers[name] = value;
    };

    this.parse = function(msgString) {
        var headers = this.$headers = {};
        var responseParts = msgString.split("\r\n\r\n");

        var headerText = responseParts[0];
        this.$content = responseParts[1];

        var re = /([\w\-\d]+):([\w\-\d]*)(\r\n|$)/g;
        headerText.replace(re, function(str, key, value) {
            headers[key] = value;
        });

        return this;
    };

    this.stringify = function() {
        var headers = this.getHeaders();

        var str = [];
        for (var name in headers)
            str.push(name, ":", headers[name], "\r\n");
        if (this.$content)
            str.push("\r\n", this.$content);
        return str.join("");
    };

    this.getHeaders = function() {
        this.$headers["Content-Length"] = this.$content.length;
        this.$headers["Tool"] = this.$headers["Tool"] || "DevToolsService";

        return this.$headers;
    };

}).call(DevToolsMessage.prototype);

DevToolsMessage.fromString = function(msgString) {
    return new DevToolsMessage().parse(msgString);
};

});
/**
 * Ajax.org Code Editor (ACE)
 *
 * @copyright 2010, Ajax.org Services B.V.
 * @license LGPLv3 <http://www.gnu.org/licenses/lgpl-3.0.txt>
 * @author Fabian Jakobs <fabian AT ajax DOT org>
 */

define('debug/V8DebuggerService',['require','exports','module','./util','./DevToolsMessage'],function(require, exports, module) {
"use strict";

var Util = require("./util");
var EventEmitter = Util.EventEmitter;
var DevToolsMessage = require("./DevToolsMessage");

var V8DebuggerService = module.exports = function(msgStream) {
    this.$msgStream = msgStream;
    this.$pending = {};

    var self = this;
    this.$msgStream.addEventListener("message", function(e) {
        var response = e.data;
        if (response.getHeaders()["Tool"] !== "V8Debugger")
            return;

        var content = JSON.parse(response.getContent());
        var command = content.command;

        var queue = self.$pending[command];
        if (queue && queue.length)
            queue.shift()(content.data);

        var event = command;
        var tabId = response.getHeaders()["Destination"];
        if (tabId)
            event += "_" + tabId;

        self.emit(event, {data: content.data});
    });
};

(function() {

    Util.implement(this, EventEmitter);

    this.attach = function(tabId, callback) {
        this.$send(tabId, "attach", null, callback);
    };

    this.detach = function(tabId, callback) {
        this.$send(tabId, "detach", null, callback);
    };

    this.evaluateJavaScript = function(tabId, jsCode) {
        this.$send(tabId, "evaluate_javascript", '"' + jsCode + '"', null);
    };

    this.debuggerCommand = function(tabId, v8Command) {
        this.$send(tabId, "debugger_command", v8Command);
        var self = this;
        setTimeout(function() {
            self.$send(tabId, "evaluate_javascript", '"javascript:void(0);"', null);
        }, 100);
    };

    this.$send = function(destination, command, data, callback) {
        var headers = {
            "Tool": "V8Debugger",
            "Destination": destination
        };

        var commandJson = ['{"command":"', command, '"'];
        data && commandJson.push(',"data":', data);
        commandJson.push("}");

        var msg = new DevToolsMessage(headers, commandJson.join(""));
        this.$msgStream.sendRequest(msg);

        if (callback) {
            if (!this.$pending[command])
                this.$pending[command] = [];

            this.$pending[command].push(callback);
        }
    };


}).call(V8DebuggerService.prototype);

});
/**
 * Ajax.org Code Editor (ACE)
 *
 * @copyright 2010, Ajax.org Services B.V.
 * @license LGPLv3 <http://www.gnu.org/licenses/lgpl-3.0.txt>
 * @author Fabian Jakobs <fabian AT ajax DOT org>
 */

define('debug/DevToolsService',['require','exports','module','./DevToolsMessage'],function(require, exports, module) {
"use strict";

var DevToolsMessage = require("./DevToolsMessage");

var DevToolsService = module.exports = function(msgStream) {
    this.$msgStream = msgStream;
    this.$pending = [];

    var self = this;
    this.$msgStream.on("message", function(e) {
        var response = e.data;
        if (response.getHeaders()["Tool"] !== "DevToolsService")
            return;

        if (self.$pending.length)
            self.$pending.shift()(JSON.parse(response.getContent()).data);
    });
};

(function() {

    this.ping = function(callback) {
        this.$send("ping", callback);
    };

    this.getVersion = function(callback) {
        this.$send("version", callback);
    };

    this.listTabs = function(callback) {
        this.$send("list_tabs", callback);
    };

    this.$send = function(command, callback) {
        var msg = new DevToolsMessage(null, '{"command":"' + command + '"}');
        this.$msgStream.sendRequest(msg);
        this.$pending.push(callback);
    };

}).call(DevToolsService.prototype);

});
/**
 * Ajax.org Code Editor (ACE)
 *
 * @copyright 2010, Ajax.org Services B.V.
 * @license LGPLv3 <http://www.gnu.org/licenses/lgpl-3.0.txt>
 * @author Fabian Jakobs <fabian AT ajax DOT org>
 */


define('debug/V8Message',['require','exports','module','./util'],function(require, exports, module) {
"use strict";

var Util = require("./util");

var V8Message = module.exports = function(type) {
    this.seq = V8Message.$seq++;
    this.type = type;
};

(function() {

    this.$msgKeys = [
        "seq",
        "type",
        "command",
        "arguments",
        "request_seq",
        "body",
        "running",
        "success",
        "message",
        "event"
    ];
    var len = this.$msgKeys.length;

    this.parse = function(msgString) {
        var json = JSON.parse(msgString);
        Util.mixin(this, json);
        return this;
    };

    this.stringify = function() {
        var tmp = {};
        for (var i = 0; i < len; i++) {
            var name = this.$msgKeys[i];
            if (typeof this[name] != "undefined")
                tmp[name] = this[name];
        }
        return JSON.stringify(tmp);
    };

}).call(V8Message.prototype);

V8Message.$seq = 1;

V8Message.fromString = function(msgString) {
    return new V8Message().parse(msgString);
};

V8Message.fromObject = function(obj) {
    var msg = new V8Message();
    Util.mixin(msg, obj);
    return msg;
};

});
/**
 * Ajax.org Code Editor (ACE)
 *
 * @copyright 2010, Ajax.org Services B.V.
 * @license LGPLv3 <http://www.gnu.org/licenses/lgpl-3.0.txt>
 * @author Fabian Jakobs <fabian AT ajax DOT org>
 */
define('debug/V8Debugger',['require','exports','module','./util','./V8Message'],function(require, exports, module) {
 
"use strict";
   
var Util = require("./util");
var EventEmitter = Util.EventEmitter;
var V8Message = require("./V8Message");

var V8Debugger = module.exports = function(tabId, v8service) {
    this.tabId = tabId;
    this.$running = true;
    this.$service = v8service;

    var pending = this.$pending = {};

    var self = this;
    this.$service.addEventListener("debugger_command_" + tabId, function(e) {
        var response = V8Message.fromObject(e.data);
        //console.log("Incoming debugger message for event " + response.event + " (" + response.request_seq + "): ", response);

        var requestSeq = response.request_seq;
        if (pending[requestSeq]) {
            pending[requestSeq](response.body, response.refs || null, 
                !response.success && {message: response.message} || null);
            delete pending[requestSeq];
        }
        else if (response.event) {
            if (response.event == "break") {
                var event = JSON.stringify(response.body);
                if (this.lastBreak != event) {
                    this.lastBreak = event;
                    self.emit(response.event, {data: response.body});
                }
            }
            else
                self.emit(response.event, {data: response.body});
        }

        self.$updateRunning(response);
     });
};

(function() {

    Util.implement(this, EventEmitter);

    this.$seq = 0;

    this.$updateRunning = function(response) {
        // workaround for V8 bug
        // http://code.google.com/p/v8/issues/detail?id=724
        if (response.event == "scriptCollected")
            return;

        var running = true;
        if (response.type == "response") {
            running = response.running;
        }
        else if (response.type == "event") {
            if (response.event == "break" || response.event == "exception")
                running = false;
        }

        if (running !== this.$running) {
            this.$running = running;
            this.emit("changeRunning", {data: running});
        }
    };

    this.isRunning = function() {
        return this.$running;
    };

    this.continueScript = function(stepaction, stepcount, callback) {
        var msg = new V8Message("request");
        msg.command = "continue";
        if (stepaction) {
            msg.arguments = {
                stepcount: stepcount || 1,
                stepaction: stepaction
            };
        }
        this.$send(msg, callback);
    };

    this.lookup = function(handles, includeSource, callback) {
        var msg = new V8Message("request");
        msg.command = "lookup";
        msg.arguments = {
            inlineRefs: false,
            handles: handles
        };
        if (includeSource)
            msg.arguments.includesSource = includeSource;

        this.$send(msg, callback);
    };

    this.backtrace = function(fromFrame, toFrame, bottom, inlineRefs, callback) {
        var msg = new V8Message("request");
        msg.command = "backtrace";
        msg.arguments = {
            inlineRefs: !!inlineRefs
        };
        if (fromFrame)
            msg.arguments.fromFrame = fromFrame;

        if (toFrame)
            msg.arguments.toFrame = toFrame;

        if (typeof(bottom) === "boolean")
            msg.arguments.bottom = bottom;

        this.$send(msg, callback);
    };

    this.scope = function(number, frameNumber, inlineRefs, callback) {
        var msg = new V8Message("request");
        msg.command = "scope";
        msg.arguments = {
            number: number,
            inlineRefs: !!inlineRefs
        };

        if (typeof frameNumber == "number")
            msg.arguments.frameNumber = frameNumber;

        this.$send(msg, callback);
    };

    this.version = function(callback) {
        var msg = new V8Message("request");
        msg.command = "version";
        this.$send(msg, callback);
    };

    this.scripts = function(types, ids, includeSource, callback) {
        var msg = new V8Message("request");
        msg.command = "scripts";
        msg.arguments = {
            types: types || V8Debugger.NORMAL_SCRIPTS,
            includeSource: !!includeSource
        };
        if (ids)
            msg.arguments.ids = ids;
        this.$send(msg, function(scripts, refs, err) {
            callback(scripts || [], refs, err);
        });
    };

    this.evaluate = function(expression, frame, global, disableBreak, callback) {
        var _self = this;
        
        var msg = new V8Message("request");
        msg.command = "evaluate";
        msg.arguments = {
            expression : expression
        };
        if (frame) {
            msg.arguments.frame = frame;
        }
        if (global) {
            msg.arguments.global = global;
        }
        if (disableBreak) {
            msg.arguments.disable_break = disableBreak;
        }
        
        /* evaluation always take place on one single frame, but we need additional variables
         * that are not there, because the v8 debugger only passes variables to the frame that
         * are needed. Therefore we need to push additional items to the stack, and we gain them
         * from the backtrace
         */
        this.backtrace(null, null, false, true, function (resp) {
            // build a hashtable
            var addContext = { };
            // run over all frames
            for(var ix = 0, frames = resp.frames, frame = frames[ix]; ix < frames.length; frame = frames[++ix]) {
                // then over all the locals
                for (var lix = 0, local = frame.locals[lix]; lix < frame.locals.length; local = frame.locals[++lix]) {
                    // check whether a higher frame already has a variable declared under this name
                    // this way we prevent property overwriting
                    if (!addContext[local.name]) {
                        addContext[local.name] = local.value.ref;
                    }
                }
            }
            
            // the message needs an array so we map the object to one
            msg.arguments.additional_context = [];
            for (var name in addContext) {
                if (!addContext.hasOwnProperty(name)) continue;
                
                msg.arguments.additional_context.push({ name: name, handle: addContext[name] });
            }
            
            // and now send the complete message to the debugger
            _self.$send(msg, callback);
        });
    };

    this.setbreakpoint = function(type, target, line, column, enabled, condition, ignoreCount, callback) {
        var msg = new V8Message("request");
        msg.command = "setbreakpoint";
        msg.arguments = {
            type: type,
            target: target,
            line: line,
            enabled: enabled === undefined ? enabled : true
        };

        if (column)
            msg.column = column;

        if (condition)
            msg.condition = condition;

        if (ignoreCount)
            msg.ignoreCount = ignoreCount;
        
        this.$send(msg, callback);
    };

    this.changebreakpoint = function(breakpoint, enabled, condition, ignoreCount, callback) {
        var msg = new V8Message("request");
        msg.command = "changebreakpoint";
        msg.arguments = {
            enabled: enabled !== true ? false : true,
            breakpoint: breakpoint
        };

        if (condition)
            msg.condition = condition;

        if (ignoreCount)
            msg.ignoreCount = ignoreCount;

        this.$send(msg, callback);
    };

    this.clearbreakpoint = function(breakpoint, callback) {
        var msg = new V8Message("request");
        msg.command = "clearbreakpoint";
        msg.arguments = {
            breakpoint: breakpoint
        };
        this.$send(msg, callback);
    };

    this.listbreakpoints = function(callback) {
        var msg = new V8Message("request");
        msg.command = "listbreakpoints";
        this.$send(msg, callback);
    };

    this.suspend = function(callback) {
        var msg = new V8Message("request");
        msg.command = "suspend";
        this.$send(msg, callback);
    };
    
    this.changelive = function(scriptId, newSource, previewOnly, callback) {
        var msg = new V8Message("request");
        msg.command = "changelive";
        msg.arguments = {
            script_id: scriptId,
            new_source: newSource,
            preview_only: !!previewOnly
        };

        this.$send(msg, callback);
    };

    this.$send = function(msg, callback) {
        if (callback)
            this.$pending[msg.seq] = callback;
        this.$service.debuggerCommand(this.tabId, msg.stringify());
    };

}).call(V8Debugger.prototype);

V8Debugger.NATIVE_SCRIPTS = 1;
V8Debugger.EXTENSION_SCRIPTS = 2;
V8Debugger.NORMAL_SCRIPTS = 4;

});
/**
 * Ajax.org Code Editor (ACE)
 *
 * @copyright 2010, Ajax.org Services B.V.
 * @license LGPLv3 <http://www.gnu.org/licenses/lgpl-3.0.txt>
 * @author Fabian Jakobs <fabian AT ajax DOT org>
 */

define('debug/MessageReader',['require','exports','module'],function(require, exports, module) {
"use strict";

var MessageReader = module.exports = function(socket, callback) {
    this.$socket = socket;
    this.$callback = callback;

    this.$received = "";
    this.$cbReceive = this.$onreceive.bind(this);
    socket.on("data", this.$cbReceive);
};

(function() {

    this.$onreceive = function(data) {
        //this.$socket.clearBuffer();
        this.$received += data;

        var fullResponse;
        while (fullResponse = this.$checkForWholeMessage())
            this.$callback(fullResponse);
    };

    this.$checkForWholeMessage = function() {
        var i, c, l;
        var responseLength;
        var fullResponse = false;
        var received = this.$received;

        if ((i = received.indexOf("\r\n\r\n")) != -1) {
            if ((c = received.indexOf("Content-Length:")) != -1) {
                l = received.substring(c + 15);
                l = l.substring(0, l.indexOf("\r\n"));
                responseLength = i + 4 + parseInt(l, 10);
                if (responseLength <= received.length) {
                    fullResponse = received.substring(0, responseLength);
                    this.$received = received.substring(responseLength);
                    this.$socket.setMinReceiveSize(0);
                }
                else {
                    this.$socket.setMinReceiveSize(responseLength - received.length);
                }
            }
        }
        return fullResponse;
    };
    
    this.destroy = function() {
        this.$socket.removeListener("data", this.$cbReceive);
        delete this.$socket;
        delete this.$callback;
        this.$received = "";
    };

}).call(MessageReader.prototype);

});
/**
 * Ajax.org Code Editor (ACE)
 *
 * @copyright 2010, Ajax.org Services B.V.
 * @license LGPLv3 <http://www.gnu.org/licenses/lgpl-3.0.txt>
 * @author Fabian Jakobs <fabian AT ajax DOT org>
 */

define('debug/StandaloneV8DebuggerService',['require','exports','module','./util','./MessageReader','./DevToolsMessage'],function(require, exports, module) {
"use strict";

var Util = require("./util");
var EventEmitter = Util.EventEmitter;
var MessageReader = require("./MessageReader");
var DevToolsMessage = require("./DevToolsMessage");

var StandaloneV8DebuggerService = module.exports = function(socket) {
    this.$socket = socket;
    this.$attached = false;
};

(function() {

    Util.implement(this, EventEmitter);

    this.attach = function(tabId, callback) {
        if (this.$attached)
            throw new Error("already attached!");

        var self = this;
        this.$reader = new MessageReader(this.$socket, function(messageText) {
            //console.log("Connect>", messageText);
            self.$reader.destroy();
            self.emit("connect");
            self.$reader = new MessageReader(self.$socket, self.$onMessage.bind(self));
            callback();
        });
        this.$socket.connect();
    };

    this.detach = function(tabId, callback) {
        this.$socket.close();
        this.$attached = false;
        if (this.$reader)
            this.$reader.destroy();
        callback();
    };

    this.$onMessage = function(messageText) {
        var response = new DevToolsMessage.fromString(messageText);

        var contentText = response.getContent();
        if (!contentText)
            return;

        var content;
        try {
            content = JSON.parse(contentText);
        }
        catch(ex) {
            return;
        }
        this.emit("debugger_command_0", {data: content});
    };

    this.debuggerCommand = function(tabId, v8Command) {
        this.$send(v8Command);
    };

    this.$send = function(text) {
        var msg = ["Content-Length:", text.length, "\r\n\r\n", text].join("");
        //console.log("SEND>", msg);
        this.$socket.send(msg);
    };

}).call(StandaloneV8DebuggerService.prototype);

});
/**
 * Ajax.org Code Editor (ACE)
 *
 * @copyright 2010, Ajax.org Services B.V.
 * @license LGPLv3 <http://www.gnu.org/licenses/lgpl-3.0.txt>
 * @author Fabian Jakobs <fabian AT ajax DOT org>
 */
define('debug/WSV8DebuggerService',['require','exports','module','./util'],function(require, exports, module) {
"use strict";

var Util = require("./util");
var EventEmitter = Util.EventEmitter;

var WSV8DebuggerService = module.exports = function(socket) {
    this.$socket = socket;
    this.$state = "initialized";
    this.$onAttach = [];
};

(function() {

    Util.implement(this, EventEmitter);

    this.attach = function(tabId, callback) {
        if (this.$state == "connected")
            return callback(new Error("already attached!"));

        this.$onAttach.push(callback);
        if (this.$state == "initialized") {
            this.$socket.send(JSON.stringify({command: "DebugAttachNode"}));
            this.$onMessageHandler = this.$onMessage.bind(this);
            this.$socket.on("message", this.$onMessageHandler);
            this.$state = "connecting";
        }
    };

    this.$onMessage = function(data) {
        var message;
        //console.log("INCOMING: ", data);
        try {
            message = JSON.parse(data);
        }
        catch (ex) {
            return;
        }
        if (message.type == "node-debug-ready") {
            this.pid = message.pid;
            this.$state = "connected";
            for (var i = 0, l = this.$onAttach.length; i < l; i++)
                this.$onAttach[i]();
            this.$onAttach = [];
        }
        else if (message.type == "node-debug") {
            this.emit("debugger_command_0", {data: message.body});
        }
    };

    this.detach = function(tabId, callback) {
        this.$state = "initialized";
        this.$socket.removeListener("message", this.$onMessageHandler);
        callback();
    };

    this.debuggerCommand = function(tabId, v8Command) {
        this.$socket.send(JSON.stringify({
            command: "debugNode", 
            pid: this.pid,
            body: JSON.parse(v8Command)
        }));
    };

}).call(WSV8DebuggerService.prototype);

});
define('treehugger/tree',['require','exports','module'],function(require, exports, module) {

function inRange(p, pos) {
    if(p && p.sl <= pos.line && p.el >= pos.line) {
        if(p.sl < pos.line && p.el > pos.line)
            return true;
        else if(p.sl == pos.line && p.el > pos.line)
            return p.sc <= pos.col;
        else if(p.sl == pos.line && p.el === pos.line)
            return p.sc <= pos.col && p.ec >= pos.col;
        else if(p.sl < pos.line && p.el === pos.line)
            return p.ec >= pos.col;
    }
}

/**
 * Base 'class' of every tree node
 */
function Node() {
}

Node.prototype.toPrettyString = function(prefix) {
    prefix = prefix || "";
    return prefix + this.toString();
};

Node.prototype.setAnnotation = function(name, value) {
    this.annos = this.annos || {};
    this.annos[name] = value;
};

Node.prototype.getAnnotation = function(name) {
    return this.annos ? this.annos[name] : undefined;
};

Node.prototype.getPos = function() {
    if(this.annos && this.annos.pos) {
        return this.annos.pos;
    } else {
        return null;
    }
};

Node.prototype.findNode = function(pos) {
    var p = this.getPos();
    if(inRange(p, pos)) {
        return this;
    } else {
        return null;
    }
};

/**
 * Represents a constructor node
 * 
 * Example: Add(Num("1"), Num("2")) is constucted
 *    using new ConsNode(new ConsNode("Num", [new StringNode("1")]),
 *                                         new ConsNode("Num", [new StringNode("2")]))
 *    or, more briefly:
 *        tree.cons("Add", [tree.cons("Num", [ast.string("1"), ast.string("2")])])
 */
function ConsNode(cons, children) {
    this.cons = cons;
    for(var i = 0; i < children.length; i++) {
        this[i] = children[i];
    }
    this.length = children.length;
}

ConsNode.prototype = new Node();

/**
 * Simple human-readable string representation (no indentation)
 */
ConsNode.prototype.toString = function(prefix) {
    try {
        var s = this.cons + "(";
        for ( var i = 0; i < this.length; i++) {
            s += this[i].toString() + ",";
        }
        if (this.length > 0) {
            s = s.substring(0, s.length - 1);
        }
        return s + ")";
    } catch(e) {
        console.error("Something went wrong: ", this, e);
    }
};

/**
 * Human-readable string representation (indentented)
 * @param prefix is for internal use
 */
ConsNode.prototype.toPrettyString = function(prefix) {
    prefix = prefix || "";
    try {
        if(this.length === 0) {
            return prefix + this.cons + "()";
        }
        if(this.length === 1 && (this[0] instanceof StringNode || this[0] instanceof NumNode)) {
            return prefix + this.cons + "(" + this[0].toString() + ")";
        }
        var s = prefix + this.cons + "(\n";
        for ( var i = 0; i < this.length; i++) {
            s += this[i].toPrettyString(prefix + "    ") + ",\n";
        }
        s = s.substring(0, s.length - 2);
        s += "\n";
        return s + prefix + ")";
    } catch(e) {
        console.error("Something went wrong: ", this, e);
    }
};

/**
 * Matches the current term against `t`, writing matching placeholder values to `matches`
 * @param t the node to match against
 * @param matches the object to write placeholder values to
 * @returns the `matches` object if it matches, false otherwise
 */
ConsNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if (t instanceof ConsNode) {
        if (this.cons === t.cons) {
            if (this.length === t.length) {
                for ( var i = 0; i < this.length; i++) {
                    if (!this[i].match(t[i], matches)) {
                        return false;
                    }
                }
                return matches;
            }
        }
    }
    return false;
};

/**
 * Builds a node, based on values (similar to `matches` object),
 * replacing placeholder nodes with values from `values`
 * @returns resulting cons node
 */
ConsNode.prototype.build = function(values) {
    var children = [];
    for ( var i = 0; i < this.length; i++) {
        children.push(this[i].build(values));
    }
    return new ConsNode(this.cons, children);
};

/**
 * Prettier JSON representation of constructor node.
 */
ConsNode.prototype.toJSON = function() {
    var l = [];
    for(var i = 0; i < this.length; i++) {
        l.push(this[i]);
    }
    return {cons: this.cons, children: l};
};

ConsNode.prototype.getPos = function() {
    var pos = {sl : 9999999999,
               sc : 9999999999,
               el : 0,
               ec : 0};
    if (this.getAnnotation("pos")) {
        var nodePos = this.getAnnotation("pos");
        pos = {sl : nodePos.sl,
               sc : nodePos.sc,
               el : nodePos.el,
               ec : nodePos.ec};
    }
    for (var i = 0; i < this.length; i++) {
        var p = this[i].getPos();

        if (p) {
            var oldSl = pos.sl;
            pos.sl = Math.min(pos.sl, p.sl);
            if(pos.sl !== oldSl)
                pos.sc = p.sc;
            else
                pos.sc = Math.min(pos.sc, p.sc);
            var oldEl = pos.el;
            pos.el = Math.max(pos.el, p.el);
            if(pos.el !== oldEl)
                pos.ec = p.ec;
            else
                pos.ec = Math.max(pos.ec, p.ec);
        }
    }
    return pos;
};

ConsNode.prototype.findNode = function(pos) {
    var p = this.getPos();

    if(inRange(p, pos)) {
        for(var i = 0; i < this.length; i++) {
            var p2 = this[i].getPos();
            if(inRange(p2, pos)) {
                var node = this[i].findNode(pos);
                if(node)
                    return node instanceof StringNode ? this : node;
                else
                    return this[i];
            }
        }
    } else {
        return null;
    }
};

/**
 * Constructor node factory.
 */
exports.cons = function(name, children) {
    return new ConsNode(name, children);
};

/**
 * AST node representing a list
 * e.g. for constructors with variable number of arguments, e.g. in
 *      Call(Var("alert"), [Num("10"), Num("11")])
 * 
 */
function ListNode (children) {
    for(var i = 0; i < children.length; i++)
        this[i] = children[i];
    this.length = children.length;
}

ListNode.prototype = new Node();

ListNode.prototype.toString = function() {
    var s = "[";
    for (var i = 0; i < this.length; i++)
        s += this[i].toString() + ",";
    if (this.length > 0)
        s = s.substring(0, s.length - 1);
    return s + "]";
};

ListNode.prototype.toPrettyString = function(prefix) {
    prefix = prefix || "";
    try {
        if(this.length === 0)
            return prefix + "[]";
        var s = prefix + "[\n";
        for ( var i = 0; i < this.length; i++)
            s += this[i].toPrettyString(prefix + "  ") + ",\n";
        s = s.substring(0, s.length - 2);
        s += "\n";
        return s + prefix + "]";
    } catch(e) {
        console.error("Something went wrong: ", this);
    }
};

ListNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if (t instanceof ListNode) {
        if (this.length === t.length) {
            for ( var i = 0; i < this.length; i++)
                if (!this[i].match(t[i], matches))
                    return false;
            return matches;
        }
        else
            return false;
    }
    else
        return false;
};

ListNode.prototype.build = function(values) {
    var children = [];
    for (var i = 0; i < this.length; i++)
        children.push(this[i].build(values));
    return new ListNode(children);
};

ListNode.prototype.getPos = ConsNode.prototype.getPos;
ListNode.prototype.findNode = ConsNode.prototype.findNode;

/**
 * forEach implementation, similar to Array.prototype.forEach
 */
ListNode.prototype.forEach = function(fn) {
    for(var i = 0; i < this.length; i++) {
        fn.call(this[i], this[i], i);
    }
};

/**
 * Whether the list is empty (0 elements)
 */
ListNode.prototype.isEmpty = function() {
    return this.length === 0;
};

/**
 * Performs linear search, performing a match
 * with each element in the list
 * @param el the element to search for
 * @returns true if found, false if not
 */
ListNode.prototype.contains = function(el) {
    for(var i = 0; i < this.length; i++)
        if(el.match(this[i]))
            return true;
    return false;
};

/**
 * Concatenates list with another list, similar to Array.prototype.concat
 */
ListNode.prototype.concat = function(l) {
    var ar = [];
    for(var i = 0; i < this.length; i++)
        ar.push(this[i]);
    for(i = 0; i < l.length; i++)
        ar.push(l[i]);
    return exports.list(ar);
};

ListNode.prototype.toJSON = function() {
    var l = [];
    for(var i = 0; i < this.length; i++)
        l.push(this[i]);
    return l;
};

/**
 * Returns a new list node, with all duplicates removed
 * Note: cubic complexity algorithm used
 */
ListNode.prototype.removeDuplicates = function() {
    var newList = [];
    lbl: for(var i = 0; i < this.length; i++) {
        for(var j = 0; j < newList.length; j++)
            if(newList[j].match(this[i]))
                continue lbl;
        newList.push(this[i]);
    }
    return new exports.list(newList);
};

ListNode.prototype.toArray = ListNode.prototype.toJSON;

/**
 * ListNode factory
 */
exports.list = function(elements) {
    return new ListNode(elements);
};

function NumNode (value) {
    this.value = value;
}

NumNode.prototype = new Node();

NumNode.prototype.toString = function() {
    return ""+this.value;
};

NumNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if (t instanceof NumNode)
        return this.value === t.value ? matches : false;
    else
        return false;
};

NumNode.prototype.build = function(values) {
    return this;
};

exports.num = function(value) {
    return new NumNode(value);
};

function StringNode (value) {
    this.value = value;
}

StringNode.prototype = new Node();

StringNode.prototype.toString = function() {
    return '"' + this.value + '"';
};

StringNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if (t instanceof StringNode)
        return this.value === t.value ? matches : false;
    else
        return false;
};

StringNode.prototype.build = function(values) {
    return this;
};

exports.string = function(value) {
    return new StringNode(value);
};

function PlaceholderNode(id) {
    this.id = id;
}

PlaceholderNode.prototype = new Node();

PlaceholderNode.prototype.toString = function() {
    return this.id;
};

PlaceholderNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if(this.id === '_')
        return matches;
    if(matches[this.id]) // already bound
        return matches[this.id].match(t);
    else {
        matches[this.id] = t;
        return matches;
    }
};

PlaceholderNode.prototype.build = function(values) {
    return values[this.id];
};

exports.placeholder = function(n) {
    return new PlaceholderNode(n);
};

var parseCache = {};

function parse (s) {
    var idx = 0;
    function accept (str) {
        for ( var i = 0; i < str.length && idx + i < s.length; i++) {
            if (str[i] != s[idx + i]) {
                return false;
            }
        }
        return i == str.length;
    }
    function lookAheadLetter() {
        return s[idx] >= 'a' && s[idx] <= 'z' || s[idx] >= 'A' && s[idx] <= 'Z' || s[idx] === '_' || s[idx] >= '0' && s[idx] <= '9';
    }
    function skipWhitespace () {
        while (idx < s.length && (s[idx] === " " || s[idx] === "\n" || s[idx] === "\r" || s[idx] === "\t")) {
            idx++;
        }
    }
    function parseInt () {
        var pos = idx;
        if (s[idx] >= '0' && s[idx] <= '9') {
            var ns = s[idx];
            idx++;
            while (idx < s.length && s[idx] >= '0' && s[idx] <= '9') {
                ns += s[idx];
                idx++;
            }
            skipWhitespace();
            return new NumNode(+ns, pos);
        } else {
            return null;
        }
    }
    function parseString () {
        var pos = idx;
        if (accept('"')) {
            var ns = "";
            idx++;
            while (!accept('"') || (accept('"') && s[idx - 1] == '\\')) {
                ns += s[idx];
                idx++;
            }
            var ns2 = '';
            for ( var i = 0; i < ns.length; i++) {
                if (ns[i] == "\\") {
                    i++;
                    switch (ns[i]) {
                        case 'n':
                            ns2 += "\n";
                            break;
                        case 't':
                            ns2 += "\t";
                            break;
                        default:
                            ns2 += ns[i];
                    }
                } else {
                    ns2 += ns[i];
                }
            }
            idx++;
            skipWhitespace();
            return new StringNode(ns2, pos);
        } else {
          return null;
        }
    }
    function parsePlaceholder() {
        var pos = idx;
        if (lookAheadLetter() && s[idx].toLowerCase() === s[idx]) {
            var ns = "";
            while (lookAheadLetter() && idx < s.length) {
                ns += s[idx];
                idx++;
            }
            skipWhitespace();
            return new PlaceholderNode(ns, pos);
        }
        else {
            return null;
        }
    }
    function parseList() {
        var pos = idx;
        if (accept('[')) {
            var items = [];
            idx++;
            skipWhitespace();
            while (!accept(']') && idx < s.length) {
                items.push(parseExp());
                if (accept(',')) {
                    idx++; // skip comma
                    skipWhitespace();
                }
            }
            idx++;
            skipWhitespace();
            return new ListNode(items, pos);
        }
        else {
            return null;
        }
    }
    function parseCons () {
        var pos = idx;
        // assumption: it's an appl
        var ns = "";
        while (!accept('(')) {
            ns += s[idx];
            idx++;
        }
        idx++; // skip (
        var items = [];
        while (!accept(')') && idx < s.length) {
            items.push(parseExp());
            if (accept(',')) {
                idx++; // skip comma
                skipWhitespace();
            }
        }
        idx++;
        skipWhitespace();
        return new ConsNode(ns, items, pos);
    }

    function parseExp() {
        var r = parseInt();
        if (r) return r;
        r = parseString();
        if (r) return r;
        r = parseList();
        if (r) return r;
        r = parsePlaceholder();
        if (r) return r;
        return parseCons();
    }
  
    if(typeof s !== 'string') {
        return null;
    }
  
    if(s.length < 200 && !parseCache[s]) {
        parseCache[s] = parseExp();
    } else if(!parseCache[s]) {
        return parseExp();
    }
    return parseCache[s];
}

exports.Node = Node;
exports.ConsNode = ConsNode;
exports.ListNode = ListNode;
exports.NumNode = NumNode;
exports.StringNode = StringNode;
exports.PlaceholderNode = PlaceholderNode;
exports.parse = parse;
exports.inRange = inRange;

});

define('treehugger/traverse',['require','exports','module','treehugger/tree'],function(require, exports, module) {

var tree = require('treehugger/tree');

if (!Function.prototype.curry) {
    Function.prototype.curry = function() {
        var fn = this,
            args = Array.prototype.slice.call(arguments);
        return function() {
            return fn.apply(this, args.concat(Array.prototype.slice.call(arguments)));
        };
    };
}

function normalizeArgs(args) {
    if (args.length === 1 && args[0].apply) { // basic, one function, shortcut!
        return args[0];
    }
    args = Array.prototype.slice.call(args, 0);
    if (args[0] && Object.prototype.toString.call(args[0]) === '[object Array]') {
        args = args[0];
    }
    return function() {
        var result;
        for (var i = 0; i < args.length; i++) {
            if (typeof args[i] === 'string') {
                var parsedPattern = tree.parse(args[i]);
                var bindings = parsedPattern.match(this);
                if (bindings) {
                    if (args[i + 1] && args[i + 1].apply) {
                        result = args[i + 1].call(this, bindings, this);
                        i++;
                    }
                    else
                        result = this;
                    if (result)
                        return result;
                }
                else if (args[i + 1] && args[i + 1].apply)
                    i++;
            }
            else if (args[i].apply) {
                result = args[i].call(this);
                if (result)
                    return result;
            }
            else
                throw Error("Invalid argument: ", args[i]);
        }
        return false;
    };
}

exports.traverseAll = function(fn) {
    var result, i;
    fn = normalizeArgs(arguments);
    if (this instanceof tree.ConsNode || this instanceof tree.ListNode) {
        for (i = 0; i < this.length; i++) {
            result = fn.call(this[i]);
            if (!result)
                return false;
        }
    }
    return this;
};

/**
 * Sequential application last argument is term
 */
function seq() {
    var fn;
    var t = this;
    for (var i = 0; i < arguments.length; i++) {
        fn = arguments[i];
        t = fn.call(t);
        if (!t)
            return false;
    }
    return this;
}
// Try
exports.attempt = function(fn) {
    fn = normalizeArgs(arguments);
    var result = fn.call(this);
    return !result ? this : result;
};

exports.debug = function(pretty) {
    console.log(pretty ? this.toPrettyString("") : this.toString());
    return this;
};

// A somewhat optimized version of the "clean" topdown traversal
function traverseTopDown(fn) {
    var result, i;
    result = fn.call(this);
    if(result)
        return result;
    if (this instanceof tree.ConsNode || this instanceof tree.ListNode) {
        for (i = 0; i < this.length; i++) {
            traverseTopDown.call(this[i], fn);
        }
    }
    return this;
}

exports.traverseTopDown = function(fn) {
    fn = normalizeArgs(arguments);
    return traverseTopDown.call(this, fn);
    //exports.rewrite.call(this, fn, exports.traverseAll.curry(exports.traverseTopDown.curry(fn)));
    //return this;
};

/**
 * Traverse up the tree (using parent pointers) and return the first matching node
 * Doesn't only traverse parents, but also upward siblings
 */
exports.traverseUp = function(fn) {
    fn = normalizeArgs(arguments);
    var result = fn.call(this);
    if(result)
        return result;
    if (!this.parent)
        return false;
    return this.parent.traverseUp(fn);
};

exports.collectTopDown = function(fn) {
    fn = normalizeArgs(arguments);
    var results = [];
    this.traverseTopDown(function() {
        var r = fn.call(this);
        if (r) {
            results.push(r);
        }
        return r;
    });
    return tree.list(results);
};

exports.map = function(fn) {
    fn = normalizeArgs(arguments);
    var result, results = [];
    for (var i = 0; i < this.length; i++) {
        result = fn.call(this[i], this[i]);
        if (result) {
            results.push(result);
        }
        else {
            throw Error("Mapping failed: ", this[i]);
        }
    }
    return tree.list(results);
};

exports.each = function(fn) {
    fn = normalizeArgs(arguments);
    for (var i = 0; i < this.length; i++) {
        fn.call(this[i], this[i]);
    }
};

// fn return boolean
exports.filter = function(fn) {
    fn = normalizeArgs(arguments);
    var matching = [];
    this.forEach(function(el) {
        var result = fn.call(el);
        if (result) {
            matching.push(result);
        }
    });
    return tree.list(matching);
};

exports.rewrite = function(fn) {
    fn = normalizeArgs(arguments);
    return fn.call(this);
};

for (var p in exports) {
    if (exports.hasOwnProperty(p)) {
        tree.Node.prototype[p] = exports[p];
    }
}

exports.addParentPointers = function(node) {
    return node.traverseTopDown(function() {
        var that = this;
        this.traverseAll(function() {
            this.parent = that;
            return this;
        });
    });
};

});
/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.

  This version is suitable for Node.js.  With minimal changes (the
  exports stuff) it should work on any JS platform.

  This file contains the tokenizer/parser.  It is a port to JavaScript
  of parse-js [1], a JavaScript parser library written in Common Lisp
  by Marijn Haverbeke.  Thank you Marijn!

  [1] http://marijn.haverbeke.nl/parse-js/

  Exported functions:

    - tokenizer(code) -- returns a function.  Call the returned
      function to fetch the next token.

    - parse(code) -- returns an AST of the given JavaScript code.

  ----------------------------------------------------------------------
  
  This is an updated version of UglifyJS, adapted by zef@c9.io with error
  recovery, to keep  parsing code when errors are encountered

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>
    Based on parse-js (http://marijn.haverbeke.nl/parse-js/).

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/
 
define('treehugger/js/uglifyparser',['require','exports','module'],function(require, exports, module) {

/* -----[ Tokenizer (constants) ]----- */

var KEYWORDS = array_to_hash([
    "break",
    "case",
    "catch",
    "const",
    "continue",
    "default",
    "delete",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "in",
    "instanceof",
    "new",
    "return",
    "switch",
    "throw",
    "try",
    "typeof",
    "var",
    "void",
    "while",
    "with",
    "let"
]);

var RESERVED_WORDS = array_to_hash([
    "abstract",
    "boolean",
    "byte",
    "char",
    "class",
    "debugger",
    "double",
    "enum",
    "export",
    "extends",
    "final",
    "float",
    "goto",
    "implements",
    "import",
    "int",
    "interface",
    "long",
    "native",
    "package",
    "private",
    "protected",
    "public",
    "short",
    "static",
    "super",
    "synchronized",
    "throws",
    "transient",
    "volatile"
]);

var KEYWORDS_BEFORE_EXPRESSION = array_to_hash([
    "return",
    "new",
    "delete",
    "throw",
    "else",
    "case"
]);

var KEYWORDS_ATOM = array_to_hash([
    "false",
    "null",
    "true",
    "undefined"
]);

var OPERATOR_CHARS = array_to_hash(characters("+-*&%=<>!?|~^"));

var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
var RE_OCT_NUMBER = /^0[0-7]+$/;
var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;

var OPERATORS = array_to_hash([
    "in",
    "instanceof",
    "typeof",
    "new",
    "void",
    "delete",
    "++",
    "--",
    "+",
    "-",
    "!",
    "~",
    "&",
    "|",
    "^",
    "*",
    "/",
    "%",
    ">>",
    "<<",
    ">>>",
    "<",
    ">",
    "<=",
    ">=",
    "==",
    "===",
    "!=",
    "!==",
    "?",
    "=",
    "+=",
    "-=",
    "/=",
    "*=",
    "%=",
    ">>=",
    "<<=",
    ">>>=",
    "|=",
    "^=",
    "&=",
    "&&",
    "||"
]);

var WHITESPACE_CHARS = array_to_hash(characters(" \u00a0\n\r\t\f\u000b\u200b\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000"));

var PUNC_BEFORE_EXPRESSION = array_to_hash(characters("[{}(,.;:"));

var PUNC_CHARS = array_to_hash(characters("[]{}(),;:"));

var REGEXP_MODIFIERS = array_to_hash(characters("gmsiy"));

/* -----[ Tokenizer ]----- */

// regexps adapted from http://xregexp.com/plugins/#unicode
var UNICODE = {
    letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0523\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971\\u0972\\u097B-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3D\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8B\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2C6F\\u2C71-\\u2C7D\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FC3\\uA000-\\uA48C\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA65F\\uA662-\\uA66E\\uA67F-\\uA697\\uA717-\\uA71F\\uA722-\\uA788\\uA78B\\uA78C\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA90A-\\uA925\\uA930-\\uA946\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAC00\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
    non_spacing_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
    space_combining_mark: new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),
    connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]")
};

function is_letter(ch) {
    return UNICODE.letter.test(ch);
}

function is_digit(ch) {
    ch = ch.charCodeAt(0);
    return ch >= 48 && ch <= 57; //XXX: find out if "UnicodeDigit" means something else than 0..9
}

function is_alphanumeric_char(ch) {
    return is_digit(ch) || is_letter(ch);
}

function is_unicode_combining_mark(ch) {
    return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);
}

function is_unicode_connector_punctuation(ch) {
    return UNICODE.connector_punctuation.test(ch);
}

function is_identifier_start(ch) {
    return ch == "$" || ch == "_" || is_letter(ch);
}

function is_identifier_char(ch) {
    return is_identifier_start(ch)
            || is_unicode_combining_mark(ch)
            || is_digit(ch)
            || is_unicode_connector_punctuation(ch)
            || ch == "\u200c" // zero-width non-joiner <ZWNJ>
            || ch == "\u200d"; // zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)
}

function parse_js_number(num) {
    if (RE_HEX_NUMBER.test(num)) {
        return parseInt(num.substr(2), 16);
    }
    else if (RE_OCT_NUMBER.test(num)) {
        return parseInt(num.substr(1), 8);
    }
    else if (RE_DEC_NUMBER.test(num)) {
        return parseFloat(num);
    }
}

function JS_Parse_Error(message, line, col, pos) {
    this.message = message;
    this.line = line;
    this.col = col;
    this.pos = pos;
    this.stack = new Error().stack;
}

JS_Parse_Error.prototype.toString = function() {
    return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")" + "\n\n" + this.stack;
}

function js_error(message, line, col, pos) {
    throw new JS_Parse_Error(message, line, col, pos);
}

function is_token(token, type, val) {
    return token.type == type && (val == null || token.value == val);
}

var EX_EOF = {};

function tokenizer($TEXT) {
    
    var S = {
        text            : $TEXT.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/^\uFEFF/, ''),
        pos             : 0,
        tokpos          : 0,
        line            : 0,
        tokline         : 0,
        col             : 0,
        tokcol          : 0,
        newline_before  : false,
        regex_allowed   : false,
        comments_before : []
    };
    
    function peek() {
        return S.text.charAt(S.pos);
    }
    
    function next(signal_eof) {
        var ch = S.text.charAt(S.pos++);
        if (signal_eof && !ch) throw EX_EOF;
        if (ch == "\n") {
            S.newline_before = true;
            ++S.line;
            S.col = 0;
        }
        else {
            ++S.col;
        }
        return ch;
    }
    
    function eof() {
        return !S.peek();
    }
    
    function find(what, signal_eof) {
        var pos = S.text.indexOf(what, S.pos);
        if (signal_eof && pos == -1) throw EX_EOF;
        return pos;
    }
    
    function start_token() {
        S.tokline = S.line;
        S.tokcol = S.col;
        S.tokpos = S.pos;
    }
    
    function token(type, value, is_comment) {
        S.regex_allowed = ((type == "operator" && !HOP(UNARY_POSTFIX, value)) ||
                           (type == "keyword" && HOP(KEYWORDS_BEFORE_EXPRESSION, value)) ||
                           (type == "punc" && HOP(PUNC_BEFORE_EXPRESSION, value)));
        var ret = {
            type  : type,
            value : value,
            line  : S.tokline,
            col   : S.tokcol,
            pos   : S.tokpos,
            nlb   : S.newline_before
        };
        if (!is_comment) {
            ret.comments_before = S.comments_before;
            S.comments_before = [];
        }
        S.newline_before = false;
        return ret;
    }
    
    function skip_whitespace() {
        while (HOP(WHITESPACE_CHARS, peek()))
            next();
    }
    
    function read_while(pred) {
        var ret = "", ch = peek(), i = 0;
        while (ch && pred(ch, i++)) {
            ret += next();
            ch = peek();
        }
        return ret;
    }
    
    function parse_error(err) {
        js_error(err, S.tokline, S.tokcol, S.tokpos);
    }
    
    function read_num(prefix) {
        var has_e = false,
            after_e = false,
            has_x = false,
            has_dot = prefix == ".";
        var num = read_while(function(ch, i) {
            if (ch == "x" || ch == "X") {
                if (has_x) return false;
                return has_x = true;
            }
            if (!has_x && (ch == "E" || ch == "e")) {
                if (has_e) return false;
                return has_e = after_e = true;
            }
            if (ch == "-") {
                if (after_e || (i == 0 && !prefix)) return true;
                return false;
            }
            if (ch == "+") return after_e;
            after_e = false;
            if (ch == ".") {
                if (!has_dot && !has_x) return has_dot = true;
                return false;
            }
            return is_alphanumeric_char(ch);
        });
        if (prefix) num = prefix + num;
        var valid = parse_js_number(num);
        return token("num", num);
    }
    
    function read_escaped_char() {
        var ch = next(true);
        switch (ch) {
        case "n":
            return "\n";
        case "r":
            return "\r";
        case "t":
            return "\t";
        case "b":
            return "\b";
        case "v":
            return "\u000b";
        case "f":
            return "\f";
        case "0":
            return "\0";
        case "x":
            return String.fromCharCode(hex_bytes(2));
        case "u":
            return String.fromCharCode(hex_bytes(4));
        case "\n":
            return "";
        default:
            return ch;
        }
    }
    
    function hex_bytes(n) {
        var num = 0;
        for (; n > 0; --n) {
            var digit = parseInt(next(true), 16);
            if (isNaN(digit)) parse_error("Invalid hex-character pattern in string");
            num = (num << 4) | digit;
        }
        return num;
    }
    
    function read_string() {
        return with_eof_error("Unterminated string constant", function(){
            var quote = next(), ret = "";
            for (;;) {
                var ch = next(true);
                if (ch == "\\") {
                    // read OctalEscapeSequence (XXX: deprecated if "strict mode")
                    // https://github.com/mishoo/UglifyJS/issues/178
                    var octal_len = 0, first = null;
                    ch = read_while(function(ch){
                        if (ch >= "0" && ch <= "7") {
                            if (!first) {
                                first = ch;
                                return ++octal_len;
                            }
                            else if (first <= "3" && octal_len <= 2) return ++octal_len;
                            else if (first >= "4" && octal_len <= 1) return ++octal_len;
                        }
                        return false;
                    });
                    if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8));
                    else ch = read_escaped_char();
                }
                else if (ch == quote) break;
                ret += ch;
            }
            return token("string", ret);
        });
    }
    
    function read_line_comment() {
        next();
        var i = find("\n"), ret;
        if (i == -1) {
            ret = S.text.substr(S.pos);
            S.pos = S.text.length;
        } else {
            ret = S.text.substring(S.pos, i);
            S.pos = i;
        }
        return token("comment1", ret, true);
    }
    
    function read_multiline_comment() {
        next();
        return with_eof_error("Unterminated multiline comment", function() {
            var i = find("*/", true),
                text = S.text.substring(S.pos, i),
                tok = token("comment2", text, true);
            S.pos = i + 2;
            S.line += text.split("\n").length - 1;
            S.newline_before = text.indexOf("\n") >= 0;
            // https://github.com/mishoo/UglifyJS/issues/#issue/100
            if (/^@cc_on/i.test(text)) {
                warn("WARNING: at line " + S.line);
                warn("*** Found \"conditional comment\": " + text);
                warn("*** UglifyJS DISCARDS ALL COMMENTS.  This means your code might no longer work properly in Internet Explorer.");
            }
            return tok;
        });
    }
    
    function read_name() {
        var backslash = false,
            name = "",
            ch;
        while ((ch = peek()) != null) {
            if (!backslash) {
                if (ch == "\\") backslash = true, next();
                else if (is_identifier_char(ch)) name += next();
                else break;
            }
            else {
                if (ch != "u") parse_error("Expecting UnicodeEscapeSequence -- uXXXX");
                ch = read_escaped_char();
                if (!is_identifier_char(ch)) parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier");
                name += ch;
                backslash = false;
            }
        }
        return name;
    }
    
    function read_regexp(regexp) {
        return with_eof_error("Unterminated regular expression", function() {
            var prev_backslash = false,
                ch, in_class = false;
            while ((ch = next(true))) if (prev_backslash) {
                regexp += "\\" + ch;
                prev_backslash = false;
            }
            else if (ch == "[") {
                in_class = true;
                regexp += ch;
            }
            else if (ch == "]" && in_class) {
                in_class = false;
                regexp += ch;
            }
            else if (ch == "/" && !in_class) {
                break;
            }
            else if (ch == "\\") {
                prev_backslash = true;
            }
            else {
                regexp += ch;
            }
            var mods = read_name();
            return token("regexp", [regexp, mods]);
        });
    }
    
    function read_operator(prefix) {
        function grow(op) {
            if (!peek()) return op;
            var bigger = op + peek();
            if (HOP(OPERATORS, bigger)) {
                next();
                return grow(bigger);
            }
            else {
                return op;
            }
        };
        return token("operator", grow(prefix || next()));
    }
    
    function handle_slash() {
        next();
        var regex_allowed = S.regex_allowed;
        switch (peek()) {
        case "/":
            S.comments_before.push(read_line_comment());
            S.regex_allowed = regex_allowed;
            return next_token();
        case "*":
            S.comments_before.push(read_multiline_comment());
            S.regex_allowed = regex_allowed;
            return next_token();
        }
        return S.regex_allowed ? read_regexp("") : read_operator("/");
    }
    
    function handle_dot() {
        next();
        return is_digit(peek()) ? read_num(".") : token("punc", ".");
    }
    
    function read_word() {
        var word = read_name();
        return !HOP(KEYWORDS, word)
                ? token("name", word)
                : HOP(OPERATORS, word)
                ? token("operator", word)
                : HOP(KEYWORDS_ATOM, word)
                ? token("atom", word)
                : token("keyword", word);
    };
    
    function with_eof_error(eof_error, cont) {
        try {
            return cont();
        }
        catch (ex) {
            if (ex === EX_EOF) parse_error(eof_error);
            else throw ex;
        }
    }
    
    function next_token(force_regexp) {
        if (force_regexp != null) return read_regexp(force_regexp);
        skip_whitespace();
        start_token();
        var ch = peek();
        if (!ch) return token("eof");
        if (is_digit(ch)) return read_num();
        if (ch == '"' || ch == "'") return read_string();
        if (HOP(PUNC_CHARS, ch)) return token("punc", next());
        if (ch == ".") return handle_dot();
        if (ch == "/") return handle_slash();
        if (HOP(OPERATOR_CHARS, ch)) return read_operator();
        if (ch == "\\" || is_identifier_start(ch)) return read_word();
        parse_error("Unexpected character '" + ch + "'");
    }
    
    next_token.context = function(nc) {
        if (nc) S = nc;
        return S;
    };
    
    return next_token;
}

/* -----[ Parser (constants) ]----- */

var UNARY_PREFIX = array_to_hash([
        "typeof",
        "void",
        "delete",
        "--",
        "++",
        "!",
        "~",
        "-",
        "+"
]);

var UNARY_POSTFIX = array_to_hash([ "--", "++" ]);

var ASSIGNMENT = (function(a, ret, i) {
    while (i < a.length) {
        ret[a[i]] = a[i].substr(0, a[i].length - 1);
        i++;
    }
    return ret;
})(["+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&="], {
    "=": true
}, 0);

var PRECEDENCE = (function(a, ret) {
    for (var i = 0, n = 1; i < a.length; ++i, ++n) {
        var b = a[i];
        for (var j = 0; j < b.length; ++j) {
            ret[b[j]] = n;
        }
    }
    return ret;
})([
    ["||"],
    ["&&"],
    ["|"],
    ["^"],
    ["&"],
    ["==", "===", "!=", "!=="],
    ["<", ">", "<=", ">=", "in", "instanceof"],
    [">>", "<<", ">>>"],
    ["+", "-"],
    ["*", "/", "%"]
], {});

var STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ]);
var ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]);

/* -----[ Parser ]----- */

function NodeWithToken(str, start, end) {
    this.name = str;
    this.start = start;
    this.end = end;
}

NodeWithToken.prototype.toString = function() {
    return this.name;
};

function parse($TEXT, exigent_mode, embed_tokens) {
    var S = {
        input       : typeof $TEXT == "string" ? tokenizer($TEXT, true) : $TEXT,
        token       : null,
        prev        : null,
        peeked      : null,
        in_function : 0,
        in_loop     : 0,
        labels      : [],
        line        : 0,
        col         : 0,
        error       : null
    };

    S.token = next();

    function is(type, value) {
        return is_token(S.token, type, value);
    }

    function peek() {
        return S.peeked || (S.peeked = S.input());
    }
    
    function register_error(message, token) {
        if (!token)
            token = S.token;
        if(!S.error)
            S.error = {line: token.line, col: token.col, message: message};
    }
    
    function next() {
        S.prev = S.token;
        var context = S.input.context();
        S.line = context.line;
        S.col = context.col;
        if (S.peeked) {
            S.token = S.peeked;
            S.peeked = null;
        }
        else {
            S.token = S.input();
        }
        return S.token;
    }
    
    function prev() {
        return S.prev;
    }
    
    function croak(msg, line, col, pos) {
        var ctx = S.input.context();
        js_error(msg,
                 line != null ? line : ctx.tokline,
                 col != null ? col : ctx.tokcol,
                 pos != null ? pos : ctx.tokpos);
    }

    function token_error(token, msg) {
        // RECOVERY
        register_error(msg, token);
        // croak(msg, token.line, token.col);
    }

    function unexpected(token) {
        // RECOVERY
        if (token == null)
            token = S.token;
        register_error("Unexpected token: " + token.type + " (" + token.value + ")", token);
        /*if (token == null)
            token = S.token;
        token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");*/
    }

    function expect_token(type, val) {
        if (is(type, val)) {
            return next();
        }
        register_error("Unexpected token " + S.token.type + ", expected " + type, S.token);
    }
    
    function expect(punc) {
        // RECOVER
        if(is("punc", punc))
           return next();
        
        register_error("Expected: " + punc);
        // return expect_token("punc", punc);
    }

    function can_insert_semicolon() {
        return !exigent_mode && (S.token.nlb || is("eof") || is("punc", "}"));
    }
    
    function semicolon() {
        // RECOVER
        if (is("punc", ";")) 
            next();
        else if (!can_insert_semicolon())
            register_error("Semicolon expected");
    }

    function as() {
       return slice(arguments);
    }

    function parenthesised() {
        if(!is("punc", "(")) {
            // RECOVER
            register_error("Expected: (");
            return as("ERROR");
        }
        expect("(");
        var ex = expression();
        expect(")");
        return ex;
    }

    function add_tokens(str, start, end) {
        return str instanceof NodeWithToken ? str : new NodeWithToken(str, start, end);
    }

    function maybe_embed_tokens(parser) {
        if (embed_tokens) return function() {
            var start = S.token;
            var ast = parser.apply(this, arguments);
            if (!ast) {
                register_error("Parse error");
                return ["ERROR"];
            }
            ast[0] = add_tokens(ast[0], start, prev());
            return ast;
        };
        else return parser;
    }
    
    var statement = maybe_embed_tokens(function() {
        if (is("operator", "/") || is("operator", "/=")) {
            S.peeked = null;
            S.token = S.input(S.token.value.substr(1)); // force regexp
        }
        switch (S.token.type) {
        case "num":
        case "string":
        case "regexp":
        case "operator":
        case "atom":
            return simple_statement();

        case "name":
            return is_token(peek(), "punc", ":")
                    ? labeled_statement(prog1(S.token.value, next, next))
                    : simple_statement();

        case "punc":
            switch (S.token.value) {
            case "{":
                return as("block", block_());
            case "[":
            case "(":
                return simple_statement();
            case ";":
                next();
                return as("block");
            default:
                // RECOVER
                next();
                register_error("Bracket expected.");
                return as("ERROR");
                //unexpected();
            }

        case "keyword":
            switch (prog1(S.token.value, next)) {
            case "break":
                return break_cont("break");

            case "continue":
                return break_cont("continue");

            case "debugger":
                semicolon();
                return as("debugger");

            case "do":
                return (function(body) {
                    // RECOVER
                    if (is("keyword", "while")) {
                        expect_token("keyword", "while");
                        return as("do", prog1(parenthesised, semicolon), body);
                    }
                    else {
                        register_error("Invalid do statement.");
                        return as("do", as("ERROR"), as("ERROR"));
                    }
                })(in_loop(statement));
            case "for":
                return for_();

            case "function":
                return function_(true);

            case "if":
                return if_();

            case "return":
                // RECOVERY
                if (S.in_function == 0)
                    register_error("'return' outside of function");
                return as("return",
                          is("punc", ";")
                          ? (next(), null)
                          : can_insert_semicolon()
                          ? null
                          : prog1(expression, semicolon));

            case "switch":
                return as("switch", parenthesised(), switch_block_());

            case "throw":
                if (S.token.nlb)
                    croak("Illegal newline after 'throw'");
                return as("throw", prog1(expression, semicolon));

            case "try":
                return try_();

            case "var":
                return prog1(var_, semicolon);
                
            case "let":
                return prog1(let_, semicolon);

            case "const":
                return prog1(const_, semicolon);

            case "while":
                return as("while", parenthesised(), in_loop(statement));

            case "with":
                return as("with", parenthesised(), statement());

            default:
                unexpected();
            }
        }
    });

    function labeled_statement(label) {
        S.labels.push(label);
        var start = S.token,
            stat = statement();
        if (exigent_mode && !HOP(STATEMENTS_WITH_LABELS, stat[0])) unexpected(start);
        S.labels.pop();
        return as("label", label, stat);
    }
    
    function simple_statement() {
        return as("stat", prog1(expression, semicolon));
    }
    
    function break_cont(type) {
        var name;
        if (!can_insert_semicolon()) {
            name = is("name") ? S.token.value : null;
        }
        if (name != null) {
            next();
            if (!member(name, S.labels)) croak("Label " + name + " without matching loop or statement");
        }
        else if (S.in_loop == 0) croak(type + " not inside a loop or switch");
        semicolon();
        return as(type, name);
    }

    function for_() {
        // RECOVER
        if(!is("punc", "(")) {
            register_error("Expected: (");
            return as("for", as("ERROR"), as("ERROR"), as("ERROR"), as("ERROR"));
        } else {
            expect("(");
            var init = null;
            if (!is("punc", ";")) {
                if(is("keyword", "var"))
                    init = (next(), var_(true));
                else if(is("keyword", "let"))
                    init = (next(), let_(true));
                else
                    init = expression(true, true);
                if (is("operator", "in"))
                        return for_in(init);
            }
            return regular_for(init);
        }
    }

    function regular_for(init) {
        expect(";");
        var test = is("punc", ";") ? null : expression();
        // RECOVER
        if(is("punc", ";")) {
            expect(";");
            var step = is("punc", ")") ? null : expression();
            expect(")");
        }
        else {
            register_error("Expected: ;");
        }
        return as("for", init, test, step, in_loop(statement));
    };

    function for_in(init) {
        var lhs;
        if(init[0] == "var")
            lhs = as("name", init[1][0]);
        else if(init[0] == "let")
            lhs = as("name", init[1][0]);
        else
            lhs = init;
        next();
        var obj = expression();
        expect(")");
        return as("for-in", init, lhs, obj, in_loop(statement));
    }

    var function_ = maybe_embed_tokens(function(in_statement) {
        var prev = S.token;
        var name = is("name") ? prog1(S.token.value, next) : null;
        name = add_tokens(name, prev, S.token);
        if (in_statement && !name) {
            // RECOVER
            register_error("Invalid function definition");
            return as("function", "", [], []);
        }
        expect("(");
        return as(in_statement ? "defun" : "function", name,
        // arguments
        (function(first, a) {
            while (!is("punc", ")") && !is("eof")) {
                if (first) first = false;
                else expect(",");
                if (!is("name")) unexpected();
                a.push(add_tokens(S.token.value, S.token));
                next();
            }
            next();
            return a;
        })(true, []),
        // body
        (function() {
            ++S.in_function;
            var loop = S.in_loop;
            S.in_loop = 0;
            var a = block_();
            --S.in_function;
            S.in_loop = loop;
            return a;
        })());
    });
    
    function if_() {
        var cond = parenthesised(),
            body = statement(),
            belse;
        if (is("keyword", "else")) {
            next();
            belse = statement();
        }
        return as("if", cond, body, belse);
    };
    
    function block_() {
        expect("{");
        var a = [];
        while (!is("punc", "}")) {
            if (is("eof")) {
                // RECOVERY
                //unexpected();
                return a;
            }
            a.push(statement());
        }
        next();
        return a;
    };
    
    var switch_block_ = curry(in_loop, function() {
        // RECOVER
        if (is("punc", "{")) expect("{");
        var a = [],
            cur = null;
        while (!is("punc", "}")) {
            if (is("eof")) {
                // RECOVER
                break;
                //unexpected();
            }
            if (is("keyword", "case")) {
                next();
                cur = [];
                a.push([expression(), cur]);
                expect(":");
            }
            else if (is("keyword", "default")) {
                next();
                expect(":");
                cur = [];
                a.push([null, cur]);
            }
            else {
                if (!cur) {
                    // RECOVER
                    //unexpected();
                    return a;
                }
                cur.push(statement());
            }
        }
        next();
        return a;
    });
    
    function try_() {
        var body = block_(),
            bcatch, bfinally;
        if (is("keyword", "catch")) {
            next();
            expect("(");
            if (!is("name")) croak("Name expected");
            var name = S.token.value;
            next();
            expect(")");
            bcatch = [name, block_()];
        }
        if (is("keyword", "finally")) {
            next();
            bfinally = block_();
        }
        if (!bcatch && !bfinally) croak("Missing catch/finally blocks");
        return as("try", body, bcatch, bfinally);
    }
    
    function vardefs(no_in) {
        var a = [];
        for (;;) {
            if (!is("name")) unexpected();
            var prev = S.token;
            var name = S.token.value;
            next();
            name = add_tokens(name, prev, S.token);
            if (is("operator", "=")) {
                next();
                a.push([name, expression(false, no_in)]);
            }
            else {
                a.push([name]);
            }
            if (!is("punc", ",")) break;
            next();
        }
        return a;
    }
    
    function var_(no_in) {
        return as("var", vardefs(no_in));
    }
    
    function let_(no_in) {
        return as("let", vardefs(no_in));
    }
    
    function const_() {
        return as("const", vardefs());
    }
    
    function new_() {
        var newexp = expr_atom(false),
            args;
        if (is("punc", "(")) {
            next();
            args = expr_list(")");
        }
        else {
            args = [];
        }
        return subscripts(as("new", newexp, args), true);
    }
    
    var expr_atom = maybe_embed_tokens(function(allow_calls) {
        if (is("operator", "new")) {
            next();
            return new_();
        }
        if (is("punc")) {
            switch (S.token.value) {
            case "(":
                next();
                return subscripts(prog1(expression, function() {
                    // RECOVER
                    // curry(expect, ")")
                    expect(")");
                }), allow_calls);
            case "[":
                next();
                return subscripts(array_(), allow_calls);
            case "{":
                next();
                return subscripts(object_(), allow_calls);
            }
            // RECOVER
            register_error("Bracket expected.");
            return as("ERROR");
            //unexpected();
        }
        if (is("keyword", "function")) {
            next();
            return subscripts(function_(false), allow_calls);
        }
        if (HOP(ATOMIC_START_TOKEN, S.token.type)) {
            var atom = S.token.type == "regexp"
                    ? as("regexp", S.token.value[0], S.token.value[1])
                    : as(S.token.type, S.token.value);
            return subscripts(prog1(atom, next), allow_calls);
        }
        unexpected();
    });

    function expr_list(closing, allow_trailing_comma, allow_empty) {
        var first = true,
            a = [];
        while (!is("punc", closing) && !is("eof")) {
            if (first) first = false;
            else expect(",");
            if (allow_trailing_comma && is("punc", closing)) break;
            if (is("punc", ",") && allow_empty) {
                a.push(["atom", "undefined"]);
            }
            else {
                a.push(expression(false));
            }
        }
        next();
        return a;
    }
    
    function array_() {
        return as("array", expr_list("]", !exigent_mode, true));
    }
    
    function object_() {
        var first = true,
            a = [];
        while (!is("punc", "}") && !is("eof")) {
            if (first) first = false;
            else expect(",");
            if (!exigent_mode && is("punc", "}"))
                // allow trailing comma
                break;
            var type = S.token.type;
            
            var name = as_property_name();
            if (type == "name" && (name == "get" || name == "set") && !is("punc", ":")) {
                a.push([as_name(), function_(false), name]);
            }
            else {
                expect(":");
                a.push([name, expression(false)]);
            }
        }
        next();
        return as("object", a);
    }
    
    function as_property_name() {
        switch (S.token.type) {
        case "num":
        case "string":
            return prog1(S.token.value, next);
        }
        return as_name();
    };
    
    function as_name() {
        switch (S.token.type) {
        case "name":
        case "operator":
        case "keyword":
        case "atom":
            return prog1(S.token.value, next);
        default:
            //unexpected();
            // RECOVER: Return empty token
            register_error("Name, operator, keyword or atom expected.");
            return ""; // prog1("", next);
        }
    };
    
    function insert_token(ast, prev) {
        ast[0] = add_tokens(ast[0], prev, S.token);
        return ast;
    }
    
    function subscripts(expr, allow_calls) {
        var p = S.prev;
        if(!(expr[0] instanceof NodeWithToken)) {
            expr = insert_token(expr, p);
        }
        if (is("punc", ".")) {
            next();
            return subscripts(insert_token(as("dot", expr, as_name()), p), allow_calls);
        }
        if (is("punc", "[")) {
            next();
            return subscripts(as("sub", expr, prog1(expression, curry(expect, "]"))), allow_calls);
        }
        if (allow_calls && is("punc", "(")) {
            next();
            return subscripts(as("call", expr, expr_list(")")), true);
        }
        return expr;
    }
    
    function maybe_unary(allow_calls) {
        if (is("operator") && HOP(UNARY_PREFIX, S.token.value)) {
            return make_unary("unary-prefix", prog1(S.token.value, next), maybe_unary(allow_calls));
        }
        var val = expr_atom(allow_calls);
        while (is("operator") && HOP(UNARY_POSTFIX, S.token.value) && !S.token.nlb) {
            val = make_unary("unary-postfix", S.token.value, val);
            next();
        }
        return val;
    }
    
    function make_unary(tag, op, expr) {
        if ((op == "++" || op == "--") && !is_assignable(expr)) croak("Invalid use of " + op + " operator");
        return as(tag, op, expr);
    }
    
    function expr_op(left, min_prec, no_in) {
        var op = is("operator") ? S.token.value : null;
        if (op && op == "in" && no_in) op = null;
        var prec = op != null ? PRECEDENCE[op] : null;
        if (prec != null && prec > min_prec) {
            next();
            var right = expr_op(maybe_unary(true), prec, no_in);
            return expr_op(as("binary", op, left, right), min_prec, no_in);
        }
        return left;
    }
    
    function expr_ops(no_in) {
        return expr_op(maybe_unary(true), 0, no_in);
    }
    
    function maybe_conditional(no_in) {
        var expr = expr_ops(no_in);
        if (is("operator", "?")) {
            next();
            var yes = expression(false);
            expect(":");
            return as("conditional", expr, yes, expression(false, no_in));
        }
        return expr;
    }
    
    function is_assignable(expr) {
        if (!exigent_mode) return true;
        switch (expr[0] + "") {
        case "dot":
        case "sub":
        case "new":
        case "call":
            return true;
        case "name":
            return expr[1] != "this";
        }
    }
    
    function maybe_assign(no_in) {
        var left = maybe_conditional(no_in),
            val = S.token.value;
        if (is("operator") && HOP(ASSIGNMENT, val)) {
            if (is_assignable(left)) {
                next();
                return as("assign", ASSIGNMENT[val], left, maybe_assign(no_in));
            }
            croak("Invalid assignment");
        }
        return left;
    }
    
    var expression = maybe_embed_tokens(function(commas, no_in) {
        if (arguments.length == 0) commas = true;
        // RECOVER: prevent infinite loops
        var oldLine = S.line;
        var oldCol = S.col;
        //
        var expr = maybe_assign(no_in);
        if (commas && is("punc", ",")) {
            next();
            return as("seq", expr, expression(true, no_in));
        }
        if(S.col === oldCol && S.line === oldLine) {
            // RECOVER: Preventing infinite loops here
            next();
        }
        return expr;
    });
    
    function in_loop(cont) {
        try {
            ++S.in_loop;
            return cont();
        }
        finally {
            --S.in_loop;
        }
    }
    
    return {
        ast: as("toplevel", (function(a) {
            while (!is("eof"))
            a.push(statement());
            return a;
        })([])),
        error: S.error
    };
};

/* -----[ Utilities ]----- */

function curry(f) {
    var args = slice(arguments, 1);
    return function() {
        return f.apply(this, args.concat(slice(arguments)));
    };
}

function prog1(ret) {
    if (ret instanceof Function) ret = ret();
    for (var i = 1, n = arguments.length; --n > 0; ++i)
    arguments[i]();
    return ret;
}

function array_to_hash(a) {
    var ret = {};
    for (var i = 0; i < a.length; ++i)
    ret[a[i]] = true;
    return ret;
}

function slice(a, start) {
    return Array.prototype.slice.call(a, start || 0);
}

function characters(str) {
    return str.split("");
}

function member(name, array) {
    for (var i = array.length; --i >= 0;)
    if (array[i] === name) return true;
    return false;
}

function HOP(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}

var warn = function() {};

/* -----[ Exports ]----- */

exports.tokenizer = tokenizer;
exports.parse = parse;
exports.slice = slice;
exports.curry = curry;
exports.member = member;
exports.array_to_hash = array_to_hash;
exports.PRECEDENCE = PRECEDENCE;
exports.KEYWORDS_ATOM = KEYWORDS_ATOM;
exports.RESERVED_WORDS = RESERVED_WORDS;
exports.KEYWORDS = KEYWORDS;
exports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;
exports.OPERATORS = OPERATORS;
exports.is_alphanumeric_char = is_alphanumeric_char;
exports.set_logger = function(logger) {
    warn = logger;
};

});
define('treehugger/js/parse',['require','exports','module','treehugger/js/uglifyparser','treehugger/tree'],function(require, exports, module) {

var parser = require("treehugger/js/uglifyparser");
var tree = require('treehugger/tree');

exports.parse = function(s) {
    var result = parser.parse(s, false, true);
    var node = exports.transform(result.ast);
    if(result.error)
        node.setAnnotation("error", result.error);
    return node;
};


function setIdPos(oNode, node) {
    if(!oNode.name)
        oNode.name = "";
    node.setAnnotation("pos", {
        sl: oNode.start.line,
        sc: oNode.start.col,
        // Let's not rely on what Uglify is telling us here
        el: oNode.start.line,
        ec: oNode.start.col + oNode.name.length
    });
    return node;
}

exports.transform = function(n) {
    if (!n) {
        return tree.cons("None", []);
    }
    var transform = exports.transform; 
    var nodeName = typeof n[0] === 'string' ? n[0] : n[0].name;
    
    var resultNode;
    
    switch(nodeName) {
        case "toplevel":
            resultNode = tree.list(n[1].map(transform));
            break;
        case "var":
            resultNode = tree.cons("VarDecls", [tree.list(n[1].map(function(varNode) {
                var idNode = tree.string(varNode[0].name);
                setIdPos(varNode[0], idNode);
                if(varNode[1])
                    return tree.cons("VarDeclInit", [idNode, transform(varNode[1])]);
                else
                    return tree.cons("VarDecl", [idNode]);
            }))]);
            break;
        case "let":
            resultNode = tree.cons("LetDecls", [tree.list(n[1].map(function(varNode) {
                var idNode = tree.string(varNode[0].name);
                setIdPos(varNode[0], idNode);
                if(varNode[1])
                    return tree.cons("LetDeclInit", [idNode, transform(varNode[1])]);
                else
                    return tree.cons("LetDecl", [idNode]);
            }))]);
            break;
        case "const":
            resultNode = tree.cons("ConstDecls", [tree.list(n[1].map(function(varNode) {
                return tree.cons("ConstDeclInit", [tree.string(varNode[0]), transform(varNode[1])]);
            }))]);
            break;
        case "num":
            resultNode = tree.cons("Num", [tree.string(n[1])]);
            break;
        case "string":
            resultNode = tree.cons("String", [tree.string(n[1])]);
            break;
        case "stat":
            return transform(n[1]);
        case "call":
            resultNode = tree.cons("Call", [transform(n[1]), tree.list(n[2].map(transform))]);
            break;
        case "return":
            resultNode = tree.cons("Return", [transform(n[1])]);
            break;
        case "new":
            resultNode = tree.cons("New", [transform(n[1]), tree.list(n[2].map(transform))]);
            break;
        case "object":
            resultNode = tree.cons("ObjectInit", [tree.list(n[1].map(function(propInit) {
                return tree.cons("PropertyInit", [tree.string(propInit[0]), transform(propInit[1])]);
            }))]);
            break;
        case "array":
            resultNode = tree.cons("Array", [tree.list(n[1].map(transform))]);
            break;
        case "conditional":
            resultNode = tree.cons("TernaryIf", [transform(n[1]), transform(n[2]), transform(n[3])]);
            break;
        case "label":
            resultNode = tree.cons("Label", [tree.string(n[1]), transform(n[2])]);
            break;
        case "continue":
            resultNode = tree.cons("Continue", [tree.string(n[1])]);
            break;
        case "assign":
            if(typeof n[1] === 'string') {
                resultNode = tree.cons("OpAssign", [tree.string(n[1]), transform(n[2]), transform(n[3])]);
            } else {
                resultNode = tree.cons("Assign", [transform(n[2]), transform(n[3])]);
            }
            break;
        case "dot":
            resultNode = tree.cons("PropAccess", [transform(n[1]), tree.string(n[2])]);
            break;
        case "name":
            resultNode = tree.cons("Var", [tree.string(n[1])]);
            break;
        case "defun":
            resultNode = tree.cons("Function", [setIdPos(n[1], tree.string(n[1].name || "")), tree.list(n[2].map(function(arg) {
                return setIdPos(arg, tree.cons("FArg", [tree.string(arg.name)]));
            })), tree.list(n[3].map(transform))]);
            break;
        case "function":
            var funName = tree.string(n[1].name || "");
            if(n[1].name)
                setIdPos(n[1], funName);
            var fargs = tree.list(n[2].map(function(arg) {
                return setIdPos(arg, tree.cons("FArg", [tree.string(arg.name)]));
            }));
            /*if(fargs.length > 0) {
                fargs.setAnnotation("pos", {
                    sl: fargs[0].getPos().sl,
                    sc: fargs[0].getPos().sl,
                    el: fargs[fargs.length - 1].getPos().el,
                    ec: fargs[fargs.length - 1].getPos().ec
                });
            }*/
            resultNode = tree.cons("Function", [funName, fargs, tree.list(n[3].map(transform))]);
            break;
        case "binary":
            resultNode = tree.cons("Op", [tree.string(n[1]), transform(n[2]), transform(n[3])]);
            break;
        case "unary-postfix":
            resultNode = tree.cons("PostfixOp", [tree.string(n[1]), transform(n[2])]);
            break;
        case "unary-prefix":
            resultNode = tree.cons("PrefixOp", [tree.string(n[1]), transform(n[2])]);
            break;
        case "sub":
            resultNode = tree.cons("Index", [transform(n[1]), transform(n[2])]);
            break;
        case "for":
            resultNode = tree.cons("For", [transform(n[1]), transform(n[2]), transform(n[3]), transform(n[4])]);
            break;
        case "for-in":
            resultNode = tree.cons("ForIn", [transform(n[1]), transform(n[3]), transform(n[4])]);
            break;
        case "while":
            resultNode = tree.cons("While", [transform(n[1]), transform(n[2])]);
            break;
        case "do": 
            resultNode = tree.cons("Do", [transform(n[2]), transform(n[1])]);
            break;
        case "switch":
            resultNode = tree.cons("Switch", [transform(n[1]), tree.list(n[2].map(function(opt) {
                return tree.cons("Case", [transform(opt[0]), tree.list(opt[1].map(transform))]);
            }))]);
            break;
        case "break":
            resultNode = tree.cons("Break", []);
            break;
        case "seq":
            resultNode = tree.cons("Seq", [transform(n[1]), transform(n[2])]);
            break;
        case "if":
            resultNode = tree.cons("If", [transform(n[1]), transform(n[2]), transform(n[3])]);
            break;
        case "block":
            resultNode = tree.cons("Block", [tree.list(n[1] ? n[1].map(transform) : [])]);
            break;
        case "regexp":
            resultNode = tree.cons("RegExp", [tree.string(n[1]), tree.string(n[2])]);
            break;
        case "throw":
            resultNode = tree.cons("Throw", [transform(n[1])]);
            break;
        case "try":
            resultNode = tree.cons("Try", [tree.list(n[1].map(transform)),
                 tree.list(n[2] ? [tree.cons("Catch", [tree.string(n[2][0]), tree.list(n[2][1].map(transform))])] : []),
                 n[3] ? tree.list(n[3].map(transform)) : tree.cons("None", [])]);
            break;
        case "with":
            resultNode = tree.cons("With", [transform(n[1]), tree.list(n[2][1].map(transform))]);
            break;
        case "atom":
            resultNode = tree.cons("Atom", []);
            break;
        case "ERROR":
            resultNode = tree.cons("ERROR", []);
            break;
        default:
            console.log("Not yet supported: "+ nodeName);
            console.log("Current node: "+ JSON.stringify(n));
    }

    resultNode.setAnnotation("origin", n);
    if(n[0].start) {
        if(resultNode.length === 1 && resultNode[0] instanceof tree.StringNode && resultNode[0].value) {
            resultNode.setAnnotation("pos", {sl: n[0].start.line, sc: n[0].start.col,
                                             el: n[0].start.line, ec: n[0].start.col + resultNode[0].value.length});
            
        } else {
            resultNode.setAnnotation("pos", {sl: n[0].start.line, sc: n[0].start.col,
                                             el: n[0].end.line,   ec: n[0].end.col});
        }
    }
    return resultNode;
};

});

/*
 RequireJS text 1.0.7 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
 Available via the MIT or new BSD license.
 see: http://github.com/jrburke/requirejs for details
*/
(function(){var k=["Msxml2.XMLHTTP","Microsoft.XMLHTTP","Msxml2.XMLHTTP.4.0"],n=/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,o=/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,i=typeof location!=="undefined"&&location.href,p=i&&location.protocol&&location.protocol.replace(/\:/,""),q=i&&location.hostname,r=i&&(location.port||void 0),j=[];define('text',[],function(){var g,h,l;typeof window!=="undefined"&&window.navigator&&window.document?h=function(a,c){var b=g.createXhr();b.open("GET",a,!0);b.onreadystatechange=
function(){b.readyState===4&&c(b.responseText)};b.send(null)}:typeof process!=="undefined"&&process.versions&&process.versions.node?(l=require.nodeRequire("fs"),h=function(a,c){var b=l.readFileSync(a,"utf8");b.indexOf("\ufeff")===0&&(b=b.substring(1));c(b)}):typeof Packages!=="undefined"&&(h=function(a,c){var b=new java.io.File(a),e=java.lang.System.getProperty("line.separator"),b=new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(b),"utf-8")),d,f,g="";try{d=new java.lang.StringBuffer;
(f=b.readLine())&&f.length()&&f.charAt(0)===65279&&(f=f.substring(1));for(d.append(f);(f=b.readLine())!==null;)d.append(e),d.append(f);g=String(d.toString())}finally{b.close()}c(g)});return g={version:"1.0.7",strip:function(a){if(a){var a=a.replace(n,""),c=a.match(o);c&&(a=c[1])}else a="";return a},jsEscape:function(a){return a.replace(/(['\\])/g,"\\$1").replace(/[\f]/g,"\\f").replace(/[\b]/g,"\\b").replace(/[\n]/g,"\\n").replace(/[\t]/g,"\\t").replace(/[\r]/g,"\\r")},createXhr:function(){var a,c,
b;if(typeof XMLHttpRequest!=="undefined")return new XMLHttpRequest;else for(c=0;c<3;c++){b=k[c];try{a=new ActiveXObject(b)}catch(e){}if(a){k=[b];break}}if(!a)throw Error("createXhr(): XMLHttpRequest not available");return a},get:h,parseName:function(a){var c=!1,b=a.indexOf("."),e=a.substring(0,b),a=a.substring(b+1,a.length),b=a.indexOf("!");b!==-1&&(c=a.substring(b+1,a.length),c=c==="strip",a=a.substring(0,b));return{moduleName:e,ext:a,strip:c}},xdRegExp:/^((\w+)\:)?\/\/([^\/\\]+)/,useXhr:function(a,
c,b,e){var d=g.xdRegExp.exec(a),f;if(!d)return!0;a=d[2];d=d[3];d=d.split(":");f=d[1];d=d[0];return(!a||a===c)&&(!d||d===b)&&(!f&&!d||f===e)},finishLoad:function(a,c,b,e,d){b=c?g.strip(b):b;d.isBuild&&(j[a]=b);e(b)},load:function(a,c,b,e){if(e.isBuild&&!e.inlineText)b();else{var d=g.parseName(a),f=d.moduleName+"."+d.ext,m=c.toUrl(f),h=e&&e.text&&e.text.useXhr||g.useXhr;!i||h(m,p,q,r)?g.get(m,function(c){g.finishLoad(a,d.strip,c,b,e)}):c([f],function(a){g.finishLoad(d.moduleName+"."+d.ext,d.strip,a,
b,e)})}},write:function(a,c,b){if(c in j){var e=g.jsEscape(j[c]);b.asModule(a+"!"+c,"define(function () { return '"+e+"';});\n")}},writeFile:function(a,c,b,e,d){var c=g.parseName(c),f=c.moduleName+"."+c.ext,h=b.toUrl(c.moduleName+"."+c.ext)+".js";g.load(f,b,function(){var b=function(a){return e(h,a)};b.asModule=function(a,b){return e.asModule(a,h,b)};g.write(a,f,b,d)},d)}}})})();

define('text!ext/settings/settings.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:window id="winSettings"\n      skin      = "fm-window"\n      class     = "unselectable"\n      title     = "Preferences"\n      flex      = "1"\n      modal     = "false"\n      model     = "{require(\'ext/settings/settings\').model}"\n      optimize  = "true">\n        <a:hbox\n          anchors  = "0 0 0 0"\n          overflow = "hidden">\n            <a:bar id="barSettings" skinset="prefs" skin="bar-preferences" flex="1" scrollbar="sbShared 2 2 2">\n            </a:bar>\n        </a:hbox>\n    </a:window>\n</a:application>\n';});

define('text!ext/settings/skin.xml',[],function () { return '<?xml version=\'1.0\'?>\n<a:skin xmlns:a="http://ajax.org/2005/aml" xmlns="http://www.w3.org/1999/xhtml">\n    <a:bar name="bar-preferences">\n        <a:style><![CDATA[\n            .bar-preferences {\n                position         : relative;\n                overflow-y       : hidden;\n                overflow-x       : hidden;\n                /*background-image : url(images/panelbg.png);*/\n                color            : #202020;\n                font-family      : Tahoma, Arial;\n                font-size        : 12px;\n                text-shadow : rgba(255, 255, 255, 0.8) 0px 1px 0px;\n            }\n            \n            .bar-preferences .header {\n                background-color : #f6f6f6;\n                height           : 39px;\n                padding          : 0;\n                cursor           : default;\n                border-bottom    : 1px solid white;\n                font-weight      : bold;\n                font-size        : 13px;\n                position         : relative;\n                overflow         : visible;\n                display          : block;\n                font-family      : Tahoma, Arial;\n                font-size        : 13px;\n                color            : #303030;\n                font-weight      : bold;\n                margin           : 5px 4px 10px 4px;\n                \n                text-shadow : none;\n                \n                -moz-border-radius    : 3px;\n                -webkit-border-radius : 3px;\n                \n                -moz-box-shadow: 1px 1px 1px -1px rgba(0, 0, 0, 0.15);\n                -webkit-box-shadow: 1px 1px 1px -1px rgba(0, 0, 0, 0.15);\n                box-shadow: 1px 1px 1px -1px rgba(0, 0, 0, 0.15);\n                \n                filter: progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr=\'#ffffff\', endColorstr=\'#ebebeb\');\n                -ms-filter: "progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr=\'#ffffff\', endColorstr=\'#ebebeb\')";\n                \n                background: -webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 1)), color-stop(1, rgba(235, 235, 235,1)));\n                -webkit-background-origin: padding-box; \n                -webkit-background-clip: content-box;\n                \n                background:-moz-linear-gradient(\n                    center bottom,\n                    rgba(235, 235, 235, 1) 15%,\n                    rgba(255, 255, 255,1) 60%\n                \n                )  repeat scroll 0 0 transparent;\n            }\n            \n            .bar-preferences .header SPAN {\n                background-image    : url(images/preferences.png);\n                background-position : 0 0;\n                background-repeat   : no-repeat;\n                width:21px;\n                height:21px;\n                position:absolute;\n                top:11px;\n                left:10px;\n            }\n            \n            .bar-preferences .header DIV {\n                padding : 12px 0 0 39px;\n            }\n            \n            .bar-preferences .cbcontainer {\n                margin : 0px 0 0 5px;\n            }\n            \n            .bar-preferences .first {\n                margin-top : 10px;\n            }\n            \n            .bar-preferences .underlined,\n            .bar-preferences .underlined2 {\n                border-bottom : 1px dashed #b9b9b9;\n                margin        : 5px 0 0 5px;\n                padding-bottom : 6px;\n                \n                -moz-box-shadow    : 1px 1px 1px -1px rgba(255, 255, 255, 0.5);\n                -webkit-box-shadow : 1px 1px 1px -1px rgba(255, 255, 255, 0.5);\n                box-shadow         : 1px 1px 1px -1px rgba(255, 255, 255, 0.5);\n            }\n            \n            .bar-preferences .underlined2 {\n                margin: 1px 0 0 5px;\n            }\n        ]]></a:style>\n    \n        <a:presentation>\n            <a:main container=".">\n                <div class="bar-preferences">\n                    \n                </div>\n            </a:main>\n        </a:presentation>\n    </a:bar>\n</a:skin>';});

define('text!ext/panels/panels.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:menu id="mnuWindows">\n        <a:item submenu="mnuProjectBar">Project bar</a:item>\n    \t<a:item submenu="mnuTabs">Tabs</a:item>\n    \t<a:item submenu="mnuToolbar">Toolbar</a:item>\n    \t<a:divider />\n    </a:menu>\n    \n    <a:menu id="mnuTabs">\n    </a:menu>\n    \n    <a:menu id="mnuProjectBar">\n    </a:menu>\n    \n    <a:menu id="mnuToolbar">\n    </a:menu>\n</a:application>';});

/*
    TODO:    
    - floating sections or menus
    
    - single page should drag whole tab like button to section does
    - anim should wait x00ms before playing
    
    - tweak tab animations
    - menu should appear onmouseup not down
    
    INTEGRATION
    - add conditional availability of buttons
    - add right click menu to buttons/sections
*/

define('ext/dockpanel/libdock',['require','exports','module'],function(require, exports, module) {

var DockableLayout = module.exports = function(parentHBox, cbFindPage, cbStorePage, cbFindOptions, cbChange, cbAnimate) {
    this.columnCounter  = 0;
    this.$parentHBox    = parentHBox;
    this.$cbFindPage    = cbFindPage;
    this.$cbStorePage   = cbStorePage;
    this.$cbChange      = cbChange;
    this.$cbFindOptions = cbFindOptions;
    this.$cbAnimate     = cbAnimate;
    
    var indicator = this.indicator = document.body.appendChild(document.createElement("div"));
    indicator.style.position = "absolute";
    indicator.style.display = "none";
    indicator.style.border = "3px solid #5c5c5c";
    indicator.style.zIndex = 1000000;
};

(function(){
    var whiledrag, lastInfo, diffPixel = 3;
    var menuCounter = 100;
    var state, lookup; //@todo wrong use of scope. 
    
    function findParentState(data, forceSearch){
        var uniqueId = data.uniqueId;
        if (!uniqueId)
            return;
        var node = lookup[uniqueId].node;
        
        if (!forceSearch && node && node.parentNode)
            return node.parentNode.$dockData;
        else {
            var found;
            state.bars.each(function(bar){
                if (found) return;
                    
                bar.sections.each(function(section){
                    if (found) return;

                    if (section.uniqueId == uniqueId)
                        found = bar;
                    
                    section.buttons.each(function(button){
                        if (found) return;
                        
                        if (button.uniqueId == uniqueId)
                            found = section;
                    });
                    
                });
            });
            
            return found;
        }
    }
    
    function hasVisibleChildren(list){
        for (var i = 0; i < list.length; i++) {
            var l2 = list[i].buttons || list[i].sections;
            if (l2) {
                if (hasVisibleChildren(l2))
                    return true;
            }
            else if (list[i].hidden < 0)
                return true;
        }
        return false;
    }
    
    function findNextKnownNode(list, index){
        for (var i = index; i < list.length; i++) {
            if (list[i].uniqueId 
              && lookup[list[i].uniqueId].node
              && lookup[list[i].uniqueId].node.parentNode)
                return lookup[list[i].uniqueId].node;
        }
    }
    
    function tableCleanup(pNode, btnPNode, oldMenu, b){
        if (!pNode.getPages || !pNode.getPages().length) { //@todo move this to addPage

            if (b) {
                var buttons = btnPNode.$dockData.buttons;
                for (var i = 0; i < buttons.length; i++) {
                    b.insertIndex(buttons[i].$dockData, i);
                }
            }
            
            var barParent = btnPNode.parentNode;
            oldMenu.removeNode();//destroy(true, true);
            
            if (pNode.parentNode)
                oldMenu.appendChild(pNode);
                //pNode.removeNode();//destroy(true, true);
            
            btnPNode.removeNode();//destroy(true, true);
            //lookup[btnPNode.$dockData.uniqueId].node = undefined;
            
            if (!barParent.selectNodes("vbox").length) {
                barParent.removeNode();//destroy(true, true);
                //lookup[barParent.$dockData.uniqueId].node = undefined;
                
                if (barParent.vbox) {
                    barParent.vbox.removeNode();//destroy(true, true);
                    barParent.splitter.removeNode();//destroy(true, true);
                }
            }
            /*else {
                barParent.$dockData.sections.remove(btnPNode.$dockData);
            }*/
        }
    }
    
    function checkBars(){
        var bar, bars = state.bars;
        for (var i = bars.length - 1; i >= 0; i--) {
            bar = bars[i];
            if (bar.cache && bar.cache.childNodes.length == 1) {
                bar.cache.destroy(true, true);
                delete bar.cache;
                //bars.remove(bar);
            }
        }
    }
    
    function registerLookup(node){
        if (!node.$dockData.uniqueId)
            node.$dockData.uniqueId = lookup.push({node: node, data: node.$dockData}) - 1;
        else
            lookup[node.$dockData.uniqueId] = {node: node, data: node.$dockData};
    }
    
    function findNextBar(start){
        var bar = start.nextSibling;
        while (bar) {
            if (bar.localName == "bar" && bar.visible)
                break;
            if (bar.localName == "vbox" && bar.visible) {
                bar = bar.bar;
                break;
            }
            bar = bar.nextSibling;
        }
        return bar != start ? bar : null;
    }
    
    function findPreviousBar(start){
        var bar = start.previousSibling;
        while (bar) {
            if (bar.localName == "bar" && bar.visible)
                break;
            if (bar.localName == "vbox" && bar.visible) {
                bar = bar.bar;
                break;
            }
            bar = bar.previousSibling;
        }
        return bar != start ? bar : null;
    }
    
    function findNextElement(start, type){
        var el = start.nextSibling;
        while (el && !el.visible && (!type || el.localName != type)) {
            el = el.nextSibling;
        }
        return el;
    }
    
    /**
     * Retrieve the current state of the layout as a JSON object
     * 
     */
    this.getState = function(raw){
        if (raw)
            return state;
        
        var copy = {};
        copy.bars = state.bars.slice(0);

        (copy.bars).each(function(bar, i, list){
            bar = list[i] = apf.extend({}, bar);
            //bar.cache = undefined;
            delete bar.cache;
            bar.sections = bar.sections.slice(0);
            
            (bar.sections).each(function(section, i, list){
                section = list[i] = apf.extend({}, section);
                //section.cache = undefined;
                delete section.cache;
                section.buttons = section.buttons.slice(0);
                
                (section.buttons).each(function(button, i, list){
                    button = list[i] = apf.extend({}, button);
                    //button.cache = undefined;
                    delete button.cache;
                });
            });
        });
        
        return JSON.parse(JSON.stringify(copy));
    };
    
    /**
     * Set the current layout via a JSON object
     * @param {Object} obj JSON object with the following structure:
     *  {
     *      bars : [
     *          {
     *              expanded : false,
     *              width : 300,
     *              sections : [
     *                  {
     *                      flex : 1,
     *                      width : 200,
     *                      height : 200,
     *                      buttons : [
     *                          {
     * 
     *                          }
     *                      ]
     *                  }
     *              ]
     *          }
     *      ]
     *  }
     * 
     */
    this.loadState = function(data){
        this.clearState();

        state  = JSON.parse(JSON.stringify(data));
        lookup = [];
        
        if (!state.bars) 
            return;
        
        state.bars.each(function(bar){
            bar.uniqueId = lookup.push({data: bar}) - 1;
            
            bar.sections.each(function(section){
                section.uniqueId = lookup.push({data: section}) - 1;
                
                section.buttons.each(function(button){
                    button.uniqueId = lookup.push({data: button}) - 1;
                });
            });
        });

        var bars = state.bars;
        for (var i = 0; i < bars.length; i++) {
            addBarState.call(this, bars[i]);
        }
    };
    
    /**
     * Destroy full state
     */
    this.clearState = function(){
        if (!state || !state.bars)
            return;
        state.bars.each(function(b) {
            var bar = b.cache;
            if (!bar) return;
            
            if (bar.localName == "bar" && bar.dock) {
                bar.hide();
                if (bar.vbox)
                    bar.vbox.hide();
                var sections = bar.selectNodes("vbox");
                for (var i = 0; i < sections.length; i++) {
                    var buttons = sections[i].selectNodes("button");
                    if (buttons && buttons.length && buttons[0]) {
                        for (var j = 0; j < buttons.length; j++) {
                            buttons[j].hideMenu();
                            buttons[j].$dockpage.parentNode.remove(buttons[j].$dockpage);
                            buttons[j].$dockData.hidden = -1;
                        }
                    }
                }
            }
            else if (!bar.bar) {
                return;
            }
            
            bar.destroy(true, true);
            if (bar.vbox)
                bar.vbox.destroy(true, true);
        });
    };
    
    /**
     * Experimental and probably useless
     *
    this.updateState = function(data, section){
        var before;
        
        if (data.bars) {
            var bars = data.bars;
            for (var i = 0; i < bars.length; i++) {
                if (!bars[i].uniqueId) {
                    var before = findNextKnownNode(bars, i);
                    addBarState.call(this, bars[i], before);
                }
                else
                    this.updateState(bars[i]);
            }
        }
        else if (data.sections) {
            var bar = this.lookup[data.uniqueId];
            
            var sections = data.sections;
            for (var i = 0; i < sections.length; i++) {
                if (!sections[i].uniqueId) {
                    var before = findNextKnownNode(sections, i);
                    addSectionState.call(this, sections[i], before, bar);
                }
                else
                    this.updateState(sections[i]);
            }
            
            //@todo update other states here
        }
        else if (data.buttons) {
            section = section || this.lookup[data.uniqueId];
            
            var buttons = data.buttons;
            for (var i = 0; i < buttons.length; i++) {
                if (!buttons[i].uniqueId) {
                    var before = findNextKnownNode(buttons, i);
                    addButtonState.call(this, buttons[i], before, section);
                }
                else {
                    this.updateState(buttons[i], section);
                }
            }
            
            //@todo update other states here
        }
        else {
            var button = this.lookup[data.uniqueId];
            
            var hidden = state.$dockData.hidden;
            if (button.$dockData.hidden != hidden) {
                if (hidden)
                    buttons[j].$dockpage.parentNode.remove(buttons[j].$dockpage);
                else {
                    return true;
                }
            }
            
            //@todo update other states here
        }
    };*/
    
    this.addTo = function(def, uniqueId) {
        var item = lookup[uniqueId].data;
        
        if (item.buttons) {
            item.buttons.push(def);
        }
        else if (item.sections) {
            item.sections.push(def);
        }
        
        def.uniqueId = lookup.push({data: def}) - 1;
        return def.uniqueId;
    };
    
    this.show = function(uniqueId, byUser){
        var item  = lookup[uniqueId].data;
        var before;
        
        if (!item.bars && !item.sections) {
            var section = findParentState(lookup[uniqueId].data);
            if (!hasVisibleChildren(section.buttons)) {
                
                var bar = findParentState(section);
                if (!hasVisibleChildren(bar.sections)) {
                    section.buttons.each(function(button){
                        if (button.hidden != 2 || button.uniqueId == uniqueId)
                            button.hidden = byUser ? -2 : -1;
                    });
                    
                    before = findNextKnownNode(state.bars, state.bars.indexOf(bar) + 1);
                    addBarState.call(this, bar, before);
                }
                else {
                    section.buttons.each(function(button){
                        if (button.hidden != 2 || button.uniqueId == uniqueId)
                            button.hidden = byUser ? -2 : -1;
                    });
                    
                    before = findNextKnownNode(bar.sections, bar.sections.indexOf(section) + 1);
                    addSectionState.call(this, section, before, lookup[bar.uniqueId].node);
                }
            }
            else {
                if (item.hidden > 0) {
                    item.hidden = byUser ? -2 : -1;
                    before = findNextKnownNode(section.buttons, section.buttons.indexOf(item) + 1);
                    addButtonState.call(this, item, before, lookup[section.uniqueId].node);
                }
                else
                    addButtonState.call(this, item, null, lookup[section.uniqueId].node);
            }
        }
        else {
            (item.bars || [item]).each(function(bar){
                (bar.sections || [bar]).each(function(section){
                    (section.buttons || [section]).each(function(button){
                        //@todo
                    });
                });
            });
        }
    };
    
    this.hide = function(uniqueId, byUser){
        var item  = lookup[uniqueId].data;

        (item.bars || [item]).each(function(bar){
            (bar.sections || [bar]).each(function(section){
                (section.buttons || [section]).each(function(button){
                    button = lookup[button.uniqueId].node;
                    if (button.$dockData.hidden < 0) {
                        button.setValue(false);
                        var page = button.$dockpage;
                        page.parentNode.remove(page, null, true);
                        button.$dockData.hidden = byUser ? 2 : 1;
                    }
                });
            });
        });
    };
    
    this.isExpandedFull = function(node){
        var pNode = node.parentNode;
        while (pNode && pNode.id != "hboxDockPanel") {
            if(pNode.expanded)
                return true;
            pNode = pNode.parentNode;
        }
        return false;
    };
    
    this.isExpanded = function(uniqueId){
        var button = lookup[uniqueId].node;
        if (!button) {
            this.show(uniqueId);
            button = lookup[uniqueId].node;
        }
        
        var bar = findParentState(findParentState(lookup[uniqueId].data));
        return lookup[bar.uniqueId].data.expanded;
    };
    
    this.showMenu = function(uniqueId){
        var button = lookup[uniqueId].node;
        if (!button) {
            this.show(uniqueId);
            button = lookup[uniqueId].node;
        }
        
        button.showMenu();
        
        var tab = button.$dockpage.parentNode;
        if (!tab.activepage)
            tab.set(tab.getPage(0));
    };
    
    this.findBar = function(uniqueId, el){
        var button = lookup[uniqueId].node;
        var node = button && button.parentNode.parentNode;
        
        return el ? node : node.$dockData;
    };
    
    this.findTabs = function(uniqueId, el){
        var bar = lookup[uniqueId].node;
        var nodes = bar.vbox.selectNodes("tab");
        
        if (el)
            return apf.getArrayFromNodelist(nodes);
        
        var list = [];
        for (var i = 0; i < nodes.length; i++) {
            list.push(nodes[i].$dockData);
        }
        
        return list;
    };
    
    function addBarState(state, beforeBar){
        var sections = state.sections;

        if (!hasVisibleChildren(sections))
            return;
        
        var bar = this.$addBar(beforeBar, state);
            
        for (var j = 0; j < sections.length; j++) {
            addSectionState.call(this, sections[j], 
              sections[j].position 
                ? bar.childNodes[sections[j].position]
                : null, bar);
        }
        
        if (state.expanded > 0)
            this.expandBar(bar, state.expanded == 2, true);
    }
    
    function addSectionState(state, beforeState, bar){
        var buttons = state.buttons;
        if (!hasVisibleChildren(buttons))
            return;
        
        var section = this.$addSection(bar, 
            beforeState, 
            null, state);
        
        this.$addMenu(section, state);
        
        for (var k = 0; k < buttons.length; k++) {
            addButtonState.call(this, buttons[k], null, section);
        }
    }
    
    function addButtonState(state, before, section){
        if (state.hidden > 0)
            return;
        
        // code here to throw if no parentNode is set.
        section.parentNode;
        this.$addButton(section, before, section.$menu, 
            this.$addPage(
                this.$cbFindPage(state.ext), 
                before && before.$dockpage,
                section.$menu, 
                state.caption, 
                state.caption && state.caption.toLowerCase() || "",
                section
            ), apf.extend(state, this.$cbFindOptions(state.ext) || {}) //@todo options don't need to be late anymore
        );
    }
    
    function animate(bar, reverse, callback){
        var _self = this;

        if (this.animateControl)
            this.animateControl.stop();
        
        this.animating = true;
    
        bar.show();
        bar.vbox.show();
 
        var from = bar.getWidth();
        var to   = bar.vbox.getWidth() - apf.getWidthDiff(bar.vbox.$ext);

        if (reverse)
            bar.hide();
        else
            bar.vbox.setWidth(from);
        
        var tweens = [
            (reverse
                ? {oHtml: bar.vbox.$ext, type: "width", from: to, to: from}
                : {oHtml: bar.vbox.$ext, type: "width", from: from, to: to})
        ]
        
        var nodes = bar.vbox.getElementsByTagNameNS(apf.ns.aml, "tab");
        nodes.each(function(tab){
            tweens.push(reverse
                ? {oHtml: tab.$ext, type: "fade", from: 1, to: -1}
                : {oHtml: tab.$ext, type: "fade", from: 0, to: 1})
            tab.$ext.style.width = to + "px";
        });

        var options = {
            steps : 6,
            interval : apf.isChrome ? 5 : 5,
            control : this.animateControl = {},
            anim : apf.tween.easeOutCubic,
            tweens : tweens,
            oneach: function(){
                apf.layout.forceResize(bar.vbox.$ext);
            },
            onfinish : function(){
                setTimeout(function(){ 
                    //if (reverse) {
                        nodes.each(function(tab){
                            apf.setOpacity(tab.$ext, 1);
                            tab.$ext.style.width = "";
                        });
                    //}
                });
                bar.vbox.setWidth(to);
                callback && callback();
                _self.animating = false;
            }
        };
        options.onstop = options.onfinish;
        
        apf.tween.multi(document.body, options);
    }
    
    /**
     * Expand a bar
     */
    this.expandBar = function (bar, byUser, showAnimation){
        if (typeof bar == "number")
            bar = lookup[bar].node;
        
        if (this.$currentMenu)
            this.$currentMenu.hide();
        
        var pNode = bar.parentNode || this.$parentHBox;

        if (!bar.vbox) {
            var _self = this;
            bar.vbox = pNode.insertBefore(new apf.vbox({
                padding   : 0,
                width     : bar.$dockData && bar.$dockData.width || 260,
                splitters : true,
                vdock     : 1,
                "class"   : "dockcol unselectable expandedpanel",
                childNodes : [
                    new apf.button({
                        dock       : 1,
                        skin       : "dockheader",
                        "class"    : "expanded",
                        nosplitter : true,
                        height     : 11,
                        resizable  : false,
                        margin     : "0 0 0 0",
                        onclick    : function(){
                            _self.collapseBar(bar, true, true);
                        }
                    })
                ]
            }), bar);

            if (!bar.vbox)
                return;

            var ps = bar.vbox.previousSibling;

            bar.splitter = pNode.insertBefore(new apf.splitter({
                scale   : "right",
                "class" : "splitter-editor-right" + " panelsplitter",//+ (panelSplittersCount > 0 ? " panelsplitter" : ""),
                width   : "0",
                ondragstart : function(){
                    if (_self.$currentMenu)
                        _self.$currentMenu.hide();
                }
            }), bar.vbox);
            
            if (!ps)
                bar.splitter.setAttribute("parent", bar.parentNode.parentNode.parentNode);
            
            bar.splitter.bar = 
            bar.vbox.bar     = bar;
        }
        else {
            pNode.insertBefore(bar.vbox, bar);
            pNode.insertBefore(bar.splitter, bar.vbox);
        }
        
        var vbox = bar.selectNodes("vbox");
        
        for (var i = 0; i < vbox.length; i++) {
            var button  = vbox[i].selectSingleNode("button"),
                menu    = self[button.submenu],
                childEl = menu && menu.firstChild;
            
            if (childEl) {
                childEl.extId = button.$dockData.ext[0];
                bar.vbox.appendChild(childEl);
                if (childEl.skin == "dockbar")
                    childEl.setAttribute("height", 34);
                if (!childEl.flex && childEl.tagName != "bar" && !childEl.noflex)
                    childEl.setAttribute("flex", 1);
            }
        }

        if (bar.vbox) {
            bar.vbox.show();
            bar.vbox.expanded = true; 
            bar.vbox.firstChild.$ext.onmousemove({});
        }
        
        this.findTabs(bar.$dockData.uniqueId, true)
            .each(function(tab){
                if (!tab.activepage)
                    tab.set(tab.getPage(0));
            });
        
        if (false && showAnimation && this.$cbAnimate())
            animate.call(this, bar);
        
        bar.hide();
        bar.expanded = true;
        bar.splitter.show();
        bar.$dockData.expanded = byUser ? 2 : 1;
        
        this.$cbChange();
    };
    
    /**
     * Collapse a bar
     */
    this.collapseBar = function(bar, byUser, showAnimation){
        if (typeof bar == "number")
            bar = lookup[bar].node;
        
        bar.$dockData.expanded = byUser ? -2 : -1;
        bar.expanded = false;

        //if (!hasVisibleChildren(bar.$dockData.sections))
            //return;

        if (this.$currentMenu)
            this.$currentMenu.hide();

        function done(){
            var vboxes = bar.selectNodes("vbox");
            var tabs = bar.vbox.selectNodes("tab");
            for (var i = 0; i < vboxes.length; i++) {
                //What is all this?
                /*if (!vboxes[i].getAttribute("visible")) {
                    skip++;
                    continue;
                }*/
    
                var menu = self[vboxes[i].selectSingleNode("button").submenu];
                menu.appendChild(tabs[i]); //-skip
            }
            
            bar.show();
            bar.vbox.hide();
            bar.parentNode.removeChild(bar.vbox);
            bar.vbox.expanded = false;
            bar.splitter.hide();
        }

        if (false && showAnimation && this.$cbAnimate())
            animate.call(this, bar, true, done);
        else
            done();
        
        //Hack for button
        bar.firstChild.$ext.onmousemove({});
        
        this.$cbChange();
    };
    
    this.$isLastBar = function(aml) {
        var last = this.$parentHBox.lastChild;
        while (last && !last.visible)
            last = last.previousSibling;
        
        return aml == last || aml == last.vbox;
    };

    this.$getLastBar = function(){
        var firstBar = this.$parentHBox.firstChild;
        if (!firstBar)
            return;
        
        if (!firstBar.visible) {
            while (firstBar && !firstBar.visible) {
                firstBar = firstBar.nextSibling;
            }
        }

        if (firstBar.localName != "bar")
            firstBar = firstBar.bar;
           
        //if (lastBar && !lastBar.visible)
            //lastBar = lastBar.vbox;
            
        return firstBar.visible ? firstBar : firstBar.vbox;
    };
    
    /**
     * Starts the docking detection during drag&drop
     */
    this.$startDrag = function (dragged, original){
        var last, state = 0, _self = this;

        apf.setOpacity(dragged.$ext, 0.2);
        
        apf.setStyleClass(dragged.$ext, 'dragging');
        
        var lastBar   = this.$getLastBar();
        var leftEdge  = apf.getAbsolutePosition(lastBar.$ext)[0];
        var indicator = this.indicator;
        
        lastInfo = null;
        
        //Fix, actually bug is in interactive
        apf.addListener(document, "mouseup", function(e){
            apf.removeListener(document, "mousemove", whiledrag);
            apf.removeListener(document, "mouseup", arguments.callee);
        });
        
        apf.addListener(document, "mousemove", whiledrag = function(e){
            if (last) {
                last.$ext.style.borderBottom = "";
                last = null;
            }
            
            if (!e) return;
            
            if (e.button !== 0) {
                document.onmouseup(null, true);
                return;
            }
            
            var indicatorTop = indicator.style.top;
            dragged.$ext.style.top = "-2000px";
            indicator.style.top = "-2000px";
            apf.plane.hide();
            
            var info, aml;
            //Adding a column
            if (e.clientX > leftEdge - 40 && e.clientX < leftEdge) {
                var isSameColumn = dragged.localName == "vbox" 
                    && dragged.$dockbar == lastBar
                    && !dragged.$dockbar.selectNodes("vbox").length;

                info = {
                    position : isSameColumn ? "none" : "left_of_column",
                    aml : aml = last = lastBar
                };
            }
            //Rest
            else {
                info = _self.$calcAction(e, original);
                aml  = last = info.aml;
            }
            
            if (lastInfo && lastInfo.position == info.position && lastInfo.aml == aml) {
                indicator.style.top = indicatorTop;
                //indicator.style.display = "block";
                return;
            }
            
            lastInfo = info;
            
            if (!aml || !aml.dock && !aml.bar) {
                if (!state && false) {
                    state = 1;
                    apf.tween.single(dragged.$ext, {
                        type: "fade",
                        from: 0.2,
                        to  : 1,
                        steps : 20,
                        onfinish : function(){
                            state = 1;
                        }
                    });
                }
                return;
            }

            var borderColor = "rgba(154,190,144,0.50)";
            var borderColor2 = "rgba(154,190,144,0.75)";
            var pos = apf.getAbsolutePosition(aml.$ext);
            indicator.style.left = pos[0] + "px";
            indicator.style.top  = pos[1] + "px";
            indicator.style.display = "block";
            indicator.style.backgroundColor = "";
            indicator.style.borderColor = borderColor;
            indicator.style.marginLeft = "0";
            indicator.innerHTML = "";
            
            if (state && false) {
                state = 0;
                apf.tween.single(dragged.$ext, {
                    type: "fade",
                    from: 1,
                    to  : 0.2,
                    steps : 20,
                    onfinish : function(){
                        state = 0;
                    }
                });
            }
            
            var isDropExpanded = _self.isExpandedFull(info.aml);
            var width = aml.$ext.offsetWidth;
            var height = aml.$ext.offsetHeight;
            switch (info.position) {
                case "before_button":
                case "after_button":
                    indicator.innerHTML = "<div></div><div style='position:absolute'></div>";
                    indicator.style.border = "1px solid " + borderColor2;
                    
                    var pos2 = apf.getAbsolutePosition(aml.parentNode.$ext);
                    indicator.style.left = (pos2[0] - 1) + "px";
                    indicator.style.top  = pos2[1] + "px";
                    width = aml.parentNode.$ext.offsetWidth + 1;
                    height = aml.parentNode.$ext.offsetHeight + 1;
                    
                    var divHead = indicator.firstChild;
                    divHead.style.height = "7px";
                    divHead.style.backgroundColor = borderColor;
                    
                    var div = indicator.childNodes[1];
                    var oBtn = getOriginal("button", original);
                    var isSameElement = aml == oBtn || 
                        findNextElement(aml, "button") == oBtn && info.position == "after_button";
                    if (isSameElement) { //@todo Checks needs to include different representations
                        if (aml != oBtn)
                            pos = apf.getAbsolutePosition(oBtn.$ext);
                        div.style.top = (pos[1] - pos2[1] + 4) + "px";
                        div.style.left = "2px";
                        div.style.right = "3px";
                        div.style.height = (oBtn.$ext.offsetHeight - 9) + "px";
                        div.style.border = "2px solid " + borderColor;
                        div.style.webkitBorderRadius = "4px";
                    }
                    else {
                        div.style.top = (pos[1] - pos2[1]
                            + (info.position == "before_button" ? 0 : aml.$ext.offsetHeight) 
                            ) + "px";
                        div.style.width = "34px";
                        div.style.margin = "0 2px 0 1px";
                        div.style.borderBottom = "3px solid " + borderColor;
                    }
                    
                    break;
                case "in_section":
                    if (getOriginal("section", original) == aml.$dockfor) {//@todo move this
                        indicator.style.borderWidth = "1px 1px 1px 1px";
                        height--;
                    }
                    break;
                case "after_page":
                case "before_page":
                    var pNode = aml.parentNode;
                    var pos2 = apf.getAbsolutePosition(pNode.$ext);
                    indicator.style.left = (pos2[0] + (!isDropExpanded ? 0 : 3)) + "px";
                    indicator.style.top  = (pos2[1] + (!isDropExpanded ? -2 : 3)) + "px";
                    indicator.style.borderColor = borderColor2;
                    width = pNode.$ext.offsetWidth + (!isDropExpanded ? 6 : 2);
                    height = pNode.$ext.offsetHeight + (!isDropExpanded ? 11 : 0);
                    indicator.style.borderWidth = "3px 3px 3px 3px";
                    
                    var compareAml = info.position == "before_page" 
                        ? aml.previousSibling 
                        : aml.nextSibling;
                    var originalAml = getOriginal("page", original);
                    var matchAml = originalAml == aml 
                        ? aml 
                        : (originalAml == compareAml ? compareAml : false);
                    var diff = apf.getAbsolutePosition((matchAml || aml).$button, pNode.$ext);
                    if (matchAml) {
                        indicator.innerHTML = "<div style='position:absolute;'></div><div style='position:absolute;'></div><div style='position:absolute;'></div>";
                        var div1 = indicator.firstChild;
                        var div2 = indicator.childNodes[1];
                        var div3 = indicator.childNodes[2];
                        div1.style.left = (diff[0] - (!isDropExpanded ? 3 : 6)) + "px";
                        div1.style.width = (matchAml.$button.offsetWidth - 6) + "px";
                        div1.style.height = !isDropExpanded ? "16px" : "19px";
                        div1.style.margin = "-19px 0 0 0px";
                        div1.style.border = "3px solid " + borderColor2;
                        div1.style.borderWidth = "3px 3px 0 3px";
                        
                        div2.style.left = (diff[0] + matchAml.$button.offsetWidth - (!isDropExpanded ? 6 : 6)) + "px";
                        div2.style.right = "0px";
                        div3.style.borderBottom =
                        div2.style.borderBottom = "3px solid " + borderColor2;
                        
                        div3.style.left = "0px";
                        div3.style.right = (width - diff[0] - (!isDropExpanded ? 12 : 8)) + "px";
                        
                        indicator.style.borderTop = "0px solid " + borderColor2;
                        indicator.style.top = (pos2[1] + (!isDropExpanded ? 19 : 23)) + "px";
                        height -= 26 + (!isDropExpanded ? 4 : 2);
                        width  -= !isDropExpanded ? 6 : 8;
                    }
                    else {
                        indicator.style.top  = (pos2[1] + (!isDropExpanded ? 0 : 4)) + "px";
                        indicator.innerHTML = "<div style='position:absolute;'><div></div></div>";
                        indicator.firstChild.style.height = "16px";
                        indicator.firstChild.style.width = "7px";
                        indicator.firstChild.style.background = borderColor2;
                        indicator.firstChild.style.top = "0px";
                        indicator.firstChild.firstChild.style.width = "0px";//background = "#5c5c5c";
                        indicator.firstChild.firstChild.style.height = "100%";
                        indicator.firstChild.firstChild.style.margin="0 3px 0 3px";
                        indicator.firstChild.firstChild.style.borderLeft = "1px dotted #666";
                        indicator.firstChild.firstChild.style.opacity = 0.6;
                        
                        var left = (diff[0] + 
                            (info.position == "before_page" ? 0 : aml.$button.offsetWidth));

                        if (left + 7 >= width) {
                            left -= (isDropExpanded ? 11 : 10);
                            indicator.firstChild.style.width = "4px";
                            indicator.firstChild.firstChild.style.marginRight = "0px";
                        }
                        else if (left > 10)
                            left -= (isDropExpanded ? 10 : 7);
                        else {
                            left -= (isDropExpanded ? 3 : 0);
                            indicator.firstChild.style.width = "4px";
                            indicator.firstChild.firstChild.style.marginLeft = "0px";
                        }
                        indicator.firstChild.style.left = left + "px";
                        height -= !isDropExpanded ? 11 : 9;
                        width  -= !isDropExpanded ? 6 : 8;
                    }
                    break;
                case "before_tab":
                    height = 0;
                case "after_tab":
                    indicator.style.left = (pos[0] + 2) + "px";
                    indicator.style.top  = (pos[1] + height - (!aml.nextSibling ? 3 : 0)) + "px";
                    indicator.style.height = "3px";
                    indicator.style.width = (width - 7) + "px";
                    indicator.style.borderWidth = "0 0 0 0";
                    indicator.style.backgroundColor = borderColor2;
                    
                    return;
                case "before_section":
                    height = 0;
                case "after_section":
                    indicator.style.left = pos[0] + "px";
                    indicator.style.top  = (pos[1] + height - 3) + "px";
                    indicator.style.height = "5px";
                    indicator.style.width = aml.$ext.offsetWidth + "px";
                    indicator.style.borderWidth = "0 0 0 0";
                    indicator.innerHTML = "<div style='margin:2px 0 2px 0'></div>";
                    indicator.firstChild.style.backgroundColor = "#5c5c5c";
                    indicator.firstChild.style.height = "1px";
                    indicator.style.backgroundColor = borderColor;
                    return;
                case "in_column":
                    indicator.innerHTML = "<div style='position:absolute'></div>";
                    indicator.style.borderWidth = "0 0 0 0";
                    
                    div = indicator.firstChild;
                    div.style.top = "100%";
                    div.style.borderTop = "3px solid " + borderColor;
                    div.style.height = (dragged.localName == "vbox" ? dragged.$ext.offsetHeight : 50) + "px";
                    div.style.background = "rgba(172,172,172,0.5)";
                    div.style.width = "100%";
                    div.style.webkitBorderRadius = "0 0 4px 4px";
                    
                    /*apf.tween.single(div, {
                        type: "height",
                        from: 0,
                        to  : dragged.localName == "vbox" ? dragged.$ext.offsetHeight : 50,
                        anim : apf.tween.EASEOUT,
                        steps : 20
                    });*/
                    
                    break;
                case "left_of_column":
                    if (aml != _self.$getLastBar()) {
                        indicator.style.borderWidth = "0 0 0 3px";
                        indicator.style.marginLeft = "-1px";
                    }
                    else {
                        indicator.innerHTML = "<div style='position:absolute'></div>";
                        indicator.style.borderWidth = "0 0 0 0";
                        
                        var div = indicator.firstChild;
                        div.style.right = "100%";
                        div.style.width = 0;
                        div.style.height = "100%";
                        div.style.borderRight = "3px solid " + borderColor;
                        div.style.background = "rgba(172,172,172,0.5)";
                        div.style.webkitBorderRadius = "4px 0 0 4px";
                        
                        apf.tween.single(div, {
                            type: "width",
                            from: 0,
                            to  : 40,
                            anim : apf.tween.EASEOUT,
                            steps : 20
                        });
                    }
                    break;
                case "right_of_column":
                    indicator.style.borderWidth = "0 3px 0 0";
                    if (!_self.$isLastBar(aml))
                        indicator.style.marginLeft = "2px";
                    break;
                default:
                    indicator.style.display = "none";
                    //apf.setOpacity(dragged.$ext, 1);
                    apf.setStyleClass(dragged.$ext, '', ['dragging']);
                    break;
            }
            
            diff = apf.getDiff(indicator);
            indicator.style.width  = (width - diff[0]) + "px";
            indicator.style.height = (height - diff[1]) + "px";
        });
        
        whiledrag.dragged  = dragged;
        whiledrag.original = original;
    };
    
    /**
     * Normalize types by converting them to the requested widget type of the
     * conceptual single object
     */
    function getOriginal(type, aml) {
        var buttons;
        if (type == "button") {
            if (aml.localName == "page")
                return aml.$dockbutton;
            if (aml.localName == "divider") {
                buttons = aml.parentNode.selectNodes("button");
                if (buttons.length == 1)
                    return buttons[0];
            }
            return aml;
        }
        else if (type == "page") {
            if (aml.localName == "button")
                return aml.$dockpage;
            if (aml.localName == "divider") {
                buttons = aml.parentNode.selectNodes("button");
                if (buttons.length == 1)
                    return buttons[0].$dockpage;
            }
            return aml;
        }
        else if (type == "section") {
            if (aml.localName == "page" && aml.parentNode.getPages().length == 1)
                return aml.$dockbutton.parentNode;
            if (aml.localName == "divider")
                return aml.parentNode;
            return aml;
        }
    }
    
    function matchTab(pos, y) {
        return y > pos - diffPixel && y < pos + diffPixel;
    }
    
    /**
     * Calculate what action will be performed based on the relative location
     * of the mouse cursor
     */
    this.$calcAction = function(e, original){
        var position = "none";

        var el = document.elementFromPoint(e.clientX, e.clientY);
        if (el == document.body)
            return {};
        
        var aml = apf.findHost(el);
        if (!aml) 
            return {};

        if (aml.localName == "codeeditor") {
            while (aml && !aml.$dockData) {
                aml = aml.bar || aml.parentNode;
            }
        }
        if (!aml)
            return {};

        var pos;
        if (!aml.dock || aml.localName == "page" || aml.localName == "tab") {
            var node = aml;
            while (node && !node.vdock)
                node = node.parentNode;
            
            if (node && node.localName == "vbox") {
                pos = apf.getAbsolutePosition(node.$ext)[1];
                var tabs = node.selectNodes("tab");
                var doTest = original.parentNode.localName == "tab" 
                    && original.parentNode.getPages().length == 1;

                if (matchTab(apf.getAbsolutePosition(tabs[0].$ext, node.$ext)[1] + pos, e.clientY)) {
                    return doTest && original.parentNode == tabs[0] 
                        ? {} : {position: "before_tab", aml: tabs[0]};
                }
                        
                for (var i = 0; i < tabs.length; i++) {
                    if (matchTab(tabs[i].$ext.offsetHeight + 1 
                      + apf.getAbsolutePosition(tabs[i].$ext, node.$ext)[1] + pos - (!aml.nextSibling ? 3 : 0), e.clientY)) {
                        return doTest && (original.parentNode == tabs[i] || original.parentNode == tabs[i+1])
                            ? {} : {position: "after_tab", aml: tabs[i]};
                    }
                }
            }
        }
        
        if (aml.localName == "splitter") {
            //aml.$ext.style.display = "none";
            //aml = apf.findHost(document.elementFromPoint(e.clientX, e.clientY));
            //aml.$ext.style.display = "block";
            aml = aml.nextSibling;
        }
    
        if (!aml.dock && !aml.bar)
            return {};

        var bar = aml;
        while (bar && bar.localName != "bar" && (bar.localName != "vbox" || !bar.dock && !bar.bar))
            bar = bar.parentNode;
    
        var l, r, t, isSameColumn, pages;
        if (bar) {
            pos = apf.getAbsolutePosition(e.target, bar.$ext);
            l = pos[0] + e.offsetX;
            r = bar.$ext.offsetWidth - l;
        }
        
        if (bar && l < diffPixel) {
            aml = bar.parentNode.localName == "bar" ? bar.parentNode : bar;
            isSameColumn = 
                (original.localName == "divider" 
                  && (original.parentNode.$dockbar == aml
                    || original.parentNode.$dockbar == findPreviousBar(aml))
                  && !original.parentNode.$dockbar.selectNodes("vbox").length
                || original.localName == "button" && original.parentNode.childNodes.length == 2
                  && (original.parentNode.parentNode == aml
                    || original.parentNode.parentnode == findPreviousBar(aml))
                || original.localName == "page" && original.parentNode.getPages().length == 1
                  && (original.$dockbutton.parentNode.parentNode == (aml.bar || aml)
                    || original.$dockbutton.parentNode.parentNode == findPreviousBar(aml))
                );

            return {
                position : isSameColumn ? "none" : "left_of_column",
                aml : aml
            };
        }
        else if (bar) {
            if (!bar)
                return {};
            
            var df = (this.$isLastBar(bar)
                ? diffPixel * 2
                : diffPixel);
    
            if (bar && r < df) {
                aml = bar.parentNode.localName == "bar" ? bar.parentNode : bar;
                
                isSameColumn = 
                (original.localName == "divider" 
                  && (original.parentNode.$dockbar == aml
                    || original.parentNode.$dockbar == findNextBar(aml))
                  && !original.parentNode.$dockbar.selectNodes("vbox").length
                || original.localName == "button" && original.parentNode.childNodes.length == 2
                  && (original.parentNode.parentNode == aml
                    || original.parentNode.parentnode == findNextBar(aml))
                || original.localName == "page" && original.parentNode.getPages().length == 1
                  && (original.$dockbutton.parentNode.parentNode == (aml.bar || aml)
                    || original.$dockbutton.parentNode.parentNode == findNextBar(aml))
                );

                return {
                    position : isSameColumn ? "none" : "right_of_column",
                    aml : aml
                };
            }
        }
        
        if (aml.localName == "page" || aml.localName == "tab" || aml.localName == "menu") {
            position = "before_page";
            if (aml.localName == "page") {
                pos = apf.getAbsolutePosition(aml.$button);
                l = e.clientX - pos[0];
    
                if (l > aml.$button.offsetWidth/2)
                    position = "after_page";
            }
            else if (aml.localName == "menu") {
                if (aml.firstChild.getPages) {
                    pages = aml.firstChild.getPages();
                    aml = pages[pages.length - 1];
                }
                position = "after_page";
            }
            else if (aml.localName == "tab") {
                pages = aml.getPages();
                aml = pages[pages.length - 1];
                position = "after_page";
            }
    
            //var pos2 = apf.getAbsolutePosition(aml.parentNode.$ext);
            //var t = e.clientY - pos2[1];
            //if (t > 18)
                //return {};
        }
        else {
            if (aml.localName == "bar" || aml.skin == "dockheader") {
                if (aml.skin == "dockheader") {
                    aml = aml.parentNode.selectNodes("vbox")[0];
                    position = "before_section";
                }
                else {
                    position = original.localName == "divider" 
                      && original.parentNode.$dockbar == aml
                      && aml.lastChild.$dockfor == original.parentNode //!aml.selectNodes("vbox").length
                        ? "in_section"
                        : "in_column";
                    aml = aml.lastChild;/*selectNodes("vbox");
                    aml = vboxs[vboxs.length - 1];*/
                }
            }
            else if (aml.localName == "button") {
                position = "after_button";
                pos = apf.getAbsolutePosition(aml.$ext);
                t = e.clientY - pos[1];
                if (t < aml.$ext.offsetHeight/2) {
                    if (aml.previousSibling && aml.previousSibling.localName == "button") {
                        aml = aml.previousSibling;
                    }
                    else {
                        position = "before_button";
                        //aml = aml.parentNode;
                    }
                }
            }
            else if (aml.dock && (aml.localName == "divider" || aml.localName == "vbox")) {
                if (aml.localName == "divider")
                    aml = aml.parentNode;
                
                var buttons = aml.selectNodes("button");
                if (!buttons.length)
                    return {position: "in_section", aml: aml};
                
                pos = apf.getAbsolutePosition(aml.$ext);
                t = e.clientY - pos[1];
                var b = aml.$ext.offsetHeight - t;
    
                if (t < diffPixel) {
                    if (original.localName != "divider" 
                      || original.parentNode != (aml.previousSibling 
                      && aml.previousSibling.$dockfor)) {
                        position = "before_section";
                    }
                }
                else if (b < diffPixel && aml.nextSibling) {
                    if (original.localName != "divider" 
                      || original.parentNode != aml.$dockfor) {
                        if (!aml.nextSibling
                          || aml.nextSibling.$dockfor != getOriginal("section", original))
                            position = "after_section";
                    }
                }
                
                if (position == "none") {
                    if (t < aml.$ext.offsetHeight/2) {
                        position = "before_button";
                        aml = buttons[0];
                    }
                    else {
                        position = "after_button";
                        aml = buttons[buttons.length - 1];
                    }
                }
            }
        }
    
        return {
            position : position,
            aml      : aml
        };
    };
    
    /**
     * clearState after dragging (detect dropping)
     * 
     * @todo because of the caching this function can become simpler
     */
    this.$stopDrag = function(e){
        whiledrag();
        apf.removeListener(document, "mousemove", whiledrag);
        
        var indicator = this.indicator;
        var info = lastInfo;//calcAction(e);
        var aml  = info && info.aml;
        
        indicator.style.display = "none";
        
        var original = whiledrag.dragged;
        apf.setOpacity(original.$ext, 1);
        apf.setStyleClass(original.$ext, '', ['dragging']);
        
        if (!aml) return;
        switch(info.position) {
            case "before_button":
            case "after_button":
                var submenu = self[aml.submenu];
                var dragAml = whiledrag.original;
    
                this.$moveTo(submenu, dragAml, aml, info.position == "before_button" 
                    ? aml 
                    : aml.nextSibling, aml.parentNode, info.position);
                break;
            case "before_tab":
            case "after_tab":
                var bar      = aml.parentNode.bar;
                var childNr  = apf.getChildNumber(aml);
                var sections = bar.selectNodes("vbox");
                var section = this.$addSection(bar, info.position == "before_tab"
                    ? sections[0]
                    : sections[childNr + 1], null, original && original.$dockData);
                
                //reconstruct menu
                var submenu = this.$addMenu(section);
                var dragAml = whiledrag.original;
                
                var tab = aml.parentNode.insertBefore(submenu.firstChild, info.position == "before_tab"
                    ? aml
                    : aml.nextSibling);
                tab.setAttribute("flex", 1);
    
                this.$moveTo(submenu, dragAml, tab, null, section, info.position, tab);//, null, pNode);
                break;
            case "before_section":
            case "in_column":
            case "after_section":
                var section = this.$addSection(aml.parentNode, info.position == "before_section"
                    ? aml
                    : (info.position == "in_column"
                        ? null
                        : aml.nextSibling), null, original && original.$dockData);
                
                //reconstruct menu
                var submenu = this.$addMenu(section);
                var dragAml = whiledrag.original;
    
                this.$moveTo(submenu, dragAml, aml, null, section, info.position);
                break;
            case "before_page":
            case "after_page":
                var submenu = self[aml.$dockbutton.submenu];//aml.parentNode.parentNode;
                var dragAml = whiledrag.original;
                
                this.$moveTo(submenu, dragAml, aml.parentNode, info.position == "before_page" 
                    ? aml.$dockbutton
                    : aml.nextSibling && aml.nextSibling.$dockbutton, submenu.ref, 
                        info.position, aml.parentNode);
                break;
            case "left_of_column":
                var bar = this.$addBar(aml);
                //Single Tab Case
                //create new section
                var section = this.$addSection(bar, null, null, original && original.$dockData);
                
                var dragAml = whiledrag.original, oldSectionData;
                if (dragAml.localName == "button" || dragAml.localName == "divider")
                    oldSectionData = dragAml.parentNode.$dockData;
                else if (dragAml.localName == "page")
                    oldSectionData = dragAml.$dockbutton.parentNode.$dockData;
                
                var submenu = this.$addMenu(section, oldSectionData);
                this.$moveTo(submenu, dragAml, aml, null, section, info.position);
                break;
            case "right_of_column":
                var bar = this.$addBar(aml.nextSibling);
                //Single Tab Case
                //create new section
                var section = this.$addSection(bar, null, null, original && original.$dockData);
                
                //reconstruct menu
                var submenu = this.$addMenu(section);
                var dragAml = whiledrag.original;
    
                this.$moveTo(submenu, dragAml, aml, null, section, info.position);
                break;
            default:
                break;
        }
    };
    
    /**
     * Manages the move of a conceptual single element, represented by either
     * a button, page or divider and performs the move from it's current position
     * to it's new position.
     * 
     * @todo because of the caching this function can become simpler
     */
    this.$moveTo = function(submenu, dragAml, aml, beforeButton, parentNode, position, tab, pNode, ignoreEvent){
        var beforePage = beforeButton && beforeButton.$dockpage;

        if (dragAml.localName == "page" || dragAml.localName == "button" || dragAml.localName == "hbox") {
            if ((submenu.skin == "dockwin_runbtns" && dragAml.id != "btnRunCommands")  //@giannis tsss
              || (submenu.skin != "dockwin_runbtns" && dragAml.id == "btnRunCommands"))
                return;

            if (dragAml.localName == "page" || dragAml.localName == "hbox") {
                var page = dragAml;
                var button = dragAml.$dockbutton;
            }
            else if (dragAml.localName == "button") {
                page = dragAml.$dockpage;
                button = dragAml;
            }
            
            if (!pNode)
                pNode = page.parentNode;
            
            var btnPNode = button.parentNode;
            var oldMenu  = self[page.$dockbutton.submenu];
            var newPNode = tab || submenu.firstChild;
            
            if (newPNode) {
                newPNode.insertBefore(page, beforePage);
                if (!self[page.id])
                    self[page.id] = page;
                
                if (!newPNode.getPages || newPNode.getPages().length == 1) {
                    var mnu = self[page.$dockbutton.submenu];
                    if (mnu) {
                        mnu.setAttribute("width", oldMenu.width);
                        mnu.setAttribute("height", oldMenu.height);
                    }
                    var totalFlex = 0, count = 0;
                    if (newPNode.parentNode.localName == "vbox") {
                        newPNode.parentNode.selectNodes("tab").each(function(tab){ 
                            totalFlex += tab.flex || 1;
                            count++;
                        });
                    }
                    else {
                        var vboxes = parentNode.parentNode.selectNodes("vbox");
                        vboxes.each(function(vbox){  
                            var button = vbox.selectSingleNode("button");
                            totalFlex += button && self[button.submenu].firstChild.flex || 1;
                            count++;
                        });
                    }
                    if (!newPNode.height)
                        newPNode.setAttribute("flex", totalFlex/count);
                }
            }
            
            if (beforeButton && beforeButton.previousSibling == button || beforeButton == button
              || !beforeButton && !button.nextSibling && button.parentNode == parentNode)
                return;
    
            button.setAttribute("submenu", submenu.id);

            //add button to section
            parentNode.insertBefore(button, beforeButton);
            
            //correct state
            var i, b = parentNode.$dockData.buttons;
            btnPNode.$dockData.buttons.remove(button.$dockData);
            
            if (beforeButton)
                b.insertIndex(button.$dockData, b.indexOf(beforeButton.$dockData));
            else
                i = b.push(button.$dockData);
            
            tableCleanup(pNode, btnPNode, oldMenu, b);
            checkBars();
        }
        else if (dragAml.localName == "divider") {
            var buttons = dragAml.parentNode && dragAml.parentNode.selectNodes("button");
            for (var i = buttons.length - 1; i >= 0; i--) {
                var button = buttons[i];
                this.$moveTo(submenu, button, aml, beforeButton, parentNode, position, tab, pNode, true);
            }
            
            checkBars();
        }
        
        if (!ignoreEvent)
            this.$cbChange();
    };
    
    /**
     * Creates a new menu
     */
    this.$addMenu = function(section, options){
        if (!options) 
            options = section.$dockData;
        var _self = this,
            menuId  = options.id || "submenu" + menuCounter++,
            resizeTimer;

        if (section.$menu)
            return apf.document.body.appendChild(section.$menu);

        var menu = new apf.menu({
            id        : menuId,
            width     : options.width || "350",
            height    : options.height || "200",
            ref       : section,
            right     : 10,
            pinned    : "true",
            animate   : "false",
            skin      : options.skin ? options.skin : "dockwindowblack",
            resizable : options.resizable === false ? false : "left bottom",
            dock      : 1,
            onhide    : function(e){
                if (this.firstChild && this.firstChild.getPage())
                    this.firstChild.getPage().$dockbutton.$dockData.showMenu = false;
            },
            ondisplay : function(e){
                if (_self.$currentMenu && _self.$currentMenu != this && _self.$currentMenu.parentNode)
                    _self.$currentMenu.hide();
                _self.$currentMenu = this;
                
                var pos   = apf.getAbsolutePosition(menu.opener.$ext);
                var width = apf.getWindowWidth();
                var dist  = //menu.$ext.offsetWidth > width - pos[0] //Weird bug - chrome only??
                    width - pos[0] 
                    //: menu.$ext.offsetWidth;

                menu.$ext.style.right = (dist + 5) + "px";
                menu.$ext.style.left = "";

                var x;
                setTimeout(x = function(){
//                    menu.$ext.style.marginRight = "0";
//                    menu.$ext.style.right = (width - pos[0] + 6) + "px";
//                    menu.$ext.style.left = "";
//                    menu.$ext.style.zIndex = "9999";
                    
                    if (menu.opener && menu.opener.$dockData && menu.opener.$dockData.caption) {
                        var btnPos = apf.getAbsolutePosition(menu.opener.$ext),
                            arrow;
                        if (typeof menu.$ext.getElementsByClassName == "function" && (arrow = menu.$ext.getElementsByClassName("arrow")[0])) {
                            arrow.style.top = btnPos[1] - apf.getAbsolutePosition(menu.$ext)[1] + 8 + "px"
                        }
                    }
                });
                x();
                
                if (this.firstChild.getPage())
                    this.firstChild.getPage().$dockbutton.$dockData.showMenu = true;
            },
            onafterresize : function(){
                section.$dockData.width  = this.getWidth();
                section.$dockData.height = this.getHeight();
                
                _self.$cbChange();
            },
            childNodes : [
                new apf.tab({
                    anchors : options.noTab ? "1 -7 0 4" : "5 4 5 4", 
                    skin    : options.noTab ? "dockbar" : "docktab",
                    buttons : "scale, close",
                    anims   : "remove",
                    dock    : 1,
                    nosplitter : options.noTab ? true : false,
                    flex    : options.flex || (options.noflex ? 0 : 1), 
                    activepage : 0,
                    noflex  : options.noflex,
                    onafterswitch : function(e){
                        setTimeout(function(){
                            if (e.previousPage) {
                                var button = e.previousPage.$dockbutton;
                                button.$dockData.active = false;
                                if (button.value && menu.visible) {
                                    button.value = false;
                                    button.$setState("Out", {});
                                }
                            }
                            if (e.nextPage && e.nextPage.$dockbutton) {
                                var button = e.nextPage.$dockbutton;
                                button.$dockData.active = true;
                                if (!button.value && menu.visible) {
                                    button.value = true;
                                    button.$setState("Down", {});
                                }
                                
                                if (menu.visible) {
                                    menu.opener = button;
                                    menu.dispatchEvent("display");
                                }
                            }
                            
                            _self.$cbChange();
                        });
                    },
                    onresize : function(e){
                        clearTimeout(resizeTimer);
                        
                        var tab = this;
                        resizeTimer = setTimeout(function(){
                            if (section.parentNode && section.parentNode.$dockData
                              && section.parentNode.$dockData.expanded > 0) {
                                section.parentNode.$dockData.width  = tab.getWidth();
                                options.flex = tab.flex;
                                
                                _self.$cbChange();
                            }
                        }, 500);
                    },
                    onclose : function(e){
                        var page = e.page;
                        page.lastParent = this;
                        
                        _self.$cbChange();
                    }
                })
            ]
        });
        
        apf.document.body.appendChild(menu);
        
        menu.show();
        menu.hide();
        
        section.$menu = menu;
        
        menu.setAttribute("width", options.width || 260);
        if (options.height)
            menu.setAttribute("height", options.height);
        
        return menu;
    };
    
    /**
     * Creates a new bar
     */
    this.$addBar = function(before, dockData){
        var _self = this;
        
        this.columnCounter++;
        
        if (before && before.previousSibling 
          && before.previousSibling.tagName == 'splitter' )
            before = before.previousSibling;
        
        if (!dockData) {
            dockData = {sections: []};
            dockData.uniqueId = lookup.push({data: dockData}) - 1;
        }

        if (dockData && dockData.cache)
            var bar = this.$parentHBox.insertBefore(dockData.cache, before);

        else {
            var bar   = this.$parentHBox.insertBefore(new apf.bar({
                skin : "debug-panel",
                margin : "0 0 0 0",
                dock : 1,
                onDOMNodeRemovedFromDocument : function(){
                    _self.columnCounter--;
                },
                childNodes : [
                    new apf.button({
                        dock : 1,
                        skin : "dockheader",
                        onclick : function(){
                            _self.expandBar(this.parentNode, true, true);
                        }
                    }),
                ]
            }), before);
            
            bar.$dockData = dockData;
            bar.$dockData.cache = bar;
            
            if (state.bars.indexOf(bar.$dockData) == -1)
                state.bars.insertIndex(bar.$dockData, 
                  before ? state.bars.indexOf(before.$dockData) : state.bars.length);
        }
        
        registerLookup.call(this, bar);
        
        return bar;
    };
    
    /**
     * Creates a new page
     */
    this.$addPage = function(page, before, menu, caption, name, section){
        var _self = this;

        if (!page)
            page = menu.firstChild.add(caption, name);
        else if (section && section.parentNode.expanded) {
            var bar = section.parentNode;
            if (menu.firstChild) {
                menu.firstChild.insertBefore(page, before);

                bar.vbox.insertBefore(menu.firstChild, 
                    section.nextSibling && section.nextSibling.lastChild
                      && section.nextSibling.lastChild.$dockpage.parentNode);
            }
            else {
                var index = apf.getArrayFromNodelist(bar.selectNodes("vbox")).indexOf(section);
                var tab = bar.vbox.selectNodes("tab")[index];
                
                tab.insertBefore(page, before);
            }
        }
        else 
            menu.firstChild.insertBefore(page, before);

        page.oDrag = page.$button;
        page.dock  = 1;
        page.setAttribute("draggable", true);
        
        var beforeDrag;        
        
        if (!page.$addedDockEvent) {  
            page.addEventListener("beforedrag", beforeDrag = function(e){ //change this to beforedrag and recompile apf
                this.$ext.style.zIndex = "";

                var originalTab = this.parentNode;
                var oneTab = originalTab.length == 1;
                var pHtmlNode = (oneTab ? this.parentNode : this).$ext;
                
                if (oneTab) {
                    originalTab.$buttons.style.opacity = 0;
                    this.$ext.style.opacity = 0;
                    //pHtmlNode.style.background = "#434343";
                    //pHtmlNode.style.border = "3px solid #373737";
                }
                else {
                    pHtmlNode.style.background = "#fafcfe";
                }

                var tab = this.parentNode.cloneNode(false);
                tab.removeAttribute("id");
                tab.removeAttribute("activepage");
                tab.setAttribute("buttons", "close"); //@todo bug in scale that doesnt resize 
                tab.removeAttribute("anchors");
                
                apf.document.body.appendChild(tab);
                
                tab.setWidth(this.parentNode.$ext.offsetWidth - 6);
                tab.setHeight(this.parentNode.$ext.offsetHeight - 6);

                var dragPage = this.cloneNode(false);
                dragPage.removeAttribute("id");
                dragPage.removeAttribute("render");
                tab.appendChild(dragPage);
                
                var nodes = this.childNodes;
                for (var i = nodes.length - 1; i >= 0; i--) {
                    dragPage.insertBefore(nodes[i], dragPage.firstChild);
                }

                var pos = apf.getAbsolutePosition(this.parentNode.$ext);
                tab.setLeft(pos[0] - 1 + 3);
                tab.setTop(pos[1] - 2 + 3);

                tab.$ext.style.border = "1px solid #333";
                tab.addEventListener("afterdrag", function(e){
                    originalTab.$buttons.style.opacity = "";
                    page.$ext.style.opacity = "";
                    pHtmlNode.style.background = "";
                    pHtmlNode.style.border = "";
                    
                    var nodes = dragPage.childNodes;
                    for (var i = nodes.length - 1; i >= 0; i--) {
                        page.appendChild(nodes[i], page.firstChild);
                    }
                    
                    tab.id = tab.name = ""; //@todo fix this bug in apf
                    tab.destroy(true, true);
                    _self.$stopDrag(e.htmlEvent);

                    tab.removeEventListener("afterdrag", arguments.callee);
                });

                //document instead?
                var clientX = e.htmlEvent.clientX;
                var clientY = e.htmlEvent.clientY;
                tab.setAttribute("draggable", true);
                setTimeout(function(){
                    tab.$dragStart({clientX:clientX,clientY:clientY});
                    tab.$ext.style.zIndex = 1000000;
                });

                _self.$startDrag(tab, this);

                return false;
            });
            
            page.addEventListener("afterclose", function(e){
                var button = this.$dockbutton;
                var pNode = this.lastParent;
                var btnPNode = button.parentNode;

                button.removeNode();//.destroy(true, true);
                this.removeNode();

                button.$dockData.hidden = 2;

                tableCleanup(pNode, btnPNode, pNode.parentNode.localName == "menu" 
                    ? pNode.parentNode 
                    : self[button.submenu]);
                    
                _self.$cbStorePage(this);

//                page.removeEventListener("beforedrag", beforeDrag);
//                page.removeEventListener("afterclose", arguments.callee);
//                page.$addedDockEvent = false;
                
                return false;
            }, true);
            page.$addedDockEvent = true;
        }

        return page;
    };

    /**
     * Retrieves an existing section and its associated menu
     */
    this.$getSection = function(bar, ident) {
        for (var barChild in bar.childNodes) {
            if (bar.childNodes[barChild].value && bar.childNodes[barChild].value == ident) {
                return bar.childNodes[barChild];
            }
        }
        
        return null;
    };

    /**
     * Creates a new section
     */
    this.$addSection = function(bar, before, ident, sectionOpt){
        var _self   = this;
        
        if (!sectionOpt) {
            sectionOpt = {buttons: []};
            sectionOpt.uniqueId = lookup.push({data: sectionOpt}) - 1;
        }
        
        if (!bar)
            bar = this.$parentHBox.lastChild;
        
        if (sectionOpt.cache) {
            var section = bar.insertBefore(sectionOpt.cache, before);

            var pData = findParentState(sectionOpt, true);
            if (pData && pData != bar.$dockData)
                pData.sections.remove(sectionOpt);
        
            var sections = bar.$dockData.sections;
            if (sections.indexOf(section.$dockData) == -1)
                sections.insertIndex(section.$dockData, 
                  before ? sections.indexOf(before.$dockData) : sections.length);
        }
        else {
            var section = bar.insertBefore(new apf.vbox({
                padding : 0,
                edge    : "0 0 3 0",
                "class" : "docksection",
                //width   : bar.$dockData.width || "",
                value   : ident,
                dock    : sectionOpt.draggable === false ? 0 : 1,
                draggable : sectionOpt.draggable === false ? false : true,
                childNodes : [
                    new apf.divider({
                        skin      : "divider-debugpanel",
                        margin    : "3 2 -4 2",
                        dock      : 1,
                        visible   : sectionOpt.draggable === false ? false : true,
                        draggable : true
                    })
                ]
            }), before);
            
            if (sectionOpt.draggable !== false) {
                var div = section.firstChild;
                div.addEventListener("beforedrag", function(e){ //change this to beforedrag and recompile apf
                    var section = this.parentNode;
    
                    //this.hideMenu();
    
                    var pNode = section.$dockbar = section.parentNode;
                    var placeHolder = section.cloneNode(false);
                    placeHolder.removeAttribute("id");
                    placeHolder.$dockfor = section;
    
                    var diff = apf.getDiff(section.$ext);
                    var height = section.$ext.offsetHeight;
                    var pos = apf.getAbsolutePosition(section.$ext);
    
                    pNode.insertBefore(placeHolder, section);
                    placeHolder.$ext.style.background = "#434343";
                    placeHolder.$ext.style.borderTop = "1px solid #373737";
                    placeHolder.$ext.style.height = (height - diff[1]) + "px";
    
                    section.setWidth(section.$ext.offsetWidth);
                    apf.document.body.appendChild(section);
                    section.setLeft(pos[0]);
                    section.setTop(pos[1]);
    
                    section.addEventListener("afterdrag", function(e){
                        pNode.insertBefore(section, placeHolder);
                        section.setAttribute("draggable", false);
    
                        setTimeout(function(){
                            section.removeAttribute("left");
                            section.removeAttribute("top");
                            section.removeAttribute("width");
                            section.$ext.style.position = "relative";
                            section.$ext.style.zIndex = 1;
                        });
    
                        var buttons = this.selectNodes("button");
                        if (buttons.length)
                            buttons[0].setValue(false);
                            
                        placeHolder.destroy(true, true);
    
                        _self.$stopDrag(e.htmlEvent);
    
                        section.removeEventListener("afterdrag", arguments.callee);
                    });
    
                    section.setAttribute("draggable", true);
    
                    var clientX = e.htmlEvent.clientX;
                    var clientY = e.htmlEvent.clientY;
                    setTimeout(function(){
                        section.$dragStart({clientX:clientX,clientY:clientY});
                        section.$ext.style.zIndex = 1000000;
                    });
    
                    _self.$startDrag(section, this);
    
                    return false;
                });
            }

            var pData = findParentState(sectionOpt);
            if (pData && pData != bar.$dockData)
                pData.sections.remove(sectionOpt);
        
            section.$dockData = sectionOpt;
            section.$dockData.cache = section;
            
            var sections = bar.$dockData.sections;
            if (sections.indexOf(section.$dockData) == -1)
                sections.insertIndex(section.$dockData, 
                  before ? sections.indexOf(before.$dockData) : sections.length);
        }
        
        registerLookup.call(this, section);
        
        return section;
    };
    
    /**
     * Creates a new button
     */
    this.$addButton = function(section, before, submenu, page, options){
        var _self  = this, btnLock, tmp;
        var drag = true; 
        if (typeof options.draggable != "undefined" )
            drag = false;

        if (options.cache) {
            var button = section.insertBefore(options.cache, before);
            
            var pData = findParentState(options);
            if (pData && pData != section.$dockData)
                pData.buttons.remove(options);
                
            var buttons = section.$dockData.buttons;
            if (buttons.indexOf(button.$dockData) == -1)
                buttons.insertIndex(button.$dockData, 
                  before ? buttons.indexOf(before.$dockData) : buttons.length);
        }
        else {
            var button = section.insertBefore(new apf.button({
                skin    : "dockButton",
                submenu : submenu.id,
                dock    : drag ? 1 : "",
                visible : options && (options.hidden < 0) || true, 
                "class" : options["class"] || "",
                draggable : drag,
                onmousedown  : function(){
                    btnLock = true;
    
                    self[this.submenu] && self[this.submenu].firstChild 
                      && self[this.submenu].firstChild.set 
                      && self[this.submenu].firstChild.set(page);
                    btnLock = false;
                    
                    if (options && (tmp = options.primary)) {
                        var span = button.$ext.getElementsByTagName("span");
                        span[2].style.backgroundPosition = 
                            tmp.activeState.x + 'px ' 
                            + tmp.activeState.y + 'px';
                
                        if (tmp = options.secondary) {
                            span[1].style.backgroundPosition = 
                                tmp.activeState.x + 'px ' 
                                + tmp.activeState.y + 'px';
                        }
                    }
                    
                    setTimeout(function(){
                        _self.$cbChange();
                    });
                }
            }), before);
            
            if (options && options["id"])
                button.setAttribute('id', options["id"]);
            
            function _setBtnIco(_btn){
                if (options && (tmp = options.primary)) {
                    var span = _btn.$ext.getElementsByTagName("span");
                    
                    _btn.setAttribute("tooltip", options.menu.split("/").pop());
                    
                    span[2].style.background = 'url("' 
                        + tmp.backgroundImage + '") '
                        + tmp.defaultState.x + 'px '
                        + tmp.defaultState.y + 'px no-repeat';
                    
                    if (tmp = options.secondary) {
                        span[1].style.background = 'url("' 
                            + tmp.backgroundImage + '") '
                            + tmp.defaultState.x + 'px '
                            + tmp.defaultState.y + 'px no-repeat'
                    }
                    
                    if (tmp = options.tertiary) {
                        span[0].style.background =
                            tmp.backgroundColor + ' url("'
                            + tmp.backgroundImage + '") '
                            + tmp.defaultState.x + 'px '
                            + tmp.defaultState.y + 'px no-repeat';
                        span[0].style.border = "1px solid #c7c7c7";
                    }
                }
            };
            
            _setBtnIco(button);
            
            // When the page is shown, we can reset the notification count
            page.addEventListener("prop.visible", function(e) {
    //            _self.resetNotificationCount(winIdent);
    
                //if (self[button.submenu] && !btnLock && e.value && this.$ext.offsetWidth && button.parentNode) // && this.parentNode.parentNode.localName == "menu") // & !_self.expanded
                    //button.showMenu();
                    
                if (e.value == true && options && options.cbOnPageShow)
                    options.cbOnPageShow();
                    
                else if (e.value == false && options && options.cbOnPageHide)
                    options.cbOnPageHide();
            });
            
            button.addEventListener("beforedrag", function(e){ //change this to beforedrag and recompile apf
                var originalButton = this;
                
                this.hideMenu();
                this.setValue(true);
                
                //Upgrade to container if only 1 element
                if (this.parentNode.selectNodes("button").length == 1) {
                    this.parentNode.firstChild.dispatchEvent("beforedrag", e);
                    return false;
                }
                
                var btn = this.cloneNode(true);
                btn.removeAttribute("id");
                apf.document.body.appendChild(btn);
                btn.setValue(true);
                _setBtnIco(btn);
                
                var pos = apf.getAbsolutePosition(this.$ext);
                btn.setLeft(pos[0]);
                btn.setTop(pos[1]);
                btn.addEventListener("afterdrag", function(e){
                    btn.destroy(true, true);
                    originalButton.setValue(false);
                    _self.$stopDrag(e.htmlEvent);
                    
                    btn.removeEventListener("afterdrag", arguments.callee);
                });
                
                //document instead?
                var clientX = e.htmlEvent.clientX;
                var clientY = e.htmlEvent.clientY;
                setTimeout(function(){
                    btn.$dragStart({clientX:clientX,clientY:clientY});
                    btn.$ext.style.zIndex = 1000000;
                    this.removeEventListener("mouseover", arguments.callee);
                });
                
                _self.$startDrag(btn, this);
                
                return false;
            });
        
            page.$dockbutton = button;
            button.$dockpage = page;
        
            var pData = findParentState(options);
            if (pData && pData != section.$dockData)
                pData.buttons.remove(options);
                
                button.$dockData = options;
                button.$dockData.cache = button;
            
            var buttons = section.$dockData.buttons;
            if (buttons.indexOf(button.$dockData) == -1)
                buttons.insertIndex(button.$dockData, 
                  before ? buttons.indexOf(before.$dockData) : buttons.length);
        }
        
        registerLookup.call(this, button);
        
        if (options) {
            //button.hidden = options.hidden !== false;
            
            if (options.showMenu && !options.active) //Cleanup - covering up an error somewhere /me lazy
                options.showMenu = false;
            else if (options.showMenu) {
                if (options.active) {
                    submenu.firstChild && submenu.firstChild.set 
                      && submenu.firstChild.set(page);
                }
                
                button.showMenu();
            }
            else if (options.active) {
                //Set proper event to delay rendering
                if (apf.window.vManager.check(page.parentNode, "page", function(){
                    if (!page.parentNode.activepage)
                        page.parentNode.set(page);
                }) && !page.parentNode.activepage)
                    page.parentNode.set(page);
            }
        }
        
        return button;
    };
}).call(DockableLayout.prototype);

});
define('text!ext/openfiles/openfiles.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:script><![CDATA[\n        function filesort(value, args, xmlNode) {\n            return (xmlNode.tagName == "folder" ? 0 : 1) + value.toLowerCase();\n        }\n    ]]></a:script>\n    <a:window id="winOpenFiles"\n      flex     = "1"\n      skin     = "fm-window"\n      title    = "Open Files"\n      modal    = "false"\n      buttons  = "close"\n      optimize = "true">\n        <a:button\n          top="-22"\n          skin="header-btn"\n          right="5"\n          icon="panel_settings.png"\n          submenu="mnuOpenFilesSettings"/>\n        \n        <a:menu id="mnuOpenFilesSettings">\n            <a:item id="cbShowFiles"\n                caption = "Show Path"\n                type    = "check"\n                visible = "{lstOpenFiles.visible}"\n                checked = "[{require(\'ext/settings/settings\').model}::auto/openfiles/@showpath]"\n                onclick = "\n                    setTimeout(function() {\n                        var sel = lstOpenFiles.getSelection();\n                        lstOpenFiles.reload();\n                        lstOpenFiles.selectList(sel);\n                    });\n                "\n            />\n        </a:menu>\n        \n        <a:list id="lstOpenFiles" \n          canrename   = "true" \n          anchors     = "0 0 0 0" \n          model       = "{require(\'ext/openfiles/openfiles\').model}"\n          border      = "0"\n          scrollbar   = "sbShared 2 2 2"\n          multiselect = "true" \n          autoselect  = "false"\n          skin        = "tree">\n            <a:each match="[file]" sort="[@name]" sort-method="filesort">\n                <a:caption match="[@name]" value="{([../@changed] == 1 ? \'*\' : \'\') + [.] + (cbShowFiles.checked ? \' - \' + [../@path].split(\'/\').slice(-2).join(\'/\') : \'\')}" />\n                <a:icon match="[folder|project]" value="folder.png" />\n                <a:icon match="[file]" value="{require(\'core/util\').getFileIcon(%[.])}" />\n            </a:each>\n            <a:remove match="[file|folder]" />\n        </a:list>\n    </a:window>\n</a:application>';});

define('text!ext/tree/tree.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:script><![CDATA[\n        function filesort(value, args, xmlNode) {\n            return (xmlNode.tagName == "folder" ? 0 : 1) + value.toLowerCase();\n        }\n\n        function createPath(a, b){\n            return b + "/" + apf.getFilename(a);\n        }\n    ]]></a:script>\n    <a:window id="winFilesViewer"\n      flex     = "1"\n      skin     = "fm-window"\n      title    = "Project Files"\n      modal    = "false"\n      buttons  = "close"\n      optimize = "true">\n        <a:button\n          top="-22"\n          skin="header-btn"\n          right="5"\n          icon="panel_settings.png"\n          submenu="mnuFilesSettings"/>\n        <a:button\n          top="-22"\n          skin="header-btn"\n          right="29"\n          icon="panel_refresh.png"\n          visible = "{trFiles.visible}"\n          onclick="require(\'ext/tree/tree\').refresh()" />\n        <!--a:button skin="header-btn" icon="order.png" top="-22" right="7"></a:button-->\n        \n        <a:menu id="mnuFilesSettings">\n            \n        </a:menu>\n        \n        <a:tree id="trFiles" canrename="true" border="0" simpledata="true"\n          contextmenu="mnuCtxTree" multiselect="true" reselectable="true"\n          onbeforeremove="return require(\'core/util\').removeInteractive(this)" disabled="{{!stServerConnected.active}}"\n          onbeforemove="this.disable();" autoselect="false"\n          flex="1" anchors="0 0 0 0" scrollbar="sbShared 2 2 2"\n        >\n            <a:each match="[project|file|folder]" sort="[@name]" sort-method="filesort">\n                <a:insert match="[folder]" get="" id="trFilesInsertRule" />\n                <a:caption match="[@name]" value="{([../@changed] == 1 ? \'*\' : \'\') + [.]}" />\n                <a:icon match="[folder|project]" value="folder.png" />\n                <a:icon match="[file]" value="{require(\'core/util\').getFileIcon(%[.])}" />\n            </a:each>\n\n            <a:add type="folder" get="{davProject.mkdir([@path], \'New Folder\')}" />\n            <a:add type="file" get="{davProject.create([@path], \'New File.txt\', \'\')}" />\n            <a:rename match="[file|folder[not(@path=\'/workspace\')]]" set="{davProject.rename([@name], [@oldpath])}" />\n            <a:move set="{require(\'ext/tree/tree\').moveFile([@path], createPath([@path], [../@path]))}"/>\n            <a:remove match="[file|folder]" set="{require(\'ext/filesystem/filesystem\').remove([@path])}"/>\n            <a:copy match="[file|folder]" set="{\n                davProject.copy([@path], createPath([@newname] || [@path], [../@path]))\n            }" undo="{\n                alert(\'TODO!!\');\n            }"/>\n\n            <a:drag match="[folder|file]" />\n            <a:drop match="[folder|file]" target="[folder]"\n                action="tree-append" copy="{event.ctrlKey}" />\n            <a:drop match="[folder|file]" target="[file]"\n                action="insert-before" copy="{event.ctrlKey}" />    \n        </a:tree>\n        \n        <a:menu id="mnuCtxTree" disabled="{!stServerConnected.active}">\n            <a:item match="[file]" class="strong"  onclick="\n                require(\'core/ide\').dispatchEvent(\'openfile\', {doc: require(\'core/ide\').createDocument(apf.activeElement.selected)})\n            ">Edit</a:item>\n            <a:divider />\n            <a:item onclick="require(\'ext/tree/tree\').refresh()">Refresh</a:item>\n            <a:item match="[file|folder[not(@root)]]" onclick="apf.activeElement.startRename()">Rename</a:item>\n            <a:item match="[file|folder[not(@root)]]" onclick="apf.activeElement.remove()">Delete</a:item>\n            <a:divider />\n            <a:item match="[file|folder[not(@root)]]" onclick="\n                apf.clipboard.cutSelection(apf.activeElement);\n            ">Cut</a:item>\n            <a:item match="[file|folder[not(@root)]]" onclick="\n                apf.clipboard.copySelection(apf.activeElement);\n            ">Copy</a:item>\n            <a:item match="[folder|project]" disabled="{apf.clipboard.empty}" onclick="\n                apf.clipboard.pasteSelection(apf.activeElement);\n            ">Paste</a:item>\n            <a:divider />\n            <a:item match="[file|folder|project]" onclick="\n                require(\'ext/filesystem/filesystem\').createFile();\n            ">New File</a:item>\n            <a:item match="[file|folder|project]" onclick="\n                require(\'ext/filesystem/filesystem\').createFolder();\n            ">New Folder</a:item>\n        </a:menu>\n    </a:window>\n</a:application>\n\n';});

define('text!ext/save/save.css',[],function () { return '.lbl_saveas {\n    font-weight: bold;\n    color: #323232;\n}\n.lbl_filepath {\n    padding-left: 57px;\n    font-size: 11px;\n    color: #bababa;\n    text-shadow: rgba(255, 255, 255, 1) 0px 1px 0px;\n}\n\n.trDgLike .item-fix:nth-child(4n-1) {\n    background-color: #f1f0f1;\n}\n.trDgLike .item-fix:nth-child(4n+1) {\n    background-color: #fefdfe;\n}\n\n.trDgLike .item-fix.root {\n    background-color: #fefdfe;\n}\n\n.dgLikeContaier {\n    background-color: white;\n    border: 1px solid #C3C3C3;\n    color: #333333;\n    cursor: default;\n    font-family: Tahoma, Arial;\n    font-size: 8pt;\n    overflow: hidden;\n    position: relative;\n    height: 210px;\n}\n\n.dgLikeContaier .heading {\n    position : relative;\n    top : 0;\n    left : 0;\n    height : 20px;\n    z-index : 10;\n    /*padding-left : 5px;*/\n    background-color : #e6e6e6;\n    margin : 0 0 0 0;\n    white-space : nowrap;\n    \n    display : inline-block;\n    background : -webkit-gradient(linear,left bottom,left top,color-stop(0, rgb(229,229,229)),color-stop(1, rgb(248,248,248)));\n    background: -moz-linear-gradient(center bottom,rgb(229,229,229) 0%,rgb(248,248,248) 100%);\n    overflow : hidden;\n    text-overflow : ellipsis;\n    color: #333;\n    border-bottom: 1px solid #BFBFBF;\n\n    padding : 2px 4px 1px 3px;\n    display : block;\n    height : 15px;\n    text-decoration : none;\n    border-left : 1px solid white;\n    border-right : none;\n    border-top : 1px solid white;\n}\n\n.hidefiles .file_item {\n    display: none;\n}';});

define('text!ext/save/save.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:window\n      id        = "winCloseConfirm"\n      title     = "Save this file?"\n      icon      = ""\n      center    = "true"\n      render    = "runtime"\n      width     = "512"\n      skin      = "bk-window2"\n      draggable = "true"\n      class     = "relative"\n      onkeydown = "\n        if(event.keyCode == 89) {\n            btnSaveYes.dispatchEvent(\'click\', {htmlEvent: {}});\n        }\n        if(event.keyCode == 78) {\n            btnSaveNo.dispatchEvent(\'click\', {htmlEvent: {}});\n        }\n      ">\n        <a:vbox id="fileDesc" padding="10" edge="15 20 25 20">\n            \n        </a:vbox>\n\n        <a:hbox edge="6 10 10" pack="end" padding="8">\n            <a:button id="btnYesAll" caption="Yes to all" skin="btn-default-css3" />\n            <a:button id="btnNoAll" caption="No to all" skin="btn-default-css3"/>\n            <a:filler />\n            <a:button id="btnSaveYes" default="3" class="btn-green" caption="Yes" skin="btn-default-css3"/>\n            <a:button id="btnSaveNo" class="btn-red" caption="No" skin="btn-default-css3"/>\n            <a:button id="btnSaveCancel" skin="btn-default-css3">Cancel</a:button>\n        </a:hbox>\n    </a:window>\n\n    <a:script><![CDATA[\n        function chooseSaveAsFolder(folder) {\n            var fooPath = folder.getAttribute("path");\n            if (folder.getAttribute("type") != "folder" && folder.tagName != "folder") {\n                var fooPath = fooPath.split("/");\n                txtSaveAs.setValue(fooPath.pop());\n                fooPath = fooPath.join("/");\n            }\n            lblPath.setProperty(\'caption\', fooPath + \'/\');\n        }\n    ]]></a:script>\n\n    <a:window\n      id        = "winSaveAs"\n      center    = "true"\n      height    = "395"\n      icon      = ""\n      buttons   = "close"\n      skin      = "bk-window"\n      kbclose   = "true"\n      resizable = "true"\n      title     = "Save As"\n      onshow    = "require(\'ext/save/save\').expandTree();"\n      width     = "480"\n      draggable = "true">\n        <a:vbox\n          anchors   = "10 10 0 10"\n          padding   = "5">\n            <a:hbox\n              align     = "center"\n              padding   = "5">\n                <a:label flex="1" class="lbl_saveas">Save as:</a:label>\n                <a:textbox\n                  id           = "txtSaveAs"\n                  flex         = "7"\n                  focusselect  = "true"\n                  onkeydown    = "if (event.keyCode == 13) require(\'ext/save/save\').choosePath(lblPath.getProperty(\'caption\') + this.getValue())" />\n            </a:hbox>\n            <a:label id="lblPath" class="lbl_filepath" />\n\n            <div class="dgLikeContaier">\n                <div class="heading">Project folder</div>\n                <a:hbox\n                  anchors  = "20 0 0 0"\n                  overflow = "hidden">\n                    <a:tree\n                      id            = "trSaveAs"\n                      class         = "trDgLike"\n                      flex          = "1"\n                      scrollbar     = "sbShared 2 2 2"\n                      model         = "{require(\'ext/filesystem/filesystem\').model}"\n                      contextmenu   = "mnuCtxTree"\n                      onafterselect = "chooseSaveAsFolder(this.selected)"\n                      onafterchoose = "chooseSaveAsFolder(this.selected)">\n                        <a:each match="[folder|file]">\n                           <a:insert\n                             match = "[folder]"\n                             get   = "{location.host and davProject.readdir([@path])}" />\n                           <a:caption match="[@name]" />\n                           <a:icon\n                             match = "[folder]"\n                             value = "folder.png" />\n                           <a:icon\n                             match = "[file]"\n                             value = "{require(\'core/util\').getFileIcon(%[.])}" />\n                           <a:css match="[file]" value="file_item"></a:css>\n                        </a:each>\n                        <a:add type="folder" get="{davProject.mkdir([@path], \'New Folder\')}" />\n                        <a:add type="file" get="{davProject.create([@path], \'New File.txt\', \'\')}" />\n                        <a:rename set="{alert(\'boe\'); davProject.rename([@name], [@path])}"/>\n                        <a:copy match="[file|folder]" set="{davProject.copy([@path], [../@path])}"/>\n                        <a:move set="{davProject.move([@path], [../@path])}"/>\n                        <a:remove match="[file|folder]" set="{require(\'ext/filesystem/filesystem\').remove([@path])}"/>\n\n                        <a:drag match="[folder|file]" />\n                        <a:drop match="[folder|file]" target="[folder]"\n                            action="tree-append" copy="{event.ctrlKey}" />\n                    </a:tree>\n                </a:hbox>\n            </div>\n            <a:hbox padding="15" align="center">\n                <a:button\n                  width    = "104"\n                  icon     = "folder_new.png"\n                  class    = "btnIconOnly smallCaption newFolder"\n                  onclick  = "require(\'ext/filesystem/filesystem\').createFolder(\'New Folder\', trSaveAs)"\n                  tooltip  = "Create folder">\n                    Create folder\n                </a:button>\n                <a:filler />\n                <a:checkbox\n                  skin    = "checkbox_grey"\n                  checked = "true"\n                  width   = "120"\n                  margin  = "4 0 0"\n                  onafterchange="\n                    if(this.checked)\n                        trSaveAs.$ext.className = trSaveAs.$ext.className.replace(/hidefiles/, \'\');\n                    else\n                        apf.setStyleClass(trSaveAs.$ext, \'hidefiles\');\n                  ">Show files in tree</a:checkbox>\n            </a:hbox>\n            <a:hbox\n              edge    = "23 0 10"\n              pack    = "end"\n              padding = "8">\n                <a:button\n                  skin    = "btn-default-css3"\n                  onclick = "winSaveAs.hide()">\n                    Cancel\n                </a:button>\n                <a:button\n                  class    = "btn-green"\n                  default  = "2"\n                  skin     = "btn-default-css3"\n                  onclick  = "require(\'ext/save/save\').confirmSaveAs()">\n                    Save\n                </a:button>\n            </a:hbox>\n        </a:vbox>\n    </a:window>\n</a:application>\n';});

define('text!ext/gotofile/gotofile.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:window id="winGoToFile"\n      title     = "Open File" \n      buttons   = "close" \n      modal     = "false" \n      center    = "true" \n      width     = "475" \n      height    = "300"\n      resizable = "true"\n      kbclose   = "true"\n      skin      = "bk-window"\n      zindex    = "999999"\n      onshow    = "\n        txtGoToFile.select();\n      ">\n        <a:hbox edge="5">\n            <a:textbox id="txtGoToFile" realtime="true" flex="1" skin="searchbox_textbox" focusselect="true" />\n        </a:hbox>\n        <a:datagrid id="dgGoToFile"\n          anchors = "34 0 46 0"\n          border  = "1 0 0 0"\n          class   = "searchresults noscrollbar"\n          scrollbar = "sbShared 20 2 2"\n          model   = "mdlGoToFile"\n          each    = "[d:response/d:href]"\n          multiselect     = "true"\n          loading-message = "Searching Project..."\n          empty-message   = "No search results"\n          startcollapsed  = "false">\n            <a:column width="100" value="{apf.getFilename([text()])}" caption="Name" />\n            <a:column width="100%" caption="Path" value="[text()]" />\n        </a:datagrid>\n        <a:hbox edge="6 10 10" pack="end" bottom="0" right="0" left="0" padding="8">\n            <a:filler/>\n            <a:button onclick="winGoToFile.hide()" skin="btn-default-css3">Cancel</a:button>\n            <a:button \n              default  = "2" \n              skin     = "btn-default-css3" \n              class    = "btn-green"\n              onclick  = "\n                require(\'ext/gotofile/gotofile\').openFile();\n              ">Open</a:button>\n        </a:hbox>\n        <a:model id="mdlGoToFile" />\n    </a:window>\n</a:application>';});

define('text!ext/newresource/newresource.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:window\n      id        = "winNewFileTemplate"\n      title     = "New from Template"\n      icon      = ""\n      center    = "true"\n      render    = "runtime"\n      width     = "350"\n      height    = "300"\n      skin      = "bk-window"\n      resizable = "true"\n      kbclose   = "true"\n      buttons   = "close"\n      draggable = "true">\n        <a:vbox padding="10" anchors="0 0 0 0">\n\n            <a:list id="lstFileTemplates"\n              model     = "mdlFileTemplates"\n              flex      = "1"\n              margin    = "10 10 10 10"\n              caption   = "[@caption]"\n              icon      = "[@icon]"\n              class     = "noscrollbar"\n              scrollbar = "sbShared 12 12 55"\n              each      = "item"\n              eachvalue = "[@value]"\n              style     = "overflow:hidden"\n              onafterchoose = "\n                btnFileTemplateSave.dispatchEvent(\'click\');\n              " />\n            <a:hbox pack="end" padding="7" edge="10">\n                <a:button id="btnFileTemplateSave" width="80" default="2"\n                  class="btn-green" skin="btn-default-css3" caption="Create"\n                  onclick="\n                    require(\'ext/newresource/newresource\').newfile(\n                        \'.\' + lstFileTemplates.value,\n                        lstFileTemplates.selected.firstChild.nodeValue\n                    );\n                    winNewFileTemplate.hide();\n                  "/>\n                <a:button id="btnFileTemplateCancel" skin="btn-default-css3" width="80"\n                  onclick="winNewFileTemplate.hide()">Cancel</a:button>\n            </a:hbox>\n        </a:vbox>\n    </a:window>\n\n    <a:model id="mdlFileTemplates">\n        <templates>\n            <item value="txt" icon="page_white_text.png" caption="Text file"><![CDATA[]]></item>\n            <item value="js" icon="page_white_code.png" caption="JavaScript file"><![CDATA[]]></item>\n            <item value="js" icon="page_white_code.png" caption="Unit Test"><![CDATA["use strict";\nrequire("./support/paths");\n\nvar assert = require("assert");\n//var module = require("./module");\n\nmodule.exports = {\n\n    "test untitled 1" : function() {\n        //assert.equal(!true, false);\n    }\n\n};\n\nif (typeof module !== "undefined" && module === require.main) {\n    require("asyncjs").test.testcase(module.exports).exec()\n}]]></item>\n            <item value="stest" icon="page_white_code.png" caption="Selenium Test"><![CDATA[{}]]></item>\n            <item value="coffee" icon="page_white_code.png" caption="CoffeeScript file"><![CDATA[]]></item>\n            <item value="html" icon="html.png" caption="HTML file"><![CDATA[<!DOCTYPE html>\n<html>\n    <head>\n        <title> </title>\n    </head>\n    <body>\n\n    </body>\n</html>\n]]></item>\n            <item value="xml" icon="page_white_code_red.png" caption="XML file"><![CDATA[]]></item>\n            <item value="css" icon="css.png" caption="CSS file"><![CDATA[]]></item>\n            <item value="scss" icon="css.png" caption="SCSS file"><![CDATA[]]></item>\n            <item value="svg" icon="page_white_picture.png" caption="SVG file"><![CDATA[]]></item>\n            <item value="py" icon="script_code.png" caption="Python file"><![CDATA[]]></item>\n            <item value="php" icon="page_white_php.png" caption="PHP file"><![CDATA[<?php\n\n?>]]></item>\n            <item value="rb" icon="page_white_ruby.png" caption="Ruby file"><![CDATA[]]></item>\n            <item value="mli" icon="page_white_code.png" caption="OCaml file"><![CDATA[]]></item>\n            <item value="clj" icon="page_white_code.png" caption="Clojure file"><![CDATA[]]></item>\n            <item value="md" icon="page_white_text.png" caption="Markdown"><![CDATA[]]></item>\n            <item value="js" icon="page_white_code.png" caption="Express file"><![CDATA[// *******************************************************\n// expressjs template\n//\n// assumes: npm install express\n// defaults to jade engine, install others as needed\n//\n// assumes these subfolders:\n//   public/\n//   public/javascripts/\n//   public/stylesheets/\n//   views/\n//\nvar express = require(\'express\');\nvar app = module.exports = express.createServer();\nvar viewEngine = \'jade\'; // modify for your view engine\n// Configuration\napp.configure(function(){\n  app.set(\'views\', __dirname + \'/views\');\n  app.set(\'view engine\', viewEngine);\n  app.use(express.bodyParser());\n  app.use(express.methodOverride());\n  app.use(app.router);\n  app.use(express.static(__dirname + \'/public\'));\n});\napp.configure(\'development\', function(){\n  app.use(express.errorHandler({ dumpExceptions: true, showStack: true }));\n});\napp.configure(\'production\', function(){\n  app.use(express.errorHandler());\n});\n// *******************************************************\n]]></item>\n        </templates>\n    </a:model>\n</a:application>\n';});

define('text!ext/searchinfiles/skin.xml',[],function () { return '<?xml version=\'1.0\'?>\n<a:skin xmlns:a="http://ajax.org/2005/aml">\n  <a:tree name="tree">\n      <a:style><![CDATA[\n      .searchtree {\n          padding : 3px;\n          overflow: hidden;\n          cursor : default;\n          position : relative;\n          color: #EEE;\n          font-family : Arial;\n          font-size : 12px;\n      }\n  \n      searchtree .trDefines {\n          background: none;\n          border-bottom: 1px solid #c3c3c3;\n          border-top: 1px solid #c3c3c3;\n          border-right: none;\n          border-left: none;\n          posittion: relative;\n          padding-top: 8px;\n      }\n  \n      .searchtree SPAN{\n          width: 15px;\n          height: 18px;\n          background: no-repeat 3px 5px;\n          display: block;\n          margin-left: -15px;\n      }\n  \n      .searchtree DIV.pluslast SPAN,\n      .searchtree DIV.plus SPAN{\n          background-image:url(images/search_expand.png);\n      }\n  \n      .searchtree DIV.minlast SPAN,\n      .searchtree DIV.min SPAN{\n          background-image:url(images/search_collaps.png);\n      }\n  \n      .searchtree DIV{\n          padding: 0;\n          height: auto;\n          padding-left: 15px;\n          overflow : hidden;\n  \n          font-family: Tahoma, Arial, Arial;\n          font-size: 11px;\n      }\n  \n\t  .searchtree .linenumber {\n\t      width : 35px;\n\t      display : inline;\n\t      text-align : right;\n\t      padding : 0 10px 0 4px;\n\t  }\n\t  \n\t  .searchtree .excerpt {\n\t      margin : 0;\n\t      display : inline-block;\n\t  }\n\t  \n\t  .searchtree .line{\n\t      width : 35px;\n\t      display : inline-block;\n\t      text-align : right;\n\t      padding : 0 5px 0 0;\n\t  }\n\t  \n\t  .searchtree pre{\n\t      margin : 0;\n\t      display : inline-block;\n\t  }\n\t    \n      .searchtree .focusbug{\n          padding-left : 0;\n          overflow : visible;\n      }\n  \n      .searchtree LABEL{\n          padding: 1px 0 0 20px;\n          background: no-repeat 1px 1px;\n          white-space: nowrap;\n          margin-left: 0px;\n          display: block;\n          float: left;\n          margin-top: -18px;\n          padding: 1px 0 0 2px !important;\n          height: auto;\n      }\n  \n      .searchtree DIV.loading LABEL{\n  \n      }\n      .searchtree DIV.loading SPAN{\n          background: no-repeat 0px 0px;\n      }\n  \n      .searchtree U{\n          text-decoration: none;\n          cursor: default;\n          display: inline !important; display: block;\n          padding: 2px 4px 2px 2px;\n      }\n  \n      .searchtreeFocus .indicate U{\n          border: 1px dotted #CCC;\n          padding: 1px 3px 1px 1px;\n      }\n  \n      .searchtree .selected U{\n          background-color: #EEE;\n          color: black;\n          -webkit-border-radius: 3px;\n          -moz-border-radius: 3px;\n          border-radius: 3px;\n      }\n  \n      .searchtreeFocus .selected U, .tree .dragAppend U{\n          background-color: #DDD;\n          color: black;\n          -webkit-border-radius: 3px;\n          -moz-border-radius: 3px;\n          border-radius: 3px;\n      }\n  \n      .searchtree BLOCKQUOTE{\n          margin: 0;\n          padding: 0 0 0 20px;\n          display: none;\n          height: 0;\n          overflow: hidden;\n          background: repeat-y 0px center;\n      }\n   \n      .searchtree .empty, .searchtree .offline, .searchtree .loading{\n          padding: 8px;\n          color: #AAA;\n          font-weight : normal;\n          height : 0;\n          overflow: visible;\n          text-align: left !important;\n      }\n  \n      .searchtree div.loading{\n          text-align : left;\n      }\n  \n      .searchtree .message{\n          text-align: center;\n      }\n  \n      .searchtree .root{\n          position : relative;\n      }\n  ]]>\n      </a:style>\n      <a:style condition="!apf.isIE"><![CDATA[\n      .tree LABEL, .dragtree LABEL{\n          padding: 3px 0 0 20px;\n      }\n  ]]>\n      </a:style>\n  \n      <a:presentation>\n          <a:main container="." startclosed="false">\n              <div class="searchtree">\n  \n              </div>\n          </a:main>\n          <a:item\n            class        = "."\n            caption      = "label/u"\n            icon         = "label"\n            openclose    = "span"\n            select       = "label"\n            container    = "following-sibling::blockquote">\n              <div>\n                  <span> </span>\n                  <label>\n                      <u>-</u>\n                  </label>\n              </div>\n              <blockquote> </blockquote>\n          </a:item>\n          <a:loading>\n              <div class="loading">\n                  <span> </span>\n                  <label>Loading...</label>\n              </div>\n          </a:loading>\n          <a:empty caption=".">\n              <div class="message"></div>\n          </a:empty>\n      </a:presentation>\n  </a:tree>\n</a:skin>';});

define('text!ext/searchinfiles/searchinfiles.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:window id="winSearchInFiles"\n      onhide  = "require(\'ext/searchinfiles/searchinfiles\').onHide()"\n      title   = "Search in Files"\n      buttons = "close"\n      skin    = "bk-window"\n      class   = "relative"\n      modal   = "false"\n      center  = "true"\n      width   = "350"\n      kbclose = "true">\n        <a:vbox edge="10" padding="5">\n            <a:hbox align="center">\n                <a:label width="95">Containing Text</a:label>\n                <a:textbox id="txtSFFind" flex="1" focusselect="true"/>\n            </a:hbox>\n            <a:hbox align="center">\n                <a:label width="95">Filename Patterns</a:label>\n                <a:dropdown id="ddSFPatterns" flex2="1" autoselect="true" maxitems="10" width="213" height="21">\n                    <a:item value="all">All known filetypes</a:item>\n                    <a:item value="actionscript">Actionscript files</a:item>\n                    <a:item value="ada">Ada files</a:item>\n                    <a:item value="asm">Assembler files</a:item>\n                    <a:item value="batch">Batch files</a:item>\n                    <a:item value="cc">C files</a:item>\n                    <a:item value="clojure">Clojure files</a:item>\n                    <a:item value="cfmx">Coldfusion files</a:item>\n                    <a:item value="coffee">Coffeescript files</a:item>\n                    <a:item value="cpp">C++ files</a:item>\n                    <a:item value="csharp">C# files</a:item>\n                    <a:item value="css">CSS files</a:item>\n                    <a:item value="elisp">ELisp files</a:item>\n                    <a:item value="erlang">Erlang files</a:item>\n                    <a:item value="fortran">Fortran files</a:item>\n                    <a:item value="groovy">Groovy files</a:item>\n                    <a:item value="haskell">Haskell files</a:item>\n                    <a:item value="hh">Header files</a:item>\n                    <a:item value="html">HTML files</a:item>\n                    <a:item value="java">Java files</a:item>\n                    <a:item value="js">Javascript files</a:item>\n                    <a:item value="json">JSON files</a:item>\n                    <a:item value="jsp">JSP files</a:item>\n                    <a:item value="latex">Latex files</a:item>\n                    <a:item value="lisp">Lisp files</a:item>\n                    <a:item value="lua">Lua files</a:item>\n                    <a:item value="make">Make files</a:item>\n                    <a:item value="markdown">Markdown files</a:item>\n                    <a:item value="mason">Mason files</a:item>\n                    <a:item value="objc">Obj-C files</a:item>\n                    <a:item value="objcpp">Obj-C++ files</a:item>\n                    <a:item value="ocaml">Ocaml files</a:item>\n                    <a:item value="parrot">Parrot files</a:item>\n                    <a:item value="perl">Perl files</a:item>\n                    <a:item value="php">PHP files</a:item>\n                    <a:item value="plone">Plone files</a:item>\n                    <a:item value="powershell">Powershell files</a:item>\n                    <a:item value="python">Python files</a:item>\n                    <a:item value="rake">Rake files</a:item>\n                    <a:item value="ruby">Ruby files</a:item>\n                    <a:item value="scala">Scala files</a:item>\n                    <a:item value="scheme">Scheme files</a:item>\n                    <a:item value="shell">Shell script files</a:item>\n                    <a:item value="smalltalk">Smalltalk files</a:item>\n                    <a:item value="sql">SQL files</a:item>\n                    <a:item value="tcl">TCL files</a:item>\n                    <a:item value="tex">Tex files</a:item>\n                    <a:item value="text">Text files</a:item>\n                    <a:item value="textile">Textile files</a:item>\n                    <a:item value="tt">TT files</a:item>\n                    <a:item value="vb">Visual Basic files</a:item>\n                    <a:item value="vim">Vim files</a:item>\n                    <a:item value="yaml">Yaml files</a:item>\n                    <a:item value="xml">XML files</a:item>\n                </a:dropdown>\n            </a:hbox>\n            <!--a:hbox id="barReplace" align="center">\n                <a:label width="75">Replace With</a:label>\n                <a:textbox id="txtReplace" flex="1" />\n            </a:hbox-->\n            <a:hbox edge="10 0 5">\n                <a:fieldset flex="1" caption="Options" margin="0 0 1">\n                    <a:checkbox id="chkSFMatchCase"\n                      checked = "false"\n                      skin    = "checkbox_grey"\n                      margin  = "0 0 2"\n                      label   = "Match Case" />\n                    <!--a:checkbox id="chkSFWholeWords" label="Whole Words" /-->\n                    <a:checkbox id="chkSFRegEx"\n                      skin  = "checkbox_grey"\n                      label = "Regular Expressions" />\n                </a:fieldset>\n                <a:fieldset flex="1" caption="Scope" margin="0 0 1 5">\n                    <a:radiobutton\n                      group  = "grpSFScope"\n                      skin   = "radio_grey"\n                      value  = "projects"\n                      margin = "0 0 2"\n                      label  = "Project" />\n                    <a:radiobutton id="rbSFSelection"\n                      group  = "grpSFScope"\n                      skin   = "radio_grey"\n                      value  = "selection"\n                      label  = "Selection"\n                      selected = "true" />\n                </a:fieldset>\n            </a:hbox>\n        </a:vbox>\n        <a:hbox padding="10" pack="end" edge="6 10 10">\n            <!--a:button id="btnReplace">Replace</a:button>\n            <a:button id="btnReplaceAll">Replace All</a:button-->\n            <a:button id="btnSFFind" default="2" class="btn-green" skin="btn-default-css3">Find</a:button>\n            <a:button onclick="winSearchInFiles.hide()" skin="btn-default-css3">Close</a:button>\n        </a:hbox>\n    </a:window>\n\n    <a:hbox id="trSFHbox" anchors="0 0 0 0" visible="false" render="runtime">\n        <a:tree id        = "trSFResult"\n          skinset         = "searchinfiles"\n          border          = "0"\n          visible         = "false"\n          each            = "[d:response[position() &lt; 50]|d:excerpt[position() &lt; 50]|d:maxreached|d:querydetail]"\n          loading-message = "Searching..."\n          style           = "position:absolute;top:0;left:0;bottom:0;right:17px;"\n          autoselect      = "false">\n            <a:model />\n            <a:caption match="[d:querydetail]">Search results for \'{apf.htmlentities([@query])}\'</a:caption>\n            <a:caption match="[d:maxreached]">Your search yielded too many results. The first hits are listed below:</a:caption>\n            <a:caption match="[d:response]">[@path] (#[d:excerpt])</a:caption>\n            <a:caption match="[d:excerpt]"><div class="linenumber">[@line]</div><pre class="excerpt">{apf.htmlentities([text()])}</pre></a:caption>\n        </a:tree>\n        <a:scrollbar\n          id        = "sbSFResult"\n          for       = "trSFResult"\n          margin    = "0"\n          skin      = "console_scrollbar"\n          style     = "position:absolute;top:0;bottom:0;right:0;"\n          width     = "17" />\n    </a:hbox>\n</a:application>\n';});

define('text!ext/searchreplace/searchreplace.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:window id="winSearchReplace"\n      onhide  = "require(\'ext/searchreplace/searchreplace\').onHide()"\n      title   = "Search &amp; Replace" \n      buttons = "close" \n      modal   = "false" \n      center  = "true" \n      skin    = "bk-window"\n      class   = "relative"\n      width   = "395" \n      kbclose = "true">\n        <a:vbox edge="15 10 20" padding="5">\n            <a:hbox align="center">\n                <a:label width="75">Search</a:label>\n                <a:textbox id="txtFind" flex="1" focusselect="true"/>\n            </a:hbox>\n            <a:hbox id="barReplace" align="center">\n                <a:label width="75">Replace With</a:label>\n                <a:textbox id="txtReplace" flex="1" focusselect="true"/>\n            </a:hbox>\n            <a:table columns="150,150" edge="10 10 0 10">\n                <a:checkbox id="chkMatchCase" checked="false" label="Match Case" skin="checkbox_grey" />\n                <a:checkbox id="chkWrapAround" checked="true" label="Wrap Around" skin="checkbox_grey" />\n                <a:checkbox id="chkWholeWords" label="Whole Words" skin="checkbox_grey" />\n                <a:checkbox id="chkSearchSelection" label="Search Selection" skin="checkbox_grey" />\n                <a:checkbox id="chkRegEx" label="Regular Expressions" skin="checkbox_grey" />\n                <a:checkbox id="chkSearchBackwards" label="Search Backwards" skin="checkbox_grey" />\n            </a:table>\n        </a:vbox>\n        <a:hbox padding="10" pack="end" edge="6 10 10">\n            <a:button id="btnReplace" skin="btn-default-css3">Replace</a:button>\n            <a:button id="btnReplaceAll" skin="btn-default-css3">Replace All</a:button>\n            <a:button id="btnFind" default="2" class="btn-green" skin="btn-default-css3">Find</a:button>\n            <a:button onclick="winSearchReplace.hide()" skin="btn-default-css3">Close</a:button>\n        </a:hbox>\n    </a:window>\n</a:application>';});

define('text!ext/quickwatch/quickwatch.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:window id="winQuickWatch"\n      title     = "Quickwatch" \n      buttons   = "close" \n      modal     = "false" \n      center    = "true"\n      width     = "500"\n      skin      = "bk-window"\n      class     = "nofooter"\n      height    = "350"\n      resizable = "true"\n      kbclose   = "true">\n        <a:vbox anchors="0 0 0 0">\n            <a:textbox id="txtCurObject" \n                skin      = "tbempty" \n                margin    = "5" \n                realtime  = "true"\n                disabled  = "{!stDebugProcessRunning.active or stRunning.active}"\n                initial-message = "Enter an expression"\n                focusselect     = "true" \n                onclear   = "\n                    dgWatch.clear();\n                "/>\n            \n            <a:datagrid id="dgWatch"\n              flex       = "1"\n              border     = "1 0 0 0"\n              options    = "size|move"\n              class      = "noscrollbar"\n              scrollbar  = "sbShared 20 2 2"\n              prerender  = "false"\n              caching    = "false"\n              disabled   = "{!stDebugProcessRunning.active or stRunning.active}"\n              empty-message   = "Type a javascript expression and press enter."\n              loading-message = "Calculating..."\n              onafterselect   = "\n                if (this.selected)\n                    txtCurObject.setValue(require(\'ext/debugger/inspector\').calcName(this.selected, true));\n              "\n              onbeforechange  = "\n                return require(\'ext/debugger/inspector\').checkChange(event.args[0]);\n              ">\n                <a:model>\n                    <vars />\n                </a:model>\n                <a:actions />\n                <a:each match="[item|globals]" sort="[@name]">\n                    <a:insert match="[item[@children]]" get="{adbg.loadObjects(dbg, %[.])}" />\n                    <a:expanded match="[node()[@expand]]" />\n                    <a:column caption="Property" value="{[@name] || \'Globals\'}" width="120" icon="debugger/genericvariable_obj.gif" tree="true" />\n                    <a:column caption="Value" value="{apf.escapeXML([@value])}" width="100%" />\n                    <a:column caption="Type" value="[@type]" width="80"/>\n                </a:each>\n                <a:change set="{require(\'ext/debugger/inspector\').applyChange(xmlNode);}" />\n            </a:datagrid>\n        </a:vbox>\n    </a:window>\n</a:application>';});

define('text!ext/quicksearch/skin.xml',[],function () { return '<?xml version=\'1.0\'?>\n<a:skin xmlns:a="http://ajax.org/2005/aml" xmlns="http://www.w3.org/1999/xhtml">\n   <a:bar name="bar">\n        <a:style><![CDATA[\n            .barQuickSearch{\n                position : relative;\n\n                -webkit-border-top-left-radius: 0px;\n                -webkit-border-top-right-radius: 0px;\n                -webkit-border-bottom-right-radius: 8px;\n                -webkit-border-bottom-left-radius: 8px;\n                -moz-border-radius-topleft: 0px;\n                -moz-border-radius-topright: 0px;\n                -moz-border-radius-bottomright: 8px;\n                -moz-border-radius-bottomleft: 8px;\n                border-top-left-radius: 0px;\n                border-top-right-radius: 0px;\n                border-bottom-right-radius: 8px;\n                border-bottom-left-radius: 8px;\n\n                border-left: 1px solid #b8b8b8;\n                border-right: 1px solid #b8b8b8;\n                border-bottom: 1px solid #b8b8b8;\n\n                background-color: #e8e8e8;\n                background: -webkit-gradient(linear,left bottom,left top,color-stop(0, rgb(232,232,232)),color-stop(1, rgb(227,227,227)));\n                background:-moz-linear-gradient(center bottom,rgb(232,232,232) 0%,rgb(227,227,227) 100%);\n            }\n            \n            #divSearchCount {\n                position: absolute;\n                width: auto;\n                height: 19px;\n                right: 73px;\n                top: 2px;\n            }\n            \n            #divSearchCount .searchIter,\n            #divSearchCount .searchTotal {\n                color: #aaa;\n                font-size: 11px;\n                height: 19px;\n                line-height: 20px;\n                text-align: center;\n                vertical-align: middle;\n                display:inline;\n                float: left;\n            }\n            \n            #divSearchCount .searchIter {\n                margin: 0 1px 0 0;\n                padding: 0 0 0 7px;\n            }\n            \n            #divSearchCount .searchTotal {\n                margin: 0;\n                padding: 0 5px 0 2px;\n            }\n        ]]></a:style>\n\n        <a:presentation>\n            <a:main container=".">\n                <div class="barQuickSearch">\n                </div>\n            </a:main>\n        </a:presentation>\n    </a:bar>\n\n    <a:button name="btnsearchicon">\n        <a:style><![CDATA[\n            .btnsearchicon {\n                cursor             : pointer;\n                position           : relative;\n                -moz-user-select   : none;\n                -khtml-user-select : none;\n                user-select        : none;\n                \n            }\n            .btnsearchicon .lbl {\n                width              : 20px;\n                height             : 21px;\n                padding-top        : 4px;\n                overflow           : hidden;\n            }\n            .btnsearchicon span {\n                height: 20px;\n                display: block;\n                background-repeat:no-repeat;\n                background-position: 2px 1px;\n            }\n\n            .btnsearchiconOver span {\n                background-position: 2px -20px;\n            }\n            .btnsearchiconDown span {\n                background-position: 2px -40px;\n            }\n        ]]></a:style>\n        <a:presentation>\n            <a:main\n              caption    = "div[1]/text()"\n              label      = "div[1]/text()"\n              background = "."\n              icon       = "div[1]/span"\n              minwidth   = "20">\n                <div class="btnsearchicon">\n                    <div class="lbl">-\n                        <span></span>\n                    </div>\n                 </div>\n            </a:main>\n        </a:presentation>\n    </a:button>\n    <a:button name="btnquicksearchnav">\n        <a:style><![CDATA[\n            .btnquicksearchnav {\n                height             : 22px;\n                cursor             : pointer;\n                position           : relative;\n                -moz-user-select   : none;\n                -khtml-user-select : none;\n                user-select        : none;\n                width              : 20px;\n             }\n            .btnquicksearchnav .lbl{\n                background-color: #e5e5e5;\n                background: -webkit-gradient(linear,left bottom,left top,color-stop(0, rgb(229,229,229)),color-stop(1, rgb(248,248,248)));\n                background:-moz-linear-gradient(center bottom,rgb(229,229,229) 0%,rgb(248,248,248) 100%);\n                color: #333333;\n                border: 1px solid #afafaf;\n                margin: 0;\n                outline: none;\n                font-family: Tahoma, Arial;\n                font-size: 12px;\n                text-overflow: ellipsis;\n                -webkit-box-shadow: 0px 1px 0px #ffffff;\n                -moz-box-shadow: 0px 1px 0px #ffffff;\n                box-shadow: 0px 1px 0px #ffffff;\n                height : 22px;\n                padding-top: 1px;\n            }\n\n            .btnquicksearchnavOver .lbl {\n                background: -webkit-gradient(linear,left bottom,left top,color-stop(0, rgb(237,237,237)),color-stop(1, rgb(254,254,254)));\n                background:-moz-linear-gradient(center bottom,rgb(237,237,237) 0%,rgb(254,254,254) 100%);\n            }\n            .btnquicksearchnavDown .lbl {\n                background: -webkit-gradient(linear,left bottom,left top,color-stop(0, rgb(248,248,248)),color-stop(1, rgb(229,229,229)));\n                background:-moz-linear-gradient(center bottom,rgb(248,248,248) 0%,rgb(229,229,229) 100%);\n            }\n\n            .btnquicksearchnav.btnquicksearchnavLeft .lbl {\n                border-right: none;\n                border-left: none;\n            }\n            .btnquicksearchnav.btnquicksearchnavRight .lbl{\n                border-left: none;\n                -webkit-border-top-left-radius: 0px;\n                -webkit-border-top-right-radius: 4px;\n                -webkit-border-bottom-right-radius: 4px;\n                -webkit-border-bottom-left-radius: 0px;\n                -moz-border-radius-topleft: 0px;\n                -moz-border-radius-topright: 4px;\n                -moz-border-radius-bottomright: 4px;\n                -moz-border-radius-bottomleft: 0px;\n                border-top-left-radius: 0px;\n                border-top-right-radius: 4px;\n                border-bottom-right-radius: 4px;\n                border-bottom-left-radius: 0px;\n            }\n\n            .btnquicksearchnav .lbl {\n                \n            }\n            .btnquicksearchnav span {\n                background-repeat:no-repeat;\n                display: block;\n                height: 22px;\n                background-position:center center;\n            }\n\n            .btnquicksearchnav .btnDivider {\n                z-index: 1;\n                border-color: transparent white transparent #C3C3C3;\n                border-left:1px solid #C3C3C3;\n                border-right:1px solid white;\n                border-style:none solid;\n                border-width:medium 1px;\n                cursor:default;\n                height:17px;\n                line-height:0;\n                position:absolute;\n                right: -1px;\n                top:4px;\n                width:0;\n                display: none;\n            }\n\n            .btnquicksearchnav.withDivider .btnDivider {\n                display: block;\n            }\n        ]]></a:style>\n        <a:presentation>\n            <a:main\n              caption    = "div[1]/text()"\n              label      = "div[1]/text()"\n              background = "."\n              icon       = "div[1]/span"\n              minwidth   = "20">\n                <div class="btnquicksearchnav">\n                    <div class="lbl">-\n                        <span></span>\n                        <div class="btnDivider"></div>\n                    </div>\n                 </div>\n            </a:main>\n        </a:presentation>\n    </a:button>\n</a:skin>\n';});

define('text!ext/quicksearch/quicksearch.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:bar id="winQuickSearch"\n      skinset = "quicksearch"\n      visible = "false"\n      width   = "350"\n      kbclose = "true"\n      top     = "-27"\n      right   = "30"\n      focussable = "true">\n        <a:hbox edge="0 5 5 5">\n            <a:textbox id="txtQuickSearch" flex="1" focusselect="true" skin="searchbox_textbox" skinset="default" onkeyup="require(\'ext/quicksearch/quicksearch\').handleQuicksearchEscape(event)" />\n            <a:button onclick="require(\'ext/quicksearch/quicksearch\').findprevious()" skin="btnquicksearchnav" class="btnquicksearchnavLeft withDivider" icon="arrow_left_search.png" />\n            <a:button onclick="require(\'ext/quicksearch/quicksearch\').findnext()" skin="btnquicksearchnav" class="btnquicksearchnavRight" icon="arrow_right_search.png" />\n            <a:button margin="0 0 0 5" skin="btnsearchicon" icon="rounded_close.png" onclick="\n              require(\'ext/quicksearch/quicksearch\').toggleDialog(-1);\n            " />\n            <div id="divSearchCount"><span class="searchIter" id="spanSearchIter">0</span><span class="searchTotal" id="spanSearchTotal">0</span></div>\n        </a:hbox>\n    </a:bar>\n</a:application>\n';});

define('text!ext/gotoline/skin.xml',[],function () { return '<?xml version=\'1.0\'?>\r\n<a:skin xmlns:a="http://ajax.org/2005/aml" xmlns="http://www.w3.org/1999/xhtml">\r\n    <a:list name="list">\r\n        <a:style><![CDATA[\r\n            .gotolinelist{\r\n                overflow: hidden;\r\n                position: relative;\r\n                background-color: #545454;\r\n                background: -webkit-gradient(linear,left bottom,left top,color-stop(0, rgb(69,69,69)),color-stop(1, rgb(84,84,84)));\r\n                background: -moz-linear-gradient(center bottom,rgb(69,69,69) 0%,rgb(84,84,84) 100%);\r\n                color: #e7e7e7;\r\n                border-top: 1px solid #282727;\r\n                border-bottom: 1px solid #575757;\r\n                margin: 0;\r\n                outline: none;\r\n                font-family: Tahoma;\r\n                font-size: 12px;\r\n                text-overflow: ellipsis;\r\n                -webkit-border-radius: 2px;\r\n                -moz-border-radius: 2px;\r\n                border-radius: 2px;\r\n                cursor: default;\r\n                text-align: right;\r\n            }\r\n            .gotolinelist>.selected{\r\n                background-color: #5f5f5f;\r\n                color: #e7e7e7;\r\n            }\r\n            .gotolinelistFocus>.selected{\r\n                color : #e7e7e7;\r\n            }\r\n            .gotolinelist .empty, .gotolinelist .offline, .gotolinelist .loading{\r\n                text-align: center;\r\n                padding: 8px 0 0 0;\r\n                color: #777;\r\n                font-size : 8pt;\r\n                font-weight : normal;\r\n            }\r\n            .gotolinelist>DIV{\r\n                padding: 2px 6px;\r\n            }\r\n\r\n        ]]></a:style>\r\n\r\n        <a:presentation>\r\n            <a:main container=".">\r\n                <div class=\'gotolinelist\'>\r\n                </div>\r\n            </a:main>\r\n            <a:item\r\n            class     = "."\r\n            container = "."\r\n            caption   = "."\r\n            select    = "."\r\n        >\r\n                <div> </div>\r\n            </a:item>\r\n            <a:empty caption=".">\r\n                <div class="message">-</div>\r\n            </a:empty>\r\n        </a:presentation>\r\n    </a:list>\r\n    <a:bar name="bar">\r\n        <a:style><![CDATA[\r\n            .barGotoline{\r\n                position : absolute;\r\n                background-color: #353637;\r\n                -webkit-border-top-left-radius: 0px;\r\n                -webkit-border-top-right-radius: 8px;\r\n                -webkit-border-bottom-right-radius: 8px;\r\n                -webkit-border-bottom-left-radius: 0px;\r\n                -moz-border-radius-topleft: 0px;\r\n                -moz-border-radius-topright: 8px;\r\n                -moz-border-radius-bottomright: 8px;\r\n                -moz-border-radius-bottomleft: 0px;\r\n                border-top-left-radius: 0px;\r\n                border-top-right-radius: 8px;\r\n                border-bottom-right-radius: 8px;\r\n                border-bottom-left-radius: 0px;\r\n                -webkit-box-shadow: 1px 1px 4px #666666;\r\n                -moz-box-shadow: 1px 1px 4px #666666;\r\n                box-shadow: 1px 1px 4px #666666;\r\n                width : 20px;\r\n                left : -100px;\r\n            }\r\n            .brGtlContent {\r\n            }\r\n            .barGotoline .brGtlTop {\r\n                background: url(images/barGotoLineCorners.png) no-repeat 0 0;\r\n                height: 3px;\r\n                width: 4px;\r\n                position: absolute;\r\n                top: -3px;\r\n                left:0;\r\n            }\r\n            .barGotoline .brGtlBottom {\r\n                background: url(images/barGotoLineCorners.png) no-repeat 0 -3px;\r\n                height: 3px;\r\n                width: 4px;\r\n                position: absolute;\r\n                bottom: -3px;\r\n                left:0;\r\n            }\r\n        ]]></a:style>\r\n        <a:style condition="apf.isIE"><![CDATA[\r\n            .barGotoline .brGtlTop, .barGotoline .brGtlBottom {\r\n                display: none;\r\n            }\r\n        ]]></a:style>\r\n        <a:presentation>\r\n            <a:main container=".">\r\n                <div class="barGotoline">\r\n                    <div class="brGtlTop"></div>\r\n                    <div class="brGtlBottom"></div>\r\n                </div>\r\n            </a:main>\r\n        </a:presentation>\r\n    </a:bar>\r\n    <a:textbox name="textbox">\r\n        <a:style><![CDATA[\r\n            .tbGotoline {\r\n                position : relative;\r\n                height   : 25px;\r\n            }\r\n\r\n            .tbGotoline .sbtb_middle {\r\n                height           : 15px;\r\n                padding          : 2px 5px;\r\n\r\n                background-color: #ffffff;\r\n                background: -webkit-gradient(linear,left bottom,left top,color-stop(0.5, rgb(255,255,255)),color-stop(1, rgb(235,235,235)));\r\n                background: -moz-linear-gradient(center bottom,rgb(255,255,255) 50%,rgb(235,235,235) 100%);\r\n                color: #0471cf;\r\n                border-top: 1px solid #fafafa;\r\n                margin: 0;\r\n                outline: none;\r\n                font-family: Tahoma;\r\n                font-size: 12px;\r\n                text-overflow: ellipsis;\r\n                -webkit-border-radius: 2px;\r\n                -moz-border-radius: 2px;\r\n                border-radius: 2px;\r\n\r\n                -webkit-box-shadow: 0px 1px 0px #ffffff;\r\n                -moz-box-shadow: 0px 1px 0px #ffffff;\r\n                box-shadow: 0px 1px 0px #ffffff;\r\n            }\r\n\r\n            .tbGotoline .sbtb_middle INPUT {\r\n                border           : 0;\r\n                height           : 13px;\r\n                font-size        : 12px;\r\n                color            : #0471cf;\r\n                font-family      : Arial;\r\n                outline          : none;\r\n                background-color : transparent;\r\n                width: 100%;\r\n                text-align: right;\r\n            }\r\n\r\n            .tbGotolineInitial .sbtb_middle INPUT {\r\n                color : #0471cf;\r\n            }\r\n\r\n            .tbGotolineDisabled .sbtb_middle INPUT {\r\n                color : #0471cf;\r\n            }\r\n\r\n            .tbGotolineDisabled .sbtb_middle{\r\n                background: -webkit-gradient(linear,left bottom,left top,color-stop(0, rgb(235,235,235)),color-stop(0.4, rgb(255,255,255)));\r\n                background: -moz-linear-gradient(center bottom,rgb(235,235,235) 0%,rgb(255,255,255) 40%);\r\n                cursor : default;\r\n            }\r\n        ]]></a:style>\r\n        <a:style condition="apf.isWebkit"><![CDATA[\r\n            .tbGotoline .sbtb_middle INPUT {\r\n                position : relative;\r\n                top : -3px;\r\n                padding : 0;\r\n                height : auto;\r\n            }\r\n        ]]></a:style>\r\n\r\n        <a:presentation>\r\n            <a:main input="div[1]/input">\r\n                <div class="tbGotoline">\r\n                    <div class="sbtb_middle">\r\n                        <input type="text" />\r\n                    </div>\r\n                </div>\r\n            </a:main>\r\n        </a:presentation>\r\n    </a:textbox>\r\n</a:skin>\r\n';});

define('text!ext/gotoline/gotoline.xml',[],function () { return '<?xml version=\'1.0\'?>\n<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:bar id="winGotoLine"\n      skinset = "gotoline"\n      visible = "false"\n      width   = "60"\n      height  = "90"\n      left    = "-100"\n      top     = "-100"\n      zindex  = "10000">\n        <a:vbox anchors="0 0 0 0" padding="0" edge="5">\n            <a:textbox id="txtLineNr"\n              focusselect="true" />\n            <a:list id="lstLineNumber"\n              model   = "{tabEditors.getPage(tabEditors.activepagenr).$model}"\n              flex    = "1"\n              caption = "[@nr]"\n              each    = "[gotoline/line]"\n              autoselect    = "false"\n              multiselect   = "false"\n              empty-message = "empty" />\n        </a:vbox>\n    </a:bar>\n</a:application>\n';});

define('text!ext/html/html.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    \n    <a:bar id="barHtmlMode" visible="false">\n        <a:divider skin="c9-divider" />\n        <!--a:button skin="c9-toolbarbutton" id="btnHtmlRun">run on server...</a:button-->\n        <a:button skin="c9-toolbarbutton" icon="preview.png" class="preview" id="btnHtmlOpen" tooltip="Preview in browser">Preview</a:button>\n    </a:bar>\n   \n</a:application>';});

define('text!ext/help/help.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml"> \n    <a:menu id="mnuHelp">\n        <a:item id="mnuAbout" onclick="require(\'ext/help/help\').showAbout();">About</a:item>\n        <a:divider />\n        <a:item id="mnuDocumentation" onclick="window.open(\'http://support.cloud9ide.com/forums\')">Documentation</a:item>\n        <a:item id="mnuChangelog" onclick="window.open(\'http://c9.io/site/tag/changelog/\')">Changelog</a:item>\n        <a:item id="mnuQuickStart" onclick="require(\'ext/quickstart/quickstart\').launchQS();">Quick Start</a:item>\n        <a:item id="mnuGuidedTour" onclick="require(\'ext/guidedtour/guidedtour\').launchGT();">Take a Guided Tour</a:item>\n        <a:divider />\n        <a:item id="mnuKeybindings" onclick="require(\'ext/keybindings_default/keybindings_default\').keybindings();">Keyboard Shortcuts</a:item>\n        <a:divider />\n        <a:item submenu="mnuSupport">Support</a:item>\n        <a:divider />\n        <a:item submenu="mnuLearning">Learning</a:item>\n        <a:divider />\n        <a:item submenu="mnuContact">Get in Touch</a:item>\n    </a:menu>\n  \n    <a:menu id="mnuSupport">\n        <a:item id="mnuFAQ" onclick="window.open(\'http://support.cloud9ide.com/forums/20346041-frequently-asked-questions\')">FAQ</a:item>\n        <a:item id="mnuTroubleshooting" onclick="window.open(\'http://support.cloud9ide.com/forums/20329737-troubleshooting\')">Troubleshooting Tips</a:item>\n        <a:divider />\n        <a:item id="mnuLogAnIssue" onclick="window.open(\'https://github.com/ajaxorg/cloud9/issues?milestone=1\')">Report a bug</a:item>     \n    </a:menu>\n    \n    <a:menu id="mnuLearning">\n        <a:item id="mnuYouTube" onclick="window.open(\'http://www.youtube.com/user/c9ide/videos?view=pl\')">YouTube Channel for Cloud9 IDE</a:item>\n    </a:menu>\n\n    <a:menu id="mnuContact">\n        <a:item id="mnuBlog" onclick="window.open(\'http://cloud9ide.posterous.com/\')">Blog for Cloud9</a:item>\n        <a:item id="mnuTwitterSupport" onclick="window.open(\'https://twitter.com/#!/C9Support\')">Twitter (for Cloud9 IDE support)</a:item>\n        <a:item id="mnuTwitterGeneral" onclick="window.open(\'https://twitter.com/#!/cloud9ide\')">Twitter (for general Cloud9 tweets)</a:item>\n        <a:item id="mnuFacebook" onclick="window.open(\'https://www.facebook.com/Cloud9IDE\')">Facebook for Cloud9</a:item>     \n    </a:menu>\n      \n    <a:window\n      id        = "aboutDialog"\n      icon      = ""\n      kbclose   = "true"\n      center    = "true"\n      width     = "512"\n      skinset   = "help-skin"\n      buttons   = "close"\n      skin      = "win-help-about"\n      class     = "aboutDialogBox">\n        <div class="aboutImage">\n            <div id="c9Version"><?lm\n                Version {cloud9config.version}\n            ?></div>\n             <!-- <div class="c9Legal">\n            <p><a href="http://www.bettercallsaul.com/">Click here for legal notices.</p>\n            </div> -->\n            <div class="c9StaffHeader">\n                <p>Cloud9 IDE is brought to you by:</p>\n            </div>\n            <div class="c9Staff">\n                <p>\n                    Ruben Daniels, Rik Arends, David van Ballegooijen, Zef Hemel, Chrissy Welsh, \n                    Lieke Arends, Esther Visser, Sergi Mansilla, Daniela Gavidia, Mike de Boer,\n                    Fabian Jakobs, Matt Pardee, Bert Belder, Ben Noordhuis, Tim Caswell, Jos Uijterwaal,\n                    Linh Nguyen, Giannis Panagiotou, Mostafa Eweda, Jan Jongboom, Garen Torikian, \n                    Vlad Zinculescu, Detmar ter Huurne, Pippa\n                </p>\n            </div>\n            <div class="c9Copyright">\n                <p>&#169; 2010 — 2012 Cloud9 IDE Inc. All rights reserved</p>\n            </div>\n        </div>\n    </a:window>\n</a:application>';});

define('text!ext/help/style.css',[],function () { return '#c9Version {\n    position: absolute;\n    top: 80px;\n    left: 215px;\n    color: white;\n    font-size: 12px;\n    padding-left: 12px;\n}\n\n.c9Legal {\n    position: absolute;\n    top: 60px;\n    left: 225px;\n    display:none;\n}\n\n.c9Staff {\n    position: absolute;\n    top: 170px;\n    left: 75px;\n    color: #aaaaaa;\n    font-size: 10px;\n    width: 399px;\n    line-height: 16px;\n}\n\n.c9StaffHeader {\n    text-transform:uppercase;\n    color: #dddddd;\n    font-size: 10px;\n    position: absolute;\n    top: 140px;\n    left: 170px;\n}\n\n.c9Copyright {\n    position: absolute;\n    bottom: 45px;\n    left: 155px;\n    font-size: 10px;\n    color: #aaaaaa;\n}';});

define('text!ext/help/skin.xml',[],function () { return '<?xml version=\'1.0\'?>\n<a:skin xmlns:a="http://ajax.org/2005/aml">\n    <a:modalwindow name="win-help-about">\n        <a:style><![CDATA[\n            .win-help-about {\n                overflow : hidden;\n            }\n\n            .win-help-about .wh-container {\n                overflow:visible;\n                z-index: 1;\n                position: relative;\n            }\n            \n            .aboutDialogBox .aboutImage {\n                position:relative;\n                color: white;\n                background: url(images/about_cloud.png) no-repeat 0 0;\n                width: 515px;\n                height: 339px;\n            }\n            \n            .win-help-about .buttons {\n                position: absolute;\n                top: 68px;\n                right: 78px;\n                z-index: 2;\n            }\n            .win-help-about .buttons .close {\n                 height: 20px;\n                width: 19px;\n                background: url(images/close.png) no-repeat 4px 3px;\n            }\n            \n            .win-help-about .buttons .close.hover {\n                background-position: -14px 3px;\n            }\n            \n            .win-help-about .buttons .close.down {\n                background-position: -31px 3px;\n            }\n        ]]></a:style>\n    \n        <a:presentation>\n            <a:main\n              collapsed-height = "26"\n              minheight        = "50"\n              minwidth         = "50"\n              drag             = "div[2]"\n              container        = "div[2]"\n              title            = "div[2]/text()"\n              buttons          = "div[1]">\n                <div class="win-help-about">\n                    <div class="buttons"></div>\n                    <div class="wh-container"> </div>\n                </div>\n            </a:main>\n            <a:button>\n                <div> </div>\n            </a:button>\n            <a:cover>\n                <div opacity="0"> </div>\n            </a:cover>\n        </a:presentation>\n    </a:modalwindow>\n</a:skin>';});

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

// #ifdef __AMLCODEEDITOR || __INC_ALL

/**
 * Element allowing the user to type code.
 *
 * @constructor
 * @define codeeditor
 * @addnode elements
 *
 * @inherits apf.StandardBinding
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @author      Fabian Jakobs (fabian AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.1
 */

define('apf/elements/codeeditor',['require','exports','module','ace/editor','ace/edit_session','ace/virtual_renderer','ace/undomanager','ace/range','ace/lib/net','ace/lib/fixoldbrowsers'],function(require, exports, module) {

var Editor = require("ace/editor").Editor;
var EditSession = require("ace/edit_session").EditSession;
var VirtualRenderer = require("ace/virtual_renderer").VirtualRenderer;
var UndoManager = require("ace/undomanager").UndoManager;
var Range = require("ace/range").Range;
var net = require("ace/lib/net");
require("ace/lib/fixoldbrowsers");


apf.codeeditor = module.exports = function(struct, tagName) {
    this.$init(tagName || "codeeditor", apf.NODE_VISIBLE, struct);

    this.documents = [];
    this.$cache    = {};

    //this.setProperty("overwrite", false);
    this.setProperty("line", 1);
    this.setProperty("col", 1);
};

(function() {
    this.implement(
        //#ifdef __WITH_DATAACTION
        apf.DataAction
        //#endif
    );

    this.$focussable       = true; // This object can get the focus
    this.$childProperty    = "value";
    this.$isTextInput      = true;

    this.value             = "";
    this.multiline         = true;
    this.caching           = true;

    this.$booleanProperties["activeline"]               = true;
    this.$booleanProperties["caching"]                  = true;
    this.$booleanProperties["readonly"]                 = true;
    this.$booleanProperties["activeline"]               = true;
    this.$booleanProperties["showinvisibles"]           = true;
    this.$booleanProperties["showprintmargin"]          = true;
    this.$booleanProperties["overwrite"]                = true;
    this.$booleanProperties["softtabs"]                 = true;
    this.$booleanProperties["gutter"]                   = true;
    this.$booleanProperties["highlightselectedword"]    = true;
    this.$booleanProperties["autohidehorscrollbar"]     = true;
    this.$booleanProperties["behaviors"]                = true;
    this.$booleanProperties["folding"]                  = true;
    this.$booleanProperties["wrapmode"]                 = true;

    this.$supportedProperties.push("value", "syntax", "activeline", "selectstyle",
        "caching", "readonly", "showinvisibles", "showprintmargin", "printmargincolumn",
        "overwrite", "tabsize", "softtabs", "debugger", "model-breakpoints", "scrollspeed",
        "theme", "gutter", "highlightselectedword", "autohidehorscrollbar",
        "behaviors", "folding");

    this.$getCacheKey = function(value) {
        if (typeof value == "string") {
            var key = this.xmlRoot
                ? this.xmlRoot.getAttribute(apf.xmldb.xmlIdTag)
                : value;
        }
        else if (value.nodeType) {
            var key = value.getAttribute(apf.xmldb.xmlIdTag);
        }

        return key;
    };

    this.clearCacheItem = function(xmlNode) {
        if (!this.caching)
            return;

        var key = this.$getCacheKey(xmlNode);
        if (key)
            delete this.$cache[key];
    };

    this.addEventListener("unloadmodel", function() {
        this.syncValue();
    });

    /**
     * @attribute {String} value the text of this element
     * @todo apf3.0 check use of this.$propHandlers["value"].call
     */
    this.$propHandlers["value"] = function(value){ //@todo apf3.0 add support for the range object as a value
        var doc, key,
            _self = this;

        if (this.caching)
            key = this.$getCacheKey(value);

        //Assuming document
        if (value instanceof EditSession)
            doc = value;

        if (!doc && key)
            doc = this.$cache[key];

        if (!doc) {
            if (value.nodeType) {
                apf.xmldb.addNodeListener(value.nodeType == 1
                    ? value : value.parentNode, this);
            }

            doc = new EditSession(typeof value == "string"
              ? value
              : (value.nodeType > 1 && value.nodeType < 5 //@todo replace this by a proper function
                    ? value.nodeValue
                    : value.firstChild && value.firstChild.nodeValue || ""));

            doc.cacheId = key;
            doc.setUndoManager(new UndoManager());

            if (key)
                this.$cache[key] = doc;
        }
        //@todo value can also be an xml node and should be updated in a similar fashion as above
        else if (typeof value == "string" && !doc.hasValue) {
            //@todo big hack!
            doc.setValue(value);
            this.$editor.moveCursorTo(0, 0);
            doc.hasValue = true;
        }

        _self.getMode(_self.syntax, function(mode) {
            doc.setMode(mode);
        });

        doc.setTabSize(parseInt(_self.tabsize, 10));
        doc.setUseSoftTabs(_self.softtabs);
        doc.setUseWrapMode(_self.wrapmode);
        doc.setWrapLimitRange(_self.wraplimitmin, _self.wraplimitmax);
        doc.setFoldStyle(_self.folding ? "markbegin" : "manual");

        _self.$removeDocListeners && _self.$removeDocListeners();
        _self.$removeDocListeners = _self.$addDocListeners(doc);

        _self.$editor.setShowPrintMargin(_self.showprintmargin);

        // remove existing markers
        _self.$clearMarker();

        _self.$editor.setSession(doc);

        // clear breakpoints
        doc.setBreakpoints([]);
    };

    this.afterOpenFile = function(doc) {
        this.$updateMarker();
        this.$updateBreakpoints(doc);
    };

    this.$addDocListeners = function(doc) {
        var _self = this;
        var onCursorChange = function() {
            var cursor = doc.getSelection().getCursor();
            _self.setProperty("line", cursor.row+1);
            _self.setProperty("col", cursor.column+1);
        };

        doc.getSelection().addEventListener("changeCursor", onCursorChange);

        onCursorChange();

        return function() {
            doc.getSelection().removeEventListener("changeCursor", onCursorChange);
        };
    };

    this.$clearMarker = function () {
        if (this.$marker) {
            this.$editor.renderer.removeGutterDecoration(this.$lastRow[0], this.$lastRow[1]);
            this.$editor.getSession().removeMarker(this.$marker);
            this.$marker = null;
        }
    };

    /**
     * Indicates whether we are going to set a marker
     */
    this.$updateMarkerPrerequisite = function () {
        return this.$debugger && this.$debugger.$updateMarkerPrerequisite();
    };

    this.$updateMarker = function () {
        this.$clearMarker();

        var frame = this.$updateMarkerPrerequisite();
        if (!frame) {
            return;
        }

        var script = this.xmlRoot;
        if (script.getAttribute("scriptid") !== frame.getAttribute("scriptid")) {
            return;
        }

        var head = this.$debugger.$mdlStack.queryNode("frame[1]");
        var isTop = frame == head;
        var lineOffset = parseInt(script.getAttribute("lineoffset") || "0", 10);
        var row = parseInt(frame.getAttribute("line"), 10) - lineOffset;
        var range = new Range(row, 0, row + 1, 0);
        this.$marker = this.$editor.getSession().addMarker(range, isTop ? "ace_step" : "ace_stack", "line");
        var type = isTop ? "arrow" : "stack";
        this.$lastRow = [row, type];
        this.$editor.renderer.addGutterDecoration(row, type);
        this.$editor.gotoLine(row + 1, parseInt(frame.getAttribute("column"), 10));
    };

    this.$updateBreakpoints = function(doc) {
        doc = doc || this.$editor.getSession();

        doc.setBreakpoints([]);
        if (!this.$breakpoints) {
            return;
        }

        if (this.xmlRoot) {
            var scriptName = this.xmlRoot.getAttribute("scriptname");
            if (!scriptName)
                return;

            var breakpoints = this.$breakpoints.queryNodes("//breakpoint[@script='" + scriptName + "']");

            var rows = [];
            for (var i=0; i<breakpoints.length; i++) {
                rows.push(parseInt(breakpoints[i].getAttribute("line"), 10) - parseInt(breakpoints[i].getAttribute("lineoffset"), 10));
            }
            if (rows.length)
                doc.setBreakpoints(rows);
        }
    };

    this.$toggleBreakpoint = function(row) {
        this.$debugger.toggleBreakpoint(this.xmlRoot, row);
    };

    this.$propHandlers["theme"] = function(value) {
        this.$editor.setTheme(value);
    };

    this.$propHandlers["syntax"] = function(value) {
        var _self = this;
        this.getMode(value, function(mode) {
            // the syntax could have changed while loading the mode
            if (_self.syntax == value)
                _self.$editor.getSession().setMode(mode);
        });
    };

    this.$modes = {};

    this.$basePath = "";
    this.$guessBasePath = function() {
        console.log("ace base url " + define.aceBaseUrl);

        if (define.aceBaseUrl)
            return define.aceBaseUrl;

        if (this.$basePath)
            return this.$basePath;

        var scripts = document.getElementsByTagName("script");
        for (var i=0; i<scripts.length; i++) {
            var script = scripts[i];

            var src = script.src || script.getAttribute("src");
            if (!src)
                continue;

            var m = src.match(/^(?:(.*\/)ace\.js|(.*\/)ace(-uncompressed)?(-noconflict)?\.js)(?:\?|$)/);
            if (m) {
                this.$basePath = m[1] || m[2];
                break;
            }
        }
        return this.$basePath;
    };

    /**
     * Looks up an object by ID from a cache. If the item is not in the cache it is
     * created on demand using the factory function. Intermitted calls to the same
     * id are pooled until the object is created
     */
    this._lazyCreate = function(id, cache, callbackStore, factory, callback) {
        var item = cache[id];
        if (item)
            return callback(null, item);

        if (callbackStore[id]) {
            callbackStore[id].push(callback);
            return;
        }

        callbackStore[id] = [callback];

        factory(id, function(err, item) {
            var callbacks = callbackStore[id];
            delete callbackStore[id];

            cache[id] = item;

            callbacks.forEach(function(cb) {
                cb(err, item);
            });
        });
    };

    this.$modeCallbacks = {};
    this.getMode = function(syntax, callback) {
        var _self = this;

        syntax = (syntax || "text").toLowerCase();
        if (syntax.indexOf("/") == -1)
            syntax = "ace/mode/" + syntax;

        this._lazyCreate(syntax, this.$modes, this.$modeCallbacks, function(syntax, callback) {
            // load packaged version
            if (define.packaged) {
                var base = syntax.split("/").pop();
                var fileName = _self.$guessBasePath() + "mode-" + base + ".js";
                net.loadScript(fileName, afterPreload);
            }
            else
                afterPreload();

            function afterPreload() {
                require([syntax], function(modeModule) {
                    // #ifdef __DEBUG
                    if (typeof modeModule.Mode != "function") {
                        apf.console.error("Unkown syntax type: '" + syntax + "'");
                        return callback("Unkown syntax type: '" + syntax + "'");
                    }
                    // #endif
                    _self.$modes[syntax] = new modeModule.Mode();
                    callback(null, _self.$modes[syntax]);
                });
            }
        }, function(err, mode) {
            callback(mode);
        });
    };

    this.$propHandlers["activeline"] = function(value) {
        this.$editor.setHighlightActiveLine(value);
    };

    this.$propHandlers["selectstyle"] = function(value) {
        this.$editor.setSelectionStyle(value);
    };

    this.$propHandlers["showprintmargin"] = function(value, prop, initial) {
        this.$editor.setShowPrintMargin(value);
    };

    this.$propHandlers["printmargincolumn"] = function(value, prop, initial) {
        this.$editor.setPrintMarginColumn(value);
    };

    this.$propHandlers["showinvisibles"] = function(value, prop, initial) {
        this.$editor.setShowInvisibles(value);
    };

    this.$propHandlers["overwrite"] = function(value, prop, initial) {
        this.$editor.setOverwrite(value);
    };

    this.$propHandlers["readonly"] = function(value, prop, initial) {
        this.$editor.setReadOnly(value);
    };

    this.$propHandlers["tabsize"] = function(value, prop, initial) {
        this.$editor.getSession().setTabSize(parseInt(value, 10));
    };

    this.$propHandlers["folding"] = function(value, prop, initial) {
        this.$editor.setShowFoldWidgets(value);
        this.$editor.getSession().setFoldStyle(value ? "markbegin" : "manual");
    };

    this.$propHandlers["softtabs"] = function(value, prop, initial) {
        this.$editor.getSession().setUseSoftTabs(value);
    };

    this.$propHandlers["scrollspeed"] = function(value, prop, initial) {
        this.$editor.setScrollSpeed(value || 2);
    };

    this.$propHandlers["gutter"] = function(value, prop, initial) {
        this.$editor.renderer.setShowGutter(value);
    };

    this.$propHandlers["fontsize"] = function(value, prop, initial) {
        this.$ext.style.fontSize = value + "px";
    };
    this.$propHandlers["wrapmode"] = function(value, prop, initial) {
        this.$editor.getSession().setUseWrapMode(value);
    };
    this.$propHandlers["wraplimitmin"] = function(value, prop, initial) {
        this.$editor.getSession().setWrapLimitRange(value, this.wraplimitmax);
    };
    this.$propHandlers["wraplimitmax"] = function(value, prop, initial) {
        this.$editor.getSession().setWrapLimitRange(this.wraplimitmin, value);
    };
    this.$propHandlers["highlightselectedword"] = function(value, prop, initial) {
        this.$editor.setHighlightSelectedWord(value);
    };
    this.$propHandlers["autohidehorscrollbar"] = function(value, prop, initial) {
        this.$editor.renderer.setHScrollBarAlwaysVisible(!value);
    };
    this.$propHandlers["behaviors"] = function(value, prop, initial) {
        this.$editor.setBehavioursEnabled(value);
    };

    this.$propHandlers["model-breakpoints"] = function(value, prop, inital) {
        this.$debuggerBreakpoints = false;

        if (this.$breakpoints)
            this.$breakpoints.removeEventListener("update", this.$onBreakpoint);

        this.$breakpoints = value;

        if (!this.$breakpoints) {
            this.$updateBreakpoints();
            return;
        }

        var _self = this;
        _self.$updateBreakpoints();
        this.$onBreakpoint = function() {
            _self.$updateBreakpoints();
        };
        this.$breakpoints.addEventListener("update", this.$onBreakpoint);
        this.$updateBreakpoints();
    };

    this.$propHandlers["debugger"] = function(value, prop, inital) {
        if (this.$debugger) {
            this.$debugger.removeEventListener("changeframe", this.$onChangeActiveFrame);
            this.$debugger.removeEventListener("break", this.$onChangeActiveFrame);
            this.$debugger.removeEventListener("beforecontinue", this.$onBeforeContinue);
        }

        if (typeof value === "string") {
            //#ifdef __WITH_NAMESERVER
            this.$debugger = apf.nameserver.get("debugger", value);
            //#endif
        } else {
            this.$debugger = value;
        }

        if (!this.$breakpoints || this.$debuggerBreakpoints) {
            this.setProperty("model-breakpoints", this.$debugger ? this.$debugger.$mdlBreakpoints : null);
            this.$debuggerBreakpoints = true;
        }

        if (!this.$debugger) {
            this.$updateMarker();
            return;
        }

        this.$updateMarker();
        var _self = this;
        this.$onChangeActiveFrame = function(e) {
            // if you dont have data, we aren't interested in ya
            if (!e || !e.data) {
                return;
            }

            _self.$updateMarker();
        };
        this.$onBeforeContinue = function() {
            _self.$clearMarker();
        };
        this.$debugger.addEventListener("changeframe", this.$onChangeActiveFrame);
        this.$debugger.addEventListener("break", this.$onChangeActiveFrame);
        this.$debugger.addEventListener("beforecontinue", this.$onBeforeContinue);
    };

    var propModelHandler = this.$propHandlers["model"];
    this.$propHandlers["model"] = function(value) {
        propModelHandler.call(this, value);

        this.$updateMarker();
        this.$updateBreakpoints();
    };

    this.addEventListener("xmlupdate", function(e){
        var id = e.xmlNode.getAttribute(apf.xmldb.xmlIdTag);
        if (this.$cache[id]) {
            //@todo Update document
        }
    });

    /**** Public Methods ****/

    //#ifdef __WITH_CONVENIENCE_API

    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        return this.setProperty("value", value, false, true);
    };

    //@todo cleanup and put initial-message behaviour in one location
    this.clear = function(){
        this.$propHandlers["value"].call(this, "", null, true);

        this.dispatchEvent("clear");//@todo this should work via value change
    };

    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(){
        return this.$editor.getSession().getValue(); //@todo very inefficient
    };

    this.getDocument =
    this.getSession = function() {
        return this.$editor.getSession();
    };

    this.getSelection = function() {
        return this.$editor.getSession().getSelection();
    };

    this.getLastSearchOptions = function() {
        return this.$editor.getLastSearchOptions();
    };

    //#endif

    /**
     * Selects the text in this element.
     */
    this.select   = function(){

    };

    /**
     * Deselects the text in this element.
     */
    this.deselect = function(){
        this.$editor.clearSelection();
    };

    this.scrollTo = function(){ };

    this.getDefaults = function() {
        return this.$defaults;
    };

    /**** Private Methods *****/

    this.$focus = function(e){
        if (!this.$ext || this.$ext.disabled)
            return;

        this.$setStyleClass(this.$ext, this.$baseCSSname + "Focus");

        this.$editor.focus();
    };

    this.syncValue = function() {
        var doc = this.$editor.getSession();
        if (!doc.cacheId || doc.cacheId == this.$getCacheKey(this.value)) {
            var value = this.getValue();
            if (this.value != value)
                this.setProperty("value", value);
                //this.change(value);
        }
    };

    this.$blur = function(e) {
        if (!this.$ext)
            return;

        this.syncValue();

        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Focus"]);
        this.$editor.blur();
    };

    //@todo
    this.addEventListener("keydown", function(e){

    }, true);

    /**** Init ****/

    this.$isTextInput = function(e){
        return true;
    };

    this.$draw = function(){
        //Build Main Skin
        this.$ext   = this.$getExternal();
        this.$input = this.$getLayoutNode("main", "content", this.$ext);

        this.addEventListener("resize", function(e) {
            this.$editor.resize();
        });

        this.$editor = new Editor(new VirtualRenderer(this.$input));
        // read defaults...
        var ed  = this.$editor;

        var _self = this;
        ed.addEventListener("changeOverwrite", function(e) {
            _self.setProperty("overwrite", e.data);
        });

        ed.addEventListener("gutterclick", function(e) {
            if (_self.$debugger && e.clientX - ed.container.getBoundingClientRect().left < 20) {
                _self.$toggleBreakpoint(e.getDocumentPosition().row);
                e.stop();
            }
            else {
                _self.dispatchEvent("gutterclick", e);
            }
        });

        ed.addEventListener("gutterdblclick", function(e) {
            _self.dispatchEvent("gutterdblclick", e);
        });

        apf.sanitizeTextbox(ed.renderer.container.getElementsByTagName("textarea")[0]);
    };

    this.$loadAml = function(){
        var ed  = this.$editor,
            doc = ed.getSession();

        if (this.syntax === undefined)
            this.syntax = "text";
        if (this.tabsize === undefined)
            this.tabsize = doc.getTabSize(); //4
        if (this.softtabs === undefined)
            this.softtabs = doc.getUseSoftTabs(); //true
        if (this.scrollspeed === undefined)
            this.scrollspeed = ed.getScrollSpeed();
        if (this.selectstyle === undefined)
            this.selectstyle = ed.getSelectionStyle();//"line";
        if (this.activeline === undefined)
            this.activeline = ed.getHighlightActiveLine();//true;
        if (this.readonly === undefined)
            this.readonly = ed.getReadOnly();//false;
        if (this.showinvisibles === undefined)
            this.showinvisibles = ed.getShowInvisibles();//false;
        if (this.showprintmargin === undefined)
            this.showprintmargin = ed.getShowPrintMargin();//false;
        if (this.printmargincolumn === undefined)
            this.printmargincolumn = ed.getPrintMarginColumn();//80;
        if (this.overwrite === undefined)
            this.overwrite = ed.getOverwrite();//false

        if (this.fontsize === undefined)
            this.fontsize = 12;
        var wraplimit = doc.getWrapLimitRange();
        if (this.wraplimitmin === undefined)
            this.wraplimitmin = wraplimit.min;
        if (this.wraplimitmax === undefined)
            this.wraplimitmax = wraplimit.max;
        if (this.wrapmode === undefined)
            this.wrapmode = doc.getUseWrapMode(); //false
        if (this.gutter === undefined)
            this.gutter = ed.renderer.getShowGutter();
        if (this.highlightselectedword === undefined)
            this.highlightselectedword = ed.getHighlightSelectedWord();
        if (this.autohidehorscrollbar)
            this.autohidehorscrollbar = !ed.renderer.getHScrollBarAlwaysVisible();
        if (this.behaviors === undefined)
            this.behaviors = !ed.getBehavioursEnabled();
        if (this.folding === undefined)
            this.folding = true;
    };

// #ifdef __WITH_DATABINDING
}).call(apf.codeeditor.prototype = new apf.StandardBinding());
/* #else
}).call(apf.textbox.prototype = new apf.Presentation());
#endif*/

apf.config.$inheritProperties["initial-message"] = 1;

apf.aml.setElement("codeeditor", apf.codeeditor);

});
// #endif
;
define('ext/code/proxydocument',['require','exports','module','ace/lib/oop','ace/document'],function (require, exports, module) {

var oop = require('ace/lib/oop');
var Document = require('ace/document').Document;

var ProxyDocument = function (document) {
    this.$onChange = this.onChange.bind(this);
    this.setDocument(document);
};

oop.inherits(ProxyDocument, Document);

(function() {
    this.getDocument = function () {
        return this.doc;
    };

    this.setDocument = function (newDocument) {
        if (this.doc == newDocument)
            return this.doc;
            
        if (this.doc) {
            this.doc.removeEventListener("change", this.$onChange);
        }
        
        this.doc = newDocument;
        this.doc.addEventListener("change", this.$onChange);
        
        return this.doc;
    };

    this.onChange = function(e) {
        this._dispatchEvent("change", e);
    };

    this.getNewLineCharacter = function () {
        return this.doc.getNewLineCharacter();
    };

    this.getLength = function () {
        return this.doc.getLength();
    };

    this.getLine = function (row) {
        return this.doc.getLine(row);
    };

    this.getLines = function (startRow, endRow) {
        return this.doc.getLines(startRow, endRow);
    };

    this.getTextRange = function (range) {
        return this.doc.getTextRange(range);
    };

    this.insertNewLine = function (position) {
        return this.doc.insertNewLine(position);
    };

    this.insertInLine = function (position, text) {
        return this.doc.insertInLine(position, text);
    };

    this.insertLines = function (row, lines) {
        return this.doc.insertLines(row, lines);
    };

    this.removeNewLine = function (row) {
        return this.doc.removeNewLine(row);
    };

    this.removeInLine = function (row, startColumn, endColumn) {
        return this.doc.removeInLine(row, startColumn, endColumn);
    };

    this.removeLines = function (startRow, endRow) {
        return this.doc.removeLines(startRow, endRow);
    };

    this.applyDeltas = function (deltas) {
        return this.doc.applyDeltas(deltas);
    };

    this.revertDeltas = function (deltas) {
        return this.doc.revertDeltas(deltas);
    };
}).call(ProxyDocument.prototype);

module.exports = ProxyDocument;

});
define('text!ext/code/code.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:codeeditor id="ceEditor"\n      flex              = "1"\n      anchors           = "2 0 0 0"\n      visible           = "false"\n      syntax            = "{require(\'ext/code/code\').getSyntax(%[.])}"\n      theme             = "[{require(\'ext/settings/settings\').model}::editors/code/@theme]"\n      overwrite         = "[{require(\'ext/settings/settings\').model}::editors/code/@overwrite]"\n      folding           = "[{require(\'ext/settings/settings\').model}::editors/code/@folding]"\n      behaviors         = "[{require(\'ext/settings/settings\').model}::editors/code/@behaviors]"\n      selectstyle       = "[{require(\'ext/settings/settings\').model}::editors/code/@selectstyle]"\n      activeline        = "[{require(\'ext/settings/settings\').model}::editors/code/@activeline]"\n      showinvisibles    = "[{require(\'ext/settings/settings\').model}::editors/code/@showinvisibles]"\n      showprintmargin   = "[{require(\'ext/settings/settings\').model}::editors/code/@showprintmargin]"\n      printmargincolumn = "[{require(\'ext/settings/settings\').model}::editors/code/@printmargincolumn]"\n      softtabs          = "[{require(\'ext/settings/settings\').model}::editors/code/@softtabs]"\n      tabsize           = "[{require(\'ext/settings/settings\').model}::editors/code/@tabsize]"\n      scrollspeed       = "[{require(\'ext/settings/settings\').model}::editors/code/@scrollspeed]"\n      \n      fontsize          = "[{require(\'ext/settings/settings\').model}::editors/code/@fontsize]"\n      wrapmode          = "[@wrapmode]"\n      wraplimitmin      = "80"\n      wraplimitmax      = "80"\n      gutter            = "[{require(\'ext/settings/settings\').model}::editors/code/@gutter]"\n      highlightselectedword = "[{require(\'ext/settings/settings\').model}::editors/code/@highlightselectedword]"\n      autohidehorscrollbar  = "[{require(\'ext/settings/settings\').model}::editors/code/@autohidehorscrollbar]"\n      \n      contextmenu       = "mnuCtxEditor"\n      debugger          = "{this.syntax == \'javascript\' ? dbg : null}"\n      readonly          = "{[@loading] or cloud9config.readonly or (location.host and window.stDebugProcessRunning and stDebugProcessRunning.active and [@scriptid])}"\n    />\n    \n    <a:menu id="mnuCtxEditor" render="runtime">\n        <a:item onclick="tabEditors.getPage().$at.undo()">Undo</a:item>\n        <a:item onclick="tabEditors.getPage().$at.redo()">Redo</a:item>\n        <a:divider />\n        <a:item \n          visible="{stDebugProcessRunning.active and !stRunning.active}"\n          onclick="\n            require(\'ext/quickwatch/quickwatch\').toggleDialog(1, true);\n          ">Quick Watch</a:item>\n        <a:divider visible="{stDebugProcessRunning.active and !stRunning.active}" />\n        <a:item onclick="ceEditor.$editor.getSelection().selectAll()">Select All</a:item>\n    </a:menu>\n    \n    <a:menu id="mnuSyntax">\n        <a:item type="radio" value="auto">Auto-Select</a:item>\n        <a:item type="radio" value="text/plain">Plain Text</a:item>\n        <a:divider />\n        <a:item type="radio" value="text/x-csharp">C#</a:item>\n        <a:item type="radio" value="text/x-c">C/C++</a:item>\n        <a:item type="radio" value="text/x-script.clojure">Clojure</a:item>\n        <a:item type="radio" value="text/x-script.coffeescript">CoffeeScript</a:item>\n        <a:item type="radio" value="text/x-coldfusion">Coldfusion</a:item>\n        <a:item type="radio" value="text/css">CSS</a:item>\n        <a:item type="radio" value="text/x-groovy">Groovy</a:item>\n        <a:item type="radio" value="text/x-java-source">Java</a:item>\n        <a:item type="radio" value="application/javascript">JavaScript</a:item>\n        <a:item type="radio" value="application/x-latex">Latex</a:item>\n        <a:item type="radio" value="text/x-lua">Lua</a:item>\n        <a:item type="radio" value="text/x-markdown">Markdown</a:item>\n        <a:item type="radio" value="text/x-script.ocaml">OCaml</a:item>\n        <a:item type="radio" value="application/x-httpd-php">PHP</a:item>\n        <a:item type="radio" value="text/x-script.perl">Perl</a:item>\n        <a:item type="radio" value="text/x-script.powershell">Powershell</a:item>\n        <a:item type="radio" value="text/x-script.python">Python</a:item>\n        <a:item type="radio" value="text/x-script.ruby">Ruby</a:item>\n        <a:item type="radio" value="text/x-scala">Scala</a:item>\n        <a:item type="radio" value="text/x-scss">SCSS</a:item>\n        <a:item type="radio" value="text/x-sql">SQL</a:item>\n        <a:item type="radio" value="text/x-web-textile">Textile</a:item>\n        <a:item type="radio" value="text/html">(X)HTML</a:item>\n        <a:item type="radio" value="application/xml">XML</a:item>\n    </a:menu>\n</a:application>';});

define('text!ext/code/settings.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:checkbox class="underlined" label="Auto-pair Quotes, Brackets, etc." value="[editors/code/@behaviors]" skin="checkbox_grey" />\n    <a:checkbox class="underlined" label="Code Folding" value="[editors/code/@folding]" skin="checkbox_grey" />\n    <a:checkbox class="underlined" label="Full Line Selection" value="[editors/code/@selectstyle]" values="line|text" skin="checkbox_grey" />\n    <a:checkbox class="underlined" label="Highlight Active Line" value="[editors/code/@activeline]" skin="checkbox_grey" />\n    <a:checkbox class="underlined" id="cbsh"  label="Show Invisible Characters" value="[editors/code/@showinvisibles]" skin="checkbox_grey" />\n    <a:checkbox class="underlined" label="Show Gutter" value="[editors/code/@gutter]" skin="checkbox_grey" />\n    <a:checkbox class="underlined" label="Highlight Selected Word" value="[editors/code/@highlightselectedword]" skin="checkbox_grey" />\n    <a:checkbox class="underlined" label="Auto-hide Horizontal Scrollbar" value="[editors/code/@autohidehorscrollbar]" skin="checkbox_grey" />\n    \n    <a:hbox edge="0 5 2 0" align="center" class="underlined">\n        <a:label flex="1">Font Size</a:label>\n        <a:spinner value="[editors/code/@fontsize]" realtime="true" min="1" max="72" width="50" class="fixMargin2" margin="5 0 0" />\n    </a:hbox>\n    <a:hbox edge="0 5 0 0" align="center" class="underlined2">\n        <a:checkbox label="Show Print Margin" value="[editors/code/@showprintmargin]" flex="1" skin="checkbox_grey"/>\n        <a:spinner value="[editors/code/@printmargincolumn]" realtime="true" min="1" max="200" width="50" class="fixMargin5" margin="5 0 0"  />\n    </a:hbox>\n    <!--a:hbox edge="0 5 0 0" class="underlined" align="center" padding="5">\n        <a:checkbox label="Wrap Mode" value="[editors/code/@wrapmode]"  flex="1" />\n        <a:spinner value="[editors/code/@wraplimitmin]" realtime="true" min="1" max="200" width="50" />\n        <a:spinner value="[editors/code/@wraplimitmax]" realtime="true" min="1" max="200" width="50" />\n    </a:hbox-->\n    <a:hbox edge="0 5 0 0" align="center" class="underlined2">\n        <a:checkbox label="Soft Tabs" value="[editors/code/@softtabs]" style="margin-bottom:5px" flex="1" skin="checkbox_grey"/>\n        <a:spinner value="[editors/code/@tabsize]" realtime="true" min="1" max="64" width="50" class="fixMargin5" margin="5 0 0" />\n    </a:hbox>\n    <a:hbox edge="0 5 2 0" align="center" class="underlined">\n        <a:label flex="1">Mouse Scroll Speed</a:label>\n        <a:spinner value="[editors/code/@scrollspeed]" realtime="true" min="1" max="8" width="50" class="fixMargin5" margin="5 0 0" />\n    </a:hbox>\n</a:application>';});

define('text!ext/statusbar/statusbar.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:bar id="barIdeStatus" \n      skin    = "bar-status" \n      skinset = "statusbar"\n      height  = "28"\n      bottom  = "3"\n      right   = "3">\n        <a:hbox height="23">\n            <a:label id="lblInsertActive" caption="INS" visible="false" margin="2 3 0 3" />\n            <a:label id="lblSelectionLength" visible="false" margin="2 3 0 3" />\n            <a:label\n              caption = "{ceEditor.line}:{ceEditor.col}"\n              class   = "lbl_row_col"\n              margin  = "2 6 0 3"\n              onclick = "require(\'core/ide\').dispatchEvent(\'gotoline\')"\n            />\n            <a:divider class="divider-status-bar" width="2" height="20" margin="1 0 1 0" />\n            <a:button \n              skin    = "btn-expand-statusbar" \n              skinset = "statusbar"\n              icon    = "statusbar-arrow.png" \n              onclick = "require(\'ext/statusbar/statusbar\').toggleStatusBar()"\n              margin  = "1 1 2 3"\n            />\n            <a:hbox id="hboxStatusBarSettings" width="1">\n                <a:button id="btnSbTools"\n                  skin    = "btn-statusbar-icon" \n                  skinset = "statusbar"\n                  height  = "23"\n                  margin  = "0 3 0 3"\n                  icon    = "tool-ico.png"\n                  submenu = "mnuStatusBarTools"/>\n                <a:button id="btnSbPrefs"\n                  skin    = "btn-statusbar-icon" \n                  skinset = "statusbar"\n                  height  = "23"\n                  icon    = "pref-ico.png" \n                  submenu = "mnuStatusBarPrefs"/>\n            </a:hbox>\n        </a:hbox>\n    </a:bar>\n    <a:menu id="mnuStatusBarTools"\n      ref   = "{btnSbTools}"\n      class = "mnuSbTools"\n      skin  = "menu-bk">\n    </a:menu>\n    <a:menu id="mnuStatusBarPrefs"\n      ref   = "{btnSbPrefs}"\n      class = "mnuSbPrefs"\n      skin  = "menu-bk"\n      sticky = "true">\n      <a:item type="check" caption="Code Folding" checked="[{require(\'ext/settings/settings\').model}::editors/code/@folding]" />\n      <a:item type="check" caption="Full Line Selection" checked="[{require(\'ext/settings/settings\').model}::editors/code/@selectstyle]" values="line|text" />\n      <a:item type="check" caption="Highlight Active Line" checked="[{require(\'ext/settings/settings\').model}::editors/code/@activeline]" />\n      <a:item type="check" caption="Show Gutter" checked="[{require(\'ext/settings/settings\').model}::editors/code/@gutter]" />\n      <a:item type="check" caption="Highlight Selected Word" checked="[{require(\'ext/settings/settings\').model}::editors/code/@highlightselectedword]" />\n      <a:item type="check" caption="Auto-pair Quotes, Brackets, etc." checked="[{require(\'ext/settings/settings\').model}::editors/code/@behaviors]" />\n      <a:item type="check" caption="Auto-hide Horizontal Scrollbar" checked="[{require(\'ext/settings/settings\').model}::editors/code/@autohidehorscrollbar]" />\n      <a:divider />\n      <a:hbox edge="0 5 2 23" align="center">\n          <a:label flex="1" style="padding: 2px 2px 2px 0">Font Size</a:label>\n          <a:spinner value="[{require(\'ext/settings/settings\').model}::editors/code/@fontsize]" realtime="true" min="1" max="72" width="50" />\n      </a:hbox>\n      <a:hbox edge="0 5 2 0" align="center">\n          <a:checkbox label="Show Print Margin" value="[{require(\'ext/settings/settings\').model}::editors/code/@showprintmargin]" flex="1" skin="checkbox-menu" />\n          <a:spinner value="[{require(\'ext/settings/settings\').model}::editors/code/@printmargincolumn]" realtime="true" min="1" max="200" width="50" />\n      </a:hbox>\n      <a:hbox edge="0 5 2 0" align="center">\n          <a:checkbox label="Soft Tabs" value="[{require(\'ext/settings/settings\').model}::editors/code/@softtabs]" flex="1" skin="checkbox-menu"/>\n          <a:spinner value="[{require(\'ext/settings/settings\').model}::editors/code/@tabsize]" realtime="true" min="1" max="64" width="50" />\n      </a:hbox>\n      <a:hbox edge="0 5 2 23" align="center">\n          <a:label flex="1" style="padding: 2px 2px 2px 0">Mouse Scroll Speed</a:label>\n          <a:spinner value="[{require(\'ext/settings/settings\').model}::editors/code/@scrollspeed]" min="1" max="8" width="50" />\n      </a:hbox>\n    </a:menu>\n</a:application>';});

define('text!ext/statusbar/skin.xml',[],function () { return '<?xml version=\'1.0\'?>\n<a:skin xmlns:a="http://ajax.org/2005/aml" xmlns="http://www.w3.org/1999/xhtml">\n    <a:bar name="bar-status">\n        <a:style><![CDATA[\n            .bar-status {\n                position : absolute;\n                color: rgba(0, 0, 0, 0.4);\n                padding: 2px;\n                overflow: hidden;\n                border: 1px solid transparent;\n\n                border-radius: 6px;\n\n                -webkit-transition: background-color 0.2s linear, border 0.2s linear, box-shadow 0.2s linear;\n                -moz-transition: background-color 0.2s linear, border 0.2s linear, -moz-box-shadow 0.2s linear;\n\n                background: transparent url(\'images/editor_bar_bg.png\') 0px 30px repeat-x;\n            }\n\n            .bar-status:hover {\n                border: 1px solid rgba(0, 0, 0, 0.12);\n\n                -moz-box-shadow: inset 0px 1px 0px 0px #f5f5f5;\n                box-shadow: inset 0px 1px 0px 0px #f5f5f5;\n\n                background-color: transparent;\n            }\n\n            .ace_dark.bar-status:hover {\n                -moz-box-shadow: inset 0px 1px 0px 0px rgba(255, 255, 255, 0.1);\n                box-shadow: inset 0px 1px 0px 0px rgba(255, 255, 255, 0.1);\n            }\n            \n            .bar-status .lbl_row_col {\n                text-align: center;\n                color: rgba(0, 0, 0, 0.4);\n            }\n\n            .bar-status .label {\n                color: rgba(0, 0, 0, 0.4);\n                padding-left: 1px;\n                overflow: visible;\n            }\n\n            .ace_dark.bar-status .label {\n                color: rgba(255, 255, 255, 0.4);\n            }\n        ]]></a:style>\n\n        <a:presentation>\n            <a:main container=".">\n                <div class="bar-status">\n                </div>\n            </a:main>\n        </a:presentation>\n    </a:bar>\n    <a:button name="btn-expand-statusbar">\n        <a:style><![CDATA[\n            .btn-expand-statusbar {\n                height              : 8px;\n                width               : 10px;\n                overflow            : hidden;\n                cursor              : pointer;\n                position            : relative;\n                cursor              : default;\n                -moz-user-select    : none;\n                -khtml-user-select  : none;\n                user-select         : none;\n                background-position : 2px 7px;\n                background-repeat   : no-repeat;\n\n                border-radius: 3px;\n            }\n\n            .btn-expand-statusbarOver {\n                background-position : 2px -19px;\n            }\n\n            .expanded .btn-expand-statusbar {\n                background-position : -11px 7px;\n            }\n\n            .expanded .btn-expand-statusbarOver {\n                background-position : -11px -19px;\n            }\n\n            .ace_dark .btn-expand-statusbar {\n                background-position : -28px 7px;\n            }\n\n            .ace_dark .btn-expand-statusbarOver {\n                background-position : -28px -19px;\n            }\n\n            .ace_dark.expanded .btn-expand-statusbar {\n                background-position : -42px -18px;\n            }\n\n            .ace_dark.expanded .btn-expand-statusbarOver {\n                background-position : -42px 7px;\n\n            }\n        ]]></a:style>\n\n        <a:presentation>\n            <a:main\n              caption      = "text()"\n              background = "."\n              icon       = ".">\n                <div class="btn-expand-statusbar"> </div>\n            </a:main>\n        </a:presentation>\n    </a:button>\n    <a:button name="btn-statusbar-icon">\n        <a:style><![CDATA[\n            .btn-statusbar-icon {\n                height              : 23px;\n                width               : 22px;\n                overflow            : hidden;\n                cursor              : pointer;\n                position            : relative;\n                cursor              : default;\n                -moz-user-select    : none;\n                -khtml-user-select  : none;\n                user-select         : none;\n                background-position : 0 0;\n                background-repeat   : no-repeat;\n            }\n            .btn-statusbar-iconOver {\n                background-position : 0 -23px;\n            }\n\n            .btn-statusbar-iconDown {\n                background-position : 0 -46px;\n            }\n\n            .ace_dark .btn-statusbar-icon {\n                background-position : -22px 0;\n            }\n\n            .ace_dark .btn-statusbar-iconOver {\n                background-position : -22px -23px;\n            }\n\n            .ace_dark .btn-statusbar-iconDown {\n                background-position : -22px -46px;\n            }\n        ]]></a:style>\n\n        <a:presentation>\n            <a:main\n              caption      = "text()"\n              background = "."\n              icon       = ".">\n                <div class="btn-statusbar-icon"> </div>\n            </a:main>\n        </a:presentation>\n    </a:button>\n    <a:menu name="statusbar-mnu">\n        <a:style><![CDATA[\n            .statusbar-mnu {\n                margin   : 0;\n                z-index  : 10000;\n                position : absolute;\n                overflow : visible;\n                display  : none;\n\n                background-image: linear-gradient(bottom, rgba(65,65,65,0.14) 0%, rgba(255,255,255,0.14) 100%);\n                background-image: -o-linear-gradient(bottom, rgba(65,65,65,0.14) 0%, rgba(255,255,255,0.14) 100%);\n                background-image: -moz-linear-gradient(bottom, rgba(65,65,65,0.14) 0%, rgba(255,255,255,0.14) 100%);\n                background-image: -webkit-linear-gradient(bottom, rgba(65,65,65,0.14) 0%, rgba(255,255,255,0.14) 100%);\n                background-image: -ms-linear-gradient(bottom, rgba(65,65,65,0.14) 0%, rgba(255,255,255,0.14) 100%);\n\n                position : absolute;\n                border-radius : 9px;\n                -webkit-box-shadow: inset 0px 1px 2px 1px rgba(0, 0, 0, 0.25);\n                -moz-box-shadow: inset 0px 1px 2px 1px rgba(0, 0, 0, 0.25);\n                box-shadow: inset 0px 1px 2px 1px rgba(0, 0, 0, 0.25);\n                border: 1px solid #e8e8e8;\n\n                margin-top: -17px;\n                margin-left: -10px;\n\n                padding: 3px 0;\n            }\n\n            .statusbar-mnu .arrow {\n                position : absolute;\n                width: 19px;\n                height: 17px;\n                bottom: -16px;\n                left: 40px;\n                z-index: 10001;\n                background: url(images/arrow-sb.png) no-repeat 0 0;\n            }\n\n            .statusbar-mnu .menu-item {\n                padding: 5px 15px;\n                cursor: default;\n                color: rgba(0, 0, 0, 0.4);\n            }\n            .statusbar-mnu .menu-item.hover{\n                background-color: rgba(170, 170, 170, 0.14);\n            }\n        ]]></a:style>\n\n        <a:presentation>\n            <a:main container=".">\n                <div class="statusbar-mnu">\n                    <div class="arrow"> </div>\n                </div>\n            </a:main>\n            <a:item\n              caption = "text()"\n              icon    = "div"\n              hotkey  = "div"\n              inherit = "true">\n                <div class="menu-item">-<div class="icon"></div></div>\n            </a:item>\n            <a:divider inherit="true">\n                <div class="menu-divider"></div>\n            </a:divider>\n        </a:presentation>\n    </a:menu>\n</a:skin>';});

define('text!ext/imgview/imgview.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:img id="imgEditor"\n      flex              = "1"\n      anchors           = "0 0 0 0"\n      visible           = "false"\n    />\n</a:application>';});

define('text!ext/extmgr/extmgr.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:window\n      id        = "winExt"\n      title     = "Extensions Manager"\n      icon      = ""\n      center    = "true"\n      resizable = "true"\n      buttons   = "close"\n      modal     = "false"\n      skin      = "bk-window"\n      width     = "660"\n      height    = "400"\n      kbclose   = "true"\n      draggable = "true">\n        <a:vbox anchors="0 0 0 0" edge="0 0 11 0">\n            <a:tab flex="1" id="tabExtMgr" skin="extensions_tab">\n                <a:page caption="User Extensions">\n                    <a:vbox anchors="10 10 10 10">\n                        <a:hbox align="center" edge="0 0 5 0" padding="5">\n                            <a:textbox id="tbModuleName" flex="1" \n                              realtime="true" />\n                            <a:button width="80"\n                              default = "1"\n                              caption = "Add"\n                              disabled = "{!tbModuleName.value.trim()}"\n                              onclick = "require(\'ext/extmgr/extmgr\').loadExtension()"\n                            />\n                        </a:hbox>\n                        <a:datagrid id = "dgExtUser"\n                          flex       = "1"\n                          model      = "mdlExt"\n                          class      = "noscrollbar"\n                          scrollbar  = "sbShared 20 2 2"\n                          autoselect = "false"\n                          each       = "[plugin[@userext=\'1\']]"\n                          onafterselect = "require(\'ext/extmgr/extmgr\').updateEnableBtnState()"\n                          eachvalue  = "[@path]"\n                          empty-message = "No user extensions">\n                            <a:column width="25%" value="[@name]" caption="Name" />\n                            <a:column width="30%" value="[@path]" caption="Path" />\n                            <a:column width="15%" value="[@type]" caption="Type" />\n                            <a:column width="20%" value="[@dev]" caption="Developer" />\n                            <a:column width="11%" value="{[@enabled] == 1 ? \'Enabled\' : \'Disabled\'}" caption="Enabled" />\n                        </a:datagrid>\n                        \n                    </a:vbox>\n                </a:page>\n                <a:page caption="Defaults">\n                    <a:vbox anchors="10 10 10 10">\n                        <a:datagrid id="dgExt"\n                          flex       = "1"\n                          model      = "mdlExt"\n                          class      = "noscrollbar"\n                          scrollbar  = "sbShared 20 2 2"\n                          autoselect = "false"\n                          each       = "[plugin[@userext=\'0\']]"\n                          onafterselect = "require(\'ext/extmgr/extmgr\').updateEnableBtnState()"\n                          eachvalue  = "[@path]">\n                            <a:column width="25%" value="[@name]" caption="Name" /> \n                            <a:column width="30%" value="[@path]" caption="Path" /> \n                            <a:column width="15%" value="[@type]" caption="Type" /> \n                            <a:column width="20%" value="[@dev]" caption="Developer" /> \n                            <a:column width="11%" value="{[@enabled] == 1 ? \'Enabled\' : \'Disabled\'}" caption="Enabled" /> \n                        </a:datagrid>\n                    </a:vbox>\n                </a:page>\n            </a:tab>\n            <a:hbox edge="11 10 0 0" pack="end" visible="{tabExtMgr.activepage == 0}">\n                <a:button\n                  skin     = "btn-default-css3"\n                  disabled = "{!dgExtUser.selected}"\n                  caption  = "Remove"\n                  margin   = "0 10 0 0"\n                  onclick  = "require(\'ext/extmgr/extmgr\').removeExtension()"\n                />\n                <a:button\n                  id       = "btnUserExtEnable"\n                  skin     = "btn-default-css3"\n                  disabled = "{!dgExtUser.selected}"\n                  caption  = "Disable"\n                  onclick  = "\n                    if ([{dgExtUser.selected}::@enabled] == 1)\n                        require(\'ext/extmgr/extmgr\').disableExt(dgExtUser.value);\n                    else\n                        require(\'ext/extmgr/extmgr\').enableExt(dgExtUser.value);\n                  "\n                />\n                <a:button\n                  caption = "Done"\n                  margin = "0 0 0 10"\n                  skin = "btn-default-css3"\n                  onclick = "winExt.close()"\n                />\n            </a:hbox>\n            <a:hbox edge="11 10 0 0" pack="end" visible="{tabExtMgr.activepage == 1}">\n                <a:button\n                  id       = "btnDefaultExtEnable"\n                  skin     = "btn-default-css3"\n                  caption  = "Disable"\n                  disabled = "{!dgExt.selected}"\n                  onclick  = "\n                    if ([{dgExt.selected}::@enabled] == 1)\n                        require(\'ext/extmgr/extmgr\').disableExt(dgExt.value);\n                    else\n                        require(\'ext/extmgr/extmgr\').enableExt(dgExt.value);\n                  "\n                />\n                <a:button\n                  caption = "Done"\n                  margin = "0 0 0 10"\n                  skin = "btn-default-css3"\n                  onclick = "winExt.close()"\n                />\n            </a:hbox>\n        </a:vbox>\n    </a:window>\n</a:application>';});

define('text!ext/runpanel/runpanel.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n\n    <a:window id="winRunPanel" \n      title    = "Run &amp; Debug" \n      model    = "{lstRunCfg.selected}"\n      buttons  = "close" \n      skin     = "fm-window"\n      flex     = "1" \n      optimize = "true"\n      modal    = "false">\n        <a:bar skin="c9-header-bar" top="-30" right="28" height="30">\n            <a:hbox id="barTestTools" height="23">\n                <a:button\n                  caption  = "add"\n                  onclick  = "require(\'ext/runpanel/runpanel\').addConfig()"\n                  skin     = "c9-toolbarbutton" />\n                <a:button \n                  caption  = "remove"\n                  skin     = "c9-toolbarbutton"\n                  onclick  = "lstRunCfg.remove()"\n                  disabled = "{!lstRunCfg.selected || !![{lstRunCfg.selected}::@curfile]}"/>\n                  \n                <!--a:divider skin="c9-divider-double" /-->\n                \n                <!--a:button\n                  id       = "btnRun"\n                  icon     = "{itmDebug.checked ? \'bug.png\' : \'run.png\'}"\n                  caption  = "{itmDebug.checked ? \'debug\' : \'run\'}"\n                  onclick  = "require(\'ext/runpanel/runpanel\').run(itmDebug.checked)"\n                  visible  = "{!stProcessRunning.active and 1}"\n                  skin     = "c9-toolbarbutton"\n                  submenu  = "mnuRunCfg" />\n                <a:button\n                  icon     = "stop.png"\n                  caption  = "stop"\n                  skin     = "c9-toolbarbutton"\n                  onclick  = "require(\'ext/runpanel/runpanel\').stop()"\n                  visible  = "{stProcessRunning.active and 1}" /-->\n            </a:hbox>\n        </a:bar>\n        \n        <a:button\n          top="-22"\n          skin="header-btn"\n          right="5"\n          icon="panel_settings.png"\n          submenu="mnuDebugSettings" />\n        \n        <a:menu id="mnuDebugSettings">\n            <a:item\n              type    = "check"\n              checked = "[{require(\'ext/settings/settings\').model}::auto/configurations/@debug]"\n              caption = "Run in debug mode" />\n            <a:item\n              type    = "check"\n              onclick = "require(\'ext/runpanel/runpanel\').checkAutoHide()"\n              checked = "[{require(\'ext/settings/settings\').model}::auto/configurations/@autohide]"\n              caption = "Auto show/hide debug tools" />\n        </a:menu>\n      \n        <a:vbox anchors="0 0 0 0">\n            <a:list id="lstRunCfg" \n              model   = "mdlRunConfigurations"\n              border  = "0"\n              each    = "[config]"\n              caption = "[@name]"\n              flex    = "1"\n              skin    = "tree"\n              autoselect    = "true"\n              empty-message = "no run configurations"\n              onafterchoose = "\n                require(\'ext/runpanel/runpanel\').runConfig(lstRunCfg.selected, itmDebug.checked);\n              " />\n              \n            <a:bar skin="basic" style="background:#323332;border-top:1px solid #111">\n                <a:vbox padding="5" edge="10">\n                  <a:hbox>\n                    <a:label width="100" skin="black_label" >Name</a:label>\n                    <a:textbox id="txtRunCfgName" \n                      skin = "black_textbox"\n                      flex="1"\n                      realtime="true"\n                      value="[@name]"\n                      disabled="{!lstRunCfg.selected or [{lstRunCfg.selected}::@curfile]}"/>\n                  </a:hbox>\n                  <a:hbox>\n                    <a:label width="100" skin="black_label">File Path</a:label>\n                    <a:textbox skin = "black_textbox" id="txtRunCfgName" flex="1" value="[@path]" disabled="{!lstRunCfg.selected or [{lstRunCfg.selected}::@curfile]}"/>\n                    <!--a:button icon="folder.png" disabled="true" tooltip="Browse ..."></a:button-->\n                    \n                    <!--a:divider span="2" skin="c9-divider-hor" /-->\n                    <a:model id="mdlRunnerSelector">\n                        <data>\n                            <element caption="Default" value="default" />\n                            <element caption="Auto" value="auto" />\n                            <element caption="Node.js 0.6.x" value="0.6.x" />\n                            <element caption="Node.js 0.4.x" value="0.4.x" />\n                        </data>\n                    </a:model>\n                  </a:hbox>\n                    <a:hbox>\n                      <a:label width="100" skin="black_label">Runtime</a:label>\n                      <a:dropdown id="ddRunnerSelector"\n                          model     = "mdlRunnerSelector"\n                          skin      = "black_dropdown"\n                          flex      = "1"\n                          disabled  = "{!lstRunCfg.selected}"\n                          value     = "[{lstRunCfg.selected}::@value]"\n                          default   = "default"\n                          each      = "[element]"\n                          caption   = "[@caption]"\n                          eachvalue = "[@value]" />\n                    </a:hbox>\n                    <a:hbox>\n                      <a:label width="100" skin="black_label">Cmd Line Args</a:label>\n                      <a:textbox skin = "black_textbox" id="txtRunCfgName" flex="1" value="[@args]" disabled="{!!!lstRunCfg.selected}"/>\n                    </a:hbox>\n                </a:vbox>\n            </a:bar>\n        </a:vbox>\n    </a:window>\n\n</a:application>';});

define('text!ext/runpanel/runbuttons.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n\n    <a:menu id="mnuRunCfg">    \n        <a:item disabled="true" caption="no run history" />\n        <a:divider />\n        <a:item onclick="require(\'ext/runpanel/runpanel\').showRunConfigs(false)">Configure...</a:item>\n        <a:divider />\n        <a:item id="itmDebug"\n          type    = "check"\n          checked = "[{require(\'ext/settings/settings\').model}::auto/configurations/@debug]"\n          caption = "Run in debug mode" />\n        <a:item\n          type    = "check"\n          onclick = "require(\'ext/runpanel/runpanel\').checkAutoHide()"\n          checked = "[{require(\'ext/settings/settings\').model}::auto/configurations/@autohide]"\n          caption = "Auto show/hide debug tools" />\n    </a:menu>\n    \n    <a:model id="mdlRunConfigurations">\n        <configurations />\n    </a:model>\n\n    <a:bar id="tbRun">\n        <a:divider skin="c9-divider" id="divRun" />\n        <a:splitbutton\n          id       = "btnRun"\n          icon     = "{itmDebug.checked ? \'run.png\' : \'run.png\'}"\n          caption  = "{itmDebug.checked ? \'debug\' : \'run\'}"\n          onclick  = "require(\'ext/runpanel/runpanel\').run()"\n          visible  = "{!stProcessRunning.active and 1}"\n          tooltip  = "{itmDebug.checked ? \'Debug\' : \'Run\'}"\n          disabled = "{!ide.onLine}"\n          submenu  = "mnuRunCfg" />\n        <a:button id="btnStop"\n          icon     = "stop.png"\n          caption  = "stop"\n          width    = "52"\n          tooltip  = "Stop"\n          skin     = "c9-toolbarbutton"\n          onclick  = "require(\'ext/runpanel/runpanel\').stop()"\n          visible  = "{stProcessRunning.active and 1}" \n          disabled = "{!ide.onLine}" />\n    </a:bar>\n\n</a:application>';});

define('text!ext/runpanel/settings.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:model id="mdlRunnerSelector2">\n        <data>\n            <element caption="Auto" value="auto" />\n            <element caption="Node.js 0.6.x" value="0.6.x" />\n            <element caption="Node.js 0.4.x" value="0.4.x" />\n            <!--element caption="Python" value="py" /-->\n        </data>\n    </a:model>\n    <a:hbox edge="5 5 2 5" align="center">\n        <a:label flex="1">Runtime:</a:label>        \n        <a:dropdown\n          model     = "mdlRunnerSelector2"\n          width="175"  height="21"\n          disabled  = "{!lstRunCfg.selected}"\n          value     = "[{require(\'ext/settings/settings\').model}::auto/node-version/@version]"\n          default   = "auto"\n          each      = "[element]"\n          caption   = "[@caption]"\n          eachvalue = "[@value]" />\n    </a:hbox>\n</a:application>\n';});

define('text!ext/debugger/debugger.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:tab id="tabDebugButtons" skin="dockbar" visible="false">\n        <a:page id="pgDebugNav" render="runtime">\n            <a:hbox padding="3" edge="4 3 5">\n                <div class="expand-panel-bg"></div>\n                <a:button id="btnResume" tooltip="Resume"\n                  icon     = "play.png"\n                  onclick  = "dbg.continueScript();"\n                  skin     = "c9-sidepanelsbutton"\n                  disabled = "{!stDebugProcessRunning.active or stRunning.active}" />\n                <a:button  tooltip="Suspend"\n                  skin     = "c9-sidepanelsbutton"\n                  icon     = "pause.png"\n                  onclick  = "dbg.suspend();"\n                  disabled = "{!stDebugProcessRunning.active or !stRunning.active}"/>\n                <a:divider skin="c9-divider" />\n                <a:button id="btnStepOver" tooltip="Step Over"\n                  icon     = "step.png"\n                  skin     = "c9-sidepanelsbutton"\n                  onclick  = "dbg.stepNext();"\n                  disabled = "{!stDebugProcessRunning.active or stRunning.active}" />\n                <a:button id="btnStepInto" tooltip="Step Into"\n                  icon     = "stepinto.png" \n                  skin     = "c9-sidepanelsbutton"\n                  onclick  = "dbg.stepInto();" \n                  disabled = "{!stDebugProcessRunning.active or stRunning.active}" />\n                <a:button id="btnStepOut" tooltip="Step Out"\n                  icon     = "stepback.png" \n                  skin     = "c9-sidepanelsbutton"\n                  onclick  = "dbg.stepOut();"\n                  disabled = "{!stDebugProcessRunning.active or stRunning.active}" />\n            </a:hbox>\n        </a:page>\n    </a:tab>\n    <a:tab id="tabDebug" skin="docktab" visible="false" activepage="0" buttons="close">\n        <a:page id="dbgCallStack" caption="Call Stack" render="runtime" prerender="true">\n            <a:datagrid\n              id         = "dgStack"\n              anchors    = "0 0 0 0"\n              border     = "0"\n              options    = "size|move"\n              caching    = "false"\n              model      = "mdlDbgStack"\n              class      = "noscrollbar"\n              scrollbar  = "sbShared 20 2 2"\n              disabled   = "{!stDebugProcessRunning.active or stRunning.active}"\n              selected   = "{dbg.activeframe}">\n                <a:actions />\n                <a:each match="[frame]">\n                    <a:column caption="Function" value="[@name]" width="60%" icon2="debugger/stckframe_obj.gif" />\n                    <a:column caption="Script" value="[@script]" width="40%" />\n                    <a:column caption="Ln" value="[@line]" width="30"/>\n                    <a:column caption="Col" value="[@column]" width="30"/>\n                </a:each>\n            </a:datagrid>\n        </a:page>\n        <a:page id="dbInteractive" caption="Interactive" render="runtime">\n            <a:vbox anchors="0 0 0 0">\n                <a:toolbar>\n                    <a:bar border="0 0 1 0">\n                        <a:button\n                          disabled = "{!stDebugProcessRunning.active or stRunning.active}"\n                          caption  = "Execute" \n                          tooltip  = "Ctrl+Enter"\n                          onclick  = "\n                            require(\'ext/debugger/inspector\').consoleTextHandler({keyCode:13,ctrlKey:true})\n                          " />\n                        <a:button\n                          disabled2 = "{!txtCode.value.trim()}"\n                          caption  = "Clear" \n                          onclick  = "\n                            txtCode.clear();\n                          " />\n                        <a:divider skin2="c9-divider"/>\n                        <a:dropdown id="lstScripts"\n                          skin2       = "black_dropdown"\n                          margin     = "3 0 0 4"\n                          width      = "120"\n                          maxitems   = "10"\n                          model      = "mdlDbgSources"\n                          disabled   = "{!stDebugProcessRunning.active and 1}" \n                          each       = "[file]"\n                          caption    = "[@text]"\n                          autoselect = "false"\n                          icon       = "debugger/file_obj.gif" />\n                    </a:bar>\n                </a:toolbar>\n                <a:codeeditor id="txtCode" \n                  flex      = "1"\n                  disabled  = "{stRunning.active or !stDebugProcessRunning.active}"\n                  onkeydown = "return require(\'ext/debugger/inspector\').consoleTextHandler(event)" \n                  realtime  = "true"\n                  border    = "0" \n                  model     = "{require(\'ext/settings/settings\').model}" \n                  value     = "[auto/console/input]"\n                  softtabs          = "[{require(\'ext/settings/settings\').model}::editors/code/@softtabs]"\n                  tabsize           = "[{require(\'ext/settings/settings\').model}::editors/code/@tabsize]"\n                  scrollspeed       = "[{require(\'ext/settings/settings\').model}::editors/code/@scrollspeed]"\n                  theme             = "[{require(\'ext/settings/settings\').model}::editors/code/@theme]"\n                  selectstyle       = "[{require(\'ext/settings/settings\').model}::editors/code/@selectstyle]"\n                  activeline        = "[{require(\'ext/settings/settings\').model}::editors/code/@activeline]"\n                  showinvisibles    = "[{require(\'ext/settings/settings\').model}::editors/code/@showinvisibles]"\n                  showprintmargin   = "false"\n                  printmargincolumn = "0" />\n            </a:vbox>\n        </a:page>\n        <a:page id="dbgVariable" caption="Variables" render="runtime">\n            <a:datagrid id="dgVars"\n              anchors    = "0 0 0 0" \n              border     = "0"\n              class      = "noscrollbar"\n              scrollbar  = "sbShared 20 2 2"\n              options    = "size|move"\n              prerender  = "false"\n              caching    = "false"\n              model      = "[{dbg.activeframe}::vars]"\n              disabled   = "{!stDebugProcessRunning.active or stRunning.active}"\n              loading-message = "Calculating...">\n                <a:actions />\n                <a:each match="[item|globals]" sort="[@name]">\n                    <a:insert match="[globals]" get="{adbg.loadFrame(dbg, {dbg.activeframe})}"/>\n                    <a:insert match="[item[@children=\'true\']]" get="{adbg.loadObjects(dbg, %[.])}" />\n                    <a:column caption="Property" value="{[@name] || \'Globals\'}" width="40%" icon="debugger/genericvariable_obj.gif" tree="true" />\n                    <a:column caption="Value" value="[@value]" width="60%" />\n                    <a:column caption="Type" value="[@type]" width="50"/>\n                </a:each>\n            </a:datagrid>\n        </a:page>\n        <a:page id="dbgBreakpoints" caption="Breakpoints" render="runtime" prerender="true">\n            <a:list id="lstBreakpoints"\n              autoselect = "false"\n              reselectable = "true"\n              anchors    = "0 0 0 0"\n              class      = "noscrollbar"\n              scrollbar  = "sbShared 2 2 2"\n              border     = "0"\n              model      = "mdlDbgBreakpoints"\n              each       = "[breakpoint]"\n              caption    = "[@text]"\n              icon       = "debugger/brkp_obj.png">\n                <a:actions />\n            </a:list>\n        </a:page>\n        <a:model id="mdlAceAnnotations"></a:model>\n        <a:page id="aceAnnotations" caption="Bugs" render="runtime">\n            <a:datagrid id="dgAceAnnotations"\n              anchors    = "0 0 0 0" \n              border     = "0"\n              options    = "size|move"\n              class      = "noscrollbar"\n              scrollbar  = "sbShared 20 2 2"\n              prerender  = "false"\n              caching    = "false"\n              onafterchoose = "require(\'ext/debugger/debugger\').goToAnnotation()"\n              model      = "mdlAceAnnotations"\n              loading-message = "Loading..."\n              empty-message = "None found">\n                <a:each match="[annotation]" sort="[@line]">\n                    <a:column type="icon" width="20" icon="debugger/[@type]_obj.gif" />\n                    <a:column caption="Line" value="[@line]" width="50" />\n                    <a:column caption="Description" value="[@text]" width="100%" />\n                </a:each>\n            </a:datagrid>\n        </a:page>\n    </a:tab>\n</a:application>';});

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

// #ifdef __AMLDEBUGGER || __INC_ALL
if (apf.hasRequireJS) define("apf/elements/debugger",
    ["module"], function(module) {

apf.dbg = module.exports = function(struct, tagName){
    this.$init(tagName || "debugger", apf.NODE_HIDDEN, struct);
};

(function(){

    this.$host = null;
    this.$debugger = null;

    this.autoAttachComingIn = false;

    this.$supportedProperties.push("state-running", "state-attached",
        "model-sources", "model-stacks", "model-breakpoints", "activeframe");

    this.$createModelPropHandler = function(name, xml, callback) {
        return function(value) {
            if (!value) return;
            //#ifdef __WITH_NAMESERVER
            this[name] = apf.setReference(value,
                apf.nameserver.register("model", value, new apf.model()));

            // set the root node for this model
            this[name].id = this[name].name = value;
            this[name].load(xml);
            //#endif
        }
    };

    this.$createStatePropHandler = function(name) {
        return function(value) {
            if (!value) return;
            //#ifdef __WITH_NAMESERVER
            this[name] = apf.setReference(value,
                    apf.nameserver.register("state", value, new apf.state()));

            // set the root node for this model
            this[name].id = this[name].name = value;
            this[name].deactivate();
            //#endif
        }
    };

    this.$propHandlers["model-sources"] = this.$createModelPropHandler("$mdlSources", "<sources />");
    this.$propHandlers["model-stack"] = this.$createModelPropHandler("$mdlStack", "<frames />");
    this.$propHandlers["model-breakpoints"] = this.$createModelPropHandler("$mdlBreakpoints", "<breakpoints />");

    this.$propHandlers["state-running"] = this.$createStatePropHandler("$stRunning");
    this.$propHandlers["state-attached"] = this.$createStatePropHandler("$stAttached");

    this.$propHandlers["activeframe"] = function(value) {
        if (this.$debugger) {
            this.$ignoreFrameEvent = true;
            this.$debugger.setFrame(value);
            this.$ignoreFrameEvent = false;
        }
        this.dispatchEvent("changeframe", {data: value});
    };

    /**
     * If you are auto attaching, please announce yourself here
     */
    this.registerAutoAttach = function () {
        this.autoAttachComingIn = true;
    };

    /**
     * Manual click on the run button?
     * Youll get special behavior!
     */
    this.registerManualAttach = function () {
        this.autoAttachComingIn = false;
    };

    /**
     * If you are auto attaching, please announce yourself here
     */
    this.registerAutoAttach = function () {
        this.autoAttachComingIn = true;
    };

    /**
     * Manual click on the run button?
     * Youll get special behavior!
     */
    this.registerManualAttach = function () {
        this.autoAttachComingIn = false;
    };

    this.attach = function(host, tab) {
        var _self = this;

        host.$attach(this, tab, function(err, dbgImpl) {
            _self.$host = host;
            _self.$debugger = dbgImpl;

            _self.$loadSources(function() {
                dbgImpl.setBreakpoints(_self.$mdlBreakpoints, function() {
                    var backtraceModel = new apf.model();
                    backtraceModel.load("<frames></frames>");

                    _self.$debugger.backtrace(backtraceModel, function() {
                        var frame = backtraceModel.queryNode("frame[1]");
                        var allowAttach = _self.$allowAttaching(frame);
                        
                        if (!allowAttach) {
                            _self.$debugger.continueScript();
                        }
                        else {
                            _self.$mdlStack.load(backtraceModel.data);
                            // throw out a nice break statement so others know that it fired
                            _self.dispatchEvent("break");
                        }

                        dbgImpl.addEventListener("afterCompile", _self.$onAfterCompile.bind(_self));

                        _self.$stAttached.activate();
                        _self.$stRunning.setProperty("active", dbgImpl.isRunning());

                        dbgImpl.addEventListener("changeRunning", _self.$onChangeRunning.bind(_self));
                        dbgImpl.addEventListener("break", _self.$onBreak.bind(_self));
                        dbgImpl.addEventListener("detach", _self.$onDetach.bind(_self));
                        
                        // monitor the first incoming event to verify whether it's allowed
                        // to attach here
                        var firstChangeFrame = function () {
                            if (_self.$allowAttaching(_self.$debugger.getActiveFrame())) {
                                _self.$onChangeFrame();
                                // now bind to the real changeFrame method
                                dbgImpl.addEventListener("changeFrame", _self.$onChangeFrame.bind(_self));
                                dbgImpl.removeEventListener("changeFrame", firstChangeFrame);
                            }
                        };
                        dbgImpl.addEventListener("changeFrame", firstChangeFrame);
                        
                        if (allowAttach) {
                            _self.setProperty("activeframe", frame);
                        }
                        
                        _self.autoAttachComingIn = false;
                    });
                });
            });
        });
    };

    this.$allowAttaching = function (frame) {
        var _self = this;

        if (this.autoAttachComingIn) return true;

        if (frame) {
            var scriptId = frame.getAttribute("scriptid");
            var scriptName = _self.$mdlSources.queryValue("file[@scriptid='" + scriptId + "']/@scriptname");

            if (scriptName) {
                var line = frame.getAttribute("line");
                var bp = _self.$mdlBreakpoints.queryNode("breakpoint[@script='" + scriptName + "' and @line='" + line + "']");
            }
            if (!scriptName || !bp) {
               return false;
            }

            return true;
        }

        return false;
    };

    this.$onChangeRunning = function() {
        var isRunning = this.$debugger && this.$debugger.isRunning();
        if (this.$stRunning.active && !isRunning)
            this.$onBreak();

        this.$stRunning.setProperty("active", isRunning);

        //if (isRunning)
            //this.$mdlStack.load("<frames />");
    };

    this.$onBreak = function() {
        var _self = this;
        if (!this.$debugger || this.$debugger.isRunning())
            return;

        this.$debugger.backtrace(this.$mdlStack, function() {
            if (_self.activeframe && !_self.$updateMarkerPrerequisite()) {
                _self.continueScript();
                return;
            }
            _self.dispatchEvent("break");
        });
    };

    this.$updateMarkerPrerequisite = function () {
        return this.activeframe;
    };
    this.$onAfterCompile = function(e) {
        var id = e.script.getAttribute("id");
        var oldNode = this.$mdlSources.queryNode("//file[@id='" + id + "']");
        if (oldNode)
            this.$mdlSources.removeXml(oldNode);
        this.$mdlSources.appendXml(e.script);
    };

    this.$onDetach = function() {
        var _self = this;
        
        if (this.$debugger) {
            // destroy doesnt destroy the event listeners
            // so do that by hand
            Object.keys(_self.$debugger.$eventsStack).forEach(function (evname) { 
                _self.$debugger.$eventsStack[evname].forEach(function (fn) {
                    _self.$debugger.removeEventListener(evname, fn);
                });
            });
            
            this.$debugger.destroy();
            this.$debugger = null;
        }

        this.$host = null;

        this.$mdlSources.load("<sources />");
        this.$mdlStack.load("<frames />");
        this.$stAttached.deactivate();
        this.setProperty("activeframe", null);
    };

    this.$onChangeFrame = function() {
        if (!this.$ignoreFrameEvent) {
            this.setProperty("activeframe", this.$debugger.getActiveFrame());
        }
    };

    this.changeFrame = function(frame) {
        this.$debugger.setFrame(frame);
    };

    this.detach = function(callback) {
        var _self = this;

        this.continueScript();
        if (this.$host) {
            this.$host.$detach(this.$debugger, function () {
                if (typeof callback === "function")
                    callback();


                // always detach, so we won't get into limbo state
                _self.$onDetach();
            });
        }
        else {
            this.$onDetach();
        }
    };

    this.$loadSources = function(callback) {
        this.$debugger.scripts(this.$mdlSources, callback);
    };

    this.loadScript = function(script, callback) {
        this.$debugger.loadScript(script, callback);
    };

    this.loadObjects = function(item, callback) {
        this.$debugger.loadObjects(item, callback);
    };

    this.loadFrame = function(frame, callback) {
        this.$debugger.loadFrame(frame, callback);
    };

    this.toggleBreakpoint = function(script, row) {
        var model = this.$mdlBreakpoints;
        if (this.$debugger) {
            this.$debugger.toggleBreakpoint(script, row, model);
        }
        else {
            var scriptName = script.getAttribute("scriptname");
            var bp = model.queryNode("breakpoint[@script='" + scriptName + "' and @line='" + row + "']");
            if (bp) {
                apf.xmldb.removeNode(bp);
            }
            else {
                // filename is something like blah/blah/workspace/realdir/file
                // we are only interested in the part after workspace for display purposes
                var tofind = "/workspace/";
                var path = script.getAttribute("path");
                var displayText = path;
                if (path.indexOf(tofind) > -1) {
                    displayText = path.substring(path.indexOf(tofind) + tofind.length);
                }

                var bp = apf.n("<breakpoint/>")
                    .attr("script", scriptName)
                    .attr("line", row)
                    .attr("text", displayText + ":" + (parseInt(row, 10) + 1))
                    .attr("lineoffset", 0)
                    .node();
                model.appendXml(bp);
            }
        }
    };

    this.continueScript = function(callback) {
        this.dispatchEvent("beforecontinue");

        if (this.$debugger)
            this.$debugger.continueScript(callback);
        else
            callback && callback();
    };

    this.stepInto = function() {
        this.dispatchEvent("beforecontinue");

        this.$debugger && this.$debugger.stepInto();
    };

    this.stepNext = function() {
        this.dispatchEvent("beforecontinue");

        this.$debugger && this.$debugger.stepNext();
    };

    this.stepOut = function() {
        this.dispatchEvent("beforecontinue");

        this.$debugger && this.$debugger.stepOut();
    };

    this.suspend = function() {
        this.$debugger && this.$debugger.suspend();
    };

    this.evaluate = function(expression, frame, global, disableBreak, callback){
        this.$debugger && this.$debugger.evaluate(expression, frame, global, disableBreak, callback);
    };

    this.changeLive = function(scriptId, newSource, previewOnly, callback) {
        this.$debugger && this.$debugger.changeLive(scriptId, newSource, previewOnly, callback);
    };

}).call(apf.dbg.prototype = new apf.AmlElement());

apf.aml.setElement("debugger", apf.dbg);


window.adbg = {
    exec : function(method, args, callback, options) {
         if (method == "loadScript") {
             var dbg = args[0];
             var script = args[1];
             dbg.loadScript(script, function(source) {
                 if (options && options.callback) {
                     options.callback(apf.escapeXML(source), apf.SUCCESS);
                 } else {
//                     callback("<file>" + apf.escapeXML(source) + "</file>", apf.SUCCESS);
                     //TODO: ugly text() bug workaround
                     callback("<file><![CDATA[" + source.replace("]]>", "]] >") + "]]></file>", apf.SUCCESS);
                 }
             });
         }
         else if (method == "loadObjects") {
             var dbg = args[0];
             var item = args[1];

             dbg.loadObjects(item, function(xml) {
                 if (options && options.callback) {
                     options.callback(xml, apf.SUCCESS);
                 } else {
                     callback(xml, apf.SUCCESS);
                 }
             });
         }
         else if (method == "loadFrame") {
             var dbg = args[0];
             var frame = args[1];

             dbg.loadFrame(frame, function(xml) {
                 if (options && options.callback) {
                     options.callback(xml, apf.SUCCESS);
                 } else {
                     callback(xml, apf.SUCCESS);
                 }
             });
         }
     }
 };

(apf.$asyncObjects || (apf.$asyncObjects = {}))["adbg"] = 1;

});
// #endif
;
// #ifdef __AMLDEBUGGER || __INC_ALL
if (apf.hasRequireJS) define("apf/elements/dbg/v8debugger",
    ["module", "debug/Breakpoint"],
    function(module, Breakpoint) {

var V8Debugger = module.exports = function(dbg, host) {
    this.$init();

    this.$debugger = dbg;
    this.$host = host;
    this.$v8breakpoints = {};

    var _self = this;
    dbg.addEventListener("changeRunning", function(e) {
        _self.dispatchEvent("changeRunning", e);
        if (dbg.isRunning()) {
            _self.setFrame(null);
        }
    });
    dbg.addEventListener("break", function(e) {
        _self.dispatchEvent("break", e);
    });
    dbg.addEventListener("afterCompile", function(e) {
        _self.dispatchEvent("afterCompile", {script: apf.getXml(_self.$getScriptXml(e.data.script))});
    });

    this.setFrame(null);
};

(function() {
    var hasChildren = {
        "object": 8,
        "function": 4
    };

    this.stripPrefix = "";

    this.setStrip = function(stripPrefix) {
        this.stripPrefix = stripPrefix;
    };

    this.$strip = function(str) {
        if (!this.stripPrefix)
            return str;

        return str.indexOf(this.stripPrefix) === 0
            ? str.slice(this.stripPrefix.length)
            : str;
    };

    this.isRunning = function() {
        return this.$debugger.isRunning();
    };

    this.scripts = function(model, callback) {
        var _self = this;
        this.$debugger.scripts(4, null, false, function(scripts) {
            var xml = [];
            for (var i = 0, l = scripts.length; i < l; i++) {
                var script = scripts[i];
                if (script.name && script.name.indexOf("chrome-extension://") === 0)
                    continue;
                xml.push(_self.$getScriptXml(script));
            }
            model.load("<sources>" + xml.join("") + "</sources>");
            callback();
        });
    };

    this.$getScriptXml = function(script) {
        return [
            "<file scriptid='", script.id,
            "' scriptname='", apf.escapeXML(script.name || "anonymous"),
            "' text='", this.$strip(apf.escapeXML(script.text || "anonymous")),
            "' lineoffset='", script.lineOffset,
            "' debug='true' />"
        ].join("");
    };

    function getId(frame){
        return (frame.func.name || frame.func.inferredName || (frame.line + frame.position));
    }

    this.$isEqual = function(xmlFrameSet, frameSet){
        if (xmlFrameSet.length != frameSet.length)
            return false;

        var xmlFirst = xmlFrameSet[0];
        var first    = frameSet[0];
        if (xmlFirst.getAttribute("scriptid") != first.func.scriptId)
            return false;
        if (xmlFirst.getAttribute("id") != getId(first))
            return false;
        //if (xmlFirst.selectNodes("vars/item").length != (1 + first.arguments.length + first.locals.length))
            //return false;

        //@todo check for ref?? might fail for 2 functions in the same file with the same name in a different context
        return true;
    };

    /**
     * Assumptions:
     *  - .index stays the same
     *  - sequence in the array stays the same
     *  - ref stays the same when stepping in the same context
     */
    this.$updateFrame = function(xmlFrame, frame){
        //With code insertion, line/column might change??
        xmlFrame.setAttribute("line", frame.line);
        xmlFrame.setAttribute("column", frame.column);

        var i, j, l;
        var vars  = xmlFrame.selectNodes("vars/item");
        var fVars = frame.arguments;
        for (i = 1, j = 0, l = fVars.length; j < l; j++) { //i = 1 to skin this
            if (fVars[j].name)
                this.$updateVar(vars[i++], fVars[j]);
        }
        fVars = frame.locals;
        for (j = 0, l = frame.locals.length; j < l; j++) {
            if (fVars[j].name !== ".arguments")
                this.$updateVar(vars[i++], fVars[j]);
        }

        //@todo not caring about globals/scopes right now
    };

    this.$updateVar = function(xmlVar, fVar){
        xmlVar.setAttribute("value", this.$valueString(fVar.value));
        xmlVar.setAttribute("type", fVar.value.type);
        xmlVar.setAttribute("ref", fVar.value.ref);
        apf.xmldb.setAttribute(xmlVar, "children", hasChildren[fVar.value.type] ? "true" : "false");
    };

    this.$buildFrame = function(frame, ref, xml){
        var script = ref(frame.script.ref);
        xml.push(
            "<frame index='", frame.index,
            "' name='", apf.escapeXML(apf.escapeXML(this.$frameToString(frame))),
            "' column='", frame.column,
            "' id='", getId(frame),
            "' ref='", frame.ref,
            "' line='", frame.line,
            "' script='", this.$strip(script.name),
            "' scriptid='", frame.func.scriptId, //script.id,
            "'>"
        );
        xml.push("<vars>");

        var receiver = {
            name: "this",
            value: frame.receiver
        };
        xml.push(this.$serializeVariable(receiver));

        var j, l;
        for (j = 0, l = frame.arguments.length; j < l; j++) {
            if (frame.arguments[j].name)
                xml.push(this.$serializeVariable(frame.arguments[j]));
        }
        for (j = 0, l = frame.locals.length; j < l; j++) {
            if (frame.locals[j].name !== ".arguments")
                xml.push(this.$serializeVariable(frame.locals[j]));
        }
        xml.push("<globals />");
        xml.push("</vars>");

        xml.push("<scopes>");
        var scopes = frame.scopes;
        for (j = 0, l = scopes.length; j < l; j++) {
            var scope = scopes[j];
            xml.push("<scope index='",scope.index, "' type='", scope.type, "' />");
        }
        xml.push("</scopes>");

        xml.push("</frame>");
    };

    this.backtrace = function(model, callback) {
        var _self = this;
        this.$debugger.backtrace(null, null, null, true, function(body, refs) {
            function ref(id) {
                for (var i=0; i<refs.length; i++) {
                    if (refs[i].handle == id) {
                        return refs[i];
                    }
                }
                return {};
            }

            var i, l;
            var frames    = body.frames;        
            var xmlFrames = model.queryNodes("frame");
            if (xmlFrames.length && _self.$isEqual(xmlFrames, frames)) {
                for (i = 0, l = frames.length; i < l; i++)
                    _self.$updateFrame(xmlFrames[i], frames[i]);
                _self.setFrame(xmlFrames[0]);
            }
            else {
                var xml = [];
                if (frames) {
                    for (i = 0, l = frames.length; i < l; i++)
                        _self.$buildFrame(frames[i], ref, xml);
                }
                model.load("<frames>" + xml.join("") + "</frames>");
                _self.setFrame(model.data.firstChild);
            }
            callback();
        });
    };

    this.loadScript = function(script, callback) {
        var id    = script.getAttribute("scriptid");
        var _self = this;
        this.$debugger.scripts(4, [id], true, function(scripts) {
            if (!scripts.length)
                return;
            var script = scripts[0];
            callback(script.source);
        });
    };

    this.loadObjects = function(item, callback) {
        var ref   = item.getAttribute("ref");
        var _self = this;
        this.$debugger.lookup([ref], false, function(body) {
            var refs  = [];
            var props = body[ref].properties;
            for (var i = 0, l = props.length; i < l; i++)
                refs.push(props[i].ref);

            _self.$debugger.lookup(refs, false, function(body) {
                var xml = ["<item>"];
                for (var i = 0, l = props.length; i < l; i++) {
                    props[i].value = body[props[i].ref];
                    xml.push(_self.$serializeVariable(props[i]));
                }
                xml.push("</item>");
                callback(xml.join(""));
            });
        });
    };

    this.loadFrame = function(frame, callback) {
        //var xml = "<vars><item name='juhu' value='42' type='number'/></vars>"
        var scopes = frame.getElementsByTagName("scope");

        var frameIndex = parseInt(frame.getAttribute("index"), 10);

        var _self     = this;
        var processed = 0;
        var expected  = 0;
        var xml       = ["<vars>"];

        for (var i = 0, l = scopes.length; i < l; i++) {
            var scope = scopes[i];
            var type = parseInt(scope.getAttribute("type"), 10);

            // ignore local and global scope
            if (type > 1) {
                expected += 1;
                var index = parseInt(scope.getAttribute("index"), 10);
                this.$debugger.scope(index, frameIndex, true, function(body) {
                    var props = body.object.properties;
                    for (j = 0, l2 = props.length; j < l2; j++)
                        xml.push(_self.$serializeVariable(props[j]));
                    processed += 1;
                    if (processed == expected) {
                        xml.push("</vars>");
                        callback(xml.join(""));
                    }
                });
            }
        }
        if (expected === 0)
            return callback("<vars />");
    };

    this.setFrame = function(frame) {
        this.$activeFrame = frame;
        this.dispatchEvent("changeFrame", {data: frame});
    };


    this.getActiveFrame = function() {
        return this.$activeFrame;
    };

    /**
     * Initialization function that sets the breakpoints right after attaching to the debugger
     */
    this.setBreakpoints = function(model, callback) {
        var _self = this;
        
        // so read all the breakpoints, then call the debugger to actually set them
        var allBreakpoints = model.queryNodes("breakpoint");
        allBreakpoints.forEach(function(bp) {
            var script = bp.getAttribute("script");
            var line = bp.getAttribute("line");
            var col = bp.getAttribute("column");
            
            // construct a nice 'Breakpoint' object
            var v8bp = new Breakpoint(script, line, col);
            // attach it to the debugger
            v8bp.attach(_self.$debugger, function () {
                _self.$bindV8BreakpointToModel(bp, v8bp);
                
                handleAdded();
            });
        });
        
        // keep track of all breakpoints and check if they're really added
        var counter = 0;
        function handleAdded() {
            if (++counter === allBreakpoints.length) {
                callback();
            }
        }
        
        if (!allBreakpoints.length) {
            callback();
        }
    };
    
    /**
     * Used from the UI to enable or disable a breakpoint
     */
    this.toggleBreakpoint = function(script, relativeRow, model) {
        var _self      = this;
        
        // grab some basic info from the 'script' attribute
        var name       = script.getAttribute("scriptname");
        var lineOffset = parseInt(script.getAttribute("lineoffset") || "0", 10);
        var row        = lineOffset + relativeRow;
        
        // query to see if we already have breakpoints on this script + line
        var breakpoints = model.data.selectNodes("//breakpoint[@script=\'" + name + "\' and @line=" + row + "]");
        
        // if there are breakpoints already, remove them
        if (breakpoints.length) {
            breakpoints.forEach(function (bp) {
                var removeHandled = false;
                
                try {
                    // callback to the V8 debugger
                    _self.$getV8BreakpointFromModel(bp).clear(function() {
                        // and remove it from the UI
                        _self.$removeBreakpoint(bp, model);
                    });
                    removeHandled = true;
                }
                // if it fails? then remove from the UI anyways
                catch (ex) {
                    removeHandled = false;
                }
                
                // no debugger handling this via a callback, then well do it ourselves
                if (!removeHandled) {
                    _self.$removeBreakpoint(bp, model);
                }
            });
        }
        else {
            this.$addBreakpoint({
                name: name,
                row: row,
                col: 0,
                lineOffset: lineOffset,
                scriptId: script.getAttribute("scriptid")
            }, model);
        }
    };
    
    /**
     * Remove a breakpoint
     */
    this.$removeBreakpoint = function(bp, model) {
        // removing a certain breakpoint from the model
        var xpath;
        
        // check if we have some identifier
        if (bp.$id) {
            xpath = "breakpoint[@id=" + bp.$id + "]";
        }
        else {
            xpath = "//breakpoint[@script=\'" + bp.getAttribute("script") + "\' and @line=" + bp.getAttribute("line") + "]";
        }
        
        // remove all nodes
        var node;
        
        while (node = model.queryNode(xpath)) {
            apf.xmldb.removeNode(node);
        }
    };
    
    /**
     * Adds a new breakpoint
     */
    this.$addBreakpoint = function(options, model, callback) {
        var _self = this;
        
        // create 
        var v8bp = new Breakpoint(options.name, options.row, options.col, options.dbg);

        // no clue what this does
        if (options.data) {
            apf.extend(v8bp, options.data);
        }
        
        // now attach it
        v8bp.attach(this.$debugger, function () {
            // after succeeding, also add it to the the model
            model.appendXml(_self.$getBreakpointXml(v8bp, options.lineOffset, options.scriptId));
            
            // bind model and breakpoint to eachother
            _self.$bindV8BreakpointToModel(model.data.selectSingleNode("//breakpoint[@script=\'" + v8bp.source + "\' and @line=" + options.row + "]"), v8bp);
            
            if (typeof callback === "function") {
                callback();
            }            
        });
        
        return v8bp;
    };
    
    /**
     * Based on a breakpoint from the model, you can get the v8 breakpoint
     */
    this.$getV8BreakpointFromModel = function (node) {
        var id = node.getAttribute("script") + "|" + node.getAttribute("line");
        
        return this.$v8breakpoints[id];
    };
    
    /**
     * Binds a model node to a real v8 breakpoint
     */
    this.$bindV8BreakpointToModel = function (node, v8breakpoint) {
        var id = node.getAttribute("script") + "|" + node.getAttribute("line");
        
        this.$v8breakpoints[id] = v8breakpoint;
    };
    
    this.$getBreakpointXml = function(breakpoint, lineOffset, scriptId) {
        var xml = [];
        xml.push(
            "<breakpoint",
            " id='", breakpoint.$id,
            "' text='", this.$strip(apf.escapeXML(breakpoint.source)), ":", (parseInt(breakpoint.line, 10) + 1),
            "' script='", apf.escapeXML(breakpoint.source),
            scriptId ? "' scriptid='" + scriptId : "",
            "' lineoffset='", lineOffset || 0,
            "' line='", breakpoint.line,
            "' condition='", apf.escapeXML(breakpoint.condition || ""),
            "' ignorecount='", breakpoint.ignoreCount || 0,
            "' enabled='", breakpoint.enabled,
            "' />"
        );

        return xml.join("");
    };

    this.continueScript = function(callback) {
        this.$debugger.continueScript(null, null, callback);
    };

    this.stepInto = function(callback) {
        this.$debugger.continueScript("in", 1, callback);
    };

    this.stepNext = function(callback) {
        this.$debugger.continueScript("next", 1, callback);
    };

    this.stepOut = function(callback) {
        this.$debugger.continueScript("out", 1, callback);
    };

    this.suspend = function() {
        this.$debugger.suspend();
    };
  
    this.changeLive = function(scriptId, newSource, previewOnly, callback) {
        this.$debugger.changelive(scriptId, newSource, previewOnly, callback);
    };
    
    this.evaluate = function(expression, frame, global, disableBreak, callback){
        this.$debugger.evaluate(expression, frame, global, disableBreak, function(body, refs, error){
            var str = [];
            var name = expression.trim();
            if (error) {
                str.push("<item type='.error' name=\"", apf.escapeXML(name),
                    "\" value=\"", apf.escapeXML(error.message), "\" />");
            }
            else {
                str.push(
                    "<item name=\"", apf.escapeXML(name),
                    "\" value='", apf.escapeXML(body.text), //body.value ||
                    "' type='", body.type,
                    "' ref='", body.handle,
                    body.constructorFunction ? "' constructor='" + body.constructorFunction.ref : "",
                    body.prototypeObject ? "' prototype='" + body.prototypeObject.ref : "",
                    body.properties && body.properties.length ? "' children='true" : "",
                    "' />"
              );
            }
            callback(apf.getXml(str.join("")), body, refs, error);
        });
    };

    this.$valueString = function(value) {
        switch (value.type) {
            case "undefined":
            case "null":
                return value.type;

            case "boolean":
            case "number":
            case "string":
                return value.value + "";

            case "object":
                return "[" + value.className + "]";

            case "function":
                return "function " + value.inferredName + "()";

            default:
                return value.type;
        };
    };

    this.$frameToString = function(frame) {
        var str     = [];
        var args    = frame.arguments;
        var argsStr = [];

        str.push(frame.func.name || frame.func.inferredName || "anonymous", "(");
        for (var i = 0, l = args.length; i < l; i++) {
            var arg = args[i];
            if (!arg.name)
                continue;
            argsStr.push(arg.name);
        }
        str.push(argsStr.join(", "), ")");
        return str.join("");
    };

    this.$serializeVariable = function(item, name) {
        var str = [
            "<item name='", apf.escapeXML(name || item.name),
            "' value='", apf.escapeXML(this.$valueString(item.value)),
            "' type='", item.value.type,
            "' ref='", typeof item.value.ref == "number" ? item.value.ref : item.value.handle,
            hasChildren[item.value.type] ? "' children='true" : "",
            "' />"
        ];
        return str.join("");
    };
    
}).call(V8Debugger.prototype = new apf.Class());

});
// #endif
;
// #ifdef __AMLDEBUGGER || __INC_ALL
if (apf.hasRequireJS) define("apf/elements/dbg/chromedebughost",
    ["module",
     "debug/ChromeDebugMessageStream", 
     "debug/WSChromeDebugMessageStream", 
     "debug/DevToolsService", 
     "debug/V8DebuggerService",
     "debug/V8Debugger",
     "apf/elements/dbg/v8debugger"],
    function(module, ChromeDebugMessageStream, WSChromeDebugMessageStream, DevToolsService, V8DebuggerService, V8Debugger, APFV8Debugger) {

var ChromeDebugHost = module.exports = function(hostname, port, o3obj, ws) {
    this.$hostname = hostname;
    this.$port = port;
    this.$o3obj = o3obj;
    this.$ws = ws;

    this.$debuggers = {};
    
    this.$init();
    this.$connect(function() {});
};

(function() {
     
    this.$connect = function(callback) {
        var self = this;

        if (this.state == "connected") {
            return callback.call(this);
        } else {
            this.addEventListener("connect", function() {
                self.removeEventListener("connect", arguments.callee);
                callback.call(self);
            });
        }
        if (this.state == "connecting")
            return;

        this.state = "connecting";

        if (!this.$ws) {
            var socket = this.$socket = new O3Socket(this.$hostname, this.$port, this.$o3obj);
            var msgStream = new ChromeDebugMessageStream(socket);
        } else {
            var msgStream = new WSChromeDebugMessageStream(this.$ws);            
        }

        msgStream.addEventListener("connect", function() {
            self.$dts = new DevToolsService(msgStream);
            self.$v8ds = new V8DebuggerService(msgStream);
            self.state = "connected";
            self.dispatchEvent("connect");
            
            window.onunload = self.disconnect.bind(self);
        });

        msgStream.connect();        
    };
    
    this.loadTabs = function(model) {
        var self = this;
        this.$connect(function() {
            self.$dts.listTabs(function(tabs) {
                var xml = [];
                for (var i = 0; i < tabs.length; i++) {
                    xml.push("<tab id='", tabs[i][0], "' url='", apf.escapeXML(tabs[i][1]+""), "' />");
                }
                model.load("<tabs>" + xml.join("") + "</tabs>");
            });
        });
    };
    
    this.attach = function(tabId, callback) {
        var dbg;
        
        if (dbg = this.$debuggers[tabId])
            return callback(null, dbg)

        var self = this;
        this.$connect(function() {
            self.$v8ds.attach(tabId, function() {
                dbg = new APFV8Debugger(new V8Debugger(tabId, self.$v8ds), this);
                self.$debuggers[tabId] = dbg;
                callback(null, dbg);
            });
        });
    };
    
    this.detach = function(dbg, callback) {        
        var self = this;
        for (var id in this.$debuggers) {
            if (this.$debuggers[id] == dbg) {
                this.$v8ds.detach(id, function(err) {
                    delete self.$debuggers[id];
                    dbg.dispatchEvent("detach");
                    callback && callback(err);
                });                
                break;
            }    
        }
    };  
    
    this.disconnect = function(callback) {
        var debuggers = [];
        for (var id in this.$debuggers) {
            debuggers.push(id);
        }
        
        var self = this;
        var detachNext = function() {
            if (debuggers.length) {
                var id = debuggers.shift();
                var dbg = self.$debuggers[id]
                self.$v8ds.detach(id, function() {
                    detachNext();
                    dbg.dispatchEvent("detach");
                });
            } else {
                self.$socket.close();
                self.$debuggers = {};
                self.dispatchEvent("disconnect", {});
                callback && callback();
            }
        }
        
        detachNext();
    };
    
}).call(ChromeDebugHost.prototype = new apf.Class());

});
// #endif;
// #ifdef __AMLDEBUGGER || __INC_ALL
if (apf.hasRequireJS) define("apf/elements/dbg/v8debughost",
    ["module",
     "debug/StandaloneV8DebuggerService",
     "debug/V8Debugger",
     "apf/elements/dbg/v8debugger"],
    function(module, StandaloneV8DebuggerService, V8Debugger, APFV8Debugger) {

var V8DebugHost = module.exports = function(hostname, port, o3obj) {
    this.$hostname = hostname;
    this.$port = port;
    this.$o3obj = o3obj;
    
    this.$debugger = null;
    
    this.$init();
};

(function() {
     
    this.$connect = function(callback) {
        var self = this;
        
        if (this.state == "connected") {
            return callback.call(this);
        } else {
            this.addEventListener("connect", function() {
                self.removeEventListener("connect", arguments.callee);
                callback.call(self);
            });
        }
        if (this.state == "connecting")
            return;

        this.state = "connecting";
        
        var socket = this.$socket = new O3Socket(this.$hostname, this.$port, this.$o3obj);
        this.$v8ds = new StandaloneV8DebuggerService(socket);
        
        this.state = "connected";
        this.dispatchEvent("connect");
            
        window.onunload = this.disconnect.bind(this);
        callback.call(this);
    };
    
    this.loadTabs = function(model) {
        model.load("<tabs><tab id='0'>V8</tab></tabs>");
    };
    
    this.attach = function(tabId, callback) {
        var dbg = this.$debugger;
        
        if (dbg)
            return callback(null, dbg)

        var self = this;
        this.$connect(function() {
            self.$v8ds.attach(0, function() {
                dbg = new APFV8Debugger(new V8Debugger(0, self.$v8ds), this);
                self.$debugger = dbg;
                callback(null, dbg);
            });
        });
    };
    
    this.detach = function(dbg, callback) {        
        if (!dbg || this.$debugger !== dbg)
            return callback();
        
        this.$debugger = null;

        var self = this;
        this.$v8ds.detach(0, function(err) {
            dbg.dispatchEvent("detach");
            self.$socket.close();
            self.dispatchEvent("disconnect", {});
            callback && callback(err);
        });                
    };  
    
    this.disconnect = function(callback) {
        this.detach(this.$debugger, callback);
    };
    
}).call(V8DebugHost.prototype = new apf.Class());

});
// #endif;
// #ifdef __AMLDEBUGGER || __INC_ALL
if (apf.hasRequireJS) define("apf/elements/dbg/v8websocketdebughost",
    ["module",
     "debug/WSV8DebuggerService",
     "debug/V8Debugger",
     "apf/elements/dbg/v8debugger"],
    function(module, WSV8DebuggerService, V8Debugger, APFV8Debugger) {

var V8WebSocketDebugHost = module.exports = function(socket) {
    this.$socket = socket;
    this.$debugger = null;
    
    this.$init();
};

(function() {
     
    this.$connect = function(callback) {
        if (this.state != "connected")
            this.$v8ds = new WSV8DebuggerService(this.$socket);
        
        this.state = "connected";
        this.dispatchEvent("connect");
        callback.call(this);
    };
    
    this.loadTabs = function(model) {
        model.load("<tabs><tab id='0'>V8</tab></tabs>");
    };
    
    this.attach = function(tabId, callback) {
        var dbg = this.$debugger;
        
        if (dbg)
            return callback(null, dbg)

        var self = this;
        this.$connect(function() {
            self.$v8ds.attach(0, function() {
                dbg = new APFV8Debugger(new V8Debugger(0, self.$v8ds), this);
                self.$debugger = dbg;
                callback(null, dbg);
            });
        });
    };
    
    this.detach = function(dbg, callback) {        
        if (!dbg || this.$debugger !== dbg)
            return callback();
        
        this.$debugger = null;

        var self = this;
        this.$v8ds.detach(0, function(err) {
            dbg.dispatchEvent("detach");
            self.dispatchEvent("disconnect", {});
            callback && callback(err);
        });                
    };  
    
    this.disconnect = function(callback) {
        this.detach(this.$debugger, callback);
    };
    
}).call(V8WebSocketDebugHost.prototype = new apf.Class());

});
// #endif
;
// #ifdef __AMLDEBUGGER || __INC_ALL
if (apf.hasRequireJS) define("apf/elements/debughost",
    ["module",
     "apf/elements/dbg/chromedebughost",
     "apf/elements/dbg/v8debughost", 
     "apf/elements/dbg/v8websocketdebughost"],
    function(module, ChromeDebugHost, V8DebugHost, V8WebSocketDebugHost) {

apf.debughost = module.exports = function(struct, tagName){
    this.$init(tagName || "debughost", apf.NODE_HIDDEN, struct);
};

(function(){

    this.port = 9222;
    this.server = "localhost";
    this.type = "chrome";
    this.autoinit = false;
    this.$modelTabs = null;
    this.$stateConnected = null;
    
    this.$host = null;
    
    this.$booleanProperties["autostart"] = true;
    
    this.$supportedProperties.push("port", "server", "type", "autoinit",
        "model-tabs", "state-connected", "strip");

    this.$propHandlers["model-tabs"] = function(value) {
        if (!value) return;
        //#ifdef __WITH_NAMESERVER
        this.$modelTabs = apf.nameserver.get("model", value) || 
            apf.setReference(value, apf.nameserver.register("model", value, new apf.model()));
        
        // set the root node for this model
        this.$modelTabs.id = this.$modelTabs.name = value;
        this.$modelTabs.load("<tabs/>");
        //#endif
    };

    this.$propHandlers["state-connected"] = function(value) {
        if (!value) return;
        //#ifdef __WITH_NAMESERVER
        this.$stateConnected = apf.nameserver.get("state", value) || 
            apf.setReference(value, apf.nameserver.register("state", value, new apf.state()));
        
        // set the root node for this model
        this.$stateConnected.id = this.$stateConnected.name = value;
        this.$stateConnected.deactivate();
        //#endif
    };
    
    this.init = function() {
        if (this.$host)
            return;
        
        if (this.type == "chrome" || this.type == "v8" || this.type == "v8-ws") {
            if (!apf.debughost.$o3obj && this.type !== "v8-ws") {
                apf.debughost.$o3obj = window.o3Obj || o3.create("8A66ECAC-63FD-4AFA-9D42-3034D18C88F4", { 
                    oninstallprompt: function() { alert("can't find o3 plugin"); },
                    product: "O3Demo"
                }); 
            }

            if (this.type == "chrome") {
                this.$host = new ChromeDebugHost(this.server, this.port, apf.debughost.$o3obj);
            }
            else if (this.type == "v8") {
                this.$host = new V8DebugHost(this.server, this.port, apf.debughost.$o3obj);
            }
            else if (this.type == "v8-ws") {
                var socket = this.dispatchEvent("socketfind");
                if (!socket)
                    throw new Error("no socket found!")
                this.$host = new V8WebSocketDebugHost(socket);
            }
            else if (this.type == "chrome-ws") {
                var socket = this.dispatchEvent("socketfind");
                if (!socket)
                    throw new Error("no socket found!")
                this.$host = new ChromeDebugHost(null, null, null, socket);
            }
                
            var self = this;
            this.$host.addEventListener("connect", function() {
                self.dispatchEvent("connect");
                self.$stateConnected.activate();
            });
            this.$host.addEventListener("disconnect", function() {
                self.dispatchEvent("disconnect");
                self.$stateConnected.deactivate();
            });
            
            this.loadTabs();
        }
    };
    
    this.loadTabs = function() {
        if (!this.$host)
            this.init();
        
        var self = this;
        this.$host.loadTabs(this.$modelTabs, function() {
            self.$dispatchEvent("tabsloaded");
        });        
    }
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e) {
        if (this.autoinit)
            this.init();
    });
    
    this.$attach = function(dbg, tab, callback) {        
        if (!this.$host) 
            this.init();
        
        var id = tab ? tab.getAttribute("id") : null;
        
        var _self = this;
        this.$host.attach(id, function(err, dbg) {
            dbg.setStrip(_self.strip || "");
            callback(err, dbg);
        });
    };

    this.$detach = function(dbgImpl, callback) {
        if (!this.$host) 
            return;
        
        this.$host.detach(dbgImpl, callback);
    };
    
    this.disconnect = function() {
        if (!this.$host) 
            return;
        
        this.$host.disconnect();
        this.$host = null;
    };
    
}).call(apf.debughost.prototype = new apf.AmlElement());

apf.aml.setElement("debughost", apf.debughost);

});
// #endif
;
define('text!ext/noderunner/noderunner.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n\n    <a:debugger id="dbg"\n      state-running     = "stRunning"\n      state-attached    = "stAttached"\n      model-sources     = "mdlDbgSources"\n      model-stack       = "mdlDbgStack"\n      model-breakpoints = "mdlDbgBreakpoints" \n      onbreak           = ""\n      oncontinue        = "" />\n    \n    <a:debughost id="dbgNode"\n      type            = "v8-ws"\n      autoinit        = "false"\n      model-tabs      = "mdlTabs"\n      state-connected = "stDebuggerConnected" />\n      \n    <a:debughost id="dbgChrome"\n      type     = "chrome-ws"\n      autoinit = "false"\n      model-tabs      = "mdlTabs"\n      state-connected = "stDebuggerConnected" />\n      \n    <a:state id="stDebugProcessRunning" active="false" />\n    \n    <!--a:window id="winTab" \n      title     = "Choose a Tab"\n      icon      = "chromium_16.png"\n      zindex    = "10" \n      center    = "true" \n      modal     = "true" \n      width     = "450" \n      height    = "200" \n      buttons   = "close"\n      kbclose   = "true"\n      skin      = "bk-window"\n      visible   = "false">\n        <a:list id="lstTabs" \n          model="mdlTabs" \n          anchors="10 10 56 10" \n          multiselect="false" \n          autoselect="false" \n          each="[tab]" \n          caption="[@url]" \n          empty-message="Loading tabs..."\n          onafterchoose = "btnTabsOk.dispatchEvent(\'click\');"/>\n        <a:button id="btnTabsOk"\n          right="10"\n          bottom="10"\n          width="60"\n          disabled="{!lstTabs.selected}" \n          default="true"\n          skin="btn-default-css3"\n          onclick="winTab.close();dbg.attach(dbgChrome, {lstTabs.selected})">\n            OK\n        </a:button>\n    </a:window-->\n\n</a:application>';});

define('text!ext/console/console.css',[],function () { return '.console_date {\n    display:inline\n}\n.console_text div {\n    padding: 2px 10px;\n}\n.cli_divider {\n    display: block;\n    border-top: 1px solid #444;\n    margin: 6px 0 6px 0;\n}\n.console_text a:link, .console_text a:hover, .console_text a:active {\n    color: #86C2F6;\n}\n.console_text a:visited {\n    color: #909090;\n}\n.cmd_msg > span { float: left; }\n.cmd_msg > span > span { margin:0 0 0 25px; }';});

define('text!ext/console/console.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:bar id="winDbgConsole" height="41">\n        <a:vbox anchors="0 0 0 0">\n            <a:tab id="tabConsole" skin="tab_console" flex="1" visible="false" render2="runtime">\n                <a:hbox pack="end" top="2" right="3" height="24" align="center" padding="0">\n                    <a:button id="btnConsoleClear" skin="btn_icon_only" icon="console_clear.png" margin="2 2 0 0"\n                      onclick  = "\n                        if (tabConsole.activepagenr == 0)\n                            txtConsole.clear();\n                        else if (tabConsole.activepagenr == 1)\n                            txtOutput.clear();\n                      "/>\n                    <a:button id="btnConsoleSettings" skin="btn_icon_only"\n                      icon    = "console_settings.png"\n                      margin  = "2 4 0 0"\n                      submenu = "mnuConsoleSettings" />\n                    <a:button id="btnConsoleMax" skin="btn_icon_only" icon="console_max.png" state="true" margin="2 2 0 0"\n                      onclick = "\n                        var console = require(\'ext/console/console\');\n                        if (this.value)\n                            console.maximize();\n                        else\n                            console.restore();\n                      "/>\n                    <a:divider skin="divider_console"></a:divider>\n                    <a:button\n                      skin="btn_icon_only"\n                      icon="console_close_btn.png"\n                      class="dim22-22"\n                      margin="1 0 0 1"\n                      onclick="require(\'ext/console/console\').hide()"/>\n                </a:hbox>\n                <a:page id="pgConsole" caption="Console" name="console">\n                    <a:text id="txtConsole"\n                      margin     = "3 0 0 0"\n                      anchors    = "0 17 0 0"\n                      flex       = "1"\n                      scrolldown = "true"\n                      focussable = "true"\n                      textselect = "true"\n                      class      = "console_text" />\n                    <a:scrollbar\n                      for       = "txtConsole"\n                      right     = "0"\n                      top       = "0"\n                      bottom    = "0"\n                      skin      = "console_scrollbar"\n                      width     = "17" />\n                </a:page>\n                <a:page id="pgOutput" caption="Output" name="output">\n                    <a:text id="txtOutput"\n                      margin     = "3 0 0 0"\n                      anchors    = "0 17 0 0"\n                      flex       = "1"\n                      scrolldown = "true"\n                      focussable = "true"\n                      textselect = "true"\n                      class      = "console_text" />\n                    <a:scrollbar\n                      for    = "txtOutput"\n                      right  = "0"\n                      top    = "0"\n                      bottom = "0"\n                      skin   = "console_scrollbar"\n                      width  = "17" />\n                </a:page>\n            </a:tab>\n\n            <a:menu id="mnuConsoleSettings">\n                <a:item type="check"\n                  checked = "[{require(\'core/settings\').model}::auto/console/@autoshow]"\n                  caption = "Auto-show console when running" />\n            </a:menu>\n\n            <a:hbox class="consoleInputBox" edge="1" padding="4" pack="end">\n                <a:textbox id="txtConsoleInput"\n                  margin    = "4 0 0"\n                  skin      = "tb_console"\n                  flex      = "1" />\n                <a:button id="btnCollapseConsole" skin="btn_console_open" icon="console-btn.png" state="true" height="38"\n                    value = "{!!tabConsole.visible}"\n                    onprop.value="try { require(\'ext/console/console\')[event.value ? \'show\' : \'hide\'](); } catch(e) {} " />\n            </a:hbox>\n        </a:vbox>\n    </a:bar>\n</a:application>\n\n';});

define('text!ext/console/themes/arthur.css',[],function () { return '/**\n * This stylesheet is generated automatically, please don\'t edit manually.\n * Generated by iterm2css - http://github.com/mikedeboer/iterm2css\n */\n\n.term_ansi0Color {\n    color: rgb(61, 53, 42);\n}\n\n.term_ansi1Color {\n    color: rgb(205, 92, 92);\n}\n\n.term_ansi10Color {\n    color: rgb(136, 170, 34);\n}\n\n.term_ansi11Color {\n    color: rgb(255, 167, 93);\n}\n\n.term_ansi12Color {\n    color: rgb(135, 206, 235);\n}\n\n.term_ansi13Color {\n    color: rgb(153, 102, 0);\n}\n\n.term_ansi14Color {\n    color: rgb(176, 196, 222);\n}\n\n.term_ansi15Color {\n    color: rgb(221, 204, 187);\n}\n\n.term_ansi2Color {\n    color: rgb(134, 175, 128);\n}\n\n.term_ansi3Color {\n    color: rgb(232, 174, 91);\n}\n\n.term_ansi4Color {\n    color: rgb(100, 149, 237);\n}\n\n.term_ansi5Color {\n    color: rgb(222, 184, 135);\n}\n\n.term_ansi6Color {\n    color: rgb(176, 196, 222);\n}\n\n.term_ansi7Color {\n    color: rgb(187, 170, 153);\n}\n\n.term_ansi8Color {\n    color: rgb(85, 68, 68);\n}\n\n.term_ansi9Color {\n    color: rgb(204, 85, 51);\n}\n\n.term_backgroundColor {\n    background-color: rgb(28, 28, 28);\n}\n\n.term_boldColor {\n    color: rgb(255, 255, 255);\n}\n\n.term_cursorColor {\n    background-color: rgb(226, 187, 239);\n}\n\n.term_cursorTextColor {\n    background-color: rgb(0, 0, 0);\n}\n\n.term_foregroundColor {\n    color: rgb(221, 238, 221);\n}\n\n.term_selectedTextColor {\n    color: rgb(255, 255, 255);\n}\n\n.term_selectionColor {\n    color: rgb(77, 77, 77);\n}\n\n';});

define('ext/console/parser',['require','exports','module'],function(require, exports, module) {
// Parses a CLI instruction line and returns an array of its arguments, respecting
// quotes and special cases.
module.exports = function(lineBuffer) {
    var argv = [];
    var cursor = 0;
    var currentQuote = "";
    var inSpace = false;
    var len = lineBuffer.length;

    for (var i=0; i<len; i++) {
        var ch = lineBuffer.charAt(i);
        if (!argv[cursor])
            argv[cursor] = "";

        if (/["'`]/.test(ch)) {
            if (currentQuote.length) {
                if (currentQuote === ch)
                    currentQuote = "";
                else {
                    argv[cursor] += ch;
                }
            }
            else {
                currentQuote = ch;
            }
            inSpace = false;
        }
        else if (/\s/.test(ch)) {
            if (currentQuote.length) {
                inSpace = false;
                argv[cursor] += ch;
            }
            else if (!inSpace) {
                inSpace = true;
                cursor += 1;
            }
        }
        else {
            inSpace = false;
            argv[cursor] += ch;
        }
    }

    if (argv[argv.length - 1] === "")
        argv.pop();

    return argv;
};
});

/**
 * Console output for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 * @contributor Sergi Mansilla <sergi AT c9 DOT io>
 */

define('ext/console/output',['require','exports','module'],function(require, exports, module) {
module.exports = {
    general: {
        "make me a sandwich": "What? Make it yourself!",
        "make love": "I put on my robe and wizard hat.",
        "i read the source code": "<3",
        "lpr": "PC LOAD LETTER",
        "hello joshua": "How about a nice game of Global Thermonuclear War?",
        "xyzzy": "Nothing happens.",
        "date": "March 32nd",
        "hello": "Why hello there!",
        "who": "Doctor Who?",
        "su": "God mode activated. Remember, with great power comes great ... aw, screw it, go have fun.",
        "fuck": "I have a headache.",
        "whoami": "You are Richard Stallman.",
        "nano": "Seriously? Why don't you just use Notepad.exe? Or MS Paint?",
        "top": "It's up there --^",
        "moo":"moo",
        "ping": "There is another submarine three miles ahead, bearing 225, forty fathoms down.",
        "find": "What do you want to find? Kitten would be nice.",
        "more":"Oh, yes! More! More!",
        "your gay": "Keep your hands off it!",
        "hi":"Hi.",
        "echo": "Echo ... echo ... echo ...",
        "bash": "You bash your head against the wall. It's not very effective.",
        "ssh": "ssh, this is a library.",
        "uname": "Illudium Q-36 Explosive Space Modulator",
        "finger": "Mmmmmm...",
        "kill": "Terminator deployed to 1984.",
        "use the force luke": "I believe you mean source.",
        "use the source luke": "I'm not luke, you're luke!",
        "serenity": "You can't take the sky from me.",
        "enable time travel": "TARDIS error: Time Lord missing.",
        "ed": "You are not a diety."
    },
    man: {
        "last": "Man, last night was AWESOME.",
        "help": "Man, help me out here.",
        "next": "Request confirmed; you will be reincarnated as a man next.",
        "cat":  "You are now riding a half-man half-cat.",
        "__default__": "Oh, I'm sure you can figure it out."
    },
    locate: {
        "ninja": "Ninja can not be found!",
        "keys": "Have you checked your coat pocket?",
        "joke": "Joke found on user.",
        "problem": "Problem exists between keyboard and chair.",
        "raptor": "BEHIND YOU!!!",
        "__default__": "Locate what?"
    },
    sudo: {
        "make me a sandwich": "Okay.",
        "apt-get moo": [" ",
            "        (__)",
            "        (oo)",
            "  /------\\/ ",
            " / |    ||  ",
            "*  /\\---/\\  ",
            "   ~~   ~~  ",
            "....\"Have you mooed today?\"...",
            " "],
        "__default__": "E: Invalid operation %s"
    },
    // If there is a predefined (i.e. hardcoded) output for the current
    // command being executed in the CLI, show that.
    getPredefinedOutput: function(argv) {
        var rest;
        var out = this[argv[0]];
        if (out) {
            rest = argv.slice(1).join(" ").trim();
            return out[rest] || out.__default__.replace("%s", argv[0]);
        }
        else {
            rest = argv.join(" ").trim();
            return this.general[rest] || "";
        }
    }
};
});


define('text!ext/consolehints/consolehints.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <div id="barConsoleHints" class="barConsoleHints"/>\n</a:application>';});

define('text!ext/consolehints/consolehints.css',[],function () { return '.barConsoleHints {\n    z-index: 10000;\n    padding: 4px 4px 0 4px;\n    position: absolute;\n    display: none;\n\n    bottom: 41px;\n    border-bottom-left-radius: 0px;\n    border-bottom-right-radius: 0px;\n    border-top-left-radius: 8px;\n    border-top-right-radius: 8px;\n    border: 2px solid #656565;\n    border-width: 2px 2px 0 2px;\n\n    background-color: #000000;\n    background: -webkit-gradient(linear,left bottom,left top,rgb(46,48,52),rgb(31,31,31));\n    background: -moz-linear-gradient(center bottom,rgb(46,48,52),rgb(31,31,31));\n}\n\n.barConsoleHints a {\n    position: relative;\n    text-decoration: none;\n    font-weight: normal;\n    color: #eee;\n    padding: 3px 5px;\n    margin: 0 0 2px 0;\n    display: block;\n}\n\n.barConsoleHints a.selected {\n    padding: 2px 4px;\n    border-radius: 4px;\n    background-color: #f0f0f0;\n    background: -webkit-gradient(linear,left bottom,left top,rgb(55,56,58),rgb(41,42,43));\n    background: -moz-linear-gradient(center bottom,rgb(55,56,58),rgb(41,42,43));\n    color: #333;\n    border: 1px solid #505051;\n    border-bottom: 1px solid #1d1e1f;\n}\n\n.barConsoleHints a span {\n    color: #909090;\n    font-style: italic;\n    margin-left: 4px;\n    font-size: 11px;\n}\n\n.barConsoleHints a span.hints_hotkey {\n    color: #666;\n    font-weight: bold;\n    float: right;\n    margin-left : 20px;\n    margin-top : 1px;\n}\n';});

define('text!ext/tabsessions/tabsessions.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:window\n      id        = "winSaveSessionAs"\n      center    = "true"\n      height    = "300"\n      icon      = ""\n      skin      = "bk-window"\n      buttons   = "close"\n      kbclose   = "true"\n      resizable = "true"\n      title     = "Save Session As"\n      width     = "300"\n      onshow    = "txtSaveSessionAs.clear()">\n        <a:vbox\n          anchors   = "10 10 0 10"\n          padding   = "5">\n            <a:hbox\n              align     = "center"\n              padding   = "5">\n                <a:label width="83" class="lbl_saveas">Session name:</a:label>\n                <a:textbox\n                  id           = "txtSaveSessionAs"\n                  flex         = "1"\n                  focusselect  = "true"/>\n            </a:hbox>\n            <div class="dgLikeContaier" style="height: 160px;">\n                <div class="heading">Saved sessions</div>\n                <a:hbox\n                  anchors  = "20 0 0 0"\n                  overflow = "hidden">\n                    <a:list\n                      id            = "lstSaveSessionAs"\n                      class         = "noscrollbar trDgLike emptyLeft"\n                      scrollbar     = "sbShared 2 2 2"\n                      style         = "border: none; overflow: hidden"\n                      flex          = "1"\n                      model         = "{require(\'ext/settings/settings\').model}"\n                      onclick = "txtSaveSessionAs.setValue(this.selected.getAttribute(\'name\'))"\n                      onafterchoose = "require(\'ext/tabsessions/tabsessions\').saveSession(this.selected.getAttribute(\'name\'))"\n                      empty-message = "No sessions">\n                        <a:each match="[auto/sessions/session]">\n                           <a:caption match="[@name]" />\n                           <a:icon\n                             value = "page_white_text.png" />\n                        </a:each>\n                    </a:list>\n                </a:hbox>\n            </div>\n\n            <a:hbox\n              edge    = "30 0 0"\n              pack    = "end"\n              padding = "5">\n                <a:button skin = "btn-default-css3"\n                  onclick = "winSaveSessionAs.hide()">\n                    Cancel\n                </a:button>\n                <a:button\n                  class="btn-green" skin="btn-default-css3"\n                  default  = "2"\n                  onclick  = "require(\'ext/tabsessions/tabsessions\').saveSession(txtSaveSessionAs.getValue())">\n                    Save\n                </a:button>\n            </a:hbox>\n        </a:vbox>\n    </a:window>\n</a:application>\n';});

define('text!ext/keybindings_default/keybindings_default.xml',[],function () { return '<?xml version=\'1.0\'?>\n<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:window\n      id        = "winKeyBindings"\n      title     = "Default Keybindings"\n      icon      = ""\n      center    = "true"\n      visible   = "false"\n      kbclose   = "true"\n      skin      = "bk-window"\n      width     = "793"\n      height    = "500"\n      buttons   = "close"\n      class     = "relative keybindings_default"\n      draggable = "false">\n        <a:bar id="barKeyBindingsMac"\n          skin="basic"\n          class="keybindings_default_bar"\n          visible="{apf.isMac}"/>\n        <a:scrollbar\n          for      = "barKeyBindingsMac"\n          id       = "sbKeyBindingsMac"\n          margin   = "2"\n          skin     = "sbios"\n          width    = "7"\n          overflow2 = "auto"\n          top      = "0"\n          right    = "0"\n          visible  = "{barKeyBindingsMac.visible}"/>\n        <a:bar id="barKeyBindingsWin"\n          skin="basic"\n          class="keybindings_default_bar"\n          visible="{!apf.isMac}"/>\n        <a:scrollbar\n          for      = "barKeyBindingsWin"\n          id       = "sbKeyBindingsWin"\n          margin   = "2"\n          skin     = "sbios"\n          width    = "7"\n          overflow2 = "auto"\n          top      = "0"\n          right    = "0"\n          visible  = "{barKeyBindingsWin.visible}"/>\n\n        <a:bar class="keybindings_default_bottom" skin="basic">\n            <!--a:divider skin="hordivider" /-->\n            <a href="javascript:void(0);" bottom="16" left="28" onclick="barKeyBindingsMac.hide();barKeyBindingsWin.show()" class="{barKeyBindingsWin.visible ? \'selected\' : \'\'}">Windows</a>\n            <span class="keybindings_default_bottom_divider" bottom="16" left="82" >&#160;|&#160;</span>\n            <a href="javascript:void(0);" bottom="16" left="97" onclick="barKeyBindingsWin.hide();barKeyBindingsMac.show()" class="{barKeyBindingsMac.visible ? \'selected\' : \'\'}">Mac</a> \n            <!--a:button default="3" bottom="10" right="10" skin="btn-default-css3" onclick="winKeyBindings.hide()">Done</a:button-->\n        </a:bar>\n    </a:window>\n</a:application>';});

define('text!ext/keybindings_default/keybindings_default.css',[],function () { return '.keybindings_default .bg-bk-content {\n    background: url(/static/style/images/gitui_menu_backg.png);\n}\n\n/*.keybindings_default_vbox {\n    background: url(/static/style/images/gitui_menu_backg.png);\n}*/\n\n.keybindings_default_bar {\n    background: url(/static/ext/keybindings_default/res/divider.png) repeat-y top left;\n    position: relative;\n    left: 0px;\n    right: 7px;\n    top: 0px;\n    bottom: 25px;\n    height: 400px;\n    padding: 20px 10px 0 24px;\n    overflow: hidden;\n}\n\n.keybindings_default .sbios {\n    height: 408px;\n}\n\n.keybindings_default_block,\n.keybindings_default_block_border {\n    float: left;\n    width: 188px;\n    margin: 0 0 18px 0;\n    padding: 0;\n}\n\n.keybindings_default_block h3,\n.keybindings_default_block_border h3 {\n    color: #fff;\n    size: 14px;\n    font-weight: bold;\n    text-shadow: rgba(0, 0, 0, 1) 0px 2px 2px;\n    margin: 0 0 18px 0;\n    padding: 0;\n}\n\n.keybindings_default_command {\n    margin: 0 0 8px 0;\n    padding: 0;\n    line-height: 25px;\n}\n\n.keybindings_default_cmdname {\n    color: #ffd354;\n    size: 12px;\n    font-weight: bold;\n    text-shadow: rgba(0, 0, 0, 1) 0px 2px 2px;\n    margin: 0 0 4px 0;\n    padding: 0;\n}\n\n.keybindings_default_cmdkey {\n    background-color: #e2e4e7;\n    color: #444444;\n    size: 12px;\n    text-shadow: rgba(255, 255, 255, 1) 0px 1px 0px;\n    border: 1px solid #424242;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    border-radius: 4px;\n    -webkit-box-shadow: 0px 1px 0px #000;\n    -moz-box-shadow: 0px 1px 0px #000;\n    box-shadow: 0px 1px 0px #000;\n    height: 25px;\n    line-height: 25px;\n    text-align: center;\n    vertical-align: middle;\n    margin: 0;\n    padding: 7px 5px 7px 5px;\n}\n\n.keybindings_default_cmdop {\n    color: #fff;\n    font-weight: bold;\n    size: 15px;\n    margin: 0 4px 0 4px;\n}\n\n.keybindings_default_bottom {\n    position: relative;\n    height: 47px;\n    bottom: 0px;\n    left: 0px;\n    right: 0px;\n}\n\n/*.keybindings_default_bottom .btn-default-css3 {\n    margin-top: 8px;\n    float: right;\n}*/\n\n.keybindings_default_bottom a {\n    color: #fff;\n    text-decoration: none;\n}\n\n.keybindings_default_bottom a:hover {\n    text-decoration: underline;\n}\n\n.keybindings_default_bottom a.selected {\n    color: #ffd354;\n}\n\n.keybindings_default_bottom_divider {\n    color: #fff;\n}';});

define('text!ext/keybindings_default/default_mac.js',[],function () { return '/**\n * @copyright 2010, Ajax.org B.V.\n * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>\n */\ndefine(function(require, exports, module) {\n\nvar keys = require("ext/keybindings/keybindings");\n\nreturn keys.onLoad({\n    "ext" : {\n        "console" : {\n            "switchconsole": "Shift-Esc"\n        },\n        "save" : {\n            "quicksave": "Command-S",\n            "saveas": "Command-Shift-S",\n\t    "reverttosaved": "Command-Shift-Q"\n        },\n        "undo" : {\n            "undo": "Command-Z",\n            "redo": "Command-Shift-Z"\n        },\n        "clipboard" : {\n            "cut": "Shift-Command-X",\n            "copy": "Command-C",\n            "paste": "Command-V"\n        },\n        "quickwatch": {\n            "quickwatch": "Option-Q"\n        },\n        "runpanel": {\n            "run" : "F5",\n            "stop" : "Shift-F5"\n        },\n        "debugger": {\n            "resume": "F8",\n            "stepinto": "F11",\n            "stepover": "F10",\n            "stepout": "Shift-F11"\n        },\n        "zen": {\n            "zen": "Command-E",\n            "zenslow": "Command-Shift-E"\n        },\n        "gotoline": {\n           "gotoline": "Command-L"\n        },\n        "beautify": {\n            "beautify": "Command-Shift-B"\n        },\n        "gotofile": {\n            "gotofile": "Alt-Shift-R"\n        },\n        "newresource": {\n            "newfile": "Option-Shift-N",\n            "newfiletemplate": "Option-Ctrl-N",\n            "newfolder": "Option-Ctrl-Shift-N"\n        },\n        "quicksearch": {\n            "find": "Command-F",\n            "findnext": "Command-G",\n            "findprevious": "Command-Shift-G"\n        },\n        "searchreplace" : {\n            "search": "Command-Shift-F",\n            "searchreplace": "Command-Shift-R"\n        },\n        "searchinfiles" : {\n            "searchinfiles": "Alt-Shift-F"\n        },\n        "formatjson" : {\n            "format" : "Command-Shift-J"\n        },\n        "settings": {\n            "showsettings": "Command-,"\n        },\n        "tabbehaviors" : {\n            "closetab": "Option-W",\n            "closealltabs": "Option-Shift-W",\n            "closeallbutme": "Command-Option-W",\n            "gototabright": "Command-]",\n            "gototableft": "Command-[",\n            "tab1": "Command-1",\n            "tab2": "Command-2",\n            "tab3": "Command-3",\n            "tab4": "Command-4",\n            "tab5": "Command-5",\n            "tab6": "Command-6",\n            "tab7": "Command-7",\n            "tab8": "Command-8",\n            "tab9": "Command-9",\n            "revealtab": "Command-Shift-L",\n            "nexttab": "Command-Tab|Option-Tab",\n            "previoustab": "Command-Shift-Tab|Option-Shift-Tab"\n        },\n        "tabsessions" : {\n            "savetabsession": "Command-Alt-S"\n        },\n        "splitview" : {\n            "mergetableft": "Command-Option-[",\n            "mergetabright": "Command-Option-]"\n        },\n        "code" : {\n            "selectall": "Command-A",\n            "removeline": "Command-D",\n            "togglecomment": "Command-/",\n            "findnext": "Command-G",\n            "findprevious": "Command-Shift-G",\n            "find": "Command-F",\n            "replace": "Command-Shift-R",\n            "undo": "Command-Z",\n            "redo": "Command-Shift-Z|Command-Y",\n            "overwrite": "Insert",\n            "copylinesup": "Command-Option-Up",\n            "movelinesup": "Option-Up",\n            "selecttostart": "Command-Shift-Up",\n            "gotostart": "Command-Home|Command-Up",\n            "selectup": "Shift-Up",\n            "golineup": "Up",\n            "copylinesdown": "Command-Option-Down",\n            "movelinesdown": "Option-Down",\n            "selecttoend": "Command-Shift-Down",\n            "gotoend": "Command-End|Command-Down",\n            "selectdown": "Shift-Down",\n            "golinedown": "Down",\n            "selectwordleft": "Option-Shift-Left",\n            "gotowordleft": "Option-Left",\n            "selecttolinestart": "Command-Shift-Left",\n            "gotolinestart": "Command-Left|Home",\n            "selectleft": "Shift-Left",\n            "gotoleft": "Left",\n            "selectwordright": "Option-Shift-Right",\n            "gotowordright": "Option-Right",\n            "selecttolineend": "Command-Shift-Right",\n            "gotolineend": "Command-Right|End",\n            "selectright": "Shift-Right",\n            "gotoright": "Right",\n            "gotopagedown": "Command-PageDown",\n            "selectpagedown": "Shift-PageDown",\n            "pagedown": "PageDown",\n            "gotopageup": "Command-PageUp",\n            "selectpageup": "Shift-PageUp",\n            "pageup": "PageUp",\n            "selectlinestart": "Shift-Home",\n            "selectlineend": "Shift-End",\n            "del": "Delete",\n            "backspace": "Command-Backspace|Option-Backspace|Backspace",\n            "outdent": "Shift-Tab",\n            "indent": "Tab"\n        },\n        "language": {\n            "complete": "Ctrl-Space|Alt-Space",\n            "renameVar": "Command-Option-R"\n        }\n    }\n});\n\n});\n';});

define('text!ext/keybindings_default/default_win.js',[],function () { return '/**\n * @copyright 2010, Ajax.org B.V.\n * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>\n */\n\ndefine(function(require, exports, module) {\n\nvar keys = require("ext/keybindings/keybindings");\n\nreturn keys.onLoad({\n    "ext" : {\n        "console" : {\n            "switchconsole": "Shift-Esc"\n        },\n        "save" : {\n            "quicksave": "Ctrl-S",\n            "saveas": "Ctrl-Shift-S",\n            "reverttosaved": "Ctrl-Shift-Q"\n        },\n        "undo" : {\n            "undo": "Ctrl-Z",\n            "redo": "Ctrl-Y"\n        },\n        "clipboard" : {\n            "cut": "Ctrl-X",\n            "copy": "Ctrl-C",\n            "paste": "Ctrl-V"\n        },\n        "quickwatch": {\n            "quickwatch": "Ctrl-Q"\n        },\n        "runpanel": {\n            "run" : "Ctrl-F5",\n            "stop" : "Shift-F5"\n        },\n        "debugger": {\n            "resume": "F8",\n            "stepinto": "F11",\n            "stepover": "F10",\n            "stepout": "Shift-F11"\n        },\n        "zen": {\n            "zen": "Ctrl-E",\n            "zenslow": "Ctrl-Shift-E"\n        },\n        "gotoline": {\n            "gotoline": "Ctrl-G"\n        },\n        "beautify": {\n            "beautify": "Ctrl-Shift-B"\n        },\n        "gotofile": {\n            "gotofile": "Alt-Shift-R"\n        },\n        "newresource": {\n            "newfile": "Ctrl-N",\n            "newfiletemplate": "Ctrl-Shift-N",\n            "newfolder": "Ctrl-Alt-N"\n        },\n        "quicksearch": {\n            "find": "Ctrl-F",\n            "findnext": "Ctrl-K",\n            "findprevious": "Ctrl-Shift-K"\n        },\n        "searchreplace" : {\n            "search": "Ctrl-Shift-F",\n            "searchreplace": "Ctrl-Shift-R"\n        },\n        "searchinfiles" : {\n            "searchinfiles": "Alt-Shift-F"\n        },\n        "formatjson" : {\n            "format" : "Ctrl-Shift-J"\n        },\n        "settings": {\n            "showsettings": "Ctrl-,"\n        },\n        "tabbehaviors" : {\n            "closetab": "Ctrl-W",\n            "closealltabs": "Ctrl-Shift-W",\n            "closeallbutme": "Ctrl-Alt-W",\n            "gototabright": "Ctrl-]",\n            "gototableft": "Ctrl-[",\n            "tab1": "Ctrl-1",\n            "tab2": "Ctrl-2",\n            "tab3": "Ctrl-3",\n            "tab4": "Ctrl-4",\n            "tab5": "Ctrl-5",\n            "tab6": "Ctrl-6",\n            "tab7": "Ctrl-7",\n            "tab8": "Ctrl-8",\n            "tab9": "Ctrl-9",\n            "revealtab": "Ctrl-Shift-L",\n            "nexttab": "Ctrl-Tab",\n            "previoustab": "Ctrl-Shift-Tab"\n        },\n        "tabsessions" : {\n            "savetabsession": "Ctrl-Alt-S"\n        },\n        "splitview" : {\n            "mergetableft": "Ctrl-Alt-[",\n            "mergetabright": "Ctrl-Alt-]"\n        },\n        "code" : {\n            "selectall": "Ctrl-A",\n            "removeline": "Ctrl-D",\n            "gotoline": "Ctrl-G",\n            "togglecomment": "Ctrl-7",\n            "findnext": "F3",\n            "findprevious": "Shift-F3",\n            "find": "Ctrl-F",\n            "replace": "Ctrl-Shift-R",\n            "undo": "Ctrl-Z",\n            "redo": "Ctrl-Shift-Z|Ctrl-Y",\n            "overwrite": "Insert",\n            "copylinesup": "Ctrl-Alt-Up",\n            "movelinesup": "Ctrl-Up",\n            "selecttostart": "Ctrl-Shift-Up",\n            "gotostart": "Ctrl-Home",\n            "selectup": "Shift-Up",\n            "golineup": "Up",\n            "copylinesdown": "Ctrl-Alt-Down",\n            "movelinesdown": "Ctrl-Down",\n            "selecttoend": "Ctrl-Shift-Down",\n            "gotoend": "Ctrl-End",\n            "selectdown": "Shift-Down",\n            "golinedown": "Down",\n            "selectwordleft": "Ctrl-Shift-Left",\n            "gotowordleft": "Ctrl-Left",\n            "selecttolinestart": "Alt-Shift-Left",\n            "gotolinestart": "Alt-Left|Home",\n            "selectleft": "Shift-Left",\n            "gotoleft": "Left",\n            "selectwordright": "Ctrl-Shift-Right",\n            "gotowordright": "Ctrl-Right",\n            "selecttolineend": "Alt-Shift-Right",\n            "gotolineend": "Alt-Right|End",\n            "selectright": "Shift-Right",\n            "gotoright": "Right",\n            "selectpagedown": "Shift-PageDown",\n            "pagedown": "PageDown",\n            "selectpageup": "Shift-PageUp",\n            "pageup": "PageUp",\n            "selectlinestart": "Shift-Home",\n            "selectlineend": "Shift-End",\n            "del": "Delete",\n            "backspace": "Backspace",\n            "outdent": "Shift-Tab",\n            "indent": "Tab"\n        },\n        "language": {\n            "complete": "Ctrl-Space|Alt-Space",\n            "renameVar": "Ctrl-Alt-R"\n        }\n    }\n});\n\n});\n';});

define('ext/beautify/res/jsbeautify/jsbeautify-min',['require','exports','module'],function(a,b,c){b.js_beautify=function(a,b){function T(){x=0;if(p>=G)return["","TK_EOF"];v=!1;var a=c.charAt(p);p+=1;var b=F&&P(j.mode);if(b){var e=0;while(S(a,m)){a==="\n"?(H(),d.push("\n"),w=!0,e=0):a==="\t"?e+=4:a!=="\r"&&(e+=1);if(p>=G)return["","TK_EOF"];a=c.charAt(p),p+=1}j.indentation_baseline===-1&&(j.indentation_baseline=e);if(w){var h;for(h=0;h<j.indentation_level+1;h+=1)d.push(l);if(j.indentation_baseline!==-1)for(h=0;h<e-j.indentation_baseline;h++)d.push(" ")}}else{while(S(a,m)){a==="\n"&&(x+=C?x<=C?1:0:1);if(p>=G)return["","TK_EOF"];a=c.charAt(p),p+=1}if(B&&x>1)for(h=0;h<x;h+=1)J(h===0),w=!0;v=x>0}if(S(a,n)){if(p<G)while(S(c.charAt(p),n)){a+=c.charAt(p),p+=1;if(p===G)break}if(p!==G&&a.match(/^[0-9]+[Ee]$/)&&(c.charAt(p)==="-"||c.charAt(p)==="+")){var i=c.charAt(p);p+=1;var k=T(p);a+=i+k[0];return[a,"TK_WORD"]}if(a==="in")return[a,"TK_OPERATOR"];v&&f!=="TK_OPERATOR"&&f!=="TK_EQUALS"&&!j.if_line&&(B||g!=="var")&&J();return[a,"TK_WORD"]}if(a==="("||a==="[")return[a,"TK_START_EXPR"];if(a===")"||a==="]")return[a,"TK_END_EXPR"];if(a==="{")return[a,"TK_START_BLOCK"];if(a==="}")return[a,"TK_END_BLOCK"];if(a===";")return[a,"TK_SEMICOLON"];if(a==="/"){var q="",s=!0;if(c.charAt(p)==="*"){p+=1;if(p<G)while((c.charAt(p)!=="*"||!c.charAt(p+1)||c.charAt(p+1)!=="/")&&p<G){a=c.charAt(p),q+=a;if(a==="\r"||a==="\n")s=!1;p+=1;if(p>=G)break}p+=2;return s?["/*"+q+"*/","TK_INLINE_COMMENT"]:["/*"+q+"*/","TK_BLOCK_COMMENT"]}if(c.charAt(p)==="/"){q=a;while(c.charAt(p)!=="\r"&&c.charAt(p)!=="\n"){q+=c.charAt(p),p+=1;if(p>=G)break}p+=1,v&&J();return[q,"TK_COMMENT"]}}if(a==="'"||a==='"'||a==="/"&&(f==="TK_WORD"&&S(g,["return","do"])||f==="TK_COMMENT"||f==="TK_START_EXPR"||f==="TK_START_BLOCK"||f==="TK_END_BLOCK"||f==="TK_OPERATOR"||f==="TK_EQUALS"||f==="TK_EOF"||f==="TK_SEMICOLON")){var t=a,u=!1,y=a;if(p<G)if(t==="/"){var z=!1;while(u||z||c.charAt(p)!==t){y+=c.charAt(p),u?u=!1:(u=c.charAt(p)==="\\",c.charAt(p)==="["?z=!0:c.charAt(p)==="]"&&(z=!1)),p+=1;if(p>=G)return[y,"TK_STRING"]}}else while(u||c.charAt(p)!==t){y+=c.charAt(p),u?u=!1:u=c.charAt(p)==="\\",p+=1;if(p>=G)return[y,"TK_STRING"]}p+=1,y+=t;if(t==="/")while(p<G&&S(c.charAt(p),n))y+=c.charAt(p),p+=1;return[y,"TK_STRING"]}if(a==="#"){if(d.length===0&&c.charAt(p)==="!"){y=a;while(p<G&&a!="\n")a=c.charAt(p),y+=a,p+=1;d.push(I(y)+"\n"),J();return T()}var A="#";if(p<G&&S(c.charAt(p),r)){do a=c.charAt(p),A+=a,p+=1;while(p<G&&a!=="#"&&a!=="=");a!=="#"&&(c.charAt(p)==="["&&c.charAt(p+1)==="]"?(A+="[]",p+=2):c.charAt(p)==="{"&&c.charAt(p+1)==="}"&&(A+="{}",p+=2));return[A,"TK_WORD"]}}if(a==="<"&&c.substring(p-1,p+3)==="<!--"){p+=3,j.in_html_comment=!0;return["<!--","TK_COMMENT"]}if(a==="-"&&j.in_html_comment&&c.substring(p-1,p+2)==="-->"){j.in_html_comment=!1,p+=2,v&&J();return["-->","TK_COMMENT"]}if(S(a,o)){while(p<G&&S(a+c.charAt(p),o)){a+=c.charAt(p),p+=1;if(p>=G)break}return a==="="?[a,"TK_EQUALS"]:[a,"TK_OPERATOR"]}return[a,"TK_UNKNOWN"]}function S(a,b){for(var c=0;c<b.length;c+=1)if(b[c]===a)return!0;return!1}function R(){u=j.mode==="DO_BLOCK",k.length>0&&(j=k.pop())}function Q(a){return a==="[EXPRESSION]"||a==="[INDENTED-EXPRESSION]"||a==="(EXPRESSION)"}function P(a){return a==="[EXPRESSION]"||a==="[INDENTED-EXPRESSION]"}function O(a){j&&k.push(j),j={previous_mode:j?j.mode:"BLOCK",mode:a,var_line:!1,var_line_tainted:!1,var_line_reindented:!1,in_html_comment:!1,if_line:!1,in_case:!1,eat_next_space:!1,indentation_baseline:-1,indentation_level:j?j.indentation_level+(j.var_line&&j.var_line_reindented?1:0):D,ternary_depth:0}}function N(){d.length&&d[d.length-1]===l&&d.pop()}function M(){j.indentation_level+=1}function L(){w=!1,j.eat_next_space=!1,d.push(e)}function K(){if(j.eat_next_space)j.eat_next_space=!1;else{var a=" ";d.length&&(a=d[d.length-1]),a!==" "&&a!=="\n"&&a!==l&&d.push(" ")}}function J(a){j.eat_next_space=!1;if(!F||!P(j.mode)){a=typeof a=="undefined"?!0:a,j.if_line=!1,H();if(!d.length)return;if(d[d.length-1]!=="\n"||!a)w=!0,d.push("\n");for(var b=0;b<j.indentation_level;b+=1)d.push(l);j.var_line&&j.var_line_reindented&&(A===" "?d.push("    "):d.push(l))}}function I(a){return a.replace(/^\s\s*|\s\s*$/,"")}function H(a){a=typeof a=="undefined"?!1:a;while(d.length&&(d[d.length-1]===" "||d[d.length-1]===l||a&&(d[d.length-1]==="\n"||d[d.length-1]==="\r")))d.pop()}var c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x;b=b?b:{};var y;b.space_after_anon_function!==undefined&&b.jslint_happy===undefined&&(b.jslint_happy=b.space_after_anon_function),b.braces_on_own_line!==undefined&&(y=b.braces_on_own_line?"expand":"collapse"),y=b.brace_style?b.brace_style:y?y:"collapse";var z=b.indent_size?b.indent_size:4,A=b.indent_char?b.indent_char:" ",B=typeof b.preserve_newlines=="undefined"?!0:b.preserve_newlines,C=typeof b.max_preserve_newlines=="undefined"?!1:b.max_preserve_newlines,D=b.indent_level?b.indent_level:0,E=b.jslint_happy==="undefined"?!1:b.jslint_happy,F=typeof b.keep_array_indentation=="undefined"?!1:b.keep_array_indentation;w=!1;var G=a.length;l="";while(z>0)l+=A,z-=1;c=a,i="",f="TK_START_EXPR",g="",h="",d=[],u=!1,m="\n\r\t ".split(""),n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$".split(""),r="0123456789".split(""),o="+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! !! , : ? ^ ^= |= ::".split(" "),q="continue,try,throw,return,var,if,switch,case,default,for,while,break,function".split(","),k=[],O("BLOCK"),p=0;for(;;){var U=T(p);e=U[0],t=U[1];if(t==="TK_EOF")break;switch(t){case"TK_START_EXPR":if(e==="["){if(f==="TK_WORD"||g===")"){S(g,q)&&K(),O("(EXPRESSION)"),L();break}j.mode==="[EXPRESSION]"||j.mode==="[INDENTED-EXPRESSION]"?h==="]"&&g===","?(j.mode==="[EXPRESSION]"&&(j.mode="[INDENTED-EXPRESSION]",F||M()),O("[EXPRESSION]"),F||J()):g==="["?(j.mode==="[EXPRESSION]"&&(j.mode="[INDENTED-EXPRESSION]",F||M()),O("[EXPRESSION]"),F||J()):O("[EXPRESSION]"):O("[EXPRESSION]")}else O("(EXPRESSION)");g===";"||f==="TK_START_BLOCK"?J():f!=="TK_END_EXPR"&&f!=="TK_START_EXPR"&&f!=="TK_END_BLOCK"&&g!=="."&&(f!=="TK_WORD"&&f!=="TK_OPERATOR"?K():i==="function"||i==="typeof"?E&&K():(S(g,q)||g==="catch")&&K()),L();break;case"TK_END_EXPR":if(e==="]")if(F){if(g==="}"){N(),L(),R();break}}else if(j.mode==="[INDENTED-EXPRESSION]"&&g==="]"){R(),J(),L();break}R(),L();break;case"TK_START_BLOCK":i==="do"?O("DO_BLOCK"):O("BLOCK"),y=="expand"?(f!=="TK_OPERATOR"&&(g==="return"||g==="="?K():J(!0)),L(),M()):(f!=="TK_OPERATOR"&&f!=="TK_START_EXPR"?f==="TK_START_BLOCK"?J():K():P(j.previous_mode)&&g===","&&(h==="}"?K():J()),M(),L());break;case"TK_END_BLOCK":R(),y=="expand"?(g!=="{"&&J(),L()):(f==="TK_START_BLOCK"?w?N():H():P(j.mode)&&F?(F=!1,J(),F=!0):J(),L());break;case"TK_WORD":if(u){K(),L(),K(),u=!1;break}if(e==="function"){j.var_line&&(j.var_line_reindented=!0);if((w||g===";")&&g!=="{"){x=w?x:0,B||(x=1);for(var V=0;V<2-x;V++)J(!1)}}if(e==="case"||e==="default"){g===":"?N():(j.indentation_level--,J(),j.indentation_level++),L(),j.in_case=!0;break}s="NONE",f==="TK_END_BLOCK"?S(e.toLowerCase(),["else","catch","finally"])?y=="expand"||y=="end-expand"?s="NEWLINE":(s="SPACE",K()):s="NEWLINE":f!=="TK_SEMICOLON"||j.mode!=="BLOCK"&&j.mode!=="DO_BLOCK"?f==="TK_SEMICOLON"&&Q(j.mode)?s="SPACE":f==="TK_STRING"?s="NEWLINE":f==="TK_WORD"?(g==="else"&&H(!0),s="SPACE"):f==="TK_START_BLOCK"?s="NEWLINE":f==="TK_END_EXPR"&&(K(),s="NEWLINE"):s="NEWLINE",S(e,q)&&g!==")"&&(g=="else"?s="SPACE":s="NEWLINE"),j.if_line&&f==="TK_END_EXPR"&&(j.if_line=!1);if(S(e.toLowerCase(),["else","catch","finally"]))f!=="TK_END_BLOCK"||y=="expand"||y=="end-expand"?J():(H(!0),K());else if(s==="NEWLINE"){if(f!=="TK_START_EXPR"&&g!=="="&&g!==","||e!=="function")e==="function"&&g=="new"?K():g==="return"||g==="throw"?K():f!=="TK_END_EXPR"?(f!=="TK_START_EXPR"||e!=="var")&&g!==":"&&(e==="if"&&i==="else"&&g!=="{"?K():(j.var_line=!1,j.var_line_reindented=!1,J())):S(e,q)&&g!=")"&&(j.var_line=!1,j.var_line_reindented=!1,J())}else P(j.mode)&&g===","&&h==="}"?J():s==="SPACE"&&K();L(),i=e,e==="var"&&(j.var_line=!0,j.var_line_reindented=!1,j.var_line_tainted=!1),e==="if"&&(j.if_line=!0),e==="else"&&(j.if_line=!1);break;case"TK_SEMICOLON":L(),j.var_line=!1,j.var_line_reindented=!1,j.mode=="OBJECT"&&(j.mode="BLOCK");break;case"TK_STRING":f==="TK_START_BLOCK"||f==="TK_END_BLOCK"||f==="TK_SEMICOLON"?J():f==="TK_WORD"&&K(),L();break;case"TK_EQUALS":j.var_line&&(j.var_line_tainted=!0),K(),L(),K();break;case"TK_OPERATOR":var W=!0,X=!0;j.var_line&&e===","&&Q(j.mode)&&(j.var_line_tainted=!1);if(j.var_line&&e===","){if(j.var_line_tainted){L(),j.var_line_reindented=!0,j.var_line_tainted=!1,J();break}j.var_line_tainted=!1}if(g==="return"||g==="throw"){K(),L();break}if(e===":"&&j.in_case){L(),J(),j.in_case=!1;break}if(e==="::"){L();break}if(e===","){j.var_line?j.var_line_tainted?(L(),J(),j.var_line_tainted=!1):(L(),K()):f==="TK_END_BLOCK"&&j.mode!=="(EXPRESSION)"?(L(),j.mode==="OBJECT"&&g==="}"?J():K()):j.mode==="OBJECT"?(L(),J()):(L(),K());break}S(e,["--","++","!"])||S(e,["-","+"])&&(S(f,["TK_START_BLOCK","TK_START_EXPR","TK_EQUALS","TK_OPERATOR"])||S(g,q))?(W=!1,X=!1,g===";"&&Q(j.mode)&&(W=!0),f==="TK_WORD"&&S(g,q)&&(W=!0),j.mode==="BLOCK"&&(g==="{"||g===";")&&J()):e==="."?W=!1:e===":"?j.ternary_depth==0?(j.mode="OBJECT",W=!1):j.ternary_depth-=1:e==="?"&&(j.ternary_depth+=1),W&&K(),L(),X&&K(),e!=="!";break;case"TK_BLOCK_COMMENT":var Y=e.split(/\x0a|\x0d\x0a/);if(/^\/\*\*/.test(e)){J(),d.push(Y[0]);for(V=1;V<Y.length;V++)J(),d.push(" "),d.push(I(Y[V]))}else{Y.length>1?(J(),H()):K();for(V=0;V<Y.length;V++)d.push(Y[V]),d.push("\n")}J();break;case"TK_INLINE_COMMENT":K(),L(),Q(j.mode)?K():J();break;case"TK_COMMENT":v?J():K(),L(),J();break;case"TK_UNKNOWN":(g==="return"||g==="throw")&&K(),L()}h=g,f=t,g=e}return d.join("").replace(/[\n ]+$/,"")}});
define('text!ext/beautify/settings.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:checkbox class="underlined" label="Preserve Empty Lines"\n        checked="{[beautify/jsbeautify/@preserveempty] != \'\' ? [beautify/jsbeautify/@preserveempty] : \'true\'}"\n        value="[beautify/jsbeautify/@preserveempty]" skin="checkbox_grey" />\n    <a:checkbox class="underlined" label="Keep Array Indentation"\n        checked="{[beautify/jsbeautify/@keeparrayindentation] != \'\' ? [beautify/jsbeautify/@keeparrayindentation] : \'true\'}"\n        value="[beautify/jsbeautify/@keeparrayindentation]" skin="checkbox_grey" />\n    <a:checkbox class="underlined" label="JSLint Strict Whitespace"\n        checked="{[beautify/jsbeautify/@jslinthappy] != \'\' ? [beautify/jsbeautify/@jslinthappy] : \'false\'}"\n        value="[beautify/jsbeautify/@jslinthappy]" skin="checkbox_grey" />\n    <a:hbox edge="5 5 2 5" align="center">\n        <a:label flex="1">Braces</a:label>\n        <a:dropdown default="end-expand" value="[{require(\'ext/settings/settings\').model}::beautify/jsbeautify/@braces]" width="185" height="21">\n            <a:item value="collapse">Braces with control statement</a:item>\n            <a:item value="expand">Braces on own line</a:item>\n            <a:item value="end-expand">End braces on own line</a:item>\n        </a:dropdown>\n    </a:hbox>\n</a:application>\n';});

/**
 * General Purpose Offline Syncing Library
 *
 * @event losechanges   Fires before the offline state is removed.
 *   cancelable: Prevents the application from losing it's recorded offline state.
 * @event beforeoffline Fires before bringing the application offline.
 *   cancelable: Prevents the application from going offline
 * @event afteroffline  Firest after the application is brought offline.
 * @event beforeonline  Fires before bringing the application online.
 *   cancelable: Prevents the application from going online
 * @event afteronline   Fires after the application is brought online.
 * @event beforeload    Fires before loading the offline state into this application.
 *   cancelable: Prevents the application from reloading it's offline state.
 * @event sync          Fires at each sync item's completion.
 *   object:
 *   {Number} position the number of the item in the list that is currently processed.
 *   {Number} length   the total number of items in the list.
 *
 * @property {Number}  progress  the progress of the sync. A number between 0 and 1.
 * @property {Number}  position  the progress of the sync. 
 * @property {Number}  length    the total length of items to sync.
 * @property {Boolean} syncing   whether the application is syncing while coming online.
 * @property {Boolean} onLine    whether the application is online. This property is false during sync.
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
define('ext/offline/lib-offline',['require','exports','module'],function(require, exports, module) {

var Offline = module.exports = function(namespace, detectUrl){
    /**
     * whether the application is online.
     * @type {Boolean}
     */
    this.onLine    = -1;
    this.detectUrl = detectUrl;
    this.interval  = 5000;
    this.namespace = namespace;
    
    //navigator.onLine
    var cache = window.applicationCache;
    
    //@todo this is non-ie for now
    
    cache.addEventListener("offline", function(e){
        //console.log(e.type);
    }, false);
    
    cache.addEventListener("online", function(e){
        //console.log(e.type);
    }, false);
    
    cache.addEventListener("checking", function(e){
        //console.log(e.type);
    }, false);
    
    cache.addEventListener("downloading", function(e){
        //console.log(e.type);
    }, false);
    
    cache.addEventListener("progress", function(e){
        //console.log(e.type);
    }, false);
    
    cache.addEventListener("cached", function(e){
        //console.log(e.type);
    }, false);
    
    cache.addEventListener("noupdate", function(e){
        //console.log(e.type);
    }, false);
    
    cache.addEventListener("updateready", function(e){
        //console.log(e.type);
        cache.swapCache();
    }, false);
    
    cache.addEventListener("error", function(e){
        //console.log(e.type);
    }, false);
};

(function(){
    
    this.start = function(){
        // TODO: turned off because at this point the IDE is not up yet and
        // will result in JS errors
        this.offlineTime = parseInt(localStorage[this.namespace + ".offlinetime"] || 0, 10);

        //If we were offline lets stay offline
        if (this.offlineTime)
            this.goOffline();
        //I beleve these should be commented out for detection to pick up on the online state
        //else //Else we try to go online
            //this.goOnline();
        
        this.startDetect();
    }
    
    /**** Offline Detection ****/
    
    this.isSiteAvailable = function(callback){
        var _self = this;
        
        if (!this.http) {
            this.http = new apf.http();
            this.http.timeout = this.interval;
        }
        
        this.http.get(apf.getNoCacheUrl(this.detectUrl), {
            callback: function(data, state, extra){
                if (state != apf.SUCCESS){ // || !window.navigator.onLine
                    _self.goOffline(callback); //retry here??
                }
                else {
                    _self.goOnline(callback);
                }
            },
            ignoreOffline  : true,
            hideLogMessage : true
        });
    };
    
    this.startDetect = function(){
        if (this.detectErrorHandler) //Detection already started
            return;
        
        var _self = this;
        
        apf.addEventListener("error", this.detectErrorHandler = function(e){
            //Timeout detected.. Network is probably gone
            if (e.state == apf.TIMEOUT) {
                //Let's try to go offline and return false to cancel the error
                return !_self.goOffline();//callback //@todo callback???
            }
        });
        
        //Check if we have connection right now
        this.isSiteAvailable();
        
        //#ifdef __DEBUG
        apf.console.info("Started automatic detection of network state");
        //#endif
        
        this.detectTimer = setInterval(function(){
            _self.isSiteAvailable();
        }, this.interval);
    }
    
    this.stopDetect = function(){
        clearInterval(this.detectTimer);
        apf.removeEventListener("error", this.detectErrorHandler);
        
        //#ifdef __DEBUG
        apf.console.info("Stopped automatic detection of network state");
        //#endif
    }
    
    /**** Offline State Management ****/

    /**
     * Brings the application offline.
     */
    this.goOffline = function(){
        if (this.onLine === false)
            return false;

        if (this.dispatchEvent("beforeoffline") === false)
            return false;

        //We're offline, let's dim the light
        this.onLine    = false;

        if (!this.offlineTime) {
            this.offlineTime = new Date().getTime();
            // this can yield errors ('cause it's DOM):
            // [Exception... "Failure"  nsresult: "0x80004005 (NS_ERROR_FAILURE)"
            try {
                localStorage[this.namespace + ".offlinetime"] = this.offlineTime;
            }
            catch(ex) {}
        }

        this.dispatchEvent("afteroffline");

        return true;//success
    }

    /**
     * Brings the application online.
     */
    this.goOnline = function(){
        if (this.onLine === true)
            return false;

        if (this.dispatchEvent("beforeonline") === false)
            return false;

        //We're online, let's show the beacon
        this.onlineTime  = new Date().getTime();
        this.onLine      = true; //@todo Think about doing this in the callback, because of processes that will now intersect
        this.offlineTime = null;
        
        // this can yield errors ('cause it's DOM):
        // [Exception... "Failure"  nsresult: "0x80004005 (NS_ERROR_FAILURE)"
        try {
            delete localStorage[this.namespace + ".offlinetime"];
        }
        catch(ex) {}
        
        this.dispatchEvent("afteronline");

        return true;//success
    }
}).call(Offline.prototype = new apf.Class().$init());

});
/**
 * Offline Support for Cloud9
 *
 * @copyright 2011, Ajax.org B.V.
 */

define('ext/offline/lib-sync',['require','exports','module'],function(require, exports, module) {

var Sync = module.exports = function(namespace){
    this.namespace = namespace;
    
    this.items = localStorage[this.namespace + ".syncitems"]
        ? apf.unserialize(localStorage[this.namespace + ".syncitems"])
        : {length: 100};
    
};

(function(){
    this.getLength = function(){
        return this.items && this.items.length || 0;
    }
    
    /**
     * Clears all offline data.
     */
    this.clear = function(){
        if (!this.enabled)
            return false;
    
        //#ifdef __DEBUG
        apf.console.info("Clearing all offline and state cache");
        //#endif
    
         this.items = {length: 0};
         localStorage[this.namespace + ".syncitems"] = apf.serialize(this.items);
    }
    
    this.add = function(id, syncItem){
        this.items[id] = syncItem;
        this.items.length++;
        
        localStorage[this.namespace + ".syncitems"] = apf.serialize(this.items);
        
        //@todo error handling
    }
    
    /**
     * Does cleanup after we've come online
     * @private
     */
     this.start = function(handler){
        if (this.syncing)
            return;
        
        var syncItems  = apf.extend({}, this.items),
            syncLength = this.items.length,
            len, i;
    
        var _self = this;
        var next = function(error, start){
            if (!_self.syncing)
                return false;

            if (!start) {
                syncItems.length--;
                localStorage[_self.namespace + ".syncitems"] = apf.serialize(syncItems); //Save state up to now
            }
            
            if (syncItems.length < 1) {
                _self.items = {length: 0};
                localStorage[_self.namespace + ".syncitems"] = apf.serialize(_self.items);
                
                return -1;
            }
    
            var item;
            for (var id in syncItems) {
                if (id == "length") 
                    continue;
                    
                item = syncItems[id];
                delete syncItems[id];
                break;
            }
            if (item === undefined)
                return -1;
            
            handler({
                item     : item,
                progress : parseInt((syncLength - syncItems.length) / syncLength * 100, 10),
                position : (syncLength - syncItems.length),
                length   : syncLength
            }, next);
            
            return 1;
        }
    
        this.syncing = true;
        next(null, true);
    };
    
    this.stop = function(){
        if (this.syncing)
            this.syncing = false;
    };
}).call(Sync.prototype);

});
define('ext/offline/lib-offlinefs',['require','exports','module'],function(require, exports, module) {

/**
 * @package webfs
 * @copyright  Copyright(c) 2011 Ajax.org B.V. <info AT ajax.org>
 * @author Tane Piper <tane AT ajax DOT org>
 * @license http://github.com/ajaxorg/webfs/blob/master/LICENSE MIT License
 */

/**
 * We need to ensure that we have the correct version of requestFileSystem and
 * BlobBuilder available to the script
 */
window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder;


/**
 * @class WebFS object
 * @description Can take a pre-existing native local filesystem as a
 *              parameter.  If not parameter passed, filesystem can be set with
 *              setFileSystem 
 */
var WebFS = module.exports = (function() {
    
    /**
     * @constructor
     * @description Can take a pre-existing native local filesystem as a
     *              parameter.  If not parameter passed, filesystem can be set with
     *              setFileSystem
     * @param   {DOMFileSystem}     fs
     * @type    {void}
     */
    function WebFS(fs) {
        this.fs = fs;
        if (fs)
            this.root = fs.root;
    }
    
    // Filesystem system types flags
    WebFS.prototype.TEMPORARY                   = 0;
    WebFS.prototype.PERSISTENT                  = 1;
    // Filesystem progress flags
    WebFS.prototype.EMPTY                       = 0;
    WebFS.prototype.LOADING                     = 1;
    WebFS.prototype.DONE                        = 2;
    // Filesystem error flags
    WebFS.prototype.NOT_FOUND_ERR               = 1;
    WebFS.prototype.SECURITY_ERR                = 2;
    WebFS.prototype.ABORT_ERR                   = 3;
    WebFS.prototype.NOT_READABLE_ERR            = 4;
    WebFS.prototype.ENCODING_ERR                = 5;
    WebFS.prototype.NO_MODIFICATION_ALLOWED_ERR = 6;
    WebFS.prototype.INVALID_STATE_ERR           = 7;
    WebFS.prototype.SYNTAX_ERR                  = 8;
    WebFS.prototype.INVALID_MODIFICATION_ERR    = 9;
    WebFS.prototype.QUOTA_EXCEEDED_ERR          = 10;
    WebFS.prototype.TYPE_MISMATCH_ERR           = 11;
    WebFS.prototype.PATH_EXISTS_ERR             = 12;
    
    WebFS.prototype.DIR_SEPARATOR = '/';
    WebFS.prototype.DIR_BLACKLIST = ['.', './', '..', '../', '/'];
    WebFS.prototype.TYPE_FILE = 'file';
    WebFS.prototype.TYPE_DIR = 'dir';
    
    
    /**
     * Creates a stats object
     * @private
     * @param   {FileEntry, DirectoryEntry}   entry
     * @param   {Function}                    callback
     * @type    {void}
     */
    var Stats = function(entry, callback) {
        var _self = {};
        
        if (entry.isFile) {
            
            entry.file(function(file) {
                
                var t = file.lastModifiedDate;
                var m = t.getMonth() + 1;
                var month = m < 10 ? "0" + m : m;
            
                var time = [t.getFullYear(), month, t.getDate()].join('-') + 'T' + [t.getHours(), t.getMinutes(), t.getSeconds()].join(':') + 'Z';
            
                _self.mtime = time;
                _self.atime = time;
                _self.ctime = time;
                
                _self.size = file.fileSize;
                
                afterMetaData()
            });
        } else {
            entry.getMetadata(function(metadata) {
                var t = metadata.modificationTime;
                var m = t.getMonth() + 1;
                var month = m < 10 ? "0" + m : m;
                
                var time = [t.getFullYear(), month, t.getDate()].join('-') + 'T' + [t.getHours(), t.getMinutes(), t.getSeconds()].join(':') + 'Z';
                
                _self.mtime = time;
                _self.atime = time;
                _self.ctime = time;
                
                _self.size = 0;
                
                afterMetaData()
            });
        }
        
        function afterMetaData() {
            
            _self.dev = 0;
            _self.ino = 0;
            _self.mode = 0;
            _self.nlink = 0;
            _self.uid = 0;
            _self.gid = 0;
            _self.rdev = 0;
            _self.blocks = 0;
            
            
            _self.isDirectory = entry.isDirectory;
            _self.isFile = entry.isFile;
            
            /**
             * These next stats functions all return false for nodejs compatibility
             */
            _self.isBlockDevice = false;
            _self.isCharacterDevice = false;
            _self.isSymbolicLink = false;
            _self.isFIFO = false;
            _self.isSocket = false;
            
            callback(null, _self);
        }
    };

    /**
     * Returns if requestFileSystem is available
     * @type    {void}
     */
    WebFS.prototype.isAvailable = function(){
        return !!window.requestFileSystem;
    };
    
    /**
     * Error handler for file system operations
     * @param   {Error}     error
     * @type    {void}
     */
    WebFS.prototype.errorHandler = function(error) {
        var msg;
        
        switch(error.code) {
            case this.NOT_FOUND_ERR:
                error.message = "The file or directory has not been found";
                break;
            case this.SECURITY_ERR:
                error.message = "The file you are attempting to access is unsafe for web access or may be being accessed too many times.";
                break;
            case this.ABORT_ERR:
                error.message = "The current operation has been aborted";
                break;
            case this.NOT_READABLE_ERR:
                error.message = "The file you are attempting to read is not readable, this may be a permissions issue.";
                break;
            case this.ENCODING_ERR:
                error.message = "The data or URL passed is malformed";
                break;
            case this.NO_MODIFICATION_ALLOWED_ERR:
                error.message = "The file or directory cannot be modified.";
                break;
            case this.INVALID_STATE_ERR:
                error.message = "The file or directory state has changed since the last operation.";
                break;
            case this.SYNTAX_ERR:
                error.message = "There is a syntax error with this file operation.";
                break;
            case this.INVALID_MODIFICATION_ERR:
                error.message = "Invalid file operation.";
                break;
            case this.QUOTA_EXCEEDED_ERR:
                msg = "The quota for the filesystem has been exceeded.";
                break;
            case this.TYPE_MISMATCH_ERR:
                error.message = "Incorrect file operation on file or directory.";
                break;
            case this.PATH_EXISTS_ERR:
                error.message = "This path already exists";
                break;
        }
        
        return error;
    };
    
    /**
     * If the user does not use an external fs object, we can call this method
     * to create a new file system object
     * @param   {Number}    type
     * @param   {Number}    size
     * @param   {Function}  callback
     * @type    {void}
     */
    WebFS.prototype.setFileSystem = function(type, size, callback) {
        var _self = this;
        
        var successHandler = function(fs) {
            _self.fs = fs;
            _self.root = fs.root;
            callback(null, _self);
        };
        
        var errorHandler = function(error) {
            callback(_self.errorHandler(error));
        };
        
        requestFileSystem(type, (size * 1024 *1024), successHandler, errorHandler);
    };
    
    /**
     * Get the current raw filesystem for this WebFS object
     * @type    {void}
     */
    WebFS.prototype.getFileSystem = function() {
        return this.fs;
    };
    
    /**
     * Rename or move src to dest.  If dest is a directory, must contain a trailing '/' char.
     * @param   {String}    src 
     * @param   {String}    dest
     * @param   {Function}  callback
     * @type    {void}
     */
    WebFS.prototype.rename = function(src, dest, callback) {
        var _self = this;
        
        var errorHandler = function(error) {
            callback(_self.errorHandler(error));
        };
        
        var doMove = function(srcDirEntry, destDirEntry, newName) {
            var name = newName || null;
            srcDirEntry.moveTo(destDirEntry, name, function(newDirEntry) {
                callback(null, newDirEntry);
            }, errorHandler);
        };
        
        if (dest[dest.length - 1] == _self.DIR_SEPARATOR) {
            _self.root.getDirectory(src, {}, function(srcDirEntry) {
                // Create blacklist for dirs we can't re-create.
                var create = _self.DIR_BLACKLIST.indexOf(dest) != -1 ? false : true;
             
                _self.root.getDirectory(dest, {create: create}, function(destDirEntry) {
                    doMove(srcDirEntry, destDirEntry);
                }, errorHandler);
             }, function(error) {
                 // Try the src entry as a file instead.
                _self.root.getFile(src, {}, function(srcDirEntry) {
                    _self.root.getDirectory(dest, {}, function(destDirEntry) {
                        doMove(srcDirEntry, destDirEntry);
                    }, errorHandler);
                }, errorHandler);
            });
        } else {
            // Treat src/destination as files.
            _self.root.getFile(src, {}, function(srcFileEntry) {
                srcFileEntry.getParent(function(parentDirEntry) {
                    doMove(srcFileEntry, parentDirEntry, dest);
              }, errorHandler);
            }, errorHandler);
        }
    };
    
    /**
     * Takes a file handler and truncates the content to the passed length
     * @param   {FileEntry} fileEntry
     * @param   {Number}    len
     * @param   {Function}  callback
     * @type    {void}
     */
    WebFS.prototype.truncate = function(fileEntry, len, callback) {
        var _self = this;
        
        var errorHandler = function(error) {
            callback(_self.errorHandler(error));
        };
    
        fileEntry.createWriter(function(fileWriter) {
            fileWriter.onwriteend = function(e) {
                callback(null, fileEntry, e);
            };
            fileWriter.onerror = errorHandler;
                
            fileWriter.truncate(len);
        });
    };
    
    /**
     * Stub chmod function for nodejs compatiblity
     * @param   {String}    path
     * @param   {Number}    mode
     * @param   {Function}  callback
     * @type    {void}
     */
    WebFS.prototype.chmod = function(path, mode, callback) {
        callback();
    };
    
    /**
     * Returns a stat object from a path
     * @param   {String}    path
     * @param   {Function}  callback
     * @type    {void}
     */
    WebFS.prototype.stat = function(path, callback) {
        var _self = this;
        
        var errorHandler = function(error) {
            callback(_self.errorHandler(error));
        };
        
        this.open(path, function(error, fileHandler) {
            if (error && error.code == _self.TYPE_MISMATCH_ERR) {
                // Get a directory instead
                _self.root.getDirectory(path, {}, function(dirHandler) {
                    Stats(dirHandler, callback);
                }, errorHandler);
            } else if (error) {
                errorHandler(error);
            } else {
                Stats(fileHandler, callback);
            }
        });
    };
    
    /**
     * Returns a stat object from a path
     * @param   {String}    path
     * @param   {Function}  callback
     * @type    {void}
     * @function
     */
    WebFS.prototype.lstat = WebFS.prototype.stat;
    
    /**
     * Returns a stat object from a file descriptor
     * @param   {FileEntry, DirectoryEntry} fd
     * @param   {Function}                  callback
     * @type    {void}
     */
    WebFS.prototype.fstat = function(fd, callback) {
        Stats(fd, callback);
    };
    
    /**
     * Stub link function for nodejs compatibility
     * @param   {String}    srcpath
     * @param   {String}    destpath
     * @param   {Function}  callback
     * @type    {void}
     */
    WebFS.prototype.link = function(srcpath, destpath, callback) {
        callback();
    };
    
    /**
     * Stub symlink function for nodejs compatibility
     * @param   {String}    linkdata
     * @param   {String}    path
     * @param   {Function}  callback
     * @type    {void}
     */
    WebFS.prototype.symlink = function(linkdata, path, callback) {
        callback();
    };
    
    /**
     * Stub readlink function for nodejs compatibility
     * @param   {String}    path
     * @param   {Function}  callback
     * @type    {void}
     */
    WebFS.prototype.readlink = function(path, callback) {
        callback();
    };
    
    /**
     * Stub realpath function for nodejs compatibility
     * @param   {String}    path
     * @param   {Function}  callback
     * @type    {void}
     */
    WebFS.prototype.realpath = function(path, callback) {
        callback();
    };
    
    /**
     * Deletes a file from the path.  Directories are removed recursivly
     * @param   {String}    path
     * @param   {Function}  callback
     * @type    {void}
     */
    WebFS.prototype.unlink = function(path, callback) {
        var _self = this;
        
        var errorHandler = function(error) {
            callback(_self.errorHandler(error));
        };
        
        _self.root.getFile(path, {}, function(fileEntry) {
            fileEntry.remove(callback, errorHandler);
        }, function(error) {
            if (error.code == FileError.TYPE_MISMATCH_ERR) {
                _self.root.getDirectory(path, {}, function(dirEntry) {
                    dirEntry.removeRecursively(callback, errorHandler);
                }, errorHandler);
            } else {
                errorHandler(error);
            }
        });
    };
    
    /**
     * Deletes a directory from the path.  Directories are removed recursivly
     * @param   {String}    path
     * @param   {Function}  callback
     * @type    {void}
     * @function
     */
    WebFS.prototype.rmdir= WebFS.prototype.unlink;
    
    /**
     * Creates a directory on the filesystem, will recursivly create paths
     * @param   {String}    path
     * @param   {Number}    mode
     * @param   {Function}  callback
     * @type    {void}
     */
    WebFS.prototype.mkdir = function(path, mode, callback) {
        var _self = this;
        
        if (typeof callback != "function") {
            callback = mode;
        }
        
        var errorHandler = function(error) {
            callback(_self.errorHandler(error));
        };
        
        var createDir = function(rootDir, folders) {
            if (folders[0] == '.' || folders[0] == '') {
                folders = folders.slice(1);
            }

            rootDir.getDirectory(folders[0], {create: true}, function(dirEntry) {
                if (folders.length) {
                    createDir(dirEntry, folders.slice(1));
                } else {
                    callback(null, dirEntry);
                }
            }, errorHandler);
        };
        createDir(this.fs.root, path.split('/'));
    };
    
    /**
     * Reads the contents of a directory, returns the result as an array of entries
     * @param   {String}    path
     * @param   {Function}  callback
     * @type    {void}
     */
    WebFS.prototype.readdir = function(path, callback) {
        var _self = this;
        
        var errorHandler = function(error) {
            callback(_self.errorHandler(error));
        };
        
        var listHandler = function(dirHandler) {
            var dirReader = dirHandler.createReader();
            var entries = [];
            var readEntries = function() {
                dirReader.readEntries(function(results) {
                    if (!results.length) {
                        callback(null, entries.sort());
                    } else {
                        for (var i = 0, j = results.length; i < j; i++) {
                            if (results[i].isDirectory)
                                entries.push(results[i].fullPath + '/');
                            else
                                entries.push(results[i].fullPath);
                        }
                        //entries = entries.concat(Array.prototype.slice.call(results || [], 0));
                        readEntries();
                    }
                }, errorHandler);
            };
            readEntries();
        };
        
        _self.root.getDirectory(path, {}, listHandler, errorHandler);
    };
    
    /**
     * 'Close' a file or directory handler by setting it to null
     * @param   {FileEntry, DirectoryEntry} fd
     * @param   {Function}                  callback
     * @type    {void}
     */
    WebFS.prototype.close = function(fd, callback) {
        fd = null;  // Set to null for GC
        callback();
    };
    
    /**
     * Opens a file or directory and return a handler
     * @param   {String}    path
     * @param   {String}    flags
     * @param   {Number}    mode
     * @param   {Function}  callback
     * @type    {void}
     */
    WebFS.prototype.open = function(path, flags, mode, callback) { 
        var _self = this;
        
        if (typeof callback != "function") {
            callback = mode;
        }
        if (typeof callback != "function") {
            callback = flags;
        }
        
        var errorHandler = function(error) {
            if (error && error.code == _self.TYPE_MISMATCH_ERR) {
                _self.root.getDirectory(path, options, successHandler, function(error) {
                    callback(_self.errorHandler(error));
                });
            }
        };
        
        var successHandler = function(fileHandler) {
            callback(null, fileHandler);
        };
        
        var options = {};
        // If the flag is to write or append, and the file does not exist
        // then we need to ensure it's created
        if (['w', 'w+', 'a', 'a+'].indexOf(flags) > -1)
            options.create = true;

        _self.root.getFile(path, options, successHandler, errorHandler);
    };
    
    /**
     * Writes the contents of a Blob or File to a FileEntry on the filesystem
     * @param   {FileEntry} fileHandler
     * @param   {Mixed}     buffer
     * @param   {Number}    offset
     * @param   {Number}    length
     * @param   {Number}    position
     * @param   {Function}  callback
     * @type    {void}
     */
    WebFS.prototype.write = function(fileHandler, buffer, offset, length, position, callback) {
        var _self = this,
            data;
            
        if (typeof callback != "function") {
            callback = position;
        }
        if (typeof callback != "function") {
            callback = length;
        }
        if (typeof callback != "function") {
            callback = offset;
        }
            
        var errorHandler = function(error) {
            callback(_self.errorHandler(error));
        };
                
        var data = (typeof buffer == 'string') ? _self.createBlob(buffer) : buffer;
        
        var writerHandler = function(fileWriter) {
            
            fileWriter.onwriteend = function(e) {
                callback(null, e.loaded, buffer);
            };
            
            fileWriter.onerror = errorHandler;
          
            fileWriter.write(data);
        };
            
        fileHandler.createWriter(writerHandler, errorHandler);
    };
    
    /**
     * Asynchronously writes data to a file, replacing the file if it already exists.  Data can be a string or a buffer.
     * @param   {String}    filename
     * @param   {Mixed}     data
     * @param   {String}    encoding
     * @param   {Function}  callback
     * @type    {void}
     */
    WebFS.prototype.writeFile = function(filename, data, encoding, callback) {
        var _self = this;
        
        if (typeof callback != 'function') {
            callback = encoding;
        }
        
        var buffer = (typeof data == 'string') ? _self.createBlob(data) : data;
        
        var openFileHandler = function(error, fileHandler) {
            _self.truncate(fileHandler, 0, function(error) {
                if (error)
                    return callback(error);
                _self.write(fileHandler, buffer, null, null, null, function(error, written, buffer_) {
                    callback(error, buffer_);  
                });
            });
        };
        
        _self.open(filename, 'w', null, openFileHandler);  
    };
    
    /**
     * Read data from the file specified by file handler.
     * @param   {FileEntry} fileHandler
     * @param   {Mixed}     buffer
     * @param   {Number}    offset
     * @param   {Number}    length
     * @param   {Number}    position
     * @type    {void}
     */
    WebFS.prototype.read = function(fileHandler, buffer, offset, length, position, callback) {
        var _self = this,
            data;
            
        if (typeof callback != "function") {
            callback = position;
        }
        if (typeof callback != "function") {
            callback = length;
        }
        if (typeof callback != "function") {
            callback = offset;
        }
        
        var errorHandler = function(error) {
            callback(_self.errorHandler(error));
        };
        
        fileHandler.file(function(file) {
            var reader = new FileReader();
            
            reader.onloadend = function(e) {
                buffer.append(this.result);
                callback(null, buffer.getBlob().size, buffer.getBlob());
            };
            
            reader.onerror = errorHandler;
            
            // Since we want to support binary or string data, we should read
            // as an array buffer and allow the user to determine the output
            // from the Blob/File interface buffer
            reader.readAsArrayBuffer(file);
        });
    };
    
    /**
     * Asynchronously reads the entire contents of a file and returns a buffer
     * @param   {String}    filename
     * @param   {String}    encoding
     * @param   {Function}  callback
     * @type    {void}
     */
    WebFS.prototype.readFile = function(filename, encoding, callback) {
        var _self = this;
        
        if (typeof callback != 'function') {
            callback = encoding;
        }
                
        var successHandler = function(error, fileHandler) {
            if (error)
                return callback(error);
                
            _self.read(fileHandler, new BlobBuilder(), null, null, null, callback);
        };
        
        this.open(filename, null, null, successHandler);
    };
    
    /**
     * Takes data, string or binary, and creates a binary blob.
     * @param   {Mixed}     data
     * @param   {String}    encoding
     * @type    {void}
     */
    WebFS.prototype.createBlob = function(data, encoding) {
        var bb = new BlobBuilder();
        bb.append(data);
        if (encoding)
            return bb.getBlob(encoding);
        else
            return bb.getBlob();
    };
    
    /**
     * Method to get content of a blob or file as a string
     * @param   {File, Blob}    data
     * @param   {String}        encoding
     * @param   {Function}      callback
     * @type    {void}
     */
    WebFS.prototype.readString = function(data, encoding, callback) {
        
        var reader = new FileReader(),
            encoding_;
            
        if (typeof callback != 'function') {
            callback = encoding;
            encoding_ = 'UTF-8';
        } else {
            encoding_ = encoding;
        }
        
        reader.onloadend = function(event) {
            callback(null, this.result);
        };
        
        reader.onerror = function(error) {
            callback(error);
        };
        
        data = reader.readAsText(data, encoding_);
    };
    
    /**
     * Method to get content as a binary string
     * @param   {File, Blob}    data
     * @param   {Function}      callback
     * @type    {void}
     */
    WebFS.prototype.readBinaryString = function(data, callback) {
        var reader = new FileReader();
        reader.onloadend = function(event) {
            callback(null, this.result);
        };
        reader.onerror = function(error) {
            callback(error);
        };
        
        reader.readAsBinaryString(data);
    };
    
    /**
     * Method to get content as a array buffer
     * @param   {File, Blob}    data
     * @param   {Function}      callback
     * @type    {void}
     */
    WebFS.prototype.readArrayBuffer = function(data, callback) {
        var reader;
        reader = new FileReader();
        reader.onloadend = function(event) {
            callback(null, this.result);
        };
        reader.onerror = function(error) {
            callback(error);
        };
        
        reader.readAsArrayBuffer(data);
    };
    
    /**
     * Method to get content as a data url
     * @param   {File, Blob}    data
     * @param   {Function}      callback
     * @type    {void}
     */
    WebFS.prototype.readDataUrl = function(data, callback) {
        var reader = new FileReader();
        reader.onloadend = function(event) {
            callback(null, this.result);
        };
        reader.onerror = function(error) {
            callback(error);
        };
        
        reader.readAsDataURL(data);
    };
    
    return WebFS;
})();

});

define('text!ext/testpanel/testpanel.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:window id="winTestPanel" \n      flex     = "1" \n      skin     = "fm-window" \n      title    = "Test Panel" \n      modal    = "false" \n      buttons  = "close" \n      optimize = "true">\n        <a:bar skin="c9-header-bar" top="-30" right="28" height="30">\n            <a:hbox id="barTestTools">\n                <a:button\n                  id       = "btnNewTestType"\n                  caption  = "New"\n                  onclick  = ""\n                  skin     = "c9-toolbarbutton"\n                  class    = "with-arrow"\n                  submenu  = "mnuTestNew" />\n                <a:menu id="mnuTestNew">\n                    \n                </a:menu>\n                \n                <!--a:divider skin="c9-divider-double" /-->\n                \n                <a:splitbutton id="btnTestRun"\n                  caption  = "Run tests"\n                  onclick  = "require(\'ext/testpanel/testpanel\').run(dgTestProject.getSelection());"\n                  submenu  = "mnuRunSettings" \n                  visible  = "{!(stTestRun.active or !dgTestProject.selected)}" />\n            \n                <a:button\n                  icon     = "stop.png"\n                  caption  = "Stop Tests"\n                  skin     = "c9-toolbarbutton"\n                  onclick  = "require(\'ext/testpanel/testpanel\').stop()"\n                  visible  = "{!btnTestRun.visible}"\n                  disabled = "{!stTestRun.active or stTestRun.stopping}" />\n            </a:hbox>\n        </a:bar>\n      \n        <a:button\n          top="-22"\n          skin="header-btn"\n          right="5"\n          icon="panel_settings.png"\n          submenu = "mnuFilter" />\n        <a:menu id="mnuFilter">\n            <a:item type="radio" value="all" selected="true">All</a:item>\n            <a:divider />\n            \n            <a:divider />\n            <a:item type="check" checked="true" onclick="\n                require(\'ext/testpanel/testpanel\').toggleSubmodules(this.value);\n            ">Show Submodules</a:item>\n            <a:item type="check" checked="true" onclick="\n                require(\'ext/testpanel/testpanel\').toggleExpandTests(this.value);\n            ">Auto Expand Tests</a:item>\n            <a:divider />\n            <a:item submenu="mnuAutorunTests">Auto-run Tests</a:item>\n        </a:menu>\n        <a:menu id="mnuAutorunTests">\n            <a:group id="grpAutoRunTests" value="[{require(\'ext/settings/settings\').model}::auto/testpanel/@autorun]" />\n            <a:item group="grpAutoRunTests" type="radio" value="none">None</a:item>\n            <a:divider />\n            <a:item group="grpAutoRunTests" type="radio" value="selection">Selection</a:item>\n            <a:item group="grpAutoRunTests" type="radio" value="pattern" onclick="\n                require(\'ext/testpanel/testpanel\').editAutoRunPattern();\n            ">Pattern</a:item>\n        </a:menu>\n        <a:vbox anchors = "0 0 0 0" id="vboxTestPanel" style="background:#333">\n            <a:model id="mdlTests">\n                <data>\n                    <repo name="Cloud9">\n                    \n                    </repo>\n                </data>\n            </a:model>\n            \n            <a:bar skin="basic" flex="1">\n                <a:datagrid \n                  id        = "dgTestProject"\n                  anchors   = "0 0 0 0"\n                  border    = "0"\n                  options   = "size"\n                  model     = "mdlTests"\n                  each      = "[repo|file|test|assert|error]"\n                  class     = "noscrollbar with-noise"\n                  scrollbar = "sbShared 20 2 2"\n                  multiselect    = "true"\n                  startcollapsed = "true"\n                  contextmenu    = "mnuTestContext"\n                  empty-message  = "No tests yet"\n                  onbeforeremove = "return require(\'core/util\').removeInteractive(this)">\n                    <a:column id="colTestProject" caption="Name" width="60%" tree="1" icon="{require(\'ext/testpanel/testpanel\').getIcon(localName(), [@status], [@type])}"><?lm\n                        if (localName() == "error")\n                            <span style=\'color:red\'>[@name]</span>\n                        else\n                            [@name]\n                    ?></a:column>\n                    <a:column caption="Status" width="41%"><?lm\n                        if ([@status] === \'0\')\n                            <span style=\'color:red\'>\\[[@status-message]\\]</span>\n                        else if ([@status] == \'1\')\n                            <span style=\'color:green\'>\\[PASS{[@status-message] and " [@status-message]"}\\]</span>\n                        else if ([@status] == \'-1\')\n                            <span>\\[{[@status-message].uCaseFirst()}\\]</span>\n                        else\n                            \'\';\n                    ?></a:column>\n                    \n                    <a:insert match="[file]" get="{return require(\'ext/testpanel/testpanel\').parseFile(xmlNode)}" />\n                    <a:remove match="[file]" set="{require(\'ext/filesystem/filesystem\').remove([@path])}"/>\n                    \n                    <a:expanded match="[test|file[test]]" id="expTestRule" />\n                    <a:expanded match="{apf.getChildNumber(%[repo]) == 1}" />\n                </a:datagrid>\n            </a:bar>\n            \n            <!--\n                @todo Edit could be test/assert\n                      Remove could be test and assert\n            -->\n            <a:menu id="mnuTestContext">\n                <a:item match="[test|file|repo[file]]" onclick="require(\'ext/testpanel/testpanel\').run()">Run Tests</a:item>\n                <a:item match="[file]" \n                  onclick="var ide = require(\'core/ide\');ide.dispatchEvent(\'openfile\', {doc: ide.createDocument(dgTestProject.selected)});">Edit</a:item>\n                <a:divider />\n                <a:item match="[file]" onclick="dgTestProject.remove()">Remove</a:item>\n                <a:divider />\n                <a:item match="[file]" onclick="\n                    require(\'ext/tabbehaviors/tabbehaviors\').revealfile(dgTestProject.selected);\n                ">Show in File Tree</a:item>\n            </a:menu>\n        </a:vbox>\n    </a:window>\n</a:application>';});

define('text!ext/nodeunit/nodeunit.template',[],function () { return '"use strict";\nrequire("./support/paths");\n\nvar assert = require("assert");\n//var module = require("./module");\n\nmodule.exports = {\n    \n    "test untitled 1" : function() {\n        //assert.equal(!true, false);\n    }\n\n};\n\nif (typeof module !== "undefined" && module === require.main) {\n    require("asyncjs").test.testcase(module.exports).exec()\n}';});

define('ext/zen/firmin-all-min',['require','exports','module'],function(require, exports, module) {
FirminCSSMatrix=function(c){this.m11=this.m22=this.m33=this.m44=1;this.m12=this.m13=this.m14=this.m21=this.m23=this.m24=this.m31=this.m32=this.m34=this.m41=this.m42=this.m43=0;if(typeof c=="string"){this.setMatrixValue(c)}};FirminCSSMatrix.displayName="FirminCSSMatrix";FirminCSSMatrix.degreesToRadians=function(c){return c*Math.PI/180};FirminCSSMatrix.determinant2x2=function(c,b,a,d){return c*d-b*a};FirminCSSMatrix.determinant3x3=function(c,b,a,d,e,j,f,g,h){var i=FirminCSSMatrix.determinant2x2;return c*i(e,j,g,h)-d*i(b,a,g,h)+f*i(b,a,e,j)};FirminCSSMatrix.determinant4x4=function(c){var b=FirminCSSMatrix.determinant3x3,a=c.m11,d=c.m21,e=c.m31,j=c.m41,f=c.m12,g=c.m22,h=c.m32,i=c.m42,k=c.m13,l=c.m23,m=c.m33,n=c.m43,o=c.m14,p=c.m24,q=c.m34,r=c.m44;return a*b(g,l,p,h,m,q,i,n,r)-d*b(f,k,o,h,m,q,i,n,r)+e*b(f,k,o,g,l,p,i,n,r)-j*b(f,k,o,g,l,p,h,m,q)};[["m11","a"],["m12","b"],["m21","c"],["m22","d"],["m41","e"],["m42","f"]].forEach(function(b){var a=b[0],d=b[1];Object.defineProperty(FirminCSSMatrix.prototype,d,{set:function(c){this[a]=c},get:function(){return this[a]}})});FirminCSSMatrix.prototype.isAffine=function(){return this.m13===0&&this.m14===0&&this.m23===0&&this.m24===0&&this.m31===0&&this.m32===0&&this.m33===1&&this.m34===0&&this.m43===0&&this.m44===1};FirminCSSMatrix.prototype.multiply=function(c){var b=this,a=c,d=new FirminCSSMatrix();d.m11=b.m11*a.m11+b.m12*a.m21+b.m13*a.m31+b.m14*a.m41;d.m12=b.m11*a.m12+b.m12*a.m22+b.m13*a.m32+b.m14*a.m42;d.m13=b.m11*a.m13+b.m12*a.m23+b.m13*a.m33+b.m14*a.m43;d.m14=b.m11*a.m14+b.m12*a.m24+b.m13*a.m34+b.m14*a.m44;d.m21=b.m21*a.m11+b.m22*a.m21+b.m23*a.m31+b.m24*a.m41;d.m22=b.m21*a.m12+b.m22*a.m22+b.m23*a.m32+b.m24*a.m42;d.m23=b.m21*a.m13+b.m22*a.m23+b.m23*a.m33+b.m24*a.m43;d.m24=b.m21*a.m14+b.m22*a.m24+b.m23*a.m34+b.m24*a.m44;d.m31=b.m31*a.m11+b.m32*a.m21+b.m33*a.m31+b.m34*a.m41;d.m32=b.m31*a.m12+b.m32*a.m22+b.m33*a.m32+b.m34*a.m42;d.m33=b.m31*a.m13+b.m32*a.m23+b.m33*a.m33+b.m34*a.m43;d.m34=b.m31*a.m14+b.m32*a.m24+b.m33*a.m34+b.m34*a.m44;d.m41=b.m41*a.m11+b.m42*a.m21+b.m43*a.m31+b.m44*a.m41;d.m42=b.m41*a.m12+b.m42*a.m22+b.m43*a.m32+b.m44*a.m42;d.m43=b.m41*a.m13+b.m42*a.m23+b.m43*a.m33+b.m44*a.m43;d.m44=b.m41*a.m14+b.m42*a.m24+b.m43*a.m34+b.m44*a.m44;return d};FirminCSSMatrix.prototype.isIdentityOrTranslation=function(){var c=this;return c.m11===1&&c.m12===0&&c.m13===0&&c.m14===0&&c.m21===0&&c.m22===1&&c.m23===0&&c.m24===0&&c.m31===0&&c.m31===0&&c.m33===1&&c.m34===0&&c.m44===1};FirminCSSMatrix.prototype.adjoint=function(){var c=new FirminCSSMatrix(),b=this,a=FirminCSSMatrix.determinant3x3,d=b.m11,e=b.m12,j=b.m13,f=b.m14,g=b.m21,h=b.m22,i=b.m23,k=b.m24,l=b.m31,m=b.m32,n=b.m33,o=b.m34,p=b.m41,q=b.m42,r=b.m43,s=b.m44;c.m11=a(h,m,q,i,n,r,k,o,s);c.m21=-a(g,l,p,i,n,r,k,o,s);c.m31=a(g,l,p,h,m,q,k,o,s);c.m41=-a(g,l,p,h,m,q,i,n,r);c.m12=-a(e,m,q,j,n,r,f,o,s);c.m22=a(d,l,p,j,n,r,f,o,s);c.m32=-a(d,l,p,e,m,q,f,o,s);c.m42=a(d,l,p,e,m,q,j,n,r);c.m13=a(e,h,q,j,i,r,f,k,s);c.m23=-a(d,g,p,j,i,r,f,k,s);c.m33=a(d,g,p,e,h,q,f,k,s);c.m43=-a(d,g,p,e,h,q,j,i,r);c.m14=-a(e,h,m,j,i,n,f,k,o);c.m24=a(d,g,l,j,i,n,f,k,o);c.m34=-a(d,g,l,e,h,m,f,k,o);c.m44=a(d,g,l,e,h,m,j,i,n);return c};FirminCSSMatrix.prototype.inverse=function(){var c,b,a,d,e;if(this.isIdentityOrTranslation()){c=new FirminCSSMatrix();if(!(this.m41===0&&this.m42===0&&this.m43===0)){c.m41=-this.m41;c.m42=-this.m42;c.m43=-this.m43}return c}a=this.adjoint();b=FirminCSSMatrix.determinant4x4(this);if(Math.abs(b)<1e-8)return null;for(d=1;d<5;d++){for(e=1;e<5;e++){a[("m"+d)+e]/=b}}return a};FirminCSSMatrix.prototype.rotate=function(c,b,a){var d=FirminCSSMatrix.degreesToRadians;if(typeof c!="number"||isNaN(c))c=0;if((typeof b!="number"||isNaN(b))&&(typeof a!="number"||isNaN(a))){a=c;c=0;b=0}if(typeof b!="number"||isNaN(b))b=0;if(typeof a!="number"||isNaN(a))a=0;c=d(c);b=d(b);a=d(a);var e=new FirminCSSMatrix(),j=new FirminCSSMatrix(),f=new FirminCSSMatrix(),g,h,i;a/=2;g=Math.sin(a);h=Math.cos(a);i=g*g;f.m11=f.m22=1-2*i;f.m12=f.m21=2*g*h;f.m21*=-1;b/=2;g=Math.sin(b);h=Math.cos(b);i=g*g;j.m11=j.m33=1-2*i;j.m13=j.m31=2*g*h;j.m13*=-1;c/=2;g=Math.sin(c);h=Math.cos(c);i=g*g;e.m22=e.m33=1-2*i;e.m23=e.m32=2*g*h;e.m32*=-1;return f.multiply(j).multiply(e).multiply(this)};FirminCSSMatrix.prototype.rotateAxisAngle=function(c,b,a,d){if(typeof c!="number"||isNaN(c))c=0;if(typeof b!="number"||isNaN(b))b=0;if(typeof a!="number"||isNaN(a))a=0;if(typeof d!="number"||isNaN(d))d=0;if(c===0&&b===0&&a===0)a=1;var e=new FirminCSSMatrix(),j=Math.sqrt(c*c+b*b+a*a),f,g,h,i,k,l,m;d=(FirminCSSMatrix.degreesToRadians(d)||0)/2;f=Math.cos(d);g=Math.sin(d);h=g*g;if(j===0){c=0;b=0;a=1}else if(j!==1){c/=j;b/=j;a/=j}if(c===1&&b===0&&a===0){e.m22=e.m33=1-2*h;e.m23=e.m32=2*f*g;e.m32*=-1}else if(c===0&&b===1&&a===0){e.m11=e.m33=1-2*h;e.m13=e.m31=2*f*g;e.m13*=-1}else if(c===0&&b===0&&a===1){e.m11=e.m22=1-2*h;e.m12=e.m21=2*f*g;e.m21*=-1}else{i=g*f;k=c*c;l=b*b;m=a*a;e.m11=1-2*(l+m)*h;e.m12=2*(c*b*h+a*i);e.m13=2*(c*a*h-b*i);e.m21=2*(b*c*h-a*i);e.m22=1-2*(m+k)*h;e.m23=2*(b*a*h+c*i);e.m31=2*(a*c*h+b*i);e.m32=2*(a*b*h-c*i);e.m33=1-2*(k+l)*h}return this.multiply(e)};FirminCSSMatrix.prototype.scale=function(c,b,a){var d=new FirminCSSMatrix();if(typeof c!="number"||isNaN(c))c=1;if(typeof b!="number"||isNaN(b))b=c;if(typeof a!="number"||isNaN(a))a=1;d.m11=c;d.m22=b;d.m33=a;return this.multiply(d)};FirminCSSMatrix.prototype.translate=function(c,b,a){var d=new FirminCSSMatrix();if(typeof c!="number"||isNaN(c))c=0;if(typeof b!="number"||isNaN(b))b=0;if(typeof a!="number"||isNaN(a))a=0;d.m41=c;d.m42=b;d.m43=a;return this.multiply(d)};FirminCSSMatrix.prototype.setMatrixValue=function(c){c=c.trim();var b=c.match(/^matrix(3d)?\(\s*(.+)\s*\)$/),a,d,e,j,f,g;if(!b)return;a=!!b[1];d=b[2].split(/\s*,\s*/);e=d.length;j=new Array(e);if((a&&e!==16)||!(a||e===6))return;for(f=0;f<e;f++){g=d[f];if(g.match(/^-?\d+(\.\d+)?$/)){j[f]=parseFloat(g)}else return}for(f=0;f<e;f++){point=a?("m"+(Math.floor(f/4)+1))+(f%4+1):String.fromCharCode(f+97);this[point]=j[f]}};FirminCSSMatrix.prototype.toString=function(){var b=this,a,d;if(this.isAffine()){d="matrix(";a=["a","b","c","d","e","f"]}else{d="matrix3d(";a=["m11","m12","m13","m14","m21","m22","m23","m24","m31","m32","m33","m34","m41","m42","m43","m44"]}return d+a.map(function(c){return b[c].toFixed(6)}).join(", ")+")"};
Firmin=(typeof Firmin=='undefined')?{}:Firmin;Firmin.CSSMatrix=(typeof WebKitCSSMatrix=='object')?WebKitCSSMatrix:FirminCSSMatrix;Firmin.prefix=(function(){var a=document.createElement("div"),b=["webkit","Moz","O"],c=3,d;while(c--){d=b[c];a.style.cssText="-"+d.toLowerCase()+"-transition-property:opacity;";if(typeof a.style[d+"TransitionProperty"]!="undefined")return d}return d})();Firmin.matrixToString=function(d){if(Firmin.prefix!="Moz")return d.toString();var e="matrix(",f=["a","b","c","d","e","f"];return e+f.map(function(a,b){var c=d[a].toFixed(6);if(b>3)c+="px";return c}).join(", ")+")"};Firmin.angleToRadians=function(a,b){var c;switch(a){case"rad":return b;case"deg":c=Math.PI/180;break;case"grad":c=Math.PI/200;break;case"turn":c=Math.PI*2;break}return c*b};Firmin.pointToVector=function(a){if(!a)return null;return a instanceof Array?a:[a.x,a.y,a.z]};Firmin.NUMBER_PATTERN=/^-?\d+(\.\d+)?/;Firmin.parseNumeric=function(e,f){return function(b){var c,d;if(typeof b=="number"){return[f,b]}else if(typeof b!="string"){return null}d=(b.match(Firmin.NUMBER_PATTERN)||[""])[0];if(d.length===b.length){c=f}else{c=e.filter(function(a){return b.substr(d.length)===a})[0]}return c&&d?[c,parseFloat(d)]:null}};Firmin.parseAngle=Firmin.parseNumeric(["deg","grad","rad","turn"],"deg");Firmin.parseTime=Firmin.parseNumeric(["s","ms"],"s");Firmin.Transform=function(a,b){this.ctm=a||new Firmin.CSSMatrix();this.centre=Firmin.pointToVector(b)||["50%","50%",0]};Firmin.Transform.methods=["translate","translate3d","translateX","translateY","translateZ","scale","scale3d","scaleX","scaleY","scaleZ","rotate","rotate3d","rotateX","rotateY","rotateZ","skew","skewX","skewY","matrix","matrix3d"];Firmin.Transform.parse=function(a,b){var c=Firmin.Transform.methods,d={},e=null,f,g;if(typeof b==="object"&&b.transform){f=b.transform.ctm;g=b.transform.centre;e=new Firmin.Transform(f,g)}for(property in a){if(c.indexOf(property)!==-1){e=e||new Firmin.Transform();e[property](a[property])}else if(property==="origin"){e=e||new Firmin.Transform();e[property](a[property])}else{d[property]=a[property]}}return{result:e,remainder:d}};Firmin.Transform.prototype.build=function(a){var b=this.centre;if(Firmin.prefix=="O"){b=b.slice(0,2)}a=a||{};a[Firmin.prefix+"Transform"]=Firmin.matrixToString(this.ctm);a[Firmin.prefix+"TransformOrigin"]=b.join(" ");return a};Firmin.Transform.prototype.matrix=Firmin.Transform.prototype.matrix3d=function(a){var b=new Firmin.CSSMatrix();if(a.length===6){b.a=a[0];b.b=a[1];b.c=a[2];b.d=a[3];b.e=a[4];b.f=a[5]}else{b.m11=a[0];b.m12=a[1];b.m13=a[2];b.m14=a[3];b.m21=a[4];b.m22=a[5];b.m23=a[6];b.m24=a[7];b.m31=a[8];b.m32=a[9];b.m33=a[10];b.m34=a[11];b.m41=a[12];b.m42=a[13];b.m43=a[14];b.m44=a[15]}this.ctm=this.ctm.multiply(b)};Firmin.Transform.prototype.translate=Firmin.Transform.prototype.translate3d=function(a){var b,c,d,e;if(typeof a=="number"||typeof a=="string"){c=d=parseInt(a,10)||0;e=0}else{b=Firmin.pointToVector(a);c=b[0];d=b[1];e=b[2];if(typeof c!="number")c=parseInt(c,10)||0;if(typeof d!="number")d=parseInt(d,10)||0;if(typeof e!="number")e=parseInt(e,10)||0}this.ctm=this.ctm.translate(c,d,e)};Firmin.Transform.prototype.translateX=function(a){this.translate([a,0])};Firmin.Transform.prototype.translateY=function(a){this.translate([0,a])};Firmin.Transform.prototype.translateZ=function(a){this.translate3d([0,0,a])};Firmin.Transform.prototype.scale=Firmin.Transform.prototype.scale3d=function(a){var b,c,d,e;if(typeof a=="number"){c=d=a;e=1}else{b=Firmin.pointToVector(a);c=b[0];d=b[1];e=b[2]}this.ctm=this.ctm.scale(c,d,e)};Firmin.Transform.prototype.scaleX=function(a){this.scale3d([a,1,1])};Firmin.Transform.prototype.scaleY=function(a){this.scale3d([1,a,1])};Firmin.Transform.prototype.scaleZ=function(a){this.scale3d([1,1,a])};Firmin.Transform.prototype.skew=function(a){var b=Firmin.parseAngle,c=Firmin.angleToRadians,d,e;if(typeof a=="number"||typeof a=="string"){d=e=c.apply(null,b(a))||0}else{a=Firmin.pointToVector(a);d=c.apply(null,b(a[0]))||0;e=c.apply(null,b(a[1]))||0}this.matrix([1,Math.tan(e),Math.tan(d),1,0,0])};Firmin.Transform.prototype.skewX=function(a){this.skew([a,0])};Firmin.Transform.prototype.skewY=function(a){this.skew([0,a])};Firmin.Transform.prototype.rotate=function(a){a=Firmin.angleToRadians.apply(null,Firmin.parseAngle(a))*(180/Math.PI);this.ctm=this.ctm.rotate(0,0,a)};Firmin.Transform.prototype.rotate3d=function(a){var b=a.x,c=a.y,d=a.z,e=a.angle;if(typeof b!="number")b=0;if(typeof c!="number")c=0;if(typeof d!="number")d=0;e=Firmin.angleToRadians.apply(null,Firmin.parseAngle(e))*(180/Math.PI);this.ctm=this.ctm.rotateAxisAngle(b,c,d,e)};Firmin.Transform.prototype.rotateX=function(a){this.rotate3d({x:1,angle:a})};Firmin.Transform.prototype.rotateY=function(a){this.rotate3d({y:1,angle:a})};Firmin.Transform.prototype.rotateZ=function(a){this.rotate3d({z:1,angle:a})};Firmin.Transform.prototype.origin=function(a){var b=Firmin.pointToVector(a),c,d,e;if((v0=b[0]))this.centre[0]=v0;if((c=b[1]))this.centre[1]=c;if((d=b[2]))this.centre[2]=d};Firmin.Transition=function(){this.properties=["all"];this.duration=["ms",0];this.delay=["ms",0];this.timingFunction="ease"};Firmin.Transition.methods=["properties","timingFunction","duration","delay"];Firmin.Transition.parse=function(a,b){var c=Firmin.Transition.methods,d={},e=new Firmin.Transition(),f,g;for(p in a){if(c.indexOf(p)!==-1){if(p==="properties"&&typeof p=="string"){e[p]=[a[p]]}else if(p==="timingFunction"&&typeof a[p]!="string"){e[p]="cubic-bezier("+a[p].join(",")+")"}else if(p==="duration"){f=Firmin.parseTime(a[p]);if(f){e[p]=f}}else if(p==="delay"){g=Firmin.parseTime(a[p]);if(g){e[p]=g}}else{e[p]=a[p]}}else{d[p]=a[p]}}return{result:e,remainder:d}};Firmin.Transition.prototype.hasDuration=function(){return this.duration[1]!==0};Firmin.Transition.prototype.getDuration=function(){var a=this.duration;return a[0]==="s"?a[1]*1000:a[1]};Firmin.Transition.prototype.hasDelay=function(){return this.delay[1]!==0};Firmin.Transition.prototype.getDelay=function(){var a=this.delay;return a[0]==="s"?a[1]*1000:a[1]};Firmin.Transition.prototype.build=function(a){a=a||{};if(typeof this.properties=="string"){a[Firmin.prefix+"TransitionProperty"]=this.properties}else{a[Firmin.prefix+"TransitionProperty"]=this.properties.join(", ")}a[Firmin.prefix+"TransitionDuration"]=this.duration[1]+this.duration[0];a[Firmin.prefix+"TransitionDelay"]=this.delay[1]+this.delay[0];if(this.timingFunction){a[Firmin.prefix+"TransitionTimingFunction"]=this.timingFunction}return a};Firmin.Animation=function(a,b){var c,d;if(typeof a.callback=="function"){this.callback=a.callback}delete a.callback;c=Firmin.Transition.parse(a,b);this.transition=c.result;d=Firmin.Transform.parse(c.remainder,b);this.transform=d.result;this.style=d.remainder};Firmin.Animation.prototype.hasDuration=function(){return this.transition&&this.transition.hasDuration()};Firmin.Animation.prototype.getTotalDuration=function(){return this.transition?this.transition.getDuration()+this.transition.getDelay():0};Firmin.Animation.prototype.exec=function(a){var b=this.style,c;if(this.transition)b=this.transition.build(b);if(this.transform)b=this.transform.build(b);for(c in b){a.style[c]=b[c]}};Firmin.Animated=function(a){var b=this;this.element=a;this.operations=[];this.callback=null};Firmin.Animated.prototype.run=function(){var a=this.operations.shift(),b=this;if(!a){this.fired=true;return this}setTimeout(function(){a.exec(b.element)},10);setTimeout(function(){b.fireCallback();b.run()},a.getTotalDuration()||10);this.callback=a.callback;return this};Firmin.Animated.prototype.fireCallback=function(){var a=this.callback;if(typeof a==="function"){a.call(null,this.element)}};Firmin.Animated.prototype.__animate__=function(a){this.operations.push(a);this.__lastAnim=a;if(this.fired){this.fired=false;this.run()}return this};Firmin.Animated.prototype.animate=function(a,b,c){a.duration=b;a.callback=c;return this.__animate__(new Firmin.Animation(a))};Firmin.Animated.prototype.animateR=function(a,b,c){a.duration=b;a.callback=c;return this.__animate__(new Firmin.Animation(a,this.__lastAnim))};Firmin.animate=function(a,b,c,d){var e=new Firmin.Animated(a);e.animate(b,c,d);return e.run()};Firmin.animateR=function(a,b,c,d){var e=new Firmin.Animated(a),f=new Firmin.Animation({}),g=new Firmin.Transform(),h=new Firmin.CSSMatrix(),i=a.style[Firmin.prefix+"Transform"];h.setMatrixValue(i);g.ctm=h;f.transform=g;e.__lastAnim=f;e.animateR(b,c,d);return e.run()};Firmin.Transform.methods.forEach(function(f){var g=f+"R";Firmin[f]=function(a,b,c,d){var e={};e[f]=b;return Firmin.animate(a,e,c,d)};Firmin[g]=function(a,b,c,d){var e={};e[f]=b;return Firmin.animateR(a,e,c,d)};Firmin.Animated.prototype[f]=function(a,b,c){var d={};d[f]=a;return this.animate(d,b,c)};Firmin.Animated.prototype[g]=function(a,b,c){var d={};d[f]=a;return this.animateR(d,b,c)}});
});
define('text!ext/zen/zen.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:button id="btnZenFullscreen"\n      visible = "true"\n      width   = "26"\n      height  = "26"\n      top     = "13"\n      right   = "11"\n      class = "notfull"\n      skinset = "zen"\n      skin = "zenbutton"\n      onclick = "require(\'ext/zen/zen\').toggleFullscreenZen(event)"\n      onmouseover = "require(\'ext/zen/zen\').fadeZenButtonIn()"\n      onmouseout = "require(\'ext/zen/zen\').fadeZenButtonOut()"\n     />\n\n</a:application>\n';});

define('text!ext/zen/skin.xml',[],function () { return '<?xml version=\'1.0\'?>\n<a:skin xmlns:a="http://ajax.org/2005/aml" xmlns="http://www.w3.org/1999/xhtml">\n    <a:button name="zenbutton">\n        <a:style><![CDATA[\n            .zenbutton {\n                height             : 23px;\n                overflow           : hidden;\n                cursor             : default;\n                position           : relative;\n                -moz-user-select   : none;\n                -khtml-user-select : none;\n                user-select        : none;\n                line-height        : 17px;\n                opacity : 0.01;\n            }\n            \n            .zenbutton.full {\n                background : url(images/zen-buttons.png) -1px -28px no-repeat;\n            }\n\n            .zenbutton.full.zenbuttonOver {\n                background : url(images/zen-buttons.png) -28px -28px no-repeat;\n            }\n\n            .zenbutton.notfull {\n                background : url(images/zen-buttons.png) -1px -1px no-repeat;\n            }\n\n            .zenbutton.notfull.zenbuttonOver {\n                background : url(images/zen-buttons.png) -28px -1px no-repeat;\n            }\n            \n            #animateZen {\n                z-index: 90014;\n                position: absolute;\n                -webkit-box-shadow: 0px 0px 25px #000;\n                -moz-box-shadow: 0px 0px 25px #000;\n                overflow: hidden;\n            }\n            \n            #animateZenPosition {\n                position: absolute;\n            }\n            \n            #zenHandleRight, #zenHandleLeft {\n                position: absolute;\n                z-index: 90014;\n                width: 5px;\n                background: transparent;\n                cursor: ew-resize;\n                opacity: 0;\n            }\n            \n            #zenHandleLeft {\n                background-image: linear-gradient(right , rgb(153,153,153) 0%, rgb(204,204,204) 50%);\n                background-image: -o-linear-gradient(right , rgb(153,153,153) 0%, rgb(204,204,204) 50%);\n                background-image: -moz-linear-gradient(right , rgb(153,153,153) 0%, rgb(204,204,204) 50%);\n                background-image: -webkit-linear-gradient(right , rgb(153,153,153) 0%, rgb(204,204,204) 50%);\n                background-image: -ms-linear-gradient(right , rgb(153,153,153) 0%, rgb(204,204,204) 50%);\n            }\n            \n            #zenHandleRight {\n                background-image: linear-gradient(left , rgb(153,153,153) 0%, rgb(204,204,204) 50%);\n                background-image: -o-linear-gradient(left , rgb(153,153,153) 0%, rgb(204,204,204) 50%);\n                background-image: -moz-linear-gradient(left , rgb(153,153,153) 0%, rgb(204,204,204) 50%);\n                background-image: -webkit-linear-gradient(left , rgb(153,153,153) 0%, rgb(204,204,204) 50%);\n                background-image: -ms-linear-gradient(left , rgb(153,153,153) 0%, rgb(204,204,204) 50%);\n            }\n            \n            .vbZen {\n                opacity: 0;\n                z-index: 90013;\n                background: url(images/zenbg.png);\n                padding: 0 80px;\n            }\n        ]]></a:style>\n        <a:presentation>\n            <a:main background="." minwidth="20">\n                <div class="zenbutton">\n                 </div>\n            </a:main>\n        </a:presentation>\n    </a:button>\n</a:skin>';});

/**
 * Cloud9 Language Foundation
 *
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
define('ext/language/marker',['require','exports','module','ace/range','ace/anchor'],function(require, exports, module) {

var Range = require("ace/range").Range;
var Anchor = require('ace/anchor').Anchor;

module.exports = {

    disabledMarkerTypes: {},

    hook: function(language, worker) {
        var _self = this;
        worker.on("markers", function(event) {
            _self.addMarkers(event, language.editor);
        });
    },

    removeMarkers: function(session) {
        var markers = session.getMarkers(false);
        for (var id in markers) {
            // All language analysis' markers are prefixed with language_highlight
            if (markers[id].clazz.indexOf('language_highlight_') === 0) {
                session.removeMarker(id);
            }
        }
        for (var i = 0; i < session.markerAnchors.length; i++) {
            session.markerAnchors[i].detach();
        }
        session.markerAnchors = [];
    },

    addMarkers: function(event, editor) {
        var _self = this;
        var annos = event.data;
        var mySession = editor.session;
        if (!mySession.markerAnchors) mySession.markerAnchors = [];
        this.removeMarkers(editor.session);
        mySession.languageAnnos = [];
        annos.forEach(function(anno) {
            // Certain annotations can temporarily be disabled
            if (_self.disabledMarkerTypes[anno.type])
                return;
            // Using anchors here, to automaticaly move markers as text around the marker is updated
            var anchor = new Anchor(mySession.getDocument(), anno.pos.sl, anno.pos.sc || 0);
            mySession.markerAnchors.push(anchor);
            var markerId;
            var colDiff = anno.pos.ec - anno.pos.sc;
            var rowDiff = anno.pos.el - anno.pos.sl;
            var gutterAnno = {
                guttertext: anno.message,
                type: anno.type === 'error' ? 'error' : 'warning',
                text: anno.message
                // row will be filled in updateFloat()
            };

            function updateFloat(single) {
                if (markerId)
                    mySession.removeMarker(markerId);
                gutterAnno.row = anchor.row;
                if (anno.pos.sc !== undefined && anno.pos.ec !== undefined) {
                    var range = Range.fromPoints(anchor.getPosition(), {
                        row: anchor.row + rowDiff,
                        column: anchor.column + colDiff
                    });
                    markerId = mySession.addMarker(range, "language_highlight_" + (anno.type ? anno.type : "default"));
                }
                if (single) mySession.setAnnotations(mySession.languageAnnos);
            }
            updateFloat();
            anchor.on("change", function() {
                updateFloat(true);
            });
            if (anno.message) mySession.languageAnnos.push(gutterAnno);
        });
        mySession.setAnnotations(mySession.languageAnnos);
    },

    /**
     * Temporarily disable certain types of markers (e.g. when refactoring)
     */
    disableMarkerType: function(type) {
        this.disabledMarkerTypes[type] = true;
        var session = ceEditor.$editor.session;
        var markers = session.getMarkers(false);
        for (var id in markers) {
            // All language analysis' markers are prefixed with language_highlight
            if (markers[id].clazz === 'language_highlight_' + type)
                session.removeMarker(id);
        }
    },

    enableMarkerType: function(type) {
        this.disabledMarkerTypes[type] = false;
    },

    /**
     * Called when text in editor is updated
     * This attempts to predict how the worker is going to adapt markers based on the given edit
     * it does so instanteously, rather than with a 500ms delay, thereby avoid ugly box bouncing etc.
     */
    onChange: function(session, event) {
        var range = event.data.range;
        var isInserting = event.data.action.substring(0, 6) !== "remove";
        var text = event.data.text;
        var adaptingId = text && text.search(/[^a-zA-Z0-9\$_]/) === -1;
        if (!isInserting) { // Removing some text
            var markers = session.getMarkers(false);
            // Run through markers
            var foundOne = false;
            for (var id in markers) {
                var marker = markers[id];
                if (marker.clazz.indexOf('language_highlight_') === 0) {
                    if (range.contains(marker.range.start.row, marker.range.start.column)) {
                        session.removeMarker(id);
                        foundOne = true;
                    }
                    else if (adaptingId && marker.range.contains(range.start.row, range.start.column)) {
                        foundOne = true;
                        var deltaLength = text.length;
                        marker.range.end.column -= deltaLength;
                    }
                }
            }
            if (!foundOne) {
                // Didn't find any markers, therefore there will not be any anchors or annotations either
                return;
            }
            // Run through anchors
            for (var i = 0; i < session.markerAnchors.length; i++) {
                var anchor = session.markerAnchors[i];
                if (range.contains(anchor.row, anchor.column)) {
                    anchor.detach();
                }
            }
            // Run through annotations
            for (var i = 0; i < session.languageAnnos.length; i++) {
                var anno = session.languageAnnos[i];
                if (range.contains(anno.row, 1)) {
                    session.languageAnnos.splice(i, 1);
                    i--;
                }
            }
            session.setAnnotations(session.languageAnnos);
        }
        else { // Inserting some text
            var markers = session.getMarkers(false);
            // Only if inserting an identifier
            if (!adaptingId) return;
            // Run through markers
            var foundOne = false;
            for (var id in markers) {
                var marker = markers[id];
                if (marker.clazz.indexOf('language_highlight_') === 0) {
                    if (marker.range.contains(range.start.row, range.start.column)) {
                        foundOne = true;
                        var deltaLength = text.length;
                        marker.range.end.column += deltaLength;
                    }
                }
            }
        }
        if (foundOne)
            session._dispatchEvent("changeBackMarker");
    }
};

});
define('text!ext/language/liveinspect.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:bar id="winLiveInspect"\n      modal     = "false" \n      center    = "false"\n      width     = "450"\n      height    = "200"\n      visible   = "false"\n      skinset   = "inlinedg" \n      skin      = "bar-liveinspect"\n      >\n    <a:vbox anchors="0 0 0 0"           >\n        <a:datagrid id="dgLiveInspect"\n          flex       = "1"\n          border     = "0 0 0 0"\n          options    = "size|move"\n          class      = "noscrollbar"\n          scrollbar  = "sbShared 20 2 2"\n          prerender  = "false"\n          caching    = "false"\n          empty-message   = "Loading..."\n          loading-message = "Calculating...">\n            <a:actions />\n            <a:each match="[item|globals]" sort="[@name]">\n                <a:insert match="[item[@children]]" get="{adbg.loadObjects(dbg, %[.])}" />\n                <a:expanded match="[node()[@expand]]" />\n                <a:column caption="Property" value="{[@name] || \'Globals\'}" width="120" icon="debugger/genericvariable_obj.gif" tree="true" />\n                <a:column caption="Value" value="{apf.escapeXML([@value])}" width="100%" />\n                <a:column caption="Type" value="[@type]" width="80"/>\n            </a:each>\n        </a:datagrid>\n    </a:vbox>\n    </a:bar>\n</a:application>';});

define('text!ext/language/liveinspect.skin.xml',[],function () { return '<?xml version=\'1.0\'?>\n<a:skin xmlns:a="http://ajax.org/2005/aml" xmlns="http://www.w3.org/1999/xhtml">\n    <a:bar name="bar-liveinspect">\n        <a:style><![CDATA[\n            .bar-liveinspect {\n                z-index: 9015;\n                border                : 1px solid rgba(0,0,0,0.31);\n                padding               : 5px 4px 4px;\n                -webkit-box-shadow: rgba(0, 0, 0, 0.308594) 0px 0px 4px 1px;\n                -moz-box-shadow: rgba(0, 0, 0, 0.308594) 0px 0px 4px 1px;\n                box-shadow: rgba(0, 0, 0, 0.308594) 0px 0px 4px 1px;\n            }\n            \n            /*.bar-liveinspect .datagridFocus .records .selected, .bar-liveinspect .datagridFocus .records .selected span {\n                background-image: linear-gradient(bottom, #494949 0%, #646469 100%);\n                background-image: -o-linear-gradient(bottom, #494949 0%, #646469 100%);\n                background-image: -moz-linear-gradient(bottom, #494949 0%, #646469 100%);\n                background-image: -webkit-linear-gradient(bottom, #494949 0%, #646469 100%);\n                background-image: -ms-linear-gradient(bottom, #494949 0%, #646469 100%);\n                \n                background-image: -webkit-gradient(\n                    linear,\n                \tleft bottom,\n                \tleft top,\n                \tcolor-stop(0, #494949),\n                \tcolor-stop(1, #646469)\n                );\n            }*/\n            \n            .bar-liveinspect .datagridFocus .records .selected span u {\n                border-left: 1px solid #808080;\n            }\n        ]]></a:style>\n        <a:presentation>\n            <a:main container=".">\n                <div class="bar bar-liveinspect">\n                    \n                </div>            \n            </a:main>\n        </a:presentation>\n    </a:bar>\n</a:skin>';});

define('text!ext/language/language.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:skin id="language_skin"\n      src       = "{require(\'ext/language/language\').skin}"/>\n\n    <a:bar id="barCompleterCont" skinset="language_skin" skin="codecomplete" width="300" visible="false">\n        <a:hbox anchors="0 0 0 0">\n            <a:text id="txtCompleter" skin="codecomplete_text" flex="1" />\n            <a:scrollbar\n              for      = "txtCompleter"\n              id       = "sbCompleter"\n              margin   = "2"\n              skin     = "sbios"\n              width    = "7"\n              overflow2 = "auto"/>\n          </a:hbox>\n    </a:bar>\n    \n</a:application>\n';});

define('text!ext/language/skin.xml',[],function () { return '<?xml version=\'1.0\'?>\n<a:skin xmlns:a="http://ajax.org/2005/aml">\n    <a:bar name="codecomplete">\n        <a:style><![CDATA[\n            .code_complete_bar {\n                overflow: hidden;\n                position : relative;\n                color: #000;\n                background-color: #f5f5f5;\n                margin: 5px;\n                -webkit-box-shadow: 0 3px 7px rgba(0,0,0,.4);\n                box-shadow: 0 3px 7px rgba(0,0,0,.4);\n            }\n            \n            .code_complete_bar {\n                border: 1px solid #b7b7b7;\n                -webkit-border-bottom-right-radius: 5px;\n                border-bottom-right-radius: 5px;\n                -webkit-border-bottom-left-radius: 5px;\n                border-bottom-left-radius: 5px;\n            }\n\n            /* Need to do this to get the radius working in Chrome, FF works fine without */\n            .code_complete_bar div.code_complete_text {\n                -webkit-border-bottom-left-radius: 5px;\n                border-bottom-left-radius: 5px;\n            }\n\n            .code_complete_bar > div {\n                -webkit-border-bottom-left-radius: 5px;\n                border-bottom-left-radius: 5px;\n            }\n\n            .cc_complete_option {\n                padding: 1px 5px;\n                cursor: default;\n            }\n            \n            .cc_complete_option:active {\n                color: #000;\n            }\n\n            .cc_complete_option_selected {\n                background: #b9d0e4;\n                color: #333;\n                padding: 1px 5px;\n                cursor: default;\n            }\n            \n            .cc_complete_option_selected:last-child, .cc_complete_option:last-child {\n                -webkit-border-bottom-left-radius: 5px;\n                border-bottom-left-radius: 5px;\n            }\n            \n            .code_complete_bar span.meta {\n                color: #555;\n                float: right;\n                padding-left: 5px;\n                padding-right: 7px;\n            }\n        ]]></a:style>\n        <a:style condition="{apf.isWebkit}"><![CDATA[\n            .code_complete_bar > div > div {\n                margin-right: -11px;\n            }\n        ]]></a:style>\n        <a:style condition="{apf.isGecko}"><![CDATA[\n            .code_complete_bar > div > div > div {\n                margin-right: -11px;\n            }\n        ]]></a:style>\n        <a:presentation>\n            <a:main container=".">\n                <div class="code_complete_bar ace_editor" />\n            </a:main>\n        </a:presentation>\n    </a:bar>\n    \n    <a:text name="codecomplete_text">\n        <a:style><![CDATA[\n            .code_complete_text .cc_complete_option_selected {\n                text-shadow: none;\n            }\n            \n            .code_complete_text {\n                color: #333;\n                position: relative;\n                overflow: hidden;\n                border: 1px solid transparent;\n                border-top-color: #fff;\n            }\n            \n            .code_complete_text u {\n                text-decoration: none;\n                color: blue;\n                text-shadow: none;\n            }\n        ]]></a:style>\n        <a:presentation>\n            <a:main container=".">\n                <div class="code_complete_text"/>\n            </a:main>\n        </a:presentation>\n    </a:text>\n</a:skin>\n';});

define('text!ext/language/language.css',[],function () { return '.language_highlight_default {\n    position: absolute;\n    border-bottom: solid 1px green;\n    z-index: 2000;\n}\n\n.language_highlight_error {\n    position: absolute;\n    border-bottom: solid 1px rgb(224, 4, 4);\n    z-index: 2000;\n}\n\n.language_highlight_warning {\n    position: absolute;\n    border-bottom: solid 1px #DDC50F;\n    z-index: 2000;\n}\n\n\n.language_highlight_unused {\n    position: absolute;\n    padding: 0;\n    border-bottom: solid 1px black;\n    margin: -.6em 0 0 0;\n    z-index: 2000;\n}\n\n.ace_dark .language_highlight_unused {\n    border-bottom: solid 1px white;\n}\n\n.language_highlight_occurrence_main {\n    position: absolute;\n    box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    -webkit-box-sizing: border-box;\n    border: solid 1px #999;\n    opacity: 0.5;\n    z-index: 2000;\n}\n\n.ace_dark .language_highlight_occurrence_main {\n    border: solid 1px #ccc;\n}\n\n.language_highlight_occurrence_other {\n    position: absolute;\n    box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    -webkit-box-sizing: border-box;\n    border: solid 1px #999;\n    opacity: 0.5;\n    z-index: 2000;\n}\n\n.ace_dark .language_highlight_occurrence_other {\n    border: solid 1px #ccc;\n}\n\n.language_rename_main {\n    background-color: #FFF4C9;\n    position: absolute;\n    border: solid 1px #777;\n    box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    -webkit-box-sizing: border-box;\n    z-index: 2001;\n}\n\n.ace_dark .language_rename_main {\n    background-color: #555;\n    border: solid 1px #777;\n}\n\n.language_rename_other {\n    background-color: #FFF4C9;\n    border: solid 1px #666;\n    position: absolute;\n    box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    -webkit-box-sizing: border-box;\n    opacity: 0.7;\n    z-index: 2001;\n}\n\n.ace_dark .language_rename_other {\n    background-color: #444;\n    border: solid 1px #888;\n}\n';});

define('text!ext/language/settings.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:checkbox class="underlined" label="Enable JSHint Rules"\n        checked="{[language/@jshint] != \'\' ? [language/@jshint] : \'true\'}"\n        value="[language/@jshint]" onclick="require(\'ext/language/language\').setJSHint()" skin="checkbox_grey"/>\n    <a:checkbox class="underlined" label="Highlight Variable Instances"\n        checked="{[language/@instanceHighlight] != \'\' ? [language/@instanceHighlight] : \'true\'}"\n        value="[language/@instanceHighlight]" onclick="require(\'ext/language/language\').setInstanceHighlight()" skin="checkbox_grey"/>\n    <a:checkbox class="underlined" label="Mark Undeclared Variables"\n        checked="{[language/@undeclaredVars] != \'\' ? [language/@undeclaredVars] : \'true\'}"\n        value="[language/@undeclaredVars]" onclick="require(\'ext/language/language\').setUndeclaredVars()" skin="checkbox_grey"/>\n    <a:checkbox class="underlined" label="Mark Unused Function Arguments"\n        checked="{[language/@unusedFunctionArgs] != \'\' ? [language/@unusedFunctionArgs] : \'true\'}"\n        value="[language/@unusedFunctionArgs]" onclick="require(\'ext/language/language\').setUnusedFunctionArgs()" skin="checkbox_grey"/>\n</a:application>\n';});

"use strict"

define('ext/vim/maps/aliases',['require','exports','module'],function(require, exports, module) {
module.exports = {
    "x": {
        operator: {
            char: "d",
            count: 1
        },
        motion: {
            char: "l",
            count: 1
        }
    },
    "shift-x": {
        operator: {
            char: "d",
            count: 1
        },
        motion: {
            char: "h",
            count: 1
        }
    },
    "shift-d": {
        operator: {
            char: "d",
            count: 1
        },
        motion: {
            char: "$",
            count: 1
        }
    },
    "shift-c": {
        operator: {
            char: "c",
            count: 1
        },
        motion: {
            char: "$",
            count: 1
        }
    },
    "s": {
        operator: {
            char: "c",
            count: 1
        },
        motion: {
            char: "l",
            count: 1
        }
    },
    "shift-s": {
        operator: {
            char: "c",
            count: 1
        },
        motion: {
            char: "l",
            count: 1
        }
    }
};
});



define('ext/vim/registers',['require','exports','module'],function(require, exports, module) {

"use strict";

module.exports = {
    _default: {
        text: "",
        isLine: false
    }
};

});

define('text!ext/guidedtour/skin.xml',[],function () { return '<?xml version=\'1.0\'?>\n<a:skin xmlns:a="http://ajax.org/2005/aml">\n    <a:window name="guidetool">\n        <a:style><![CDATA[\n            .guidetool {\n                position : relative;\n                overflow : visible;\n                z-index  : 10000;\n                box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.25);\n                -moz-border-radius    : 8px;\n                -webkit-border-radius : 8px;\n                border-radius         : 8px;\n                -webkit-box-shadow: 0 1px 5px 1px #000000;\n                -moz-box-shadow: 0 1px 5px 1px #000000;\n                box-shadow: 0 1px 5px 1px #000000;\n            }\n            .guidetool .gt-header {\n                display : none;\n            }\n            .guidetool .gt-content {\n                background : url(images/tour-info-bg.png) repeat 0 0;\n                border : 1px solid #000101;\n                -webkit-box-shadow: inset 0px 1px 0px 0px #343434;\n                -moz-box-shadow: inset 0px 1px 0px 0px #343434;\n                box-shadow: inset 0px 1px 0px 0px #343434;\n                -moz-border-radius    : 8px;\n                -webkit-border-radius : 8px;\n                border-radius         : 8px;\n                padding: 15px 15px;\n                min-height: 25px;\n            }\n            .guidetool .gt-content .text {\n                color: #cee57f;\n                background : url(images/tour-info-bg.png) repeat 0 0;\n            }\n            .guidetool .gt-arrow {\n                position: absolute;\n                width: 25px;\n                height: 25px;\n                background : url(images/arrow.png) no-repeat 0 0;\n            }\n            .guidetool.top .gt-arrow {\n                left: 50%;\n                height: 17px;\n                bottom: -16px;\n                background-position : 0 -42px;\n            }\n            .guidetool.bottom .gt-arrow {\n                left: 50%;\n                top: -15px;\n                height: 17px;\n                background-position : 0 -25px;\n            }\n            .guidetool.left .gt-arrow {\n                right: -24px;    \n                top: 37%;\n                background-position : 0 -59px;\n            }\n            \n            .guidetool.right .gt-arrow {\n                left: -24px;\t\n                top: 43%;\n                background-position : 0 0;\n            }\n            \n            .wn_cp_content .btnIcon .lbl span {\n                width: 40px;\n            }\n            \n            .tgDialog {\n                z-index: 99999;\n            }\n            .tgDialog, .guidetool {\n                z-index: 999999;\n            }\n             \n            .tgDialog > .bk-header {\n                padding-bottom: 10px;\n            }\n                \n            .tgDesc {\n            }\n             \n            .tgDesc a {\n                color: #20800a;\n                text-decoration: none;\n            }\n\n            .tgControlButton {\n                width: 85px;\n            }\n            \n            .tgPlayButton {\n                width: 40px;\n            }\n            \n            .tgPlayButton .caption {\n                height: 15px;\n                background: url(images/tg_button_play.png) no-repeat 14px 4px;\n            }\n            \n            .tgBackButton .caption {\n                height: 15px;\n                background: url(images/tg_button_back.png) no-repeat 20px -21px;\n            }\n            \n            .tgForwardButton .caption {\n                height: 15px;\n                background: url(images/tg_button_forward.png) no-repeat 27px 5px;\n            }\n        ]]></a:style>\n        <a:style condition="apf.isGecko"><![CDATA[\n            .tgDesc {\n                height: 130px;\n            }\n        ]]></a:style>\n        <a:presentation>\n            <a:main\n              collapsed-height = "30"\n              minheight        = "30"\n              minwidth         = "60"\n              container        = "div[2]"\n              drag             = "div[2]"\n              title            = "div[1]/div[1]/text()"\n              icon             = "div[1]/div[1]/div[1]"\n              buttons          = "div[1]/div[1]/div[2]">\n                <div class="guidetool">\n                    <div class="gt-header">\n                        <div class="hcontent">-<div class="icon"></div><div class="buttons"></div></div>\n                        <div class="right"></div>\n                    </div>\n                    <div class="gt-content"> </div>\n                    <div class="gt-arrow"></div>\n                </div>\n            </a:main>\n            <a:button>\n                <div> </div>\n            </a:button>\n        </a:presentation>\n    </a:window>\n    <a:modalwindow name="win-controls">\n        <a:style><![CDATA[\n            .win-controls {\n                position : relative;\n                overflow : hidden;\n                z-index  : 10000;\n                \n                -moz-border-radius    : 6px 6px 6px 6px;\n                -webkit-border-radius : 6px 6px 6px 6px;\n                border-radius         : 6px 6px 6px 6px;\n                \n                -webkit-box-shadow: 0 2px 10px 1px #000000;\n                -moz-box-shadow: 0 2px 10px 1px #000000;\n                box-shadow: 0 2px 10px 1px #000000;\n                border: 1px solid #000101;\n                background: url(images/controls-bg.png) repeat-x 0 0;\n            }\n\n            .win-controls .wc-container {\n                position:absolute;\n                overflow:visible;\n                left : 0;\n                top  : 0;\n                right : 0;\n                bottom : 0;\n                z-index: 1;\n            }\n        ]]></a:style>\n    \n        <a:presentation>\n            <a:main\n              collapsed-height = "26"\n              minheight        = "50"\n              minwidth         = "50"\n              container        = "div[1]"\n              title            = "div[1]/text()">\n                <div class="win-controls">\n                    <div class="wc-container"> </div>\n                </div>\n            </a:main>\n            <a:button>\n                <div/>\n            </a:button>\n        </a:presentation>\n    </a:modalwindow>\n</a:skin>';});

define('text!ext/guidedtour/guidedtour.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">      \n    <a:window id = "winTourGuide"\n      title   = "Guided Tour"\n      center  = "true"\n      modal   = "true"\n      buttons = "close"\n      kbclose = "true"\n      width   = "360"\n      skin    = "bk-window"\n      class   = "relative">\n        <a:vbox padding="10" edge="15">\n            <a:text id="winTourDesc" class="tgDesc modal_text"/>\n        </a:vbox>\n        <a:hbox padding="10" pack="end" edge="10 10 10 20" align="center">\n            <a:button id="winTourButtonDone" \n              default = "2"  \n              class   = "btn-green" \n              skin    = "btn-default-css3"\n              visible = "false"\n              onclick = "winTourGuide.hide();" >Done</a:button>\n            <a:button id="winTourButtonClose" \n              default = "2"  \n              skin    = "btn-default-simple" \n              onclick = "winTourGuide.hide();" >Cancel</a:button>\n            <a:button id="winTourButtonStart" \n              default = "2" \n              class   = "btn-green" \n              skin    = "btn-default-css3" \n              onclick = "require(\'ext/guidedtour/guidedtour\').startTour();">Let\'s start!</a:button>\n        </a:hbox>\n    </a:window>\n    <a:window id = "tourControlsDialog"\n      title   = ""\n      center  = "true"\n      modal   = "false"\n      kbclose = "false"\n      width   = "295"\n      zindex  = "99999"\n      height  = "58"\n      skinset = "guidedtour"\n      skin    = "win-controls"\n      class   = "tgDialog">\n        <a:vbox>\n            <a:hbox padding="10" pack="center" edge="16 15 10" align="center">\n                <!-- Play pause etc -->\n                <a:button id = "btnTourStepBack"\n                  class    = "tgControlButton tgBackButton"\n                  skin     = "btn-default-css3"\n                  width    = "75"\n                  height   = "25"\n                  disabled = "true"\n                  tooltip  = "Go Back"\n                  onclick  = "require(\'ext/guidedtour/guidedtour\').stepBack();"/>\n                <a:button id = "btnTourPlay"\n                  class   = "btn-green tgPlayButton"\n                  tooltip = "Play"\n                  width   = "40"\n                  height  = "25"\n                  skin    = "btn-default-css3"\n                  onclick = "require(\'ext/guidedtour/guidedtour\').togglePlay();" />\n                <a:button id = "btnTourStepForward"\n                  class   = "tgControlButton tgForwardButton"\n                  skin    = "btn-default-css3"\n                  tooltip = "Go Forward"\n                  width   = "75"\n                  height  = "25" \n                  onclick = "require(\'ext/guidedtour/guidedtour\').stepForward();" />\n                <a:divider skin="c9-divider" />\n                <a:button onclick="tourControlsDialog.hide();require(\'ext/guidedtour/guidedtour\').closeTG()" skin="btn-default-simple">Quit</a:button>\n            </a:hbox>\n        </a:vbox>\n    </a:window>\n        \n    <a:window id = "winTourText"\n      title     = ""\n      center    = "false"\n      modal     = "false"\n      buttons   = ""\n      kbclose   = "false"\n      width     = "160"\n      skinset   = "guidedtour"\n      skin      = "guidetool"\n      zindex    = "999999"\n      draggable = "false">\n        <a:text id="textTourDesc" flex="1" />     \n    </a:window>\n</a:application>';});

define('text!ext/guidedtour/hello-world-script.txt',[],function () { return 'var http = require(\'http\');\nhttp.createServer(function (req, res) {\n   res.writeHead(200, {\'Content-Type\': \'text/plain\'});\n   res.end(\'Hello World\\n\');\n}).listen(process.env.PORT);\nconsole.log(\'Server running\');';});

define('text!ext/quickstart/skin.xml',[],function () { return '<?xml version=\'1.0\'?>\n<a:skin xmlns:a="http://ajax.org/2005/aml">\n<a:window name="qsImage">\n        <a:style><![CDATA[\n            .qsProjectBar {\n                position:absolute;\n                width: 167px;\n                height: 117px;\n                background: url(images/your_project_bar.png) no-repeat 0 0;\n                z-index  : 999999;\n            }\n            \n            .qsMenuBar {\n                position:absolute;\n                width: 167px;\n                height: 117px;\n                background: url(images/your_top_menu.png) no-repeat 0 0;\n                z-index  : 999999;\n            }\n            \n            .qsToolbar {\n                position:absolute;\n                width: 167px;\n                height: 117px;\n                background: url(images/your_toolbar.png) no-repeat 0 0;\n                z-index  : 999999;\n            }\n            \n             .qsCLI {\n                position:absolute;\n                width: 167px;\n                height: 200px;\n                background: url(images/your_command_line.png) no-repeat 0 0;\n                z-index  : 999999;\n            }\n        ]]></a:style>\n    \n        <a:presentation>\n        <a:main\n              collapsed-height = "30"\n              minheight        = "30"\n              minwidth         = "60"\n              container        = "div[2]"\n              drag             = "div[2]"\n              title            = "div[1]/div[1]/text()">\n                <div>\n                    <div>\n                    </div>\n                    <div class="image"> </div>\n                </div>\n            </a:main>\n        </a:presentation>\n    </a:window>\n    \n    <a:window name="win-quickstart">\n        <a:style><![CDATA[\n            .win-quickstart {\n                position : relative;\n                overflow : visible;\n                z-index  : 999999;\n                border-radius: 4px;\n            }\n            \n            .win-quickstart .header {\n                background: #000;\n                position: relative;\n                border-bottom: 1px solid #7d7d7d;\n                font-size: 24px;\n                font-weight: normal;\n                padding: 15px 20px 10px;\n                color: #ffffff;\n            }\n            \n            .win-quickstart .buttons {\n                position: absolute;\n                right: 0;\n                top: -23px;\n                padding: 4px;\n                background-color: #000000;\n                \n            }\n            \n            .win-quickstart .buttons .close {\n                width: 13px;\n                height: 13px;\n                background: url(images/close.png) no-repeat 0 0;\n            }\n            \n            .win-quickstart .buttons .close.hover {\n                background-position: -18px 0;\n            }\n            \n            .win-quickstart .buttons .close.down {\n                background-position: -35px 0;\n            }\n            \n            .win-quickstart .content {\n                \n            }\n            \n            .win-quickstart p {\n                padding: 0;\n                margin: 0;\n            }\n            .tgLink {\n                background : #000;\n                color: #fff;\n                padding: 0 5px 0 5px;\n                font-family: Tahoma, Arial;\n                margin-bottom: -16px;\n                text-decoration: none;\n            }\n            \n            .tgLink:hover {\n                text-decoration: underline;\n            }\n            \n            .win-quickstart .container {\n                padding: 10px 20px;\n                background : #000;\n                margin-top: 2px;\n                border-bottom: 1px solid #7d7d7d;\n            }\n            \n            .tgtext, .tgtext a {\n                color: #ffc02a;\n                font-size: 16px;\n                text-decoration: none;\n            }\n            \n            .win-quickstart .qsSupportText {\n                font-size: 12px;\n                color: #eeeeee;\n                padding: 18px 20px;\n            }\n            \n            .supportLink {\n                color: #b1dfff;\n                text-decoration: none;\n            }\n            \n            .supportLink:hover {\n                text-decoration: underline;\n            }\n            \n            .cbcontainer {\n                color: white;\n                margin-left: 12px;\n            }\n            \n            .qsCBContainer { \n            }\n            .checkboxDiv    {\n                width: 243px;\n                padding: 17px 20px 15px 5px;\n                border-bottom: 1px solid #7d7d7d;\n                background: black;\n            }\n\n            .buttonDiv {\n                width: 255px;\n                padding: 15px 0;\n                border-bottom: 1px solid #7d7d7d;\n                background: black;\n            }\n            \n            .btnclosetour {\n                margin: 0 auto;\n            }\n        ]]></a:style>\n\n    \n        <a:presentation>\n        <a:main\n              collapsed-height = "30"\n              minheight        = "30"\n              minwidth         = "60"\n              container        = "div[2]"\n              drag             = "div[2]"\n              title            = "div[1]/text()"\n              buttons          = "div[1]/div">\n                <div class="win-quickstart">\n                    <div class="header">\n                        <div class="buttons"> </div>\n                    </div>\n                    <div class="content"> </div>\n                </div>      \n            </a:main>\n            <a:button>\n                <div> </div>\n            </a:button>\n        </a:presentation>\n    </a:window>\n</a:skin>';});

define('text!ext/quickstart/quickstart.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">    \n    <a:window\n        id = "quickStartDialog"\n        title     = "Here are a few pointers to get you started!"\n        center    = "true"\n        modal     = "false"\n        buttons   = "close"\n        kbclose   = ""\n        width     = "500"\n        height    = "210"\n        skinset   = "quickstart"\n        skin      = "win-quickstart"\n        onhide    = "require(\'ext/quickstart/quickstart\').closeStart();"\n        draggable = "false">    \n        <div class="tgtext container">\n            <a href="javascript:void(0)" onclick="require(\'ext/quickstart/quickstart\').shutdownQSStartGT();">For a detailed guided tour, <span class="tgLink">click here!</span></a>\n        </div>\n        \n         <div class="qsSupportText container">\n            <p>If you ever run into trouble, be sure to check out our support page on \n            <a href="http://support.cloud9ide.com/home" class="supportLink" target="_blank">support.cloud9ide.com</a>, \n            or talk to us on <a href="https://twitter.com/#!/C9Support" class="supportLink" target="_blank">Twitter</a>.</p>\n        </div>\n        \n        <a:hbox class="qsCBContainer" edge="2 0 0 0" padding="2">\n            <div class="checkboxDiv">\n                 <a:checkbox id="quickStartCheckbox" \n                   skin    = "checkbox_black"\n                   checked = "[{require(\'ext/settings/settings\').model}::auto/help/@show]"\n                   value   = "[{require(\'ext/settings/settings\').model}::auto/help/@show]"\n                   onafterchange = "require(\'ext/quickstart/quickstart\').setState(this.value);"\n                 >Show this quick start on startup</a:checkbox>\n            </div>\n            <div class="buttonDiv">\n                <a:button \n                  default = "2" \n                  width   = "200"\n                  skin    = "btn-default-css3" \n                  class   = "btn-green btnclosetour" \n                  onclick = "require(\'ext/quickstart/quickstart\').closeStart();">\n                    Just the editor, please\n                </a:button>              \n            </div>\n        </a:hbox>\n    </a:window>\n    \n    <a:window\n        id = "qsProjectBar"\n        title = ""\n        center = "false"\n        modal = "false"\n        buttons = ""\n        kbclose   = "false"\n        width     = "200"\n        skinset   = "quickstart"\n        skin ="qsImage"\n        draggable = "false">\n        <a:vbox class="qsProjectBar">\n        </a:vbox>\n    </a:window>\n    \n    <a:window\n        id = "qsMenuBar"\n        title = ""\n        center = "false"\n        modal = "false"\n        buttons = ""\n        kbclose   = "false"\n        width     = "200"\n        skinset   = "quickstart"\n        skin ="qsImage"\n        draggable = "false">\n        <a:vbox class="qsMenuBar">\n        </a:vbox>\n    </a:window>\n    \n    <a:window\n        id = "qsToolbar"\n        title = ""\n        center = "false"\n        modal = "false"\n        buttons = ""\n        kbclose   = "false"\n        width     = "200"\n        skinset   = "quickstart"\n        skin ="qsImage"\n        draggable = "false">\n        <a:vbox class="qsToolbar">\n        </a:vbox>\n    </a:window>\n    \n    <a:window\n        id = "qsCLI"\n        title = ""\n        center = "false"\n        modal = "false"\n        buttons = ""\n        kbclose   = "false"\n        width     = "200"\n        skinset   = "quickstart"\n        skin ="qsImage"\n        draggable = "false">\n        <a:vbox class="qsCLI">\n        </a:vbox>\n    </a:window>\n</a:application>';});

define('ext/colorpicker/colorpicker_regex',['require','exports','module'],function(require, exports, module) {
    // use the apf one, when apf is avaialble. Otherwise use some mocked one
    var namedColors = typeof apf !== "undefined" ? apf.color.colorshex : { "black":0, "white":16777215 };
    var namedPart = Object.keys(namedColors).join("|");
    
    var patterns = {
        rgb: "rgba?\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*(:?\\s*,\\s*(?:1|0|0?\\.[0-9]{1,2})\\s*)?\\)",
        rgb_alt: "rgba?\\(\\s*\\b(\\d{1,2}|100)%\\s*,\\s*\\b(\\d{1,2}|100)%\\s*,\\s*\\b(\\d{1,2}|100)%\\s*(:?\\s*,\\s*(?:1|0|0?\\.[0-9]{1,2})\\s*)?\\)",    
        hsl: "hsla?\\(\\s*\\b([1-2][0-9][0-9]|360|3[0-5][0-9]|[1-9][0-9]|[0-9])\\b\\s*,\\s*\\b(\\d{1,2}|100)%\\s*,\\s*\\b(\\d{1,2}|100)%\\s*(:?\\s*,\\s*(?:1|0|0?\\.[0-9]{1,2})\\s*)?\\)"
    };
    
    var isColor = new RegExp("(#([0-9A-Fa-f]{3,6})\\b)"
        + "|\\b(" + namedPart + ")\\b"
        + "|(" + patterns.rgb + ")"
        + "|(" + patterns.rgb_alt + ")"
        + "|(" + patterns.hsl + ")", "gi");
    
    var isRgb = new RegExp("(?:" + patterns.rgb + ")"
        + "|(?:" + patterns.rgb_alt + ")");
    
    var isHsl = new RegExp(patterns.hsl);
    
    exports = module.exports = {
        isColor: isColor,
        isRgb: isRgb,
        isHsl: isHsl
    };
});
define('text!ext/colorpicker/colorpicker.css',[],function () { return '.codetools_colorpicker {\n    position: absolute;\n    opacity: 0.9;\n    border: 1px solid #d9cb89;\n    background-color: #fff8c8;\n    -webkit-border-radius: 6px;\n    -moz-border-radius: 6px;\n    border-radius: 6px;\n    z-index: 2000;\n    padding: 0 2px 0 2px;\n}\n\n.codetools_colorpicker_tools {\n    position: absolute;\n    top: 182px;\n    left: 8px;\n    line-height: 16px;\n    font-size: 12px;\n    vertical-align: middle;\n    color: #fff;\n}\n\n.codetools_colorpicker_tools span {\n    float: left;\n    display: inline;\n    margin: 0 4px 0 0;\n}\n\n.codetools_colorpicker_tools span.color {\n    width: 15px;\n    height: 15px;\n    margin: 0 2px 0 2px;\n    border: 1px solid #fff;\n    -webkit-border-radius: 2px;\n    -moz-border-radius: 2px;\n    border-radius: 2px;\n    float: left;\n    cursor: pointer;\n    cursor: hand;\n}\n\n.codetools_colorpicker_tools span.color_hover {\n    -webkit-box-shadow: 0px 0px 6px #ffffff;\n    -moz-box-shadow: 0px 0px 6px #ffffff;\n    box-shadow: 0px 0px 6px #ffffff;\n}\n';});

define('text!ext/colorpicker/colorpicker.xml',[],function () { return '<a:application xmlns:a="http://ajax.org/2005/aml">\n    <a:skin id="colorpicker" \n      src        = "{require(\'ext/colorpicker/colorpicker\').skin}" \n      media-path = "/static/ext/colorpicker/images/" />\n\n    <a:menu id="mnuColorPicker" skin="dockwindowblack" class="left" width="366" height="205" animate="false" pinned="true" resizable="false" visible="false">\n        <a:colorpicker id="clrCodeTools" skinset="colorpicker" />\n        <div class="codetools_colorpicker_tools"/>\n    </a:menu>\n</a:application>';});

define('text!ext/colorpicker/skin.xml',[],function () { return '<?xml version=\'1.0\'?>\n<a:skin xmlns:a="http://ajax.org/2005/aml" xmlns="http://www.w3.org/1999/xhtml">\n    <a:colorpicker name="colorpicker">\n        <a:style><![CDATA[\n            .colorpicker {\n                width       : 356px;\n                height      : 176px;\n                overflow    : hidden;\n                position    : absolute;\n                background  : url(images/colorpicker_background.png);\n                font-family : Arial, Helvetica, sans-serif;\n                z-index     : 2002;\n            }\n            \n            .colorpicker_color {\n                width      : 150px;\n                height     : 150px;\n                left       : 14px;\n                top        : 13px;\n                position   : absolute;\n                background : #f00;\n                overflow   : hidden;\n                cursor     : crosshair;\n            }\n            \n            .colorpicker_color div {\n                position   : absolute;\n                top        : 0;\n                left       : 0;\n                width      : 150px;\n                height     : 150px;\n                background : url(images/colorpicker_overlay.png);\n            }\n            \n            .colorpicker_color div div {\n                position   : absolute;\n                top        : 0;\n                left       : 0;\n                width      : 11px;\n                height     : 11px;\n                overflow   : hidden;\n                background : url(images/colorpicker_select.gif);\n                margin     : -5px 0 0 -5px;\n            }\n            \n            .colorpicker_hue {\n                position : absolute;\n                top      : 13px;\n                left     : 171px;\n                width    : 35px;\n                height   : 150px;\n                cursor   : ns-resize;\n            }\n            \n            .colorpicker_hue div {\n                position   : absolute;\n                width      : 35px;\n                height     : 9px;\n                overflow   : hidden;\n                background : url(images/colorpicker_indic.gif) left top;\n                margin     : -4px 0 0 0;\n                left       : 0px;\n            }\n            \n            .colorpicker_new_color {\n                position   : absolute;\n                width      : 60px;\n                height     : 30px;\n                left       : 213px;\n                top        : 13px;\n                background : #f00;\n            }\n            \n            .colorpicker_current_color {\n                position   : absolute;\n                width      : 60px;\n                height     : 30px;\n                left       : 283px;\n                top        : 13px;\n                background : #f00;\n            }\n        ]]></a:style>\n        \n        <a:presentation>\n            <a:main \n              selector       = "div[1]" \n              selector_indic = "div[1]/div/div" \n              hue            = "div[2]/div"\n              newcolor       = "div[3]" \n              customcolor    = "div[4]" \n              inputs         = "div[5]">\n                <div class="colorpicker">\n                    <div class="colorpicker_color">\n                        <div>\n                            <div></div>\n                        </div>\n                    </div>\n                    <div class="colorpicker_hue">\n                        <div></div>\n                    </div>\n                    <div class="colorpicker_new_color"> </div>\n                    <div class="colorpicker_current_color"> </div>\n                    <div class="colorpicker_inputs"> </div>\n                </div>\n            </a:main>\n        </a:presentation>\n    </a:colorpicker>\n</a:skin>';});

/**
 * Minimap plugin for Cloud9
 * 
 * @author Sergi Mansilla
 * @contributor Matt Pardee
 * @copyright 2012, Cloud9 IDE, Inc.
 * 
 * TODO:
 * - On direct click in the map, it should
 *      take the user to the line he was pointing
 *      to, and not to the relative position of
 *      the document to the Y coordinate of the map.
 */

define('ext/minimap/map',['require','exports','module'],function(require, exports, module) {

var LINE_HEIGHT = 4;
var MARGIN_RIGHT = 2;

var Map = (function() {
    Map.createCanvas = function(w, h) {
        var canvas = document.createElement("canvas");
        canvas.width = w;
        canvas.height = h;
        return {
            canvas : canvas,
            ctx : canvas.getContext("2d")
        };
    };

    Map.storeCanvas = function(width, height, lines) {
        var canvas = Map.createCanvas(width, height);
        var ctx = canvas.ctx;
        ctx.font = LINE_HEIGHT + "px Monospace";
        ctx.fillStyle = "#fff";

        for (var i = 0, _len = lines.length; i < _len; i++)
            ctx.fillText(lines[i], 0, (i << 2) + LINE_HEIGHT);

        return canvas;
    };

    Map.prototype.refreshCanvas = function(y) {
        var code = this.codeCanvas.canvas;
        var w = Math.min(this.c.width, code.width);
        var h = Math.min(this.c.height, code.height);
        if (this.codeCanvas.canvas.height < (y + h))
            h -= (y + h) - code.height;
        this.ctx.fillRect(0, 0, this.c.width, this.c.height);
        var dw = Math.max(w - MARGIN_RIGHT, 0);
        h = Math.max(h, 1);
        w = Math.max(w, 1);
        y = Math.max(y, 0);
        if (code.height !== 0 && code.width !== 0)
            return this.ctx.drawImage(code, 0, y, w, h, MARGIN_RIGHT, 0, dw, h);
    };

    Map.prototype.refreshVisor = function(y) {
        this.visor.style.top = y + "px";
    };

    Map.prototype.resize = function(w, h) {
        this.c.width = w;
        this.c.height = h;
        if (this.codeCanvas) {
            this.codeCanvas.width = w;
            this.codeCanvas.height = h;
        }
        this.visibleLines = this.ace.$getVisibleRowCount();
        this.visorHeight = Map.toHeight(this.visibleLines);
        this.visor.style.width = this.c.width + "px";
        this.visor.style.height = this.visorHeight + "px";
        this.render();
    };

    Map.prototype.getNormal = function() {
        var normal = this.visorTop / (this.c.height - this.visorHeight);
        if (normal > 1)
            normal = 1;
        else if (normal < 0)
            normal = 0;

        return normal;
    };

    Map.prototype.afterScroll = function() {
        if (!this.mousedown) {
            var topLine = this.ace.renderer.getFirstVisibleRow();
            this.normal = topLine / (this.lines.length - this.visibleLines);
            this.visorTop = this.normal * (this.c.height - this.visorHeight);
            return this.render();
        }
    };

    function Map(ace, c, visor) {
        var _self = this;
        this.ace = ace;
        this.c = c;
        this.visor = visor;
        this.visibleLines = this.ace.$getVisibleRowCount();
        this.visorHeight = Map.toHeight(this.visibleLines);
        this.ctx = c.getContext("2d");
        this.ctx.fillStyle = "#000";
        this.ctx.fillRect(0, 0, this.c.width, this.c.height);
        this.visorTop = 0;
        this.inVisor = false;
        this.mousedown = false;

        this.ace.renderer.scrollBar.addEventListener("scroll", function() {
            _self.afterScroll();
        });

        var session = this.ace.getSession();

        visor.addEventListener("mousedown", function(e) {
            _self.inVisor = true;
            _self.visorDiff = e.offsetY || e.layerY;
            _self.mousedown = _self.visorDiff + _self.visorTop;
            _self.containerTop = apf.getAbsolutePosition(_self.c)[1];
        }, false);

        document.addEventListener("mousemove", function(e) {
            if (_self.inVisor && _self.mousedown !== false) {
                _self.visorTop = (e.pageY - _self.containerTop) - _self.visorDiff;
                _self.normal = _self.getNormal();
                _self.render(true);
            }
        }, false);

        document.addEventListener("mouseup", function(e) {
            if (!_self.inVisor && e.target === c) {
                _self.visorTop = (e.offsetY || e.layerY) - (_self.visorHeight / 2);
                _self.normal = _self.getNormal();
                _self.render(true);
            }
            _self.mousedown = _self.inVisor = false;
        }, false);

        this.updateSource(session);
    }

    Map.prototype.updateSource = function(session) {
        this.lines = session.getLines(0, session.getLength() - 1);
        this.actualHeight = Map.toHeight(this.lines.length);
        this.codeCanvas = Map.storeCanvas(this.c.width, this.actualHeight, this.lines);
        return this.render();
    };

    Map.prototype.render = function(scrollAce) {
        var top = 0;
        var height = Math.min(this.c.height, this.actualHeight);
        var fitsCanvas = this.actualHeight < this.c.height;
        var fitsScreen = this.visorHeight > height;
        var maxVisorY = height - this.visorHeight;
        if (fitsScreen) {
            this.refreshCanvas(0);
        }
        else {
            var visorTop = 0;
            if (this.visorTop > maxVisorY)
                visorTop = maxVisorY;
            else if (this.visorTop > 0)
                visorTop = this.visorTop;

            if (fitsCanvas) {
                top = visorTop;
                this.refreshCanvas(0);
            }
            else {
                top = (this.normal || 0) * (this.actualHeight - this.visorHeight);
                this.refreshCanvas(top - visorTop);
            }
            this.refreshVisor(visorTop);
        }

        if (scrollAce)
            this.ace.scrollToLine(Map.toLine(top));
    };

    Map.toLine = function(y) {
        return Math.ceil(y / LINE_HEIGHT);
    };

    Map.toHeight = function(line) {
        return line * LINE_HEIGHT;
    };

    Map.prototype.destroy = function() {
        this.lines = null;
        this.pixelData = null;
        this.ctx.clearRect(0, 0, this.c.width, this.c.height);
        this.c.removeEventListener("mousedown");
        this.c.removeEventListener("mousemove");
        this.c.removeEventListener("mouseup");
        this.c = this.ctx = this.ace = this.codeCanvas = null;
    };

    return Map;
})();

return module.exports = Map;

});
define('text!ext/minimap/style.css',[],function () { return '#minimapVisor {\n    position: absolute;\n    height: 0;\n    top: 0;\n    left: 0;\n    background: rgba(250, 250, 250, 0.2);\n}';});

/**
 * Utilities for the Ajax.org Cloud IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
define('core/util',['require','exports','module','core/util'],function(require, exports, module) {
    
exports.alert = function(title, header, msg, onhide) {
    winAlert.show();
    winAlert.setAttribute('title', title);
    winAlertHeader.$ext.innerHTML = header;
    winAlertMsg.$ext.innerHTML = msg;
    if (onhide)
        winAlert.onhide = function() {
            winAlertMsg.onhide = null;
            onhide();
        };
    else
        winAlert.onhide = null;
};

exports.confirm = function(title, header, msg, onconfirm, oncancel) {
    winConfirm.show();   
    winConfirm.setAttribute("title", title);
    winConfirmHeader.$ext.innerHTML = header;
    winConfirmMsg.$ext.innerHTML = msg;
    btnConfirmOk.onclick = onconfirm;
    btnConfirmCancel.onclick = oncancel;
};

exports.question = function(title, header, msg, onyes, onyestoall, onno, onnotoall) {
    winQuestion.show();   
    winQuestion.setAttribute("title", title);
    winQuestionHeader.$ext.innerHTML = header;
    winQuestionMsg.$ext.innerHTML = msg;
    btnQuestionYes.onclick = onyes;
    btnQuestionYesToAll.onclick = onyestoall;
    btnQuestionNo.onclick = onno;
    btnQuestionNoToAll.onclick = onnotoall;
};

exports.removeInteractive = function (amlNode) {
    if (window.cloud9config.readonly == true)
        return false;
    
    if (amlNode.confirmed == undefined)
        amlNode.confirmed = false;
    
    if (!amlNode.confirmed) {
        var files = amlNode.getSelection();

        function confirm(file) {
            var name = file.getAttribute("name");
            require("core/util").question(
                "Remove file?",
                "You are about to remove the file " + name,
                "Do you want continue? (This change cannot be undone)",
                function () { // Yes
                    amlNode.confirmed = true;
                    amlNode.remove(file);
                    amlNode.confirmed = false;
                    if (files.length > 0)
                        confirm(files.shift());
                    else
                        winQuestion.hide();
                },
                function () { // Yes to all
                    amlNode.confirmed = true;
                    amlNode.remove(file);
                    files.forEach(function (file) {
                        amlNode.remove(file);
                    });
                    amlNode.confirmed = false;
                    winQuestion.hide();
                },
                function () { // No
                    if (files.length > 0)
                        confirm(files.shift());
                    else
                        winQuestion.hide();
                },
                function () { // No to all
                    winQuestion.hide();
                }
            );
            btnQuestionYesToAll.setAttribute("visible", files.length > 0);
            btnQuestionNoToAll.setAttribute("visible", files.length > 0);
        }
        confirm(files.shift());
        return false;
    } else
        return true;
};

var SupportedIcons = {
   "application/xhtml+xml":'html',
   "text/css": "css",
   "text/x-scss": "css",
   "text/x-sass": "css",
   "text/html":'html',
    "application/pdf":'page_white_acrobat',
    "image":'image',
    "application/xml":'page_white_code_red',
    "image/svg+xml": "page_white_picture",
    "text/plain": 'page_white_text',
    "application/javascript": 'page_white_code',
    "application/json": 'page_white_code',
    "text/x-script.python": 'page_white_code',
    "text/x-script.ocaml": 'page_white_code',
    "text/x-script.clojure": 'page_white_code',
    "application/x-httpd-php": 'page_white_php',
    "text/x-coldfusion": 'page_white_php',
    "text/x-script.ruby": "page_white_ruby",
    "text/x-script.coffeescript": 'page_white_cup',
    "text/cpp": 'page_white_cplusplus',
    "text/x-c": 'page_white_c',
    "text/x-csharp": 'page_white_csharp',
    "text/text/x-java-source": 'page_white_cup',
    "text/x-markdown": 'page_white_text'
};
        
var contentTypes = {
    "js": "application/javascript",
    "json": "application/json",
    "css": "text/css",
    "scss": "text/x-scss",
    "sass": "text/x-sass",
    
    "xml": "application/xml",
    "rdf": "application/rdf+xml",
    "rss": "application/rss+xml",
    "svg": "image/svg+xml",
    "wsdl": "application/wsdl+xml",
    "xslt": "application/xslt+xml",
    "atom": "application/atom+xml",
    "mathml": "application/mathml+xml",
    "mml": "application/mathml+xml",
    
    "php": "application/x-httpd-php",
    "phtml": "application/x-httpd-php",
    "html": "text/html",
    "xhtml": "application/xhtml+xml",
    "coffee": "text/x-script.coffeescript",
    "py": "text/x-script.python",
    
    "ru": "text/x-script.ruby",
    "gemspec": "text/x-script.ruby",
    "rake": "text/x-script.ruby",
    "rb": "text/x-script.ruby",
    
    "c": "text/x-c",
    "cc": "text/x-c",
    "cpp": "text/x-c",
    "cxx": "text/x-c",
    "h": "text/x-c",
    "hh": "text/x-c",
    "hpp": "text/x-c",
    
    "bmp": "image",
    "djv": "image",
    "djvu": "image",
    "gif": "image",
    "ico": "image",
    "jpeg": "image",
    "jpg": "image",
    "pbm": "image",
    "pgm": "image",
    "png": "image",
    "pnm": "image",
    "ppm": "image",
    "psd": "image",
    "svgz": "image",
    "tif": "image",
    "tiff": "image",
    "xbm": "image",
    "xpm": "image",

    "clj": "text/x-script.clojure",
    "ml": "text/x-script.ocaml",
    "mli": "text/x-script.ocaml",
    "cfm": "text/x-coldfusion",
    "sql": "text/x-sql"
};
    
exports.getFileIcon = function(xmlNode) {
    var name = xmlNode.getAttribute('name');
    var icon  = "page_white_text";
    var ext;
    
    if (name) {
        ext = name.split(".").pop();
        icon = SupportedIcons[contentTypes[ext]] || "page_white_text";
    }
    return icon + ".png";
};

    
exports.getContentType = function(filename) {
    var type = filename.split(".").pop() || "";
    return contentTypes[type] || "text/plain";
};

exports.xmlEntityMap = {
    "quot": "34", "amp": "38", "apos": "39", "lt": "60", "gt": "62",
    "nbsp": "160", "iexcl": "161", "cent": "162", "pound": "163", "curren": "164",
    "yen": "165", "brvbar": "166", "sect": "167", "uml": "168", "copy": "169",
    "ordf": "170", "laquo": "171", "not": "172", "shy": "173", "reg": "174",
    "macr": "175", "deg": "176", "plusmn": "177", "sup2": "178", "sup3": "179",
    "acute": "180", "micro": "181", "para": "182", "middot": "183", "cedil": "184",
    "sup1": "185", "ordm": "186", "raquo": "187", "frac14": "188", "frac12": "189",
    "frac34": "190", "iquest": "191", "agrave": "192", "aacute": "193",
    "acirc": "194", "atilde": "195", "auml": "196", "aring": "197", "aelig": "198",
    "ccedil": "199", "egrave": "200", "eacute": "201", "ecirc": "202",
    "euml": "203", "igrave": "204", "iacute": "205", "icirc": "206", "iuml": "207",
    "eth": "208", "ntilde": "209", "ograve": "210", "oacute": "211", "ocirc": "212",
    "otilde": "213", "ouml": "214", "times": "215", "oslash": "216", "ugrave": "217",
    "uacute": "218", "ucirc": "219", "uuml": "220", "yacute": "221", "thorn": "222",
    "szlig": "223", "agrave": "224", "aacute": "225", "acirc": "226", "atilde": "227",
    "auml": "228", "aring": "229", "aelig": "230", "ccedil": "231", "egrave": "232",
    "eacute": "233", "ecirc": "234", "euml": "235", "igrave": "236", "iacute": "237",
    "icirc": "238", "iuml": "239", "eth": "240", "ntilde": "241", "ograve": "242",
    "oacute": "243", "ocirc": "244", "otilde": "245", "ouml": "246", "divide": "247",
    "oslash": "248", "ugrave": "249", "uacute": "250", "ucirc": "251", "uuml": "252",
    "yacute": "253", "thorn": "254", "yuml": "255", "oelig": "338", "oelig": "339",
    "scaron": "352", "scaron": "353", "yuml": "376", "fnof": "402", "circ": "710",
    "tilde": "732", "alpha": "913", "beta": "914", "gamma": "915", "delta": "916",
    "epsilon": "917", "zeta": "918", "eta": "919", "theta": "920", "iota": "921",
    "kappa": "922", "lambda": "923", "mu": "924", "nu": "925", "xi": "926",
    "omicron": "927", "pi": "928", "rho": "929", "sigma": "931", "tau": "932",
    "upsilon": "933", "phi": "934", "chi": "935", "psi": "936", "omega": "937",
    "alpha": "945", "beta": "946", "gamma": "947", "delta": "948", "epsilon": "949",
    "zeta": "950", "eta": "951", "theta": "952", "iota": "953", "kappa": "954",
    "lambda": "955", "mu": "956", "nu": "957", "xi": "958", "omicron": "959",
    "pi": "960", "rho": "961", "sigmaf": "962", "sigma": "963", "tau": "964",
    "upsilon": "965", "phi": "966", "chi": "967", "psi": "968", "omega": "969",
    "thetasym": "977", "upsih": "978", "piv": "982", "ensp": "8194", "emsp": "8195",
    "thinsp": "8201", "zwnj": "8204", "zwj": "8205", "lrm": "8206", "rlm": "8207",
    "ndash": "8211", "mdash": "8212", "lsquo": "8216", "rsquo": "8217",
    "sbquo": "8218", "ldquo": "8220", "rdquo": "8221", "bdquo": "8222",
    "dagger": "8224", "dagger": "8225", "bull": "8226", "hellip": "8230",
    "permil": "8240", "prime": "8242", "prime": "8243", "lsaquo": "8249",
    "rsaquo": "8250", "oline": "8254", "frasl": "8260", "euro": "8364",
    "image": "8465", "weierp": "8472", "real": "8476", "trade": "8482",
    "alefsym": "8501", "larr": "8592", "uarr": "8593", "rarr": "8594",
    "darr": "8595", "harr": "8596", "crarr": "8629", "larr": "8656", "uarr": "8657",
    "rarr": "8658", "darr": "8659", "harr": "8660", "forall": "8704", "part": "8706",
    "exist": "8707", "empty": "8709", "nabla": "8711", "isin": "8712",
    "notin": "8713", "ni": "8715", "prod": "8719", "sum": "8721", "minus": "8722",
    "lowast": "8727", "radic": "8730", "prop": "8733", "infin": "8734",
    "ang": "8736", "and": "8743", "or": "8744", "cap": "8745", "cup": "8746",
    "int": "8747", "there4": "8756", "sim": "8764", "cong": "8773", "asymp": "8776",
    "ne": "8800", "equiv": "8801", "le": "8804", "ge": "8805", "sub": "8834",
    "sup": "8835", "nsub": "8836", "sube": "8838", "supe": "8839", "oplus": "8853",
    "otimes": "8855", "perp": "8869", "sdot": "8901", "lceil": "8968",
    "rceil": "8969", "lfloor": "8970", "rfloor": "8971", "lang": "9001",
    "rang": "9002", "loz": "9674", "spades": "9824", "clubs": "9827",
    "hearts": "9829", "diams": "9830"
};

/**
 * Escape an xml string making it ascii compatible.
 * @param  {String}  str      the xml string to escape.
 * @param  {Boolean} noQuotes do not escape quotes.
 * @return {String} the escaped string.
 */
exports.escapeXml = function(str, noQuotes) {
    str = (String(str) || "")
        .replace(/&/g, "&#38;")
        .replace(/</g, "&#60;")
        .replace(/>/g, "&#62;");
    if (!noQuotes) {
        str = str.replace(/"/g, "&#34;")
                 .replace(/'/g, "&#39;");
    }
    return str.replace(/&([a-z]+);/gi, function(a, m) {
        if (exports.xmlEntityMap[(m = m.toLowerCase())])
            return "&#" + exports.xmlEntityMap[m] + ";";
        return a;
    });
};

/*
 * JavaScript Linkify - v0.3 - 6/27/2009
 * http://benalman.com/projects/javascript-linkify/
 * 
 * Copyright (c) 2009 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 * 
 * Some regexps adapted from http://userscripts.org/scripts/review/7122
 */
exports.linkify=function(){var k="[a-z\\d.-]+://",h="(?:(?:[0-9]|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.){3}(?:[0-9]|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])",c="(?:(?:[^\\s!@#$%^&*()_=+[\\]{}\\\\|;:'\",.<>/?]+)\\.)+",n="(?:ac|ad|aero|ae|af|ag|ai|al|am|an|ao|aq|arpa|ar|asia|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|biz|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|cat|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|coop|com|co|cr|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|ec|edu|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gov|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|info|int|in|io|iq|ir|is|it|je|jm|jobs|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mil|mk|ml|mm|mn|mobi|mo|mp|mq|mr|ms|mt|museum|mu|mv|mw|mx|my|mz|name|na|nc|net|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|org|pa|pe|pf|pg|ph|pk|pl|pm|pn|pro|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tel|tf|tg|th|tj|tk|tl|tm|tn|to|tp|travel|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|xn--0zwm56d|xn--11b5bs3a9aj6g|xn--80akhbyknj4f|xn--9t4b11yi5a|xn--deba0ad|xn--g6w251d|xn--hgbk6aj7f53bba|xn--hlcj6aya9esc7a|xn--jxalpdlp|xn--kgbechtv|xn--zckzah|ye|yt|yu|za|zm|zw)",f="(?:"+c+n+"|"+h+")",o="(?:[;/][^#?<>\\s]*)?",e="(?:\\?[^#<>\\s]*)?(?:#[^<>\\s]*)?",d="\\b"+k+"[^<>\\s]+",a="\\b"+f+o+e+"(?!\\w)",m="mailto:",j="(?:"+m+")?[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@"+f+e+"(?!\\w)",l=new RegExp("(?:"+d+"|"+a+"|"+j+")","ig"),g=new RegExp("^"+k,"i"),b={"'":"`",">":"<",")":"(","]":"[","}":"{","B;":"B+","b:":"b9"},i={callback:function(q,p){return p?'<a href="'+p+'" title="'+p+'">'+q+"</a>":q},punct_regexp:/(?:[!?.,:;'"]|(?:&|&amp;)(?:lt|gt|quot|apos|raquo|laquo|rsaquo|lsaquo);)$/};return function(u,z){z=z||{};var w,v,A,p,x="",t=[],s,E,C,y,q,D,B,r;for(v in i){if(z[v]===undefined){z[v]=i[v]}}while(w=l.exec(u)){A=w[0];E=l.lastIndex;C=E-A.length;if(/[\/:]/.test(u.charAt(C-1))){continue}do{y=A;r=A.substr(-1);B=b[r];if(B){q=A.match(new RegExp("\\"+B+"(?!$)","g"));D=A.match(new RegExp("\\"+r,"g"));if((q?q.length:0)<(D?D.length:0)){A=A.substr(0,A.length-1);E--}}if(z.punct_regexp){A=A.replace(z.punct_regexp,function(F){E-=F.length;return""})}}while(A.length&&A!==y);p=A;if(!g.test(p)){p=(p.indexOf("@")!==-1?(!p.indexOf(m)?"":m):!p.indexOf("irc.")?"irc://":!p.indexOf("ftp.")?"ftp://":"http://")+p}if(s!=C){t.push([u.slice(s,C)]);s=E}t.push([A,p])}t.push([u.substr(s)]);for(v=0;v<t.length;v++){x+=z.callback.apply(window,t[v])}return x||u}}();

});

/**
 * Main IDE object for the Ajax.org Cloud IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('core/ide',['require','exports','module','core/document','core/util'],function(require, exports, module) {
    var Document = require("core/document");
    var util = require("core/util");

    var ide = new apf.Class().$init();

    ide.createDocument = function(node, value){
        return new Document(node, value);
    };

    ide.start = function() {
        //Set references to global elements - aka extension points
        //this.tbMain       = tbMain;
        this.mnuFile        = mnuFile;
        this.mnuEdit        = mnuEdit;
        //this.barMenu      = barMenu;
        this.barTools       = barTools;
        this.sbMain         = sbMain;
        this.vbMain         = vbMain;

        this.workspaceDir   = window.cloud9config.workspaceDir.replace(/\/+$/, "");
        this.davPrefix      = window.cloud9config.davPrefix.replace(/\/+$/, "");
        this.staticPrefix   = window.cloud9config.staticUrl;
        this.sessionId      = window.cloud9config.sessionId;
        this.workspaceId    = window.cloud9config.workspaceId;
        this.readonly       = window.cloud9config.readonly;
        this.projectName    = window.cloud9config.projectName;

        this.loggedIn       = true;
            //Set references to global elements - aka extension points
            //this.tbMain       = tbMain;
            this.mnuFile        = mnuFile;
            this.mnuEdit        = mnuEdit;
            //this.barMenu      = barMenu;
            this.barTools       = barTools;
            this.sbMain         = sbMain;
            this.vbMain         = vbMain;

        this.onLine         = false;
        this.offlineFileSystemSupport = false;

        this.dispatchEvent("load");

        /**** Error Handling ****/

        //Catch all unhandled errors
        var loc = location.href;
        if (
            location.protocol != "file:"
            && loc.indexOf("dev") == -1
            && (loc.indexOf("cloud9ide.com") > -1 || loc.indexOf("c9.io") > -1))
        {
            window.onerror = function(m, u, l) {
                if (window.console)
                    console.log("An error occurred, the Cloud9 system admin has been notified.");
                apf.ajax("/debug", {
                    method      : "POST",
                    contentType : "application/json",
                    data        : apf.serialize({
                        agent       : navigator.userAgent,
                        type        : "General Javascript Error",
                        e           : [m, u, l],
                        workspaceId : ide.workspaceId
                    })
                });
                return true;
            };

            //Catch all APF Routed errors
            apf.addEventListener("error", function(e){
                apf.ajax("/debug", {
                    method      : "POST",
                    contentType : "application/json",
                    data        : apf.serialize({
                        agent       : navigator.userAgent,
                        type        : "APF Error",
                        message     : e.message,
                        tgt         : e.currentTarget && e.currentTarget.serialize(),
                        url         : e.url,
                        state       : e.state,
                        e           : e.error,
                        workspaceId : ide.workspaceId
                    })
                });
            });
        }
        else {
//                window.onerror = function(m, u, l) {
//                    window.console && console.error("An error occurred", m, u, l);
//                }
            apf.addEventListener("error", function(e){
                window.console && console.error("An APF error occurred", e);
            });
        }
    };

    apf.addEventListener("load", function(){
        ide.start();
    });

    ide.addEventListener("extload", function() {
        // fire up the socket connection:
        var options = {
            "remember transport": false,
            transports:  ["websocket", "htmlfile", "xhr-multipart", "xhr-polling"],
            reconnect: false,
            resource: window.cloud9config.socketIoUrl,
            "connect timeout": 500,
            "try multiple transports": true,
            "transport options": {
                "xhr-polling": {
                    timeout: 60000
                },
                "jsonp-polling": {
                    timeout: 60000
                }
            }
        };

        ide.socketConnect = function() {
            clearInterval(ide.$retryTimer);

            ide.socket.json.send({
                command: "attach",
                sessionId: ide.sessionId,
                workspaceId: ide.workspaceId
            });
        };

        ide.socketReconnect = function() {
            // on a reconnect of the socket.io connection, the server may have
            // lost our session. Now we do an HTTP request to fetch the current
            // session ID and update the Cloud9 config with it. Also, re-attach
            // with the backend.
            apf.ajax((window.location.pathname + "/$reconnect").replace(/\/\//g, "/"), {
                callback: function(data, state, extra) {
                    ide.sessionId = data;
                    ide.socketConnect();
                }
            });
        };

        ide.socketDisconnect = function() {
            clearTimeout(ide.$retryTimer);

            var retries = 0;
            ide.$retryTimer = setInterval(function() {
                if (++retries == 3)
                    ide.dispatchEvent("socketDisconnect");

                var sock = ide.socket.socket;
                if (!sock.connecting && !sock.reconnecting && !ide.testOffline && ide.loggedIn)
                    sock.reconnect();
            }, 1000);
        };

        ide.socketMessage = function(message) {
            if (typeof message == "string") {
                try {
                    message = JSON.parse(message);
                }
                catch(e) {
                    window.console && console.error("Error parsing socket message", e, "message:", message);
                    return;
                }
            }

            if (message.type == "attached")
                ide.dispatchEvent("socketConnect"); //This is called too often!!

            ide.dispatchEvent("socketMessage", {
                message: message
            });
        };

        // for unknown reasons io is sometimes undefined
        try {
            ide.socket = io.connect(null, options);
        }
        catch (e) {
            util.alert(
                "Error starting up",
                "Error starting up the IDE", "There was an error starting up the IDE.<br>Please clear your browser cache and reload the page.",
                function() {
                    window.location.reload();
                }
            );

            var socketIoScriptEl = Array.prototype.slice.call(
                document.getElementsByTagName("script")).filter(function(script) {
                    return script.src && script.src.indexOf("socket.io.js") >= 0;
                }
            )[0];

            var status;
            if (socketIoScriptEl) {
                apf.ajax(socketIoScriptEl.src, {
                    callback: function(data, state, extra) {
                        try {
                            status = parseInt(extra.http.status, 10);
                        } catch(ex) {}
                        apf.dispatchEvent("error", {
                            message: "socket.io client lib not loaded",
                            error: {
                                status: status,
                                state: state,
                                data: data,
                                extra: extra
                            }
                        });
                    }
                });
            } else {
                apf.dispatchEvent("error", {
                    message: "socket.io client lib not loaded",
                    error: e
                });
            }
            return;
        }

        ide.socket.on("message",    ide.socketMessage);
        ide.socket.on("connect",    ide.socketConnect);
        ide.socket.on("reconnect",  ide.socketReconnect);
        //ide.socket.on("reconnecting",  ide.socketReconnecting);
        ide.socket.on("disconnect", ide.socketDisconnect);
        this.inited = true;
    });

    ide.$msgQueue = [];
    ide.addEventListener("socketConnect", function() {
        while(ide.$msgQueue.length) {
            var q = ide.$msgQueue;
            ide.$msgQueue = [];
            q.forEach(function(msg) {
                ide.socket.json.send(msg);
            });
        }
    });

    ide.send = function(msg) {
        if (!ide.socket || !ide.socket.socket.connected) {
            ide.$msgQueue.push(msg);
            return;
        }

        ide.socket.json.send(msg);
    };

    ide.getActivePageModel = function() {
        var page = tabEditors.getPage();
        if (!page)
            return null;

        return page.$model.data;
    };

    ide.getAllPageModels = function() {
        return tabEditors.getPages().map(function(page) {
            return page.$model.data;
        });
    };

    module.exports = ide;
});

/**
 * Offline Support for Cloud9
 *
 * @copyright 2011, Ajax.org B.V.
 */

define('ext/offline/lib-offlinedav',['require','exports','module','core/ide','ext/offline/lib-offlinefs'],function(require, exports, module) {

var ide                 = require('core/ide');
var OfflineFileSystem   = require("ext/offline/lib-offlinefs");

var WebdavHtml5FileSystem = module.exports = function(callback, sync) {
    var _self   = this;
    this.sync   = sync;
    this.fs     = new OfflineFileSystem();
    
    this.fs.setFileSystem(this.fs.PERSISTENT, 1024, function(error, webfs){
        if (error)
            console.log(error);
        
        _self.webfs = webfs;
        _self.offlinefs = webfs.fs;
        _self.offlineroot = webfs.root;
        
        _self.loaded    = true;
        callback.apply(window, arguments);
        _self.emptyQueue();
    });
};

WebdavHtml5FileSystem.isAvailable = function(){
    return !!window.requestFileSystem;
};

(function() {
    this.available = true;
    this.fake      = true;
    
    this.$queue = [];
    this.queue = function(method, args) {
        this.$queue.push([method, args]);
    };
    this.emptyQueue = function() {
        var _self = this;
        this.$queue.each(function(item) {
            item[0].apply(_self, item[1]);
        });
        this.$queue = [];
    };
    
    
    this.exists = function(path, callback) {
        if (!this.loaded)
            return this.queue(this.exists, arguments);
        var new_path = path.replace(new RegExp("^" + ide.davPrefix.replace(/\//g, "\\/")), '/' + ide.projectName);
        var _self = this;
        
        this.webfs.open(new_path, 'r', function(error, handler) {
            if (error)
                callback(false);
            else
                callback(true);
        });
    };
    
    
    /**
    * Read function here currently takes in content as a string,
    * we probably want to do some MIME checking here for binary
    * files
    */
    this.read = function(path, callback){
        if (!this.loaded)
            return this.queue(this.read, arguments);
            
        var new_path = path.replace(new RegExp("^" + ide.davPrefix.replace(/\//g, "\\/")), '/' + ide.projectName);
        var _self = this;
        this.webfs.readFile(new_path, function(error, read, buffer) {
            if (error)
                return _self.handleError(callback, error);
            
            _self.webfs.readString(buffer, function(error, data) {
                if (error)
                    return _self.handleError(callback, error);
                callback(data, apf.SUCCESS, {});    
            });
        });
        /*
        if (localStorage[fIdent]) {
            var files = JSON.parse(localStorage[fIdent]);
            if (files[path])
                return callback(files[path], apf.SUCCESS, {});
        }
        this.handleError(callback);
        */
    };
    /**
     * Here we write the file to the file system, then we also
     * need to add it to the sync operations for that file
     * when we go online
     */
    this.writeFile = 
    this.write     = function(path, data, x, callback){
        if (!this.loaded)
            return this.queue(this.write, arguments);

        var new_path = path.replace(new RegExp("^" + ide.davPrefix.replace(/\//g, "\\/")), '/' + ide.projectName);
        var _self = this;
        
        this.webfs.writeFile(new_path, data, function(error, buffer) {
            if (error)
                return _self.handleError(callback, error);
            
            if (!ide.onLine) {
                _self.sync.add(path, {
                    type: "webdav-write",
                    date: new Date().getTime(),
                    path: path,
                    data: data
                });
                callback(data, apf.SUCCESS, {});
            }
        });
    };
    /**
     * method to do a ls on a directory, this returns
     * an array of FileEntry and DirectoryEntry objects
     * which can be itterated over to generate
     * a tree path
     */
    this.readdir = 
    this.scandir = 
    this.list    = function(path, callback){
        if (!this.loaded)
            return this.queue(this.list, arguments);
        
        var new_path = path.replace(new RegExp("^" + ide.davPrefix.replace(/\//g, "\\/")), '/' + ide.projectName);
        var _self = this,
            name_array,
            name;
        this.webfs.readdir(new_path, function(error, items) {
            if (error)
                return _self.handleError(callback, error);
                
            var output = [];
            var total = 0;
            
            var handleOpen = function(error, handler) {
                if (error)
                    return;
                    
                if (handler.isDirectory) {
                    output.push('<folder path="' + handler.fullPath.replace(new RegExp('^\\/' + ide.projectName), ide.davPrefix) + '"  type="folder" size="0" name="' + handler.name + '" contenttype="" modifieddate="" creationdate="" lockable="false" hidden="false" executable="false" />');
                } else if (handler.isFile) {
                    output.push('<file path="' + handler.fullPath.replace(new RegExp('^\\/' + ide.projectName), ide.davPrefix) + '"  type="file" size="" name="' + handler.name + '" contenttype="" modifieddate="" creationdate="" lockable="false" hidden="false" executable="false" />');
                }
                
                total++;
                
                if (total == items.length) {
                    callback('<files>' + output.join('\n') + '</files>', apf.SUCCESS, {});
                }
            };
            
            for (var i = 0, j = items.length; i < j; i++) {
                var item = items[i];
                _self.webfs.open(item, handleOpen);
            }
        });
    };
    
    this.rename =
    this.move = function(sFrom, sTo, bOverwrite, bLock, callback) {
        if (!this.loaded)
            return this.queue(this.move, arguments);
            
        var new_from = sFrom.replace(new RegExp("^" + ide.davPrefix.replace(/\//g, "\\/")), '/' + ide.projectName);
        var new_to = sTo.replace(new RegExp("^" + ide.davPrefix.replace(/\//g, "\\/")), '/' + ide.projectName);
        var _self = this;
        
        this.webfs.rename(new_from, new_to, function(error, newDirEntry) {
            if (error)
                return _self.handleError(callback, error);
                
            if (!ide.onLine) {
                _self.sync.add(sFrom, {
                    type: "webdav-move",
                    date: new Date().getTime(),
                    path: sFrom,
                    data: sTo
                });
                callback("", apf.SUCCESS, {});
            }
        });
    };
    
    //@todo move stuff from exec
    this.mkdir = function(sPath, bLock, callback) {
        var new_path = sPath.replace(new RegExp("^" + ide.davPrefix.replace(/\//g, "\\/")), '/' + ide.projectName);
        
        this.webfs.mkdir(new_path, function(error, directory) {
            if (error)
                return _self.handleError(callback, error);
                
            if (!ide.onLine) {
                _self.sync.add(sPath, {
                    type: "webdav-mkdir",
                    date: new Date().getTime(),
                    path: sPath,
                    data: null
                });
               callback("", apf.SUCCESS, {});
            }
        });
    };
    
    //@todo test this
    this.remove = function(sPath, bLock, callback) {
        if (!this.loaded)
            return this.queue(this.remove, arguments);
        var new_path = sPath.replace(new RegExp("^" + ide.davPrefix.replace(/\//g, "\\/")), '/' + ide.projectName);
        var _self = this;
        
        this.webfs.unlink(new_path, function(error) {
            if (error)
                return _self.handleError(callback, error);
                
            if (!ide.onLine) {
                _self.sync.add(sPath, {
                    type: "webdav-remove",
                    date: new Date().getTime(),
                    path: sPath
                });
                callback("", apf.SUCCESS, {});
            }
        });
    };
    
    //@todo
    this.copy = function(sFrom, sTo, bOverwrite, bLock, callback) {
        if (!this.loaded)
            return this.queue(this.move, arguments);
        var new_from = sFrom.replace(new RegExp("^" + ide.davPrefix.replace(/\//g, "\\/")), '/' + ide.projectName);
        var new_to = sTo.replace(new RegExp("^" + ide.davPrefix.replace(/\//g, "\\/")), '/' + ide.projectName);
        var _self = this;
        
        this.webfs.copy(new_from, new_to, function(error, newDirEntry) {
            if (error)
                return _self.handleError(callback, error);
            
            if (!ide.onLine) {
                _self.sync.add(sFrom, {
                    type: "webdav-move",
                    date: new Date().getTime(),
                    path: sFrom,
                    data: sTo
                });
                callback("", apf.SUCCESS, {});
            }
        });
    };
    
    //@todo fix double entries (move implementations to functions - Watch out for different arguments!!)
    this.exec = function(type, args, cb) {
        if (!this.loaded)
            return this.queue(this.exec, arguments);
        
        var _self = this,
            ful_path;
        switch(type) {
            //@todo this should be same as write file
            case "create":
                /**
                 * Here we create an empty file based on the path
                 * and filename passed, may have issues due to 
                 * the way directories and files are created (non-recursive)
                 */
                //args = [path, filename];
                //path = args[0].replace(new RegExp("^" + ide.davPrefix.replace(/\//g, "\\/")), '/' + ide.projectName);
                full_path = args[0] + '/' + args[1];
                this.write(full_path, 'empty_file', null, cb);
            break;
            case "move":
            case "mv":
            case "rename":
                var tmp = args[1].split('/');
                tmp.pop();
                var new_to = tmp.join('/') + "/" + args[0];
                this.rename(args[1], new_to, false, false, cb);
            break;
            case "login":
            case "authenticate":
                break;
            case "logout":
                break;
            case "exists":
                this.exists(args[0], cb);
                break;
            case "read":
                this.readFile(args[0], cb);
                break;
            case "create":
                full_path = args[0] ? args[0] : "";
                if (full_path.charAt(full_path.length - 1) != "/")
                    full_path = full_path + "/";
                this.writeFile(full_path + args[1], args[2], args[3] || false, cb);
                break;
            case "write":
            case "store":
            case "save":
                this.writeFile(args[0], args[1], args[2] || false, cb);
                break;
            case "copy":
            case "cp":
                this.copy(args[0], args[1], args[2] || true, args[3] || false, cb);
                break;
            case "rename":
                var sBasepath = args[1].substr(0, args[1].lastIndexOf("/") + 1);
                this.rename(args[1], sBasepath + args[0], args[2] || false, args[3] || false, cb);
                break;
            case "move":
            case "mv":
                full_path = args[1];
                if (full_path.charAt(full_path.length - 1) != "/")
                    full_path = full_path + "/";
                this.rename(args[0], full_path + args[0].substr(args[0].lastIndexOf("/") + 1),
                    args[2] || false, args[3] || false, cb);
                break;
            case "remove":
            case "rmdir":
            case "rm":
                this.remove(args[0], args[1] || false, cb);
                break;
            case "readdir":
            case "scandir":
                if (!ide.onLine)
                    this.readdir(args[0], cb);
                break;
            case "getroot":
                this.getProperties(this.$rootPath, 0, cb);
                break;
            case "mkdir":
                full_path = args[0] ? args[0] : "";
                if (full_path.charAt(full_path.length - 1) != "/")
                    full_path = full_path + "/";
                this.mkdir(full_path + args[1], args[2] || false, cb);
                break;
            case "lock":
                this.lock(args[0], null, null, null, cb);
                break;
            case "unlock":
                this.unlock(args[0], cb);
                break;
            case "report":
                break;
            default:
                //#ifdef __DEBUG
                throw new Error(apf.formatErrorString(0, null, "Saving/Loading data",
                    "Invalid WebDAV method '" + method + "'"));
                //#endif
                break;
        }
    };
    
    this.handleError = function(callback, error) {
        callback(null, apf.ERROR, error ? {message: error.code} : {});
    };
}).call(WebdavHtml5FileSystem.prototype = new apf.Class().$init());

});
"use strict";

define('ext/vim/maps/util',['require','exports','module','ext/vim/registers','core/ide'],function(require, exports, module) {
var registers = require("ext/vim/registers");
var ide = require("core/ide");

module.exports = {
    onVisualMode: false,
    onVisualLineMode: false,
    currentMode: 'normal',
    insertMode: function(editor) {
        var _self = this;
        var theme = editor && editor.getTheme() || "ace/theme/textmate";

        ide.dispatchEvent("vim.changeMode", { mode : "insert" });

        require(["require", theme], function (require) {
            var isDarkTheme = require(theme).isDark;

            _self.currentMode = 'insert';
            // Switch editor to insert mode
            editor.unsetStyle('insert-mode');

            var cursor = document.getElementsByClassName("ace_cursor")[0];
            if (cursor) {
                cursor.style.display = null;
                cursor.style.backgroundColor = null;
                cursor.style.opacity = null;
                cursor.style.border = null;
                cursor.style.borderLeftColor = isDarkTheme? "#eeeeee" : "#333333";
                cursor.style.borderLeftStyle = "solid";
                cursor.style.borderLeftWidth = "2px";
            }

            editor.setOverwrite(false);
            editor.keyBinding.$data.buffer = "";
            editor.keyBinding.$data.state = "insertMode";
            _self.onVisualMode = false;
            _self.onVisualLineMode = false;
            if(_self.onInsertReplaySequence) {
                // Ok, we're apparently replaying ("."), so let's do it
                editor.commands.macro = _self.onInsertReplaySequence;
                editor.commands.replay(editor);
                _self.onInsertReplaySequence = null;
                _self.normalMode(editor);
            } else {
                // Record any movements, insertions in insert mode
                if(!editor.commands.recording)
                    editor.commands.toggleRecording();
            }
        });
    },
    normalMode: function(editor) {
        // Switch editor to normal mode
        this.currentMode = 'normal';
        
        ide.dispatchEvent("vim.changeMode", { mode : "normal" });

        editor.setStyle('normal-mode');
        editor.clearSelection();

        var cursor = document.getElementsByClassName("ace_cursor")[0];
        if (cursor) {
            cursor.style.display = null;
            cursor.style.backgroundColor = "red";
            cursor.style.opacity = ".5";
            cursor.style.border = "0";
        }

        var pos;
        if (!editor.getOverwrite()) {
            pos = editor.getCursorPosition();
            if (pos.column > 0)
                editor.navigateLeft();
        }
        editor.setOverwrite(true);
        editor.keyBinding.$data.buffer = "";
        editor.keyBinding.$data.state = "start";
        this.onVisualMode = false;
        this.onVisualLineMode = false;
        // Save recorded keystrokes
        if(editor.commands.recording) {
            editor.commands.toggleRecording();
            return editor.commands.macro;
        }
        else {
            return [];
        }
    },
    getRightNthChar: function(editor, cursor, char, n) {
        var line = editor.getSession().getLine(cursor.row);
        var matches = line.substr(cursor.column + 1).split(char);

        return n < matches.length ? matches.slice(0, n).join(char).length : 0;
    },
    getLeftNthChar: function(editor, cursor, char, n) {
        var line = editor.getSession().getLine(cursor.row);
        var matches = line.substr(0, cursor.column).split(char);

        return n < matches.length ? matches.slice(-1 * n).join(char).length + 2 : 0;
    },
    toRealChar: function(char) {
        if (char.length === 1)
            return char;

        if (/^shift-./.test(char))
            return char[char.length - 1].toUpperCase();
        else
            return "";
    },
    copyLine: function(editor) {
        var pos = editor.getCursorPosition();
        editor.selection.clearSelection();
        editor.moveCursorTo(pos.row, pos.column);
        editor.selection.selectLine();
        registers._default.isLine = true;
        registers._default.text = editor.getCopyText().replace(/\n$/, "");
        editor.selection.clearSelection();
        editor.moveCursorTo(pos.row, pos.column);
    }
};
});

"use strict"

define('ext/vim/maps/motions',['require','exports','module','ext/vim/maps/util'],function(require, exports, module) {

var util = require("ext/vim/maps/util");

var keepScrollPosition = function(editor, fn) {
    var scrollTopRow = editor.renderer.getScrollTopRow();
    var initialRow = editor.getCursorPosition().row;
    var diff = initialRow - scrollTopRow;
    fn && fn.call(editor);
    editor.renderer.scrollToRow(editor.getCursorPosition().row - diff);
};

module.exports = {
    "w": {
        nav: function(editor) {
            editor.navigateWordRight();
        },
        sel: function(editor) {
            editor.selection.selectWordRight();
        }
    },
    "b": {
        nav: function(editor) {
            editor.navigateWordLeft();
        },
        sel: function(editor) {
            editor.selection.selectWordLeft();
        }
    },
    "l": {
        nav: function(editor) {
            editor.navigateRight();
        },
        sel: function(editor) {
            var pos = editor.getCursorPosition();
            var col = pos.column;
            var lineLen = editor.session.getLine(pos.row).length;

            // Solving the behavior at the end of the line due to the
            // different 0 index-based colum positions in ACE.
            if (lineLen && col !== lineLen) //In selection mode you can select the newline
                editor.selection.selectRight();
        }
    },
    "h": {
        nav: function(editor) {
            var pos = editor.getCursorPosition();
            if (pos.column > 0)
                editor.navigateLeft();
        },
        sel: function(editor) {
            var pos = editor.getCursorPosition();
            if (pos.column > 0)
                editor.selection.selectLeft();
        }
    },
    "k": {
        nav: function(editor) {
            editor.navigateUp();
        },
        sel: function(editor) {
            editor.selection.selectUp();
        }
    },
    "j": {
        nav: function(editor) {
            editor.navigateDown();
        },
        sel: function(editor) {
            editor.selection.selectDown();
        }
    },
    "i": {
        param: true,
        sel: function(editor, range, count, param) {
            switch (param) {
                case "w":
                    editor.selection.selectWord();
            }
        }
    },
    "a": {
        param: true,
        sel: function(editor, range, count, param) {
            switch (param) {
                case "w":
                    editor.selection.selectAWord();
            }
        }
    },
    "f": {
        param: true,
        nav: function(editor, range, count, param) {
            count = parseInt(count, 10) || 1;
            var ed = editor;
            var cursor = ed.getCursorPosition();
            var column = util.getRightNthChar(editor, cursor, param, count);

            if (typeof column === "number") {
                ed.selection.clearSelection(); // Why does it select in the first place?
                ed.moveCursorTo(cursor.row, column + cursor.column + 1);
            }
        },
        sel: function(editor, range, count, param) {
            count = parseInt(count, 10) || 1;
            var ed = editor;
            var cursor = ed.getCursorPosition();
            var column = util.getRightNthChar(editor, cursor, param, count);

            if (typeof column === "number") {
                ed.moveCursorTo(cursor.row, column + cursor.column + 1);
            }
        }
    },
    "shift-f": {
        param: true,
        nav: function(editor, range, count, param) {
            count = parseInt(count, 10) || 1;
            var ed = editor;
            var cursor = ed.getCursorPosition();
            var column = util.getLeftNthChar(editor, cursor, param, count);

            if (typeof column === "number") {
                ed.selection.clearSelection(); // Why does it select in the first place?
                ed.moveCursorTo(cursor.row, cursor.column - column + 1);
            }
        },
        sel: function(editor, range, count, param) {
            count = parseInt(count, 10) || 1;
            var ed = editor;
            var cursor = ed.getCursorPosition();
            var column = util.getLeftNthChar(editor, cursor, param, count);

            if (typeof column === "number") {
                ed.moveCursorTo(cursor.row, cursor.column - column + 1);
            }
        }
    },
    "t": {
        param: true,
        nav: function(editor, range, count, param) {
            count = parseInt(count, 10) || 1;
            var ed = editor;
            var cursor = ed.getCursorPosition();
            var column = util.getRightNthChar(editor, cursor, param, count);

            if (typeof column === "number") {
                ed.selection.clearSelection(); // Why does it select in the first place?
                ed.moveCursorTo(cursor.row, column + cursor.column);
            }
        },
        sel: function(editor, range, count, param) {
            count = parseInt(count, 10) || 1;
            var ed = editor;
            var cursor = ed.getCursorPosition();
            var column = util.getRightNthChar(editor, cursor, param, count);

            if (typeof column === "number") {
                ed.moveCursorTo(cursor.row, column + cursor.column);
            }
        }
    },
    "^": {
        nav: function(editor) {
            editor.navigateLineStart();
        },
        sel: function(editor) {
            editor.selection.selectLineStart();
        }
    },
    "$": {
        nav: function(editor) {
            editor.navigateLineEnd();
        },
        sel: function(editor) {
            editor.selection.selectLineEnd();
        }
    },
    "0": {
        nav: function(editor) {
            var ed = editor;
            ed.navigateTo(ed.selection.selectionLead.row, 0);
        },
        sel: function(editor) {
            var ed = editor;
            ed.selectTo(ed.selection.selectionLead.row, 0);
        }
    },
    "shift-g": {
        nav: function(editor, range, count, param) {
            count = parseInt(count, 10);
            if (!count && count !== 0) { // Stupid JS
                count = editor.session.getLength();
            }
            editor.gotoLine(count);
        },
        sel: function(editor, range, count, param) {
            count = parseInt(count, 10);
            if (!count && count !== 0) { // Stupid JS
                count = editor.session.getLength();
            }
            editor.selection.selectTo(count, 0);
        }
    },
    "ctrl-d": {
        nav: function(editor, range, count, param) {
            editor.selection.clearSelection();
            keepScrollPosition(editor, editor.gotoPageDown);
        },
        sel: function(editor, range, count, param) {
            keepScrollPosition(editor, editor.selectPageDown);
        }
    },
    "ctrl-u": {
        nav: function(editor, range, count, param) {
            editor.selection.clearSelection();
            keepScrollPosition(editor, editor.gotoPageUp);

        },
        sel: function(editor, range, count, param) {
            keepScrollPosition(editor, editor.selectPageUp);
        }
    },
    "g": {
        param: true,
        nav: function(editor, range, count, param) {
            switch(param) {
                case "m":
                    console.log("Middle line");
                    break;
                case "e":
                    console.log("End of prev word");
                    break;
                case "g":
                    editor.gotoLine(count || 0);
            }
        },
        sel: function(editor, range, count, param) {
            switch(param) {
                case "m":
                    console.log("Middle line");
                    break;
                case "e":
                    console.log("End of prev word");
                    break;
                case "g":
                    editor.selection.selectTo(count || 0, 0);
            }
        }
    },
    "o": {
        nav: function(editor, range, count, param) {
            count = count || 1;
            var content = "";
            while (0 < count--)
                content += "\n";

            if (content.length) {
                editor.navigateLineEnd()
                editor.insert(content);
                util.insertMode(editor);
            }
        }
    },
    "shift-o": {
        nav: function(editor, range, count, param) {
            var row = editor.getCursorPosition().row;
            count = count || 1;
            var content = "";
            while (0 < count--)
                content += "\n";

            if (content.length) {
                if(row > 0) {
                    editor.navigateUp();
                    editor.navigateLineEnd()
                    editor.insert(content);
                } else {
                    editor.session.insert({row: 0, column: 0}, content);
                    editor.navigateUp();
                }
                util.insertMode(editor);
            }
        }
    },
    "%": {
        nav: function(editor, range, count, param) {
            var cursor = editor.getCursorPosition();
            var match = editor.session.findMatchingBracket({
                row: cursor.row,
                column: cursor.column + 1
            });

            if (match)
                editor.moveCursorTo(match.row, match.column);
        }
    }
};

module.exports.backspace = module.exports.left = module.exports.h;
module.exports.right = module.exports.l;
module.exports.up = module.exports.k;
module.exports.down = module.exports.j;
module.exports.pagedown = module.exports["ctrl-d"];
module.exports.pageup = module.exports["ctrl-u"];

});

define('ext/vim/maps/operators',['require','exports','module','ext/vim/maps/util','ext/vim/registers'],function(require, exports, module) {

"use strict";

var util = require("ext/vim/maps/util");
var registers = require("ext/vim/registers");

module.exports = {
    "d": {
            selFn: function(editor, range, count, param) {
                registers._default.text = editor.getCopyText();
                registers._default.isLine = util.onVisualLineMode;
                if(util.onVisualLineMode)
                    editor.removeLines();
                else
                    editor.session.remove(range);
                util.normalMode(editor);
            },
            fn: function(editor, range, count, param) {
                count = parseInt(count || 1, 10);
                switch (param) {
                    case "d":
                        registers._default.text = "";
                        registers._default.isLine = true;
                        for (var i=0; i<count; i++) {
                            editor.selection.selectLine();
                            registers._default.text += editor.getCopyText();
                            var selRange = editor.getSelectionRange();
                            editor.session.remove(selRange);
                            editor.selection.clearSelection();
                        }
                        registers._default.text = registers._default.text.replace(/\n$/, "");
                        break;
                    default:
                        if (range) {
                            editor.selection.setSelectionRange(range);
                            registers._default.text = editor.getCopyText();
                            registers._default.isLine = false;
                            editor.session.remove(range);
                            editor.selection.clearSelection();
                        }
                }
            }
    },
    "c": {
            selFn: function(editor, range, count, param) {
                editor.session.remove(range);
                util.insertMode(editor);
            },
            fn: function(editor, range, count, param) {
                count = parseInt(count || 1, 10);
                switch (param) {
                    case "c":
                        for (var i=0; i < count; i++) {
                            editor.removeLines();
                            util.insertMode(editor);
                        }

                        break;
                    default:
                        if (range) {
                            editor.session.remove(range);
                            util.insertMode(editor);
                        }
                }
            }
    },
    "y": {
        selFn: function(editor, range, count, param) {
            registers._default.text = editor.getCopyText();
            registers._default.isLine = util.onVisualLineMode;
            editor.selection.clearSelection();
            util.normalMode(editor);
        },
        fn: function(editor, range, count, param) {
            count = parseInt(count || 1, 10);
            switch (param) {
                case "y":
                    var pos = editor.getCursorPosition();
                    editor.selection.selectLine();
                    for (var i = 0; i < count - 1; i++) {
                        editor.selection.moveCursorDown();
                    }
                    registers._default.text = editor.getCopyText().replace(/\n$/, "");
                    editor.selection.clearSelection();
                    registers._default.isLine = true;
                    editor.moveCursorToPosition(pos);
                    break;
                default:
                    if (range) {
                        var pos = editor.getCursorPosition();
                        editor.selection.setSelectionRange(range);
                        registers._default.text = editor.getCopyText();
                        registers._default.isLine = false;
                        editor.selection.clearSelection();
                        editor.moveCursorTo(pos.row, pos.column);
                    }
            }
        }
    },
    ">": {
        selFn: function(editor, range, count, param) {
            count = parseInt(count || 1, 10);
            for (var i = 0; i < count; i++) {
                editor.indent();
            }
            util.normalMode(editor);
        },
        fn: function(editor, range, count, param) {
            count = parseInt(count || 1, 10);
            switch (param) {
                case ">":
                    var pos = editor.getCursorPosition();
                    editor.selection.selectLine();
                    for (var i = 0; i < count - 1; i++) {
                        editor.selection.moveCursorDown();
                    }
                    editor.indent();
                    editor.selection.clearSelection();
                    editor.moveCursorToPosition(pos);
                    editor.navigateLineEnd();
                    editor.navigateLineStart();
                    break;
            }
        }
    },
    "<": {
        selFn: function(editor, range, count, param) {
            count = parseInt(count || 1, 10);
            for (var i = 0; i < count; i++) {
                editor.blockOutdent();
            }
            util.normalMode(editor);
        },
        fn: function(editor, range, count, param) {
            count = parseInt(count || 1, 10);
            switch (param) {
                case "<":
                    var pos = editor.getCursorPosition();
                    editor.selection.selectLine();
                    for (var i = 0; i < count - 1; i++) {
                        editor.selection.moveCursorDown();
                    }
                    editor.blockOutdent();
                    editor.selection.clearSelection();
                    editor.moveCursorToPosition(pos);
                    editor.navigateLineEnd();
                    editor.navigateLineStart();
                    break;
            }
        }
    }
};
});

/**
 * Vim mode for the Cloud9 IDE
 *
 * @author Sergi Mansilla <sergi AT c9 DOT io>
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/vim/commands',['require','exports','module','ext/vim/maps/util','ext/vim/maps/motions','ext/vim/maps/operators','ext/vim/maps/aliases','ext/vim/registers'],function(require, exports, module) {

"use strict";

var util = require("ext/vim/maps/util");
var motions = require("ext/vim/maps/motions");
var operators = require("ext/vim/maps/operators");
var alias = require("ext/vim/maps/aliases");
var registers = require("ext/vim/registers");

var NUMBER = 1;
var OPERATOR = 2;
var MOTION = 3;
var ACTION = 4;
var HMARGIN = 8; // Minimum amount of line separation between margins;

exports.searchStore = {
    current: "",
    options: {
        needle: "",
        backwards: false,
        wrap: true,
        caseSensitive: false,
        wholeWord: false,
        regExp: false
    }
};

var repeat = function repeat(fn, count, args) {
    count = parseInt(count, 10);
    while (0 < count--)
        fn.apply(this, args);
};

var toggleCase = function toggleCase(ch) {
    if (ch.toUpperCase() === ch)
        return ch.toLowerCase();
    else
        return ch.toUpperCase();
};

var ensureScrollMargin = function(editor) {
    setTimeout(function() {
        var curPos = editor.getCursorPosition().row;
        var topRow = editor.renderer.layerConfig.firstRow;
        var linesToBottom = editor.renderer.layerConfig.lastRow - curPos;
        var linesToTop = curPos - topRow;

        if (linesToBottom >= 0 && linesToBottom < HMARGIN) {
            editor.scrollToRow(topRow + (HMARGIN - linesToBottom));
        }
        else if (linesToTop >= 0 && linesToTop < HMARGIN) {
            editor.scrollToRow(topRow - (HMARGIN - linesToTop));
        }
    }, 20); // Delay introduced to ensure scroll after async find operation.
};

var actions = {
    "z": {
        param: true,
        fn: function(editor, range, count, param) {
            switch (param) {
                case "z":
                    editor.centerSelection();
                    break;
                case "t":
                    editor.scrollToRow(editor.getCursorPosition().row);
                    break;
            }
        }
    },
    "r": {
        param: true,
        fn: function(editor, range, count, param) {
            param = util.toRealChar(param);
            if (param && param.length) {
                repeat(function() { editor.insert(param); }, count || 1);
                editor.navigateLeft();
            }
        }
    },
    // "~" HACK
    "shift-`": {
        fn: function(editor, range, count) {
            repeat(function() {
                var pos = editor.getCursorPosition();
                var line = editor.session.getLine(pos.row);
                var ch = line[pos.column];
                editor.insert(toggleCase(ch));
            }, count || 1);
        }
    },
    "*": {
        fn: function(editor, range, count, param) {
            editor.selection.selectWord();
            editor.findNext();
            ensureScrollMargin(editor);
            var cursor = editor.selection.getCursor();
            range = editor.session.getWordRange(cursor.row, cursor.column);
            editor.selection.setSelectionRange(range, true);
        }
    },
    "#": {
        fn: function(editor, range, count, param) {
            editor.selection.selectWord();
            editor.findPrevious();
            ensureScrollMargin(editor);
            var cursor = editor.selection.getCursor();
            range = editor.session.getWordRange(cursor.row, cursor.column);
            editor.selection.setSelectionRange(range, true);
        }
    },
    "n": {
        fn: function(editor, range, count, param) {
            var options = editor.getLastSearchOptions();
            options.backwards = false;

            editor.findNext(options);

            ensureScrollMargin(editor);
            editor.selection.clearSelection();
        }
    },
    "shift-n": {
        fn: function(editor, range, count, param) {
            var options = editor.getLastSearchOptions();
            options.backwards = true;

            editor.navigateWordLeft();
            editor.findPrevious(options);
            ensureScrollMargin(editor);
            editor.selection.clearSelection();
        }
    },
    "v": {
        fn: function(editor, range, count, param) {
            editor.selection.selectRight();
            util.onVisualMode = true;
            util.onVisualLineMode = false;
            var cursor = document.getElementsByClassName("ace_cursor")[0];
            cursor.style.display = "none";
        }
    },
    "shift-v": {
        fn: function(editor, range, count, param) {
            util.onVisualLineMode = true;
            //editor.selection.selectLine();
            //editor.selection.selectLeft();
            var row = editor.getCursorPosition().row;
            editor.selection.clearSelection();
            editor.selection.moveCursorTo(row, 0);
            editor.selection.selectLineEnd();
            editor.selection.visualLineStart = row;
        }
    },
    "shift-y": {
        fn: function(editor, range, count, param) {
            util.copyLine(editor);
        }
    },
    "p": {
        fn: function(editor, range, count, param) {
            var defaultReg = registers._default;

            editor.setOverwrite(false);
            if (defaultReg.isLine) {
                var pos = editor.getCursorPosition();
                var lines = defaultReg.text.split("\n");
                editor.session.getDocument().insertLines(pos.row + 1, lines);
                editor.moveCursorTo(pos.row + 1, 0);
            }
            else {
                editor.navigateRight();
                editor.insert(defaultReg.text);
                editor.navigateLeft();
            }
            editor.setOverwrite(true);
            editor.selection.clearSelection();
        }
    },
    "shift-p": {
        fn: function(editor, range, count, param) {
            var defaultReg = registers._default;
            editor.setOverwrite(false);

            if (defaultReg.isLine) {
                var pos = editor.getCursorPosition();
                var lines = defaultReg.text.split("\n");
                editor.session.getDocument().insertLines(pos.row, lines);
                editor.moveCursorTo(pos.row, 0);
            }
            else {
                editor.insert(defaultReg.text);
            }
            editor.setOverwrite(true);
            editor.selection.clearSelection();
        }
    },
    "shift-j": {
        fn: function(editor, range, count, param) {
            var pos = editor.getCursorPosition();

            if (editor.session.getLength() === pos.row + 1)
                return;

            var nextLine = editor.session.getLine(pos.row + 1);
            var cleanLine = /^\s*(.*)$/.exec(nextLine)[1];

            editor.navigateDown();
            editor.removeLines();

            if (editor.session.getLength() > editor.getCursorPosition().row + 1)
                editor.navigateUp();

            editor.navigateLineEnd();
            editor.insert(" " + (cleanLine || ""));
            editor.moveCursorTo(pos.row, pos.column);

        }
    },
    "u": {
        fn: function(editor, range, count, param) {
            count = parseInt(count || 1, 10);
            for (var i = 0; i < count; i++) {
                editor.undo();
            }
            editor.selection.clearSelection();
        }
    },
    "ctrl-r": {
        fn: function(editor, range, count, param) {
            count = parseInt(count || 1, 10);
            for (var i = 0; i < count; i++) {
                editor.redo();
            }
            editor.selection.clearSelection();
        }
    },
    ":": {
        fn: function(editor, range, count, param) {
            editor.blur();
            txtConsoleInput.focus();
            txtConsoleInput.setValue(":");
        }
    },
    "/": {
        fn: function(editor, range, count, param) {
            editor.blur();
            txtConsoleInput.focus();
            txtConsoleInput.setValue("/");
        }
    },
    ".": {
        fn: function(editor, range, count, param) {
            util.onInsertReplaySequence = inputBuffer.lastInsertCommands;
            var previous = inputBuffer.previous;
            if (previous) // If there is a previous action
                inputBuffer.exec(editor, previous.action, previous.param);
        }
    }
};

var inputBuffer = exports.inputBuffer = {
    accepting: [NUMBER, OPERATOR, MOTION, ACTION],
    currentCmd: null,
    //currentMode: 0,
    currentCount: "",

    // Types
    operator: null,
    motion: null,

    lastInsertCommands: [],

    push: function(editor, char, keyId) {
        if (char && char.length > 1) { // There is a modifier key
            if (!char[char.length - 1].match(/[A-za-z]/) && keyId) // It is a letter
                char = keyId;
        }

        this.idle = false;
        var wObj = this.waitingForParam;
        if (wObj) {
            this.exec(editor, wObj, char);
        }
        // If input is a number (that doesn't start with 0)
        else if (!(char === "0" && !this.currentCount.length) &&
            (char.match(/^\d+$/) && this.isAccepting(NUMBER))) {
            // Assuming that char is always of type String, and not Number
            this.currentCount += char;
            this.currentCmd = NUMBER;
            this.accepting = [NUMBER, OPERATOR, MOTION, ACTION];
        }
        else if (!this.operator && this.isAccepting(OPERATOR) && operators[char]) {
            this.operator = {
                char: char,
                count: this.getCount()
            };
            this.currentCmd = OPERATOR;
            this.accepting = [NUMBER, MOTION, ACTION];
            this.exec(editor, { operator: this.operator });
        }
        else if (motions[char] && this.isAccepting(MOTION)) {
            this.currentCmd = MOTION;

            var ctx = {
                operator: this.operator,
                motion: {
                    char: char,
                    count: this.getCount()
                }
            };

            if (motions[char].param)
                this.waitForParam(ctx);
            else
                this.exec(editor, ctx);
        }
        else if (alias[char] && this.isAccepting(MOTION)) {
            alias[char].operator.count = this.getCount();
            this.exec(editor, alias[char]);
        }
        else if (actions[char] && this.isAccepting(ACTION)) {
            var actionObj = {
                action: {
                    fn: actions[char].fn,
                    count: this.getCount()
                }
            };

            if (actions[char].param) {
                this.waitForParam(actionObj);
            }
            else {
                this.exec(editor, actionObj);
            }
        }
        else if (this.operator) {
            this.exec(editor, { operator: this.operator }, char);
        }
        else {
            this.reset();
        }
    },

    waitForParam: function(cmd) {
        this.waitingForParam = cmd;
    },

    getCount: function() {
        var count = this.currentCount;
        this.currentCount = "";
        return count;
    },

    exec: function(editor, action, param) {
        var m = action.motion;
        var o = action.operator;
        var a = action.action;

        if (o) {
            this.previous = {
                action: action,
                param: param
            };
        }

        if (o && !editor.selection.isEmpty()) {
            if (operators[o.char].selFn) {
                operators[o.char].selFn(editor, editor.getSelectionRange(), o.count, param);
                this.reset();
            }
            return;
        }

        // There is an operator, but no motion or action. We try to pass the
        // current char to the operator to see if it responds to it (an example
        // of this is the 'dd' operator).
        else if (!m && !a && o && param) {
            operators[o.char].fn(editor, null, o.count, param);
            this.reset();
        }
        else if (m) {
            var run = function(fn) {
                if (fn && typeof fn === "function") { // There should always be a motion
                    if (m.count)
                        repeat(fn, m.count, [editor, null, m.count, param]);
                    else
                        fn(editor, null, m.count, param);
                }
            };

            var motionObj = motions[m.char];
            var selectable = motionObj.sel;

            if (!o) {
                if ((util.onVisualMode || util.onVisualLineMode) && selectable)
                    run(motionObj.sel);
                else
                    run(motionObj.nav);
            }
            else if (selectable) {
                repeat(function() {
                    run(motionObj.sel);
                    operators[o.char].fn(editor, editor.getSelectionRange(), o.count, param);
                }, o.count || 1);
            }
            this.reset();
        }
        else if (a) {
            a.fn(editor, editor.getSelectionRange(), a.count, param);
            this.reset();
        }
        handleCursorMove();
    },

    isAccepting: function(type) {
        return this.accepting.indexOf(type) !== -1;
    },

    reset: function() {
        this.operator = null;
        this.motion = null;
        this.currentCount = "";
        this.accepting = [NUMBER, OPERATOR, MOTION, ACTION];
        this.idle = true;
        this.waitingForParam = null;
    }
};

function setPreviousCommand(fn) {
    inputBuffer.previous = { action: { action: { fn: fn } } };
}

exports.commands = {
    start: {
        exec: function start(editor) {
            util.insertMode(editor);
            setPreviousCommand(start);
        }
    },
    startBeginning: {
        exec: function startBeginning(editor) {
            editor.navigateLineStart();
            util.insertMode(editor);
            setPreviousCommand(startBeginning);
        }
    },
    // Stop Insert mode as soon as possible. Works like typing <Esc> in
    // insert mode.
    stop: {
        exec: function stop(editor) {
            inputBuffer.reset();
            util.onVisualMode = false;
            util.onVisualLineMode = false;
            inputBuffer.lastInsertCommands = util.normalMode(editor);
        }
    },
    append: {
        exec: function append(editor) {
            var pos = editor.getCursorPosition();
            var lineLen = editor.session.getLine(pos.row).length;
            if (lineLen)
                editor.navigateRight();
            util.insertMode(editor);
            setPreviousCommand(append);
        }
    },
    appendEnd: {
        exec: function appendEnd(editor) {
            editor.navigateLineEnd();
            util.insertMode(editor);
            setPreviousCommand(appendEnd);
        }
    }
};

var handleCursorMove = exports.onCursorMove = function() {
    var editor = ceEditor.$editor;

    if(util.currentMode === 'insert' || handleCursorMove.running)
        return;
    else if(!ceEditor.$editor.selection.isEmpty()) {
        handleCursorMove.running = true;
        if(util.onVisualLineMode) {
            var originRow = editor.selection.visualLineStart;
            var cursorRow = editor.getCursorPosition().row;
            if(originRow <= cursorRow) {
                var endLine = editor.session.getLine(cursorRow);
                editor.selection.clearSelection();
                editor.selection.moveCursorTo(originRow, 0);
                editor.selection.selectTo(cursorRow, endLine.length);
            } else {
                var endLine = editor.session.getLine(originRow);
                editor.selection.clearSelection();
                editor.selection.moveCursorTo(originRow, endLine.length);
                editor.selection.selectTo(cursorRow, 0);
            }
        }
        handleCursorMove.running = false;
        return;
    }
    else {
        handleCursorMove.running = true;
        var pos = editor.getCursorPosition();
        var lineLen = editor.session.getLine(pos.row).length;

        if (lineLen && pos.column === lineLen)
            editor.navigateLeft();
        handleCursorMove.running = false;
    }
};
});

/**
 * Extension manager for the Ajax.org Cloud IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
define('core/settings',['require','exports','module','core/ide','core/settings'],function(require, exports, module) {

var ide = require("core/ide");
var template = "<settings />";

module.exports = {
    model : new apf.model(),

    save : function(){
        if (!ide.inited)
            return;

        var _self = this;
        clearTimeout(this.$customSaveTimer);

        this.$customSaveTimer = setTimeout(function(){
            ide.dispatchEvent("savesettings", {model : _self.model});
            _self.saveToFile();
        }, 100);
    },

    saveToFile : function() {
        var data = this.model.data && apf.xmldb.cleanXml(this.model.data.xml) || "";
        if (ide.onLine) {
            ide.send(JSON.stringify({
                command: "settings",
                action: "set",
                settings: data
            }));
            ide.dispatchEvent("track_action", {
                type: "save settings",
                settings: data
            });
        }
        else {
            localStorage[this.sIdent] = data;
        }
    },

    load : function(xml){
        try {
            this.model.load(xml);
        } catch(e) {
            this.model.load(template);
        }

        if (window.onerror) {
            try {
                ide.dispatchEvent("loadsettings", {
                    model : this.model
                });
            } catch(e) {
                self["requ"+"ire"]("ext/filesystem/filesystem")
                  .saveFile("/workspace/.c9.brokensettings.xml", xml.xml || xml);

                this.model.load(template);

                ide.dispatchEvent("loadsettings", {
                    model : this.model
                });
            }
        }
        else {
            ide.dispatchEvent("loadsettings", {
                model : this.model
            });
        }

        ide.addEventListener("$event.loadsettings", this.$loadsettings);

        this.loaded = true;
    },

    $loadsettings : function(cb){
        cb({model : require('core/settings').model});
    },

    /**
     * Initializes the settings. The settings can come from different sources:
     * - Template (used for when no settings have been stored previously)
     * - Parsed into the index file (by the backend - apf.IdeSettings)
     * - LocalStorage (saved for use when starting in offline mode only)
     */
    init : function(){
        var xml, _self = this;
        var resetSettings = location.href.indexOf('reset=1') > -1;
        var sIdent = this.sIdent = "cloud9.settings." + ide.workspaceId;

        if (resetSettings)
            xml = template;

        // Load from local storage
        else if (localStorage[sIdent])
            xml = localStorage[sIdent];

        // Load from template
        else if (!apf.IdeSettings || apf.IdeSettings == "defaults")
            xml = template

        // Load from parsed settings in the index file
        else if (apf.IdeSettings)
            xml = apf.IdeSettings;

        if (!xml) {
            ide.addEventListener("socketMessage", function(e){
                if (e.message.type == "settings") {
                    var settings = e.message.settings;
                    if (!settings || settings == "defaults")
                        settings = template;

                    _self.load(settings);

                    ide.removeEventListener("socketMessage", arguments.callee);
                }
            });

            if (ide.onLine === true)
                ide.send({command: "settings", action: "get"});
            return;
        }

        this.load(xml);

        /**** Events ****/

        var checkSave = function() {
            if (ide.dispatchEvent("savesettings", {
                model : _self.model
            }) === true)
                _self.saveToFile();
        };
        this.$timer = setInterval(checkSave, 60000);

        apf.addEventListener("exit", checkSave);

        ide.addEventListener("afteronline", function(){
            _self.saveToFile(); //Save to file

            localStorage[sIdent] = null;
            delete localStorage[sIdent];
        });

        ide.addEventListener("afteroffline", function(){
            if (_self.loaded)
                _self.saveToFile(); //Save in local storage
        });
    }
};

module.exports.init();

});

/**
 * Extension Manager for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/panels/panels',['require','exports','module','core/ide','core/ext','core/settings','text!ext/panels/panels.xml'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var settings = require("core/settings");
var markup = require("text!ext/panels/panels.xml");

module.exports = ext.register("ext/panels/panels", {
    name   : "Panel Manager",
    dev    : "Ajax.org",
    alone  : true,
    type   : ext.GENERAL, 
    markup : markup,
    minWidth: 150,
    nodes : [],
    panels : {},
    
    currentPanel : null,
    
    register : function(panelExt, options){
        var _self = this;
        
        var beforePanel, diff = 1000000;
        for (var path in this.panels) {
            var d = this.panels[path].$panelPosition - options.position;
            if (d > 0 && d < diff) {
                beforePanel = this.panels[path];
                diff = d;
            }
        }
        
        panelExt.mnuItem = mnuProjectBar.insertBefore(new apf.item({
            caption : panelExt.name,
            type    : "radio",
            value   : panelExt.path,
            group   : this.group,
            "onprop.selected" : function(e){
                if (e.value)
                    _self.activate(panelExt);
            }
        }), beforePanel && beforePanel.mnuItem);
        
        panelExt.button = navbar.insertBefore(new apf.button({
            skin    : "mnubtn",
            state   : "true",
            //value   : "true",
            "class" : options["class"],
            caption : options.caption
        }), beforePanel && beforePanel.button || navbar.firstChild);

        //navbar.current = this;
        panelExt.button.addEventListener("mousedown", function(e){
            var value = this.value;
            if (_self.currentPanel && (_self.currentPanel != panelExt || value) && value) {
                _self.deactivate(_self.currentPanel == panelExt, true);
                
                if (value) {
                    if (!apf.isTrue(settings.model.queryValue('general/@animateui')))
                        colLeft.hide();
                    return;
                }
            }

            _self.activate(panelExt, true);
        });
        
        this.panels[panelExt.path] = panelExt;
        panelExt.$panelPosition = options.position;
        panelExt.nodes.push(panelExt.button, panelExt.mnuItem);
        
        ide.addEventListener("init." + panelExt.path, function(e){
            panelExt.panel.setAttribute("draggable", "false");
        });
        
        ide.addEventListener("loadsettings", function(){
            if (!settings.model.queryNode("auto/panels/panel[@path='" 
                + panelExt.path + "']")) {
                settings.model.appendXml("<panel path='" 
                    + panelExt.path + "' width='" 
                    + panelExt.defaultWidth + "' />", "auto/panels");
            }
        });
        
        var active = settings.model.queryValue("auto/panels/@active");
        if (panelExt["default"] && !active || active == panelExt.path)
            _self.activate(panelExt, null, true);
    },
    
    animate : function(win, toWin, toWidth){
        var tweens = [], _self = this;
        
        if (this.animateControl)
            this.animateControl.stop();
        
        this.animating = true;
        
        navbar.$ext.style.zIndex = 10000;
        
        if (toWin) {
            var toWinExt = toWin.$altExt || toWin.$ext;
            
            //Hack because of bug in hbox.js - apparently only run dialog has .$altExt
            toWin.show();
            toWin.hide();
        }
        
        if (win) {
            var left = win.getLeft();
            var top  = win.getTop();
            var width = win.getWidth();
            var height = win.getHeight();
            
            var winExt = win.$altExt || win.$ext;
            var diff  = apf.getDiff(winExt);
            var zIndex = winExt.style.zIndex;
            if(width < this.minWidth)
                width = this.minWidth;
            
            winExt.style.position = "absolute";
            winExt.style.zIndex = 1000;
            winExt.style.left = left + "px";
            winExt.style.top = top + "px";
            winExt.style.width = (width - diff[0]) + "px";
            winExt.style.height = (height - diff[1]) + "px";
            
            if (toWin) {
                tweens.push(
                    {oHtml: toWinExt, type: "fade", from: 0, to: 1},
                    {oHtml: toWinExt, type: "width", from: width, to: toWidth},
                    {oHtml: winExt, type: "width", from: width, to: toWidth},
                    {oHtml: colLeft.$ext, type: "width", from: width, to: toWidth}
                );
            }
            else {
                colLeft.$ext.style.minWidth = 0;
                tweens.push(
                    {oHtml: winExt, type: "left", from: left, to: left - width},
                    {oHtml: colLeft.$ext, type: "width", from: width, to: 0}
                );
            }
        }
        else {
            toWin.show();
            colLeft.show();

            var left = toWin.getLeft();
            var top  = toWin.getTop();
            var height = toWin.getHeight();
            var width = 0;
            
            tweens.push(
                {oHtml: toWinExt, type: "left", from: left - toWidth, to: left},
                {oHtml: colLeft.$ext, type: "width", from: width, to: toWidth}
            );
        }
        
        if (toWin) {
            var diff2  = apf.getDiff(toWinExt);
            var zIndex2 = toWinExt.style.zIndex;
            toWinExt.style.position = "absolute";
            toWinExt.style.zIndex = 2000;
            toWinExt.style.left = left + "px";
            toWinExt.style.top = top + "px";
            toWinExt.style.width = (toWidth - diff2[0]) + "px";
            toWinExt.style.height = (height - diff2[1]) + "px";
            toWin.show();
        }
        
        colLeft.$ext.style.width = width + "px";
        //apf.setOpacity(toWinExt, 0);
        
        var options = {
            steps : 8,
            interval : apf.isChrome ? 0 : 5,
            control : this.animateControl = {},
            anim : apf.tween.EASEOUT,
            tweens : tweens,
            oneach: function(){
                apf.layout.forceResize()
            },
            onfinish : function(){
                if (toWin) {
                    toWinExt.style.zIndex = zIndex2;
                    toWinExt.style.position = 
                    toWinExt.style.left = 
                    toWinExt.style.top = 
                    toWinExt.style.height =
                    toWinExt.style.width = "";
                    apf.setOpacity(toWinExt, 1);
                    colLeft.$ext.style.minWidth = _self.minWidth + "px";
                }
                if (win) {
                    winExt.style.zIndex = zIndex;
                    winExt.style.position = 
                    winExt.style.left = 
                    winExt.style.top = 
                    winExt.style.height =
                    winExt.style.width = "";
                    apf.setOpacity(winExt, 1);
                    win.hide();
                    
                    if (!toWin)
                        colLeft.hide();
                }
                
                _self.animating = false;
            }
        };
        options.onstop = options.onfinish;
        
        apf.tween.multi(document.body, options);
    },
    
    activate : function(panelExt, noButton, noAnim){
        if (this.currentPanel == panelExt)
            return;
        
        ext.initExtension(panelExt);
        
        var lastPanel = this.currentPanel;
        
        if (this.currentPanel && (this.currentPanel != this))
            this.deactivate();
        
        var width = settings.model.queryValue("auto/panels/panel[@path='" 
            + panelExt.path + "']/@width") || panelExt.defaultWidth;
        
        if (noAnim || !apf.isTrue(settings.model.queryValue('general/@animateui'))) {
            panelExt.panel.show();
            colLeft.setWidth(width);
        }
        else if (!noAnim)
            this.animate(lastPanel && lastPanel.panel, panelExt.panel, width);

        colLeft.show();
        
        if (!noButton)
            panelExt.button.setValue(true);

        splitterPanelLeft.show();
        this.currentPanel = panelExt;
        
        //settings.model.setQueryValue("auto/panels/@active", panelExt.path);
        
        ide.dispatchEvent("showpanel." + panelExt.path);
        
        panelExt.mnuItem.select(); //Will set setting too
    },
    
    deactivate : function(noButton, anim){
        if (!this.currentPanel)
            return;

        if (!apf.isTrue(settings.model.queryValue('general/@animateui'))) {
            this.currentPanel.panel.hide();
        }
        else if (anim)
            this.animate(this.currentPanel.panel);
        
        if (!noButton)
            this.currentPanel.button.setValue(false);

        splitterPanelLeft.hide();
        
        //Quick Fix
        if (apf.isGecko)
            apf.layout.forceResize(ide.vbMain.$ext);
            
        settings.model.setQueryValue("auto/panels/@active", "");
        
        ide.dispatchEvent("hidepanel." + this.currentPanel.path);
        
        this.currentPanel = null;
    },
    
    unregister : function(panelExt){
        panelExt.mnuItem.destroy(true, true);
        delete this.panels[panelExt.path];
    },

    init : function(amlNode){
        var _self = this;
        
        this.nodes.push(
            this.group = apf.document.body.appendChild(new apf.group({
                value : "[{req"+"uire('ext/settings/settings').model}::auto/panels/@active]"
            })),
            
            barMenu.appendChild(new apf.button({
                submenu : "mnuWindows",
                caption : "Windows",
                skin    : "c9-menu-btn",
                margin  : "1 0 0 0"
            })),
            mnuWindows
        );
        
        colLeft.addEventListener("resize", function(){
            if (!_self.currentPanel || _self.animating)
                return;
            
            var query = "auto/panels/panel[@path='" 
                + _self.currentPanel.path + "']/@width";
                
            if (settings.model.queryValue(query) != colLeft.getWidth())
                settings.model.setQueryValue(query, colLeft.getWidth());
        });
        
        /**** Support for state preservation ****/
        
        var _self = this;
        this.$settings = {};
        ide.addEventListener("loadsettings", function(e){
            var animateNode = e.model.queryNode("general/@animateui");
            if (!animateNode)
                e.model.setQueryValue("general/@animateui", 
                    apf.isGecko ? false : true);
        });

        var props = ["visible", "flex", "width", "height", "state"];
        ide.addEventListener("savesettings", function(e){
            var changed = false, 
                xmlSettings = apf.createNodeFromXpath(e.model.data, "auto/panel/text()");

            var set, pset, path, parent, panel, p, i, l = props.length;
            for (path in _self.panels) {
                panel = _self.panels[path].panel;
                if (!panel) continue;

                if (!_self.$settings[path]) {
                    _self.$settings[path] = {parent: {}};
                    changed = true;
                }
                
                parent = panel.parentNode;
                set    = _self.$settings[path];
                pset   = _self.$settings[path].parent;

                for (i = 0; i < l; i++) {
                    if (props[i] == "width") {
                        if (set[p = props[i]] !== _self.panels[path].$lastWidth) {
                            set[p] = _self.panels[path].$lastWidth;
                            changed = true;
                        }
                        continue;
                    }
                        
                    if (set[p = props[i]] !== panel[p]) {
                        set[p] = panel[p];
                        changed = true;
                    }
                    if (pset[p] !== parent[p]) {
                        pset[p] = parent[p];
                        changed = true;
                    }
                }
            }
            
            if (changed) {
                xmlSettings.nodeValue = apf.serialize(_self.$settings);
                return true;
            }
        });
        
        ide.addEventListener("init.ext/settings/settings", function (e) {
            var heading = e.ext.getHeading("General");
            heading.appendChild(new apf.checkbox({
                "class" : "underlined",
                value : "[general/@animateui]",
                skin  : "checkbox_grey",
                label : "Enable UI Animations"
            }))
        });
    },
    
    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },
    
    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },
    
    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});

/**
 * Extension Manager for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/settings/settings',['require','exports','module','core/ide','core/ext','text!ext/settings/settings.xml','ext/panels/panels','text!ext/settings/skin.xml','core/settings'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var markup = require("text!ext/settings/settings.xml");
var panels = require("ext/panels/panels");
var skin = require("text!ext/settings/skin.xml");
var settings = require("core/settings");

module.exports = ext.register("ext/settings/settings", {
    name    : "Preferences",
    dev     : "Ajax.org",
    alone   : true,
    type    : ext.GENERAL,
    markup  : markup,
    skin    : {
        id   : "prefs",
        data : skin,
        "media-path" : ide.staticPrefix + "/ext/settings/images/"
    },
    
    defaultWidth : 250,
    
    commands : {
        "showsettings": {hint: "open the settings window"}
    },
    hotitems: {},

    nodes : [],

    //Backwards compatible
    save : function() {
        settings.save();
    },

    saveSettingsPanel: function() {
        var pages   = self.pgSettings ? pgSettings.getPages() : [],
            i       = 0,
            l       = pages.length,
            changed = false;
        for (; i < l; ++i) {
            if (!pages[i].$at) continue;
            if (pages[i].$at.undolength > 0) {
                pages[i].$commit(pages[i]);
                changed = true;
            }
        }
        if (ide.dispatchEvent("savesettings", {
            model : this.model
        }) !== false || changed)
            settings.save();
    },

    addSection : function(tagName, name, xpath, cbCommit){
        var node = this.model.queryNode(xpath + "/" + tagName);
        if (!node)
            this.model.appendXml('<' + tagName + ' name="' + name +'" />', xpath);
    },

    hook : function(){
        panels.register(this, {
            position : 100000,
            caption: "Preferences",
            "class": "preferences"
        });
        
        //Backwards compatible
        this.model = settings.model;
    },
    
    headings : {},
    getHeading : function(name){
        if (this.headings[name])
            return this.headings[name];
        
        var heading = barSettings.appendChild(new apf.bar({
            skin: "basic"
        }));
        heading.$int.innerHTML = '<div class="header"><span></span><div>' 
            + name + '</div></div>';
        
        this.headings[name] = heading;
        
        return heading;
    },

    init : function(amlNode){
        this.panel = winSettings;

        colLeft.appendChild(winSettings);
        
        this.nodes.push(winSettings);
    },

    showsettings: function(e) {
        panels.activate(this);
        this.enable();
        return false;
    },

    saveSettings: function() {
        winSettings.hide();
        this.saveSettingsPanel();
    },

    applySettings: function() {
        this.saveSettingsPanel();
    },

    cancelSettings: function() {
        winSettings.hide();
        var pages = pgSettings.getPages(),
            i     = 0,
            l     = pages.length;
        for (; i < l; ++i) {
            if (!pages[i].$at) continue;
            pages[i].$at.undo(-1);
        }
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },
    
    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
        
        panels.unregister(this);
    }
});

});

/**
 * File System Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/filesystem/filesystem',['require','exports','module','core/ide','core/ext','core/util','ext/settings/settings'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var util = require("core/util");
var settings = require("ext/settings/settings");

module.exports = ext.register("ext/filesystem/filesystem", {
    name   : "File System",
    dev    : "Ajax.org",
    type   : ext.GENERAL,
    alone  : true,
    deps   : [],
    commands: {
        "open": {
            "hint": "open a file to edit in a new tab",
            "commands": {
                "[PATH]": {"hint": "path pointing to a file. Autocomplete with [TAB]"}
            }
        },
        "c9": {
            "hint": "alias for 'open'",
            "commands": {
                "[PATH]": {"hint": "path pointing to a file. Autocomplete with [TAB]"}
            }
        }
    },

    readFile : function (path, callback){
        if (this.webdav)
            this.webdav.read(path, callback);
    },

    saveFile : function(path, data, callback) {
        if (!this.webdav)
            return;
        this.webdav.write(path, data, null, function(data, state, extra) {
            if ((state == apf.ERROR && extra.status == 400 && extra.retries < 3) || state == apf.TIMEOUT)
                return extra.tpModule.retry(extra.id);

            callback(data, state, extra);
        });
    },

    list : function(path, callback) {
        if (this.webdav)
            this.webdav.list(path, callback);
    },

    exists : function(path, callback) {
        if (this.webdav)
            this.webdav.exists(path, callback);
    },

    createFolder: function(name, tree) {
        if (!tree) {
            tree = apf.document.activeElement;
            if (!tree || tree.localName != "tree")
                tree = trFiles;
        }

        var node = tree.selected;
        if (!node && tree.xmlRoot)
            node = tree.xmlRoot.selectSingleNode("folder");
        if (!node)
            return;
        if (node.getAttribute("type") != "folder" && node.tagName != "folder")
            node = node.parentNode;

        if (this.webdav) {
            var prefix = name ? name : "New Folder";
            var path = node.getAttribute("path");
            if (!path) {
                path = ide.davPrefix;
                node.setAttribute("path", path);
            }

            var _self = this,
                index = 0;

            function test(exists) {
                if (exists) {
                    name = prefix + "." + index++;
                    _self.exists(path + "/" + name, test);
                } else {
                    tree.focus();
                    _self.webdav.exec("mkdir", [path, name], function(data) {
                        // @todo: in case of error, show nice alert dialog
                        if (data instanceof Error)
                            throw Error;

                        var strXml = data.match(new RegExp(("(<folder path='" + path
                                + "/" + name + "'.*?>)").replace(/\//g, "\\/")))[1];

                        tree.slideOpen(null, node, true, function(data, flag, extra){
                            var folder;
                            // empty data means it didn't trigger <insert> binding,
                            // therefore the node was expanded already
                            if (!data)
                                tree.add(apf.getXml(strXml), node);

                            folder = apf.queryNode(node, "folder[@path='"+ path +"/"+ name +"']");

                            tree.select(folder);
                            tree.startRename();
                        });
                    });
                }
            }

            name = prefix;
            this.exists(path + "/" + name, test);
        }
    },

    createFile: function(filename, newFile) {
        var node;

        if (!newFile) {
            node = trFiles.selected;
            if (!node)
                node = trFiles.xmlRoot.selectSingleNode("folder");
            if (node.getAttribute("type") != "folder" && node.tagName != "folder")
                node = node.parentNode;
        }
        else {
            node = apf.getXml('<file newfile="1" type="file" size="" changed="1" '
                + 'name="Untitled.txt" contenttype="text/plain; charset=utf-8" '
                + 'modifieddate="" creationdate="" lockable="false" hidden="false" '
                + 'executable="false"></file>');
        }

        if (this.webdav) {
            var prefix = filename ? filename : "Untitled";

            if(!newFile)
                trFiles.focus();

            var _self = this,
                path  = node.getAttribute("path");
            if (!path) {
                path = ide.davPrefix;
                node.setAttribute("path", path);
            }

            var index = 0;

            var test = function(exists) {
                if (exists) {
                    filename = prefix + "." + index++;
                    _self.exists(path + "/" + filename, test);
                }
                else {
                    if (!newFile) {
                        var file
                        var both = 0;
                        function done(){
                            if (both == 2) {
                                file = apf.xmldb.appendChild(node, file);
                                trFiles.select(file);
                                trFiles.startRename();
                                trFiles.slideOpen(null, node, true);
                            }
                        }

                        trFiles.slideOpen(null, node, true, function(){
                            both++;
                            done();
                        });

                        _self.webdav.exec("create", [path, filename], function(data) {
                            _self.webdav.exec("readdir", [path], function(data) {
                                if (data instanceof Error) {
                                    // @todo: should we display the error message in the Error object too?
                                    return util.alert("Error", "File '" + filename + "' could not be created",
                                        "An error occurred while creating a new file, please try again.");
                                }

                                var m = data.match(new RegExp(("(<file path='" + path +
                                    "/" + filename + "'.*?>)").replace(/\//g, "\\/")))
                                if (!m) {
                                    return util.alert("Error", "File '" + filename + "' could not be created",
                                        "An error occurred while creating a new file, please try again.");
                                }
                                file = apf.getXml(m[1]);

                                both++;
                                done();
                            });
                        });
                    }
                    else {
                        node.setAttribute("name", filename);
                        node.setAttribute("path", path + "/" + filename);
                        ide.dispatchEvent("openfile", {doc: ide.createDocument(node), type:"newfile"});
                    }
                }
            };

            filename = prefix;
            this.exists(path + "/" + filename, test);
        }
    },

    beforeStopRename : function(name) {
        // Returning false from this function will cancel the rename. We do this
        // when the name to which the file is to be renamed contains invalid
        // characters
        var match = name.match(/^(?:\w|[.])(?:\w|[.-])*$/);

        return match !== null && match[0] == name;
    },

    beforeRename : function(node, name, newPath, isCopyAction) {
        var path = node.getAttribute("path");
        var page = tabEditors.getPage(path);

        if (name)
            newPath = path.replace(/^(.*\/)[^\/]+$/, "$1" + name);
        else
            name = newPath.match(/[^\/]+$/);

        node.setAttribute("oldpath", node.getAttribute("path"));
        node.setAttribute("path", newPath);
        apf.xmldb.setAttribute(node, "name", name);

        // when this is a copy action, then we don't want this to happen
        if (page && !isCopyAction)
            page.setAttribute("id", newPath);

        var childNodes = node.childNodes;
        var length = childNodes.length;

        for (var i = 0; i < length; ++i) {
            var childNode = childNodes[i];
            if(!childNode || childNode.nodeType != 1)
                continue;

            // The 'name' variable is redeclared here for some fucked up reason.
            // The problem is that we are reusing that variable below. If the author
            // of this would be so kind to fix this code as soon as he sees this
            // comment, I would be eternally grateful. Sergi.
            var name = childNode.getAttribute("name");

            this.beforeRename(childNode, null, node.getAttribute("path") + "/" + name);
        }
        ide.dispatchEvent("updatefile", {
            path: path,
            newPath: newPath,
            filename: name && name.input,
            xmlNode: node
        });
    },

    beforeMove: function(parent, node, tree) {
        var path = node.getAttribute("path");
        var page = tabEditors.getPage(path);
        var newpath = parent.getAttribute("path") + "/" + node.getAttribute("name");

        node.setAttribute("path", newpath);
        if (page)
            page.setAttribute("id", newpath);

        var childNodes = node.childNodes;
        var length = childNodes.length;

        for (var i = 0; i < length; ++i) {
            this.beforeMove(node, childNodes[i]);
        }

        ide.dispatchEvent("updatefile", {
            path: path,
            xmlNode: node
        });

        return true;
    },

    remove: function(path) {
        var page = tabEditors.getPage(path);
        if (page)
            tabEditors.remove(page);

        davProject.remove(path, false, function() {});
    },

    /**** Init ****/

    init : function() {
        this.model = new apf.model();
        this.model.load("<data><folder type='folder' name='" + ide.projectName +
            "' path='" + ide.davPrefix + "' root='1'/></data>");

        this.model.setAttribute("whitespace", false);

        var processing = {};
        this.model.addEventListener("update", function(e){
            // Resort on move, copy, rename, add
            if (e.action === "attribute" || e.action === "add" || e.action === "move") {
                var xmlNode = e.xmlNode, pNode = xmlNode.parentNode;
                if (processing[xmlNode.getAttribute("a_id")]) {
                    return;
                }
                processing[xmlNode.getAttribute("a_id")] = true;

                var sort = new apf.Sort();
                sort.set({
                    xpath: "@name",
                    method: "filesort"
                });
                var nodes = sort.apply(pNode.childNodes);

                for (var i = 0, l = nodes.length; i < l; i++) {
                    if (nodes[i] == xmlNode) {
                        if (xmlNode.nextSibling != nodes[i+1]) {
                            apf.xmldb.appendChild(pNode, xmlNode, nodes[i+1]);
                        }
                        break;
                    }
                }
            }
        });

        var dav_url = location.href.replace(location.pathname + location.hash, "") + ide.davPrefix;
        this.webdav = new apf.webdav({
            id  : "davProject",
            url : dav_url,
            onauthfailure: function() {
                ide.dispatchEvent("authrequired");
            }
        });

        function openHandler(e) {
            ide.send({
                command: "internal-isfile",
                argv: e.data.argv,
                cwd: e.data.cwd,
                sender: "filesystem"
            });
            return false;
        }
        ide.addEventListener("consolecommand.open", openHandler);
        ide.addEventListener("consolecommand.c9",   openHandler);

        var fs = this;
        ide.addEventListener("openfile", function(e){
            var doc  = e.doc;
            var node = doc.getNode();
            var editor = e.doc.$page && e.doc.$page.$editor;

            apf.xmldb.setAttribute(node, "loading", "true");
            ide.addEventListener("afteropenfile", function(e) {
                if (e.node == node) {
                    apf.xmldb.removeAttribute(e.node, "loading");
                    ide.removeEventListener("afteropenfile", arguments.callee);
                }
            });

            if (doc.hasValue()) {
                ide.dispatchEvent("afteropenfile", {doc: doc, node: node, editor: editor});
                return;
            }

            // do we have a value in cache, then use that one
            if (doc.cachedValue) {
                doc.setValue(doc.cachedValue);
                delete doc.cachedValue;
                ide.dispatchEvent("afteropenfile", {doc: doc, node: node, editor: editor});
            }
            // if we're creating a new file then we'll fill the doc with nah dah
            else if ((e.type && e.type === "newfile") || Number(node.getAttribute("newfile") || 0) === 1) {
                doc.setValue("");
                ide.dispatchEvent("afteropenfile", {doc: doc, node: node, editor: editor});
            }
            // otherwise go on loading
            else {
                // add a way to hook into loading of files
                if (ide.dispatchEvent("readfile", {doc: doc, node: node}) === false)
                    return;

                var path = node.getAttribute("path");

                /**
                 * Callback function after we retrieve response from jsdav
                 */
                var readfileCallback = function(data, state, extra) {
                    // verify if the request succeeded
                    if (state != apf.SUCCESS) {
                        // 404's should give a file not found, but what about others?
                        if (extra.status == 404) {
                            ide.dispatchEvent("filenotfound", {
                                node : node,
                                url  : extra.url,
                                path : path
                            });
                        }
                    }
                    else {
                        // populate the document
                        doc.setValue(data);
                        // fire event
                        ide.dispatchEvent("afteropenfile", { doc: doc, node: node, editor: editor });
                    }
                };
                
                // if we're not online, we'll add an event handler that listens to the socket connecting (or the ping or so)
                if (!ide.onLine) {
                    var afterOnlineHandler = function () {
                        fs.readFile(path, readfileCallback);
                        ide.removeEventListener("afteronline", afterOnlineHandler);
                    };
                    ide.addEventListener("afteronline", afterOnlineHandler);
                }
                else {
                    fs.readFile(path, readfileCallback);
                }
            }
        });

        ide.addEventListener("reload", function(e) {
            var doc  = e.doc,
                node = doc.getNode(),
                path = node.getAttribute("path");

            /**
             * This callback is executed when the file is read, we need to check
             * the current state of online/offline
             */
            var readfileCallback = function(data, state, extra) {
                if (state == apf.OFFLINE) {
                    ide.addEventListener("afteronline", function(e) {
                        fs.readFile(path, readfileCallback);
                        ide.removeEventListener("afteronline", arguments.callee);
                    });
                } else if (state != apf.SUCCESS) {
                    if (extra.status == 404)
                        ide.dispatchEvent("filenotfound", {
                            node : node,
                            url  : extra.url,
                            path : path
                        });
                } else {
                   ide.dispatchEvent("afterreload", {doc : doc, data : data});
                }
            };

            fs.readFile(path, readfileCallback);
        });
    },

    enable : function() {},

    disable : function() {},

    destroy : function(){
        this.webdav.destroy(true, true);
        this.model.destroy(true, true);
    }
});

});

/**
 * Refactor Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/newresource/newresource',['require','exports','module','core/ide','core/ext','ext/filesystem/filesystem','text!ext/newresource/newresource.xml'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var fs = require("ext/filesystem/filesystem");
var markup = require("text!ext/newresource/newresource.xml");

module.exports = ext.register("ext/newresource/newresource", {
    dev     : "Ajax.org",
    name    : "New Resource",
    alone   : true,
    offline : false,
    type    : ext.GENERAL,
    markup  : markup,
    deps    : [fs],
    commands : {
        "newfile": {
            hint: "create a new file resource",
            msg: "New file created."
        },
        "newfolder": {
            hint: "create a new directory resource",
            msg: "New directory created."
        },
        "newfiletemplate": {hint: "open the new file template dialog"}
    },
    hotitems: {},

    nodes   : [],

    init : function(amlNode){
        var _self = this;

        this.nodes.push(
            ide.mnuFile.insertBefore(new apf.divider(), ide.mnuFile.firstChild),
            ide.mnuFile.insertBefore(new apf.item({
                caption : "New Folder",
                onclick : function(){
                    _self.newfolder();
                }
            }), ide.mnuFile.firstChild),
            ide.mnuFile.insertBefore(new apf.item({
                caption : "New From Template...",
                onclick : function(){
                    _self.newfiletemplate();
                }
            }), ide.mnuFile.firstChild),
            ide.mnuFile.insertBefore(new apf.item({
                caption : "New File",
                onclick : function(){
                    _self.newfile();
                }
            }), ide.mnuFile.firstChild)
        );

        this.hotitems.newfile = [this.nodes[3]];
        this.hotitems.newfiletemplate = [this.nodes[2]];
        this.hotitems.newfolder = [this.nodes[1]];
    },

    newfile: function(type, value, path) {
        if (!type) type = "";

        var node = apf.getXml("<file />");
        
        if (!path && self.trFiles) {
            var sel = trFiles.selected;
    
            if (!sel) {
                trFiles.select(trFiles.$model.queryNode('folder'));
                sel = trFiles.selected;
            }
    
            if (sel) {
                path = sel.getAttribute("path");
                if (trFiles.selected.getAttribute("type") == "file" || trFiles.selected.tagName == "file")
                    path = path.replace(/\/[^\/]*$/, "/");
                else
                    path = path + "/";
            }
        }
        if (!path)
            path = ide.davPrefix + "/";

        var name = "Untitled", count = 1;
        while (tabEditors.getPage(path + name + count + type))
            count++;

        node.setAttribute("name", name + count + type);
        node.setAttribute("path", path + name + count + type);
        node.setAttribute("changed", "1");
        node.setAttribute("newfile", "1");

        var doc = ide.createDocument(node);
        if (value)
            doc.cachedValue = value;

        ide.dispatchEvent("openfile", {
            doc: doc,
            type: "newfile"
        });
        ide.dispatchEvent("track_action", {type: "template", template: type});
    },

    newfiletemplate : function(){
        winNewFileTemplate.show();
    },

    newfolder: function() {
        fs.createFolder();
        return false;
    },

    enable : function(){
        if (!this.disabled) return;

        this.nodes.each(function(item){
            item.enable();
        });
        this.disabled = false;
    },

    disable : function(){
        if (this.disabled) return;

        this.nodes.each(function(item){
            item.disable();
        });
        this.disabled = true;
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];

        mnuNew.destroy(true, true);

        tabEditors.removeEventListener("close", this.$close);
    }
});

    }
);

/**
 * Code Editor for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/editors/editors',['require','exports','module','core/ide','core/ext','core/util','ext/settings/settings','ext/editors/editors','ext/newresource/newresource'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var util = require("core/util");
var settings = require("ext/settings/settings");

module.exports = ext.register("ext/editors/editors", {
    name    : "Editors",
    dev     : "Ajax.org",
    alone   : true,
    type    : ext.GENERAL,
    nodes   : [],

    fileExtensions  : {},

    register : function(oExtension){
        /*var id = "rb" + oExtension.path.replace(/\//g, "_");

        oExtension.$rbEditor = barButtons.appendChild(new apf.radiobutton({
            id        : id,
            label     : oExtension.name,
            value     : oExtension.path,
            margin    : "0 -1 0 0",
            visible   : "{require('ext/editors/editors').isEditorAvailable(tabEditors.activepage, '" + oExtension.path + "')}",
            onclick   : function(){
                require('ext/editors/editors').switchEditor(this.value);
            }
        }));*/

        //Add a menu item to the list of editors
        oExtension.$itmEditor = mnuEditors.appendChild(new apf.item({
            type     : "radio",
            caption  : oExtension.name,
            value    : oExtension.path,
            disabled : "{!require('ext/editors/editors').isEditorAvailable(tabEditors.activepage, '" 
                + oExtension.path + "')}",
            onclick  : function(){
                require('ext/editors/editors').switchEditor(this.value);
            }
        }));

        var _self = this;
        oExtension.fileExtensions.each(function(mime){
            (_self.fileExtensions[mime] || (_self.fileExtensions[mime] = [])).push(oExtension);
        });

        if (!this.fileExtensions["default"] || (oExtension.name && oExtension.name == "Code Editor"))
            this.fileExtensions["default"] = oExtension;
    },

    unregister : function(oExtension){
        //oExtension.$rbEditor.destroy(true, true);
        oExtension.$itmEditor.destroy(true, true);

        var _self = this;
        oExtension.fileExtensions.each(function(fe){
            _self.fileExtensions[fe].remove(oExtension);
            if (!_self.fileExtensions[fe].length)
                delete _self.fileExtensions[fe];
        });

        if (this.fileExtensions["default"] == oExtension) {
            delete this.fileExtensions["default"];

            for (var prop in this.fileExtensions) {
                this.fileExtensions["default"] = this.fileExtensions[prop][0];
                break;
            }
        }
    },

    addTabSection : function(){
        var _self = this;
        var vbox = this.hbox.appendChild(
            new apf.bar({id:"tabPlaceholder", flex:1, skin:"basic"})
        );

        var btn;
        var tab = new apf.bar({
            skin     : "basic",
            style    : "padding : 0 0 32px 0;position:absolute;", //53px
            //htmlNode : document.body,
            childNodes: [
                new apf.tab({
                    id      : "tabEditors",
                    skin    : "editor_tab",
                    style   : "height : 100%",
                    buttons : "close,scale,order",
                    overactivetab  : true,
                    onfocus        : function(e){
                        _self.switchfocus(e);
                    },
                    onbeforeswitch : function(e){
                        _self.beforeswitch(e);
                    },
                    onafterswitch : function(e){
                        _self.afterswitch(e);
                    },
                    onclose : function(e){
                        if (!ide.onLine && !ide.offlineFileSystemSupport) //For now prevent tabs from being closed
                            return false;

                        _self.close(e.page);
                    },
                    childNodes : [
                        btn = new apf.button({
                            id : "plus_tab_button",
                            style : "display:inline-block;margin: 0 0 5px 13px;",
                            right : 5,
                            top   : 8,
                            width : 30,
                            height : 17,
                            skin : "btn_icon_only",
                            background : "plustabbtn.png|horizontal|3|30",
                            onclick : function(){
                                require("ext/newresource/newresource").newfile();
                            }
                        })
                    ]
                }),
                new apf.button({
                    top   : 8,
                    left  : 5,
                    width : 17,
                    height : 17,
                    submenu : "mnuTabs",
                    skin : "btn_icon_only",
                    "class" : "tabmenubtn",
                    background : "tabdropdown.png|horizontal|3|17"
                }) /*,
                new apf.hbox({
                    id      : "barButtons",
                    edge    : "0 0 0 6",
                    "class" : "relative",
                    zindex  : "1000",
                    bottom  : "0",
                    left    : "0",
                    right   : "0"
                })*/
            ]
        });
        
        apf.document.body.appendChild(tab);

        tabEditors.$buttons.appendChild(btn.$ext);
        tabEditors.addEventListener("DOMNodeInserted",function(e){
            if (e.$isMoveWithinParent) {
                //record position in settings

                var amlNode = e.currentTarget;
                if (amlNode.localName != "page" || e.relatedNode != this || amlNode.nodeType != 1)
                    return;

                settings.save();
            }

            if (e.relatedNode == this && e.currentTarget.localName == "page") {
                tabEditors.appendChild(btn);
                tabEditors.$buttons.appendChild(btn.$ext);
                btn.$ext.style.position = "";
                btn.$ext.style.right = "";
                btn.$ext.style.top = "";
            }
        });

        tabEditors.addEventListener("DOMNodeRemoved",function(e){
            if (e.relatedNode == this && this.getPages().length == 1) {
                btn.$ext.style.position = "absolute";
                btn.$ext.style.right = "5px";
                btn.$ext.style.top = "8px";
            }
        });

        tabPlaceholder.addEventListener("resize", this.$tabPlaceholderResize = function(e){
            _self.setTabResizeValues(tab.$ext);
        });

        return vbox;
    },

    /**
     * This method has been abstracted so it can be used by
     * the focus extension to get the destination coordinates and
     * dimensions of tabEditors.parentNode when the editor goes
     * out of focus mode
     */
    setTabResizeValues : function(ext) {
        var ph;
        var pos = apf.getAbsolutePosition(ph = tabPlaceholder.$ext);
        ext.style.left = (pos[0] - 2) + "px";
        ext.style.top = pos[1] + "px";
        var d = apf.getDiff(ext);
        // + (hboxDockPanel.getWidth() && apf.isGecko ? 2 : 0)
        ext.style.width = (ph.offsetWidth + 2 - d[0]) + "px";
        ext.style.height = (ph.offsetHeight - d[1]) + "px";
    },

    /**
     * Disable the resize event when the editors are in focus mode
     */
    disableTabResizeEvent : function() {
        tabPlaceholder.removeEventListener("resize", this.$tabPlaceholderResize);
    },

    /**
     * Enable the resize event when the editors come back to non-focus mode
     */
    enableTabResizeEvent : function() {
        tabPlaceholder.addEventListener("resize", this.$tabPlaceholderResize);
    },

    isEditorAvailable : function(page, path){
        var editor = ext.extLut[path];
        if (!editor)
            return false;

        var fileExtensions = editor.fileExtensions;
        var fileExtension = (tabEditors.getPage(page).$model.queryValue("@path") || "").split(".").pop();
        var isEnabled = fileExtensions.indexOf(fileExtension) > -1;
        
        if (!isEnabled && this.fileExtensions["default"] == editor)
            return true; 
        else
            return isEnabled;
    },

    initEditor : function(editor){
        //Create Page Element
        var editorPage = new apf.page({
            id        : editor.path,
            mimeTypes : editor.fileExtensions,
            visible   : false,
            realtime  : false
        });
        tabEditors.appendChild(editorPage);

        //Initialize Content of the page
        ext.initExtension(editor, editorPage);

        return editorPage;
    },

    switchEditor : function(path){
        var page = tabEditors.getPage();
        if (!page || page.type == path)
            return;

        var lastType = page.type;
        
        var info;
        if ((info = page.$doc.dispatchEvent("validate", info)) !== true) {
            util.alert(
                "Could not switch editor",
                "Could not switch editor because this document is invalid.",
                "Please fix the error and try again:" + info
            );
            return;
        }

        var editor = ext.extLut[path];
        if (!editor.inited)
            this.initEditor(editor);

        editor.$itmEditor.select();
        //editor.$rbEditor.select();

        page.setAttribute("type", path);
        
        page.$editor = editor;
        this.currentEditor = editor;

        this.beforeswitch({nextPage: page});
        this.afterswitch({nextPage: page, previousPage: {type: lastType}});
    },

    openEditor : function(doc, init, active) {
        var xmlNode  = doc.getNode();
        var filepath = xmlNode.getAttribute("path");

        var page = tabEditors.getPage(filepath);
        if (page) {
            tabEditors.set(page);
            return;
        }

        var fileExtension = (xmlNode.getAttribute("path") || "").split(".").pop();
        var editor = this.fileExtensions[fileExtension] 
          && this.fileExtensions[fileExtension][0] 
          || this.fileExtensions["default"];

        if (!init && this.currentEditor)
            this.currentEditor.disable();

        if (!editor) {
            util.alert(
                "No editor is registered",
                "Could not find an editor to display content",
                "There is something wrong with the configuration of your IDE. No editor plugin is found.");
            return;
        }

        if (!editor.inited)
            this.initEditor(editor);

        //Create Fake Page
        if (init)
            tabEditors.setAttribute("buttons", "close");

        var model = new apf.model();
        var fake = tabEditors.add("{([@changed] == 1 ? '*' : '') + [@name]}", filepath, editor.path, null, function(page){
            page.$at     = new apf.actiontracker();
            page.$doc    = doc;
            doc.$page    = page;
            page.$editor = editor;
            page.setAttribute("tooltip", "[@path]");
            page.setAttribute("class",
                "{parseInt([@saving], 10) || parseInt([@lookup], 10) ? (tabEditors.getPage(tabEditors.activepage) == this ? 'saving_active' : 'saving') : \
                ([@loading] ? (tabEditors.getPage(tabEditors.activepage) == this ? 'loading_active' : 'loading') : '')}"
            );
            page.setAttribute("model", page.$model = model);
            page.$model.load(xmlNode);
        });

        if (init)
            tabEditors.setAttribute("buttons", "close,scale,order");

        doc.addEventListener("setnode", function(e) {
            fake.$model.load(e.node);
            ide.dispatchEvent("afteropenfile", {doc: doc, node: e.node, editor: editor});
        });

        this.initEditorEvents(fake, model);

        if (init && !active)
            return;

        //Set active page
        tabEditors.set(filepath);

        //if (editorPage.model != model)
            //this.beforeswitch({nextPage: fake});

        //Open tab, set as active and wait until opened
        /*fake.addEventListener("afteropen", function(){

        });*/

        editor.enable();
        editor.$itmEditor.select();
        //editor.$rbEditor.select();

        this.currentEditor = editor;

        // okay don't know if you would want this, but this is the way the 'open file' dialog
        // handles it so let's do that
        setTimeout(function () {
            if (typeof ceEditor !== "undefined")
                ceEditor.focus();
        }, 100);

        settings.save();
    },

    initEditorEvents: function(fake, model) {
        fake.$at.addEventListener("afterchange", function(e) {
            if (e.action == "reset") {
                delete this.undo_ptr;
                return;
            }

            var val;
            if (fake.$at.ignoreChange) {
                val = undefined;
                fake.$at.ignoreChange = false;
            }
            else if(this.undolength === 0 && !this.undo_ptr) {
                val = undefined;
            }
            else {
                val = (this.$undostack[this.$undostack.length - 1] !== this.undo_ptr)
                    ? 1
                    : undefined;
            }

            if (fake.changed !== val) {
                fake.changed = val;
                model.setQueryValue("@changed", (val ? "1" : "0"));
                
                var node = fake.$doc.getNode();
                ide.dispatchEvent("updatefile", {
                    changed : val ? 1 : 0,
                    xmlNode : node
                });
            }
        });
    },

    close : function(page) {
        page.addEventListener("afterclose", this.$close);
    },

    $close : function() {
        var page = this;
        var at   = page.$at;
        var mdl  = page.$model;

        mdl.setQueryValue("@changed", 0);
        page.$doc.dispatchEvent("close");

        if (mdl.data) {
            mdl.removeXml("data");
            ide.dispatchEvent("closefile", {xmlNode: mdl.data, page: page});
        }

        //mdl.unshare();
        mdl.destroy();

        at.reset();
        at.destroy();

        //If there are no more pages left, reset location
        if (!tabEditors.getPage()) {
            /*if (window.history.pushState) {
                var p = location.pathname.split("/");
                window.history.pushState(path, path, "/" + (p[1] || "") + "/" + (p[2] || ""));
            }
            else {
                apf.history.setHash("");
            }*/
            apf.history.setHash("");
        }

        //Destroy the app page if it has no application instance
        //if (!tabEditors.selectNodes("page[@type='" + page.type + "']").length && editorPage)
            //editorPage.destroy(true, true);

        settings.save();
    },

    switchfocus : function(e){

    },

    beforeswitch : function(e) {
        var page       = e.nextPage,
            editorPage = tabEditors.getPage(page.type);
        if (!editorPage) return;

        // fire this event BEFORE editor sessions are swapped.
        ide.dispatchEvent("beforeeditorswitch", {
            previousPage: e.previousPage,
            nextPage: e.nextPage
        });

        if (editorPage.model != page.$model)
            editorPage.setAttribute("model", page.$model);
        if (editorPage.actiontracker != page.$at)
            editorPage.setAttribute("actiontracker", page.$at);

        if (page.$editor && page.$editor.setDocument) {
            page.$editor.setDocument(page.$doc, page.$at);
        }

        ide.dispatchEvent("editorswitch", {
            previousPage: e.previousPage,
            nextPage: e.nextPage
        });
    },

    afterswitch : function(e) {
        var page = e.nextPage;
        var fromHandler, toHandler = ext.extLut[page.type];

        if (e.previousPage && e.previousPage != e.nextPage)
            fromHandler = ext.extLut[e.previousPage.type];

        if (fromHandler != toHandler) {
            if (fromHandler)
                fromHandler.disable();
            toHandler.enable();
        }
        
        var path = page.$model.data.getAttribute("path").replace(/^\/workspace/, "");
        /*if (window.history.pushState) {
            var p = location.pathname.split("/");
            window.history.pushState(path, path, "/" + (p[1] || "name") + "/" + (p[2] || "project") + path);
        }
        else {
            apf.history.setHash("!" + path);
        }*/
        apf.history.setHash("!" + path);
        
        toHandler.$itmEditor.select();
        
        var fileExtension = (path || "").split(".").pop();
        var editor = this.fileExtensions[fileExtension] 
          && this.fileExtensions[fileExtension][0] 
          || this.fileExtensions["default"];

        if (!editor) {
            util.alert(
                "No editor is registered",
                "Could not find an editor to display content",
                "There is something wrong with the configuration of your IDE. No editor plugin is found.");
            return;
        }

        if (!editor.inited)
            this.initEditor(editor);
        
        this.currentEditor = editor;
        editor.ceEditor.focus();

        //toHandler.$rbEditor.select();

        /*if (self.TESTING) {}
            //do nothing
        else if (page.appid)
            app.navigateTo(page.appid + "/" + page.id);
        else if (!page.id)
            app.navigateTo(app.loc || (app.loc = "myhome"));*/
    },

    /**** Init ****/

    init : function(){
        var _self = this;
        
        window.onpopstate = function(e){
            var page = "/workspace" + e.state;
            if (tabEditors.activepage != page && tabEditors.getPage(page))
                tabEditors.set(page);
        };

        apf.addEventListener("hashchange", function(e){
            var page = "/workspace" + e.page;
            if (tabEditors.activepage != page && tabEditors.getPage(page))
                tabEditors.set(page);
        });
        
        apf.document.body.appendChild(new apf.menu({
            id : "mnuEditors"
        }));
        
        mnuView.insertBefore(new apf.item({
            caption : "Editor",
            submenu : "mnuEditors"
        }), mnuView.firstChild);
        
        ext.addType("Editor", function(oExtension){
            _self.register(oExtension);
          }, function(oExtension){
            _self.unregister(oExtension);
          });

        ide.addEventListener("openfile", function(e){
            _self.openEditor(e.doc, e.init, e.active);
        });

        ide.addEventListener("filenotfound", function(e) {
            var page = tabEditors.getPage(e.path);
            if (page)
                tabEditors.remove(page);
        });

        var vbox  = colMiddle;
        this.hbox = vbox.appendChild(new apf.hbox({flex : 1, padding : 5, splitters : true}));
        //this.splitter = vbox.appendChild(new apf.splitter());
        this.nodes.push(this.addTabSection());

        this.panel = this.hbox;

        /**** Support for state preservation ****/

        this.$settings = {};
        ide.addEventListener("loadsettings", function(e){
            if (!e.model.queryNode("auto/files"));
                apf.createNodeFromXpath(e.model.data, "auto/files");
            
            function checkExpand(path, doc) {
                ide.addEventListener("init.ext/tree/tree", function(){
                    var parent_path = apf.getDirname(path).replace(/\/$/, "");
                    var expandEventListener = function(e) {
                        if (e.xmlNode && e.xmlNode.getAttribute("path") == parent_path) {
                            // if the file has been loaded from the tree
                            if (doc.getNode().getAttribute("newfile") != 1) {
                                // databind the node from the tree to the document
                                doc.setNode(e.xmlNode.selectSingleNode("node()[@path='" + path + "']"));
                            }
                            else {
                                // if not? then keep it this way, but invoke setNode() anyway because
                                // it triggers events
                                doc.setNode(doc.getNode());
                            }
                            trFiles.removeEventListener("expand", expandEventListener);
                        }
                    };
    
                    trFiles.addEventListener("expand", expandEventListener);
                });
            }

            var model = e.model;
            ide.addEventListener("extload", function(){
                // you can load a file from the hash tag, if that succeeded then return
                var loadFileFromHash =  (_self.loadFileFromHash(window.location.hash, checkExpand));
                if (loadFileFromHash) {
                    window.location.hash = loadFileFromHash; // update hash
                    return;
                }

                // otherwise, restore state from the .config file
                var active = model.queryValue("auto/files/@active");
                var nodes  = model.queryNodes("auto/files/file");

                for (var i = 0, l = nodes.length; i < l; i++) {
                    var node  = nodes[i];
                    var state = node.getAttribute("state");
                    var doc   = ide.createDocument(node);

                    try {
                        if (state)
                            doc.state = JSON.parse(state);
                    }
                    catch (ex) {}

                    // node.firstChild is not always present (why?)
                    if ((node.getAttribute("changed") == 1) && node.firstChild) {
                        doc.cachedValue = node.firstChild.nodeValue
                            .replace(/\n]\n]/g, "]]")
                            .replace(/\\r/g, "\r")
                            .replace(/\\n/g, "\n");
                    }

                    ide.dispatchEvent("openfile", {
                        doc    : doc,
                        init   : true,
                        active : active
                            ? active == node.getAttribute("path")
                            : i == l - 1
                    });

                    checkExpand(node.getAttribute("path"), doc);
                }
            });
        });

        ide.addEventListener("savesettings", function(e){
            if (!e.model.data)
                return;

            var pNode   = e.model.data.selectSingleNode("auto/files");
            var state   = pNode && pNode.xml;
            var pages   = tabEditors.getPages();

            if (pNode) {
                pNode.parentNode.removeChild(pNode);
                pNode = null;
            }

            if (pages.length) {
                var active = tabEditors.activepage;
                e.model.setQueryValue("auto/files/@active", active);

                pNode = apf.createNodeFromXpath(e.model.data, "auto/files");
                for (var i = 0, l = pages.length; i < l; i++) {
                    if(!pages[i] || !pages[i].$model)
                        continue;
                        
                    var file = pages[i].$model.data;
                    if (!file || file.getAttribute("debug"))
                        continue;

                    var copy = apf.xmldb.cleanNode(file.cloneNode(false));
                    //copy.removeAttribute("changed");
                    copy.removeAttribute("loading");
                    copy.removeAttribute("saving");
                    pNode.appendChild(copy);

                    var state = pages[i].$editor.getState && pages[i].$editor.getState(pages[i].$doc);
                    if (state)
                        copy.setAttribute("state", apf.serialize(state));

                    //@todo the second part of this if can be removed as soon
                    //as the collab team implements stored changed settings
                    //please note that for this to work on loadsettings we
                    //should check whether the file on disk has changed and
                    //popup a file watch dialog to ask if the user wants to
                    //load the new file from disk, losing changes.
                    if (copy.getAttribute("changed") == 1 && copy.getAttribute("newfile") == 1) {
                        copy.appendChild(copy.ownerDocument.createCDATASection(
                            pages[i].$doc.getValue()
                                .replace(/\r/g, "\\r")
                                .replace(/\n/g, "\\n")
                                .replace(/\]\]/g, "\n]\n]")
                        ));
                    }
                }
            }

            if (state != (pNode && pNode.xml))
                return true;
        });

        ide.addEventListener("reload", function(e) {
            var doc = e.doc;
            doc.state = doc.$page.$editor.getState && doc.$page.$editor.getState(doc);
        });

        ide.addEventListener("afterreload", function(e) {
            var doc         = e.doc,
                acesession  = doc.acesession,
                sel         = acesession.getSelection();

            sel.selectAll();
            acesession.getUndoManager().ignoreChange = true;
            acesession.replace(sel.getRange(), e.data);
            sel.clearSelection();

            if (doc.state) {
                var editor = doc.$page.$editor;
                editor.setState && editor.setState(doc, doc.state);
            }
        });
    },

    /** Load any file from the hash, with optional some lines selected
     *
     * @param {string} hash Hash as obtained from the window element
     * @param {function} checkExpand Function that expands the tree for the given file
     * @return {string} The new hash
     */
    loadFileFromHash : function (hash, checkExpand) {
        // an initial state can be sent in the hash
        // match 'openfile-',
        // match any character except :& or end of file
        // optional: match : digit - digit
        // [1] is filename, [2] is starting line number, [3] is ending line number
        var editorInitialStatePattern = /openfile-(.[^:&$]*)(?:\:(\d+)-(\d+))?/;
        var rawState = hash.match(editorInitialStatePattern);

        if (rawState) {
            // build the real path, as the one in the hash is relative
            var path = ide.davPrefix.replace(/\/$/, "") + "/" + rawState[1];
            var doc = ide.createDocument(this.createFileNodeFromPath(path));

            // if selection information was added, add that to the state
            if (rawState[2] && rawState[3]) {
                doc.state = {
                    scrollleft: 0, scrolltop: 0,
                    selection: {
                        start: { row: parseInt(rawState[2] || 0, 10) - 1, column: 0 },
                        end: { row: parseInt(rawState[3] || 0, 10), column: 0 } // plus 1 to capture whole previous line
                    }
                };
            }

            // send it to the dispatcher
            ide.dispatchEvent("openfile", {
                doc: doc,
                active: true
            });
            // and expand the tree
            checkExpand(path, doc);

            // return the new hash
            return hash.replace(editorInitialStatePattern, "");
        }

        return null;
    },

    createFileNodeFromPath : function (path) {
        var name = path.split("/").pop();
        var node = apf.n("<file />")
            .attr("name", name)
            .attr("contenttype", util.getContentType(name))
            .attr("path", path)
            .node();
        return node;
    },

    showFile : function(path, row, column, text, state) {
        var node = this.createFileNodeFromPath(path);

        this.jump(node, row, column, text);
    },

    jump : function(fileEl, row, column, text, doc, page) {
        var path    = fileEl.getAttribute("path");
        var hasData = page && (tabEditors.getPage(path) || { }).$doc ? true : false;

        if (row !== undefined) {
            var jumpTo = function(){
                setTimeout(function() {
                    // TODO move this to the editor
                    ceEditor.$editor.gotoLine(row, column);
                    if (text)
                        ceEditor.$editor.find(text);
                    ceEditor.focus();
                }, 100);
            };

            if (hasData) {
                tabEditors.set(path);
                jumpTo();
            }
            else
                ide.addEventListener("afteropenfile", function(e) {
                    var node = e.doc.getNode();

                    if (node.getAttribute("path") == path) {
                        ide.removeEventListener("afteropenfile", arguments.callee);
                        jumpTo();
                    }
                });
        }

        if (!hasData)
            ide.dispatchEvent("openfile", {
                doc: doc || ide.createDocument(fileEl)
            });
        else
            tabEditors.set(path);
    },

    enable : function(){
        this.hbox.show();
        //this.splitter.show();
    },

    disable : function(){
        this.hbox.hide();
        //this.splitter.hide();
    },

    destroy : function(){
        this.hbox.destroy(true, true);
        //this.splitter.destroy(true, true);
    }
});

});

/**
 * Logger
 * The logger outputs given messages into the console output, properly formatted.
 *
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 * @contributor Sergi Mansilla <sergi AT c9 DOT io>
 */
define('ext/console/logger',['require','exports','module','ext/editors/editors'],function(require, exports, module) {
var editors = require("ext/editors/editors");

exports.test = {};
var MAX_LINES = 512;
var RE_relwsp = /(?:\s|^|\.\/)([\w\_\$-]+(?:\/[\w\_\$-]+)+(?:\.[\w\_\$]+))?(\:\d+)(\:\d+)*/g;
var RE_URL = /\b((?:(?:https?):(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()[\]{};:'".,<>?«»“”‘’]))/i;
var RE_COLOR = /\u001b\[([\d;]+)?m/g;

// Remove as many elements in the console output area so that between
// the existing buffer and the stream coming in we have the right
// amount of lines according to MAX_LIMIT.
var balanceBuffer = function(elem) {
    var len = elem.childNodes.length;
    if (len <= MAX_LINES)
        return;

    len = len - MAX_LINES;
    for (var i = 0; i < len; i++)
        elem.removeChild(elem.firstChild);
};

var jump = function(path, row, column) {
    row = parseInt(row.slice(1), 10);
    column = column ? parseInt(column.slice(1), 10) : 0;
    editors.showFile(path, row, column);
};

// Maximum amount of buffer history
var bufferInterval = {};
var setBufferInterval = function(el, id) {
    bufferInterval[id] = setInterval(function() {
        balanceBuffer(el);
    }, 1000);
};

var strRepeat = function(s, t) { return new Array(t + 1).join(s); };
var escRegExp = function(s) { return s.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1'); };

var createItem = module.exports.test.createItem = function(line, ide) {
    if (!line) return "";

    var workspaceDir = ide.workspaceDir;
    var davPrefix = ide.davPrefix;
    var wsRe = new RegExp(escRegExp(workspaceDir) + "\\/([^:]*)(:\\d+)(:\\d+)*", "g");

    if ((line.search(RE_relwsp) !== -1) || (line.search(wsRe) !== -1)) {
        var html = "<a href='#' data-wsp='" + davPrefix + "/$1,$2,$3'>___$1$2$3</a>";
        line = line
            .replace(RE_relwsp, html.replace("___", ""))
            .replace(wsRe, html.replace("___", workspaceDir + "/"));
    }
    else if (line.search(RE_URL) !== -1) {
        line = line.replace(RE_URL, "<a href='$1' target='_blank'>$1</a>");
    }
    
    // escape HTML/ XML, but preserve the links:
    var links = [];
    var replacer = "###$#$#$##0";
    line = line.replace(/(<a.*?a>)/gi, function(m) {
        links.push(m);
        return replacer;
    });
    
    line = apf.escapeXML(line);
    
    line = line.replace(replacer, function() {
        return links.shift();
    });
    
    var open = 0;
    line = line
        .replace(/\s{2,}/g, function(str) { return strRepeat("&nbsp;", str.length); })
        .replace(RE_COLOR, function(m, style) {
            if (!style)
                return "";
            style = parseInt(style.replace(";", ""), 10);
            // check for end of style delimiters
            if (open > 0 && (style === 39 || (style < 30 && style > 20))) {
                --open;
                return "</span>";
            }
            else {
                if (style === 1) {
                    ++open;
                    return "<span class=\"term_boldColor\" style=\"font-weight:bold\">";
                }
                else if (style === 3) {
                    ++open;
                    return "<span style=\"font-style:italic\">";
                }
                else if (style === 4) {
                    ++open;
                    return "<span style=\"text-decoration:underline\">";
                }
                else if (style >= 30 && !(style > 40 && style < 50)) {
                    ++open;
                    var ansiColor = (style % 30);
                    if (ansiColor >= 10)
                        ansiColor -= 2;
                    return "<span class=\"term_ansi" + ansiColor + "Color\">";
                }
                else
                    return "";
            }
        })
        .replace(/(\u0007|\u001b)\[(K|2J)/g, "");

    if (open > 0)
        return line + (new Array(open + 1).join("</span>"));
    return line;
};

var childBuffer = {};
var childBufferInterval = {};
var eventsAttached;

var getOutputElement = function(choice) {
    var ret = {
        element: txtConsole.$ext,
        id: "console"
    };
    if (!choice)
        return ret;

    // legacy support: choice passed as Boolean TRUE means 'use txtOutput'.
    if (typeof choice == "boolean" && choice) {
        ret.element = txtOutput.$ext;
        ret.id = "output";
    }
    else if (choice.$ext && choice.id) {
        ret.element = choice.$ext;
        ret.id = choice.id;
    }

    return ret;
}

module.exports.logNodeStream = function(data, stream, useOutput, ide) {
    var out = getOutputElement(useOutput);
    var parentEl = out.element;
    var outputId = out.id;

    if (eventsAttached !== true) {
        parentEl.addEventListener("click", function(e) {
            var node = e.target;
            if (node.hasAttribute("data-wsp"))
                jump.apply(null, e.target.getAttribute("data-wsp").split(","));
        });
        eventsAttached = true;
    }

    if (!bufferInterval[outputId]) {
        setBufferInterval(parentEl, outputId);
    }

    // This is a bit cumbersome, but it solves the issue in which logging stuff
    // in the console at a high speed keeps the browser incredibly busy, and
    // sometimes it even crashes. An interval is created in which every 100ms
    // The lines stored in the document fragment are appended in the actual console
    // output.
    if (!childBuffer[outputId]) {
        childBuffer[outputId] = document.createDocumentFragment();
        childBufferInterval[outputId] = setInterval(function() {
            parentEl.appendChild(childBuffer[outputId]);
            childBuffer[outputId] = document.createDocumentFragment();
        }, 100);
    }

    var lines = (data.toString()).split("\n", MAX_LINES);
    var fragment = document.createDocumentFragment();
    for (var i=0, l = lines.length; i<l; i++) {
        var div = document.createElement("div");
        var divContent = createItem(lines[i], ide);
        if (divContent && divContent.length) {
            div.innerHTML = divContent;
            fragment.appendChild(div);
        }
    }
    childBuffer[outputId].appendChild(fragment);
};

var messages = {
    divider: "<span class='cli_divider'></span>",
    prompt: "<span style='color:#86c2f6'>__MSG__</span>",
    command: "<span style='color:#86c2f6'><span>&gt;&gt;&gt;</span><div>__MSG__</div></span>"
};

module.exports.log = function(msg, type, pre, post, useOutput) {
    msg = msg.toString().escapeHTML();
    if (!type)
        type = "log";

    if (messages[type]) {
        msg = messages[type].replace("__MSG__", msg);
    }

    var out = getOutputElement(useOutput);
    var parentEl = out.element;
    var outputId = out.id;

    if (!bufferInterval[outputId]) {
        setBufferInterval(parentEl, outputId);
    }

    parentEl.innerHTML +=
        "<div class='item console_" + type + "'>" +
            (pre || "") + msg + (post || "") +
        "</div>";
};

});

/**
 * Console for the Cloud9 IDE
 *
 * The console plugin takes care of rendering a CLI at the bottom of the IDE and
 * of sending user input and parsing and outputting stdout in the
 * console.
 *
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 * @contributor Sergi Mansilla <sergi AT c9 DOT io>
 */

define('ext/console/console',['require','exports','module','core/ide','core/ext','core/settings','ext/console/logger','text!ext/console/console.css','text!ext/console/console.xml','text!ext/console/themes/arthur.css','ext/console/parser','ext/console/output','ext/editors/editors'],function(require, exports, module) {

var editors, parseLine, predefinedCmds; // These modules are loaded on demand
var ide = require("core/ide");
var ext = require("core/ext");
var settings = require("core/settings");
var Logger = require("ext/console/logger");
var css = require("text!ext/console/console.css");
var markup = require("text!ext/console/console.xml");
var theme = require("text!ext/console/themes/arthur.css");

// Some constants used throughout the plugin
var RE_band = /^\s*!/;
var KEY_TAB = 9, KEY_CR = 13, KEY_UP = 38, KEY_ESC = 27, KEY_DOWN = 40;
var actionCodes = [KEY_TAB, KEY_CR, KEY_UP, KEY_ESC, KEY_DOWN];

// Executes a command (presumably coming from the CLI).
var execAction = function(cmd, data) {
    ide.dispatchEvent("track_action", {
        type: "console",
        cmd: cmd,
        argv: data.argv
    });

    if (ext.execCommand(cmd, data) !== false) {
        var commandEvt = "consolecommand." + cmd;
        var consoleEvt = "consolecommand";
        var commandEvResult = ide.dispatchEvent(commandEvt, { data: data });
        var consoleEvResult = ide.dispatchEvent(consoleEvt, { data: data });

        if (commandEvResult !== false && consoleEvResult !== false) {
            if (!ide.onLine)
                this.write("Cannot execute command. You are currently offline.");
            else
                ide.send(data);
        }
        else {
            // If any of the `consolecommand` events returns false, it means
            // that we don't want the console to show up.
            return false;
        }
    }
    return true;
};

// This object is a simple FIFO queue that keeps track of the list of commands
// introduced by the user at any given time and allows the console to go back and forward.
var cmdHistory = {
    _history: [],
    _index: 0,

    push: function(cmd) {
        this._history.push(cmd);
        this._index = this.length();
    },
    length: function() {
        return this._history.length;
    },
    getNext: function() {
        this._index += 1;
        var cmd = this._history[this._index] || "";
        this._index = Math.min(this.length(), this._index);

        return cmd;
    },
    getPrev: function() {
        this._index = Math.max(0, this._index - 1);
        return this._history[this._index];
    }
};

module.exports = ext.register("ext/console/console", {
    name   : "Console",
    dev    : "Ajax.org",
    type   : ext.GENERAL,
    alone  : true,
    markup : markup,
    css    : css + theme,
    height : 200,
    hidden : true,
    nodes : [],
    minHeight : 150,

    autoOpen : true,
    excludeParent : true,
    allCommands: {},
    keyEvents: {},
    commands: {
        "help": {
            hint: "show general help information and a list of available commands"
        },
        "clear": {
            hint: "clear all the messages from the console"
        },
        "switchconsole": {
            hint: "toggle focus between the editor and the console"
        },
        "send": {
            hint: "send a message to the server"
        }
    },

    messages: {
        cd: function(message) {
            var res = message.body;
            if (res.cwd) {
                this.$cwd = res.cwd.replace(ide.workspaceDir, "/workspace");
                this.write("Working directory changed.");
            }
        },
        
        error: function(message) {
            Logger.log(message.body);
            Logger.log("", "divider");
        },
        
        /**
         * Info does the same as error in this case
         * but it's here for the future, we might want to distinguise these
         * on colors or something...
         */
        info: function (message) {
            Logger.log(message.body);
            Logger.log("", "divider");
        },
        
        __default__: function(message) {
            var res = message.body;
            if (res) {
                res.out && Logger.logNodeStream(res.out, null, null, ide);
                res.err && Logger.logNodeStream(res.err, null, null, ide);
                res.code && Logger.log("", "divider"); // End of command
            }
        }
    },

    help: function() {
        var words = Object.keys(this.allCommands);
        var tabs = "\t\t\t\t";
        var _self = this;

        Logger.logNodeStream(
            words.sort()
                .map(function(w) { return w + tabs + _self.allCommands[w].hint; })
                .join("\n"),
            null, null, ide
        );
    },

    clear: function() {
        if (txtConsole) {
            txtConsole.clear();
        }
        
        return false;
    },

    switchconsole : function() {
        if (apf.activeElement === txtConsoleInput) {
            if (window.ceEditor) {
                ceEditor.focus();
                this.hide();
            }
        }
        else {
            txtConsoleInput.focus()
        }
    },

    showOutput: function() {
        tabConsole.set(1);
    },

    getCwd: function() {
        return this.$cwd && this.$cwd.replace("/workspace", ide.workspaceDir);
    },

    write: function(lines) {
        if (typeof lines === "string")
            lines = lines.split("\n");

        lines.forEach(function(line) { Logger.log(line, "log"); });
        Logger.log("", "divider");
    },

    keyupHandler: function(e) {
        if (actionCodes.indexOf(e.keyCode) === -1)
            return this.commandTextHandler(e);
    },

    keydownHandler: function(e) {
        if (actionCodes.indexOf(e.keyCode) !== -1)
            return this.commandTextHandler(e);
    },

    evalCmd: function(line) {
        parseLine || (parseLine = require("ext/console/parser"));
        var argv = parseLine(line);
        if (!argv || argv.length === 0) // no commmand line input
            return;

        // Replace any quotes in the command
        argv[0] = argv[0].replace(/["'`]/g, "");
        cmdHistory.push(line);
        Logger.log(this.getPrompt(line), "prompt");
        tabConsole.set("console");

        var showConsole = true;
        var cmd = argv[0];

        predefinedCmds || (predefinedCmds = require("ext/console/output"));
        var defCmd = predefinedCmds.getPredefinedOutput(argv);
        if (defCmd !== "") {
            this.write(defCmd);
        }
        else {
            if (cmd.trim().charAt(0) === "!") {
                cmd = "bash";
                argv[0] = argv[0].replace(RE_band, "");
                line = line.replace(RE_band, "");
            }

            var data = {
                command: cmd,
                argv: argv,
                line: line,
                cwd: this.getCwd(),
                // the requireshandling flag indicates that this message cannot
                // be silently ignored by the server.
                // An error event should be thrown if no plugin handles this message.
                requireshandling: true
            };

            if (cmd.trim() === "npm")
                data.version = settings.model.queryValue("auto/node-version/@version") || "auto";

            showConsole = execAction(cmd, data);
        }
        if (showConsole === true) this.show();
    },

    commandTextHandler: function(e) {
        var code = e.keyCode;
        if (this.keyEvents[code])
            this.keyEvents[code](e.currentTarget);
    },

    onMessage: function(e) {
        var message = e.message;
        if (!message.type)
            return;
        if (message.type === "node-data")
            return Logger.logNodeStream(message.data, message.stream, true, ide);

        if (message.type === "node-exit")
            return Logger.log("", "divider", null, null, true);

        if (message.type.match(/-data$/))
            return Logger.logNodeStream(message.data, message.stream, false, ide);

        if (message.type.match(/-exit$/))
            return Logger.log("", "divider", false);

        if (message.type !== "result")
            return;

        if (this.messages[message.subtype])
            this.messages[message.subtype].call(this, message);
        else
            this.messages.__default__.call(this, message);

        ide.dispatchEvent("consoleresult." + message.subtype, { data: message.body });
    },

    getPrompt: function(suffix) {
        var u = this.username;
        if (!u)
            u = (ide.workspaceId.match(/user\/(\w+)\//) || [,"guest"])[1];

        return "[" + u + "@cloud9]:" + this.$cwd + "$" + ((" " + suffix) || "");
    },
    
    hook: function() {
        var _self = this;
        // Listen for new extension registrations to add to the
        // hints
        ide.addEventListener("ext.register", function(e){
            if (e.ext.commands)
                apf.extend(_self.allCommands, e.ext.commands);
        });

        ext.initExtension(this);
    },

    init: function(amlNode){
        var _self = this;
        this.panel = tabConsole;
        this.$cwd  = "/workspace"; // code smell

        apf.importCssString(this.css);
        // Append the console window at the bottom below the tab
        mainRow.appendChild(winDbgConsole);

        stProcessRunning.addEventListener("activate", function() {
            _self.showOutput();

            var autoshow = settings.model.queryValue("auto/console/@autoshow");
            if (_self.autoOpen && apf.isTrue(autoshow))
                _self.show();
        });

        // before the actual run target gets called we clear the console
        ide.addEventListener("beforeRunning", function () {
            _self.clear();
        });

        ide.addEventListener("socketMessage", this.onMessage.bind(this));
        ide.addEventListener("consoleresult.internal-isfile", function(e) {
            var data = e.data;
            var path = data.cwd.replace(ide.workspaceDir, ide.davPrefix);
            if (!editors)
                editors = require("ext/editors/editors");
            if (data.isfile)
                editors.showFile(path);
            else
                Logger.log("'" + path + "' is not a file.");
        });

        txtConsoleInput.addEventListener("keyup", this.keyupHandler.bind(this));
        txtConsoleInput.addEventListener("keydown", this.keydownHandler.bind(this));

        function kdHandler(e){
            if (!e.ctrlKey && !e.metaKey && !e.altKey
              && !e.shiftKey && apf.isCharacter(e.keyCode))
                txtConsoleInput.focus();
        }

        tabConsole.addEventListener("afterrender", function() {
            txtOutput.addEventListener("keydown", kdHandler);
            txtConsole.addEventListener("keydown", kdHandler);

            var activePage = settings.model.queryValue("auto/console/@active");
            if (activePage && !this.getPage(activePage))
                activePage = null;

            if (!activePage)
                activePage = this.getPages()[0].name;

            this.set(activePage);
        });

        tabConsole.addEventListener("afterswitch", function(e){
            settings.model.setQueryValue("auto/console/@active", e.nextPage.name)
        });

        winDbgConsole.previousSibling.addEventListener("dragdrop", function(e){
            settings.model.setQueryValue("auto/console/@height",
                _self.height = winDbgConsole.height)
        });

        this.nodes.push(
            winDbgConsole,
            mnuWindows.appendChild(new apf.item({
                id: "chkConsoleExpanded",
                caption: "Console",
                type: "check",
                "onprop.checked" : function(e) {
                    if (e.value)
                        _self.show();
                    else
                        _self.hide();
                }
            }))
        );

        ide.addEventListener("loadsettings", function(e){
            if (!e.model.queryNode("auto/console/@autoshow"))
                e.model.setQueryValue("auto/console/@autoshow", true);

            _self.height = e.model.queryValue("auto/console/@height") || _self.height;

            if (apf.isTrue(e.model.queryValue("auto/console/@maximized"))) {
                _self.show(true);
                _self.maximize();
            }
            else {
                if (apf.isTrue(e.model.queryValue("auto/console/@expanded")))
                    _self.show(true);
                else
                    _self.hide(true);
            }
        });

        this.keyEvents[KEY_UP] = function(input) {
            var newVal = cmdHistory.getPrev();
            if (newVal)
                input.setValue(newVal);
        };
        this.keyEvents[KEY_DOWN] = function(input) {
            var newVal = cmdHistory.getNext();
            if (newVal)
                input.setValue(newVal);
            else
                input.setValue("");
        };
        this.keyEvents[KEY_CR] = function(input) {
            _self.evalCmd(input.getValue());
            input.setValue("");
        };

        apf.extend(this.allCommands, ext.commandsLut);
    },

    maximize: function(){
        if (this.maximized)
            return;
        this.maximized = true;

        apf.document.body.appendChild(winDbgConsole);
        winDbgConsole.setAttribute('anchors', '0 0 0 0');
        this.lastZIndex = winDbgConsole.$ext.style.zIndex;
        winDbgConsole.removeAttribute('height');
        winDbgConsole.$ext.style.zIndex = 900000;

        settings.model.setQueryValue("auto/console/@maximized", true);
        btnConsoleMax.setValue(true);
    },

    restore : function(){
        if (!this.maximized)
            return;
        this.maximized = false;

        mainRow.appendChild(winDbgConsole);
        winDbgConsole.removeAttribute('anchors');
        winDbgConsole.setAttribute('height', this.height);
        winDbgConsole.$ext.style.zIndex = this.lastZIndex;

        settings.model.setQueryValue("auto/console/@maximized", false);
        btnConsoleMax.setValue(false);
    },

    show: function(immediate) { this._show(true, immediate); },
    hide: function(immediate) { this._show(false, immediate); },

    _show: function(shouldShow, immediate) {
        if (this.hidden != shouldShow)
            return;

        this.hidden = !shouldShow;

        if (this.$control)
            this.$control.stop();
        
        var _self = this;
        var cfg;
        if (shouldShow) {
            cfg = {
                height: this.height,
                dbgVisibleMethod: "show",
                chkExpandedMethod: "check",
                animFrom: 65,
                animTo: this.height > this.minHeight ? this.height : this.minHeight,
                animTween: "easeOutQuint"
            };

            tabConsole.show();
            apf.setStyleClass(btnCollapseConsole.$ext, "btn_console_openOpen");
        }
        else {
            cfg = {
                height: 41,
                dbgVisibleMethod: "hide",
                chkExpandedMethod: "uncheck",
                animFrom: this.height > this.minHeight ? this.height : this.minHeight,
                animTo: 65,
                animTween: "easeInOutCubic"
            };

            if (winDbgConsole.parentNode != mainRow)
                this.restore();

            apf.setStyleClass(btnCollapseConsole.$ext, "", ["btn_console_openOpen"]);
            winDbgConsole.$ext.style.minHeight = 0;
        }

        var finish = function() {
            if (!shouldShow)
                tabConsole.hide();
            else
                winDbgConsole.$ext.style.minHeight = _self.minHeight + "px";

            winDbgConsole.height = cfg.height + 1;
            winDbgConsole.setAttribute("height", cfg.height);
            winDbgConsole.previousSibling[cfg.dbgVisibleMethod]();
            apf.layout.forceResize();

            settings.model.setQueryValue("auto/console/@expanded", shouldShow);
            chkConsoleExpanded[cfg.chkExpandedMethod]();
        };

        var animOn = apf.isTrue(settings.model.queryValue("general/@animateui"));
        if (!immediate && animOn) {
            apf.tween.single(winDbgConsole.$ext, {
                control : this.$control = {},
                type  : "height",
                anim  : apf.tween[cfg.animTween],
                from  : cfg.animFrom,
                to    : cfg.animTo,
                steps : 8,
                interval : 5,
                onfinish : finish,
                oneach : function() { apf.layout.forceResize(); }
            });
        }
        else {
            finish();
        }
    },
    enable: function(){
        this.nodes.each(function(item) { item.enable(); });
    },

    disable: function(){
        this.nodes.each(function(item) { item.disable(); });
    },

    destroy: function(){
        this.nodes.each(function(item) { item.destroy(true, true); });
        this.nodes = [];
    }
});
});


/**
 * Extension manager for the Ajax.org Cloud IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
define('core/ext',['require','exports','module','core/ide','core/util'],function(require, exports, module) {

var ide = require("core/ide");
var util = require("core/util");

var ext;
module.exports = ext = {
    //Extension types
    GENERAL       : 1,
    defLength     : 1,

    extHandlers   : {
        1 : {
            register : function(oExtension){
                if (!oExtension.hook)
                    ext.initExtension(oExtension);
            },
            unregister : function(oExtension) {}
        }
    },
    extensions    : [],
    extLut        : {},
    commandsLut   : {},
    typeLut       : {
        1 : "General"
    },

    currentLayoutMode : null,

    addType : function(defName, regHandler, unregHandler){
        this[defName.toUpperCase()] = ++this.defLength;
        this.extHandlers[this.defLength] = {
            register : regHandler,
            unregister : unregHandler
        };
        this.typeLut[this.defLength] = defName;
    },

    register : function(path, oExtension, force){
        if (oExtension.registered)
            return oExtension;

        if (!mdlExt.queryNode("plugin[@path='" + path + "']"))
            mdlExt.appendXml('<plugin type="' + this.typeLut[oExtension.type]
                + '" name="' + (oExtension.name || "") + '" path="' + path
                + '" dev="' + (oExtension.dev || "") + '" enabled="1" userext="0" />');
        else
            mdlExt.setQueryValue("plugin[@path='" + path + "']/@enabled", 1);

        if (oExtension.commands) {
            for (var cmd in oExtension.commands)
                oExtension.commands[cmd].ext = path;
            apf.extend(this.commandsLut, oExtension.commands);
        }

        //Don't init general extensions that cannot live alone
        if (!force && oExtension.type == this.GENERAL && !oExtension.alone) {
            oExtension.path = path;
            return oExtension;
        }

        oExtension.registered = true;
        oExtension.path = path;

        this.extHandlers[oExtension.type].register(oExtension);

        this.extLut[path] = oExtension;
        this.extensions.push(oExtension);

        if (oExtension.hook) {
            oExtension.hook();
            
            ide.dispatchEvent("hook." + oExtension.path, {
                ext : oExtension
            });
            ide.addEventListener("$event.hook." + oExtension.path, function(callback){
                callback.call(this, {ext : oExtension});
            });
        }
        
        ide.dispatchEvent("ext.register", {ext: oExtension});

        return oExtension;
    },

    unregister : function(oExtension, silent){
        //Check exts that depend on oExtension
        var using = oExtension.using;
        if (using) {
            var inUseBy = [];
            for (var use, i = 0, l = using.length; i < l; i++) {
                if ((use = using[i]).registered)
                    inUseBy.push(use.path);
            }

            if (inUseBy.length) {
                //@todo move this to outside this function
                if (!silent)
                    util.alert(
                        "Could not disable extension",
                        "Extension is still in use",
                        "This extension cannot be disabled, because it is still in use by the following extensions:<br /><br />"
                        + " - " + inUseBy.join("<br /> - ")
                        + "<br /><br /> Please disable those extensions first.");
                return false;
            }
        }

        delete oExtension.registered;
        this.extensions.remove(oExtension);
        delete this.extLut[oExtension.path];

        //Check commands to clean up
        var commands = oExtension.commands;
        if (commands) {
            for (var cmd in commands) {
                if (this.commandsLut[cmd])
                    delete this.commandsLut[cmd];
            }
        }

        //Check deps to clean up
        var deps = oExtension.deps;
        if (deps) {
            for (var dep, ii = 0, ll = deps.length; ii < ll; ii++) {
                dep = deps[ii];
                if (dep.registered && dep.type == this.GENERAL && !oExtension.alone)
                    this.unregister(dep, true);
            }
        }

        this.extHandlers[oExtension.type].unregister(oExtension);

        mdlExt.setQueryValue("plugin[@path='" + oExtension.path + "']/@enabled", 0);

        if (oExtension.inited) {
            oExtension.destroy();
            delete oExtension.inited;
        }

        return true;
    },

    initExtension : function(oExtension, amlParent) {
        if (oExtension.inited)
            return;

        var skin = oExtension.skin;
        if (skin && typeof skin == "object") {
            var data = oExtension.skin.data;
            oExtension.skinNode = new apf.skin(apf.extend({}, oExtension.skin, {data: null}));
            oExtension.skinNode.setProperty("src", data);
            apf.document.body.appendChild(oExtension.skinNode);
        }

        //Load markup
        var markup = oExtension.markup;
        if (markup) 
            apf.document.body.insertMarkup(markup);

        var deps = oExtension.deps;
        if (deps) {
            deps.each(function(dep){
                if (!dep.registered)
                    ext.register(dep.path, dep, true);

                (dep.using || (dep.using = [])).pushUnique(oExtension);
            });
        }

        if (this.currentKeybindings) {
            var name = oExtension.path.substr(oExtension.path.lastIndexOf("/") + 1);
            var keyBindings = this.currentKeybindings[name];

            if (keyBindings)
                oExtension.currentKeybindings = keyBindings;
        }

        oExtension.init(amlParent);
        oExtension.inited = true;
        
        ide.dispatchEvent("init." + oExtension.path, {
            ext : oExtension
        });
        ide.addEventListener("$event.init." + oExtension.path, function(callback){
            callback.call(this, {ext : oExtension});
        });
    },

    enableExt : function(path) {
        var ext = require(path);
        if(!ext.enable)
            return;

        ext.enable();
        mdlExt.setQueryValue("plugin[@path='" + path + "']/@enabled", 1);
    },

    disableExt : function(path) {
        var ext = require(path);
        if(!ext.disable)
            return;

        ext.disable();
        mdlExt.setQueryValue("plugin[@path='" + path + "']/@enabled", 0);
    },

    execCommand: function(cmd, data) {
        if (cmd)
            cmd = cmd.trim();
        else
            cmd = "";

        var oCmd = this.commandsLut[cmd];
        if (!oCmd || !oCmd.ext) {
            return;
        }

        var oExt = require(oCmd.ext);
        if (oExt && typeof oExt[cmd] === "function") {
            require(["ext/console/console"], function(consoleExt) {
                if (oExt.commands[cmd].msg)
                    consoleExt.write(oExt.commands[cmd].msg);
            });
            var res = oExt[cmd](data);
            
            // if the command specifies a return value, then pass that back
            if (typeof res !== "undefined") {
                return res;
            }
            
            // otherwise respond with 'false'
            // I would expected true here but soit; console.js checks explicitly for 'false'
            return false;
        }
    }
};

});
/**
 * Code Editor for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/themes/themes',['require','exports','module','core/ide','core/ext','ext/settings/settings'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var settings = require("ext/settings/settings");

module.exports = ext.register("ext/themes/themes", {
    name    : "Themes",
    dev     : "Ajax.org",
    alone   : true,
    offline : false,
    type    : ext.GENERAL,
    nodes   : [],
    currTheme : "",
    saved   : false,

    register : function(themes){
        var _self = this;
        
        for (var name in themes) {
            this.nodes.push(
                mnuThemes.appendChild(new apf.item({
                    caption : name,
                    type    : "item",
                    value   : themes[name],
                    onmouseover: function(e) {
                        _self.currTheme = settings.model.queryValue("editors/code/@theme");
                        settings.model.setQueryValue("editors/code/@theme", this.value);
                        _self.saved = false;
                    },
                    onmouseout: function(e) {
                        if (!_self.saved) {
                            settings.model.setQueryValue("editors/code/@theme", _self.currTheme);
                            _self.saved = false;
                        }
                    }
                }))
            );
        }
    },

    set : function(path, dispatch){
        //Save theme settings
        settings.model.setQueryValue("editors/code/@theme", path);
        settings.save();
        ide.dispatchEvent("theme_change", {theme: path});
        this.saved = true;
        ide.dispatchEvent("track_action", {type: "theme change", theme: path});
    },

    init : function(){
        var _self = this;
        var menuItem = new apf.item({
            caption : "Themes",
            submenu : "mnuThemes"
        });

        this.nodes.push(
            mnuView.appendChild(menuItem),
            apf.document.body.appendChild(new apf.menu({
                id : "mnuThemes",
                onitemclick : function(e){
                    _self.set(e.relatedNode.value);
                }
            }))
        );

        ide.addEventListener("init.ext/code/code", function() {
            if (ceEditor && ceEditor.$editor)
                mnuThemes.select(null, ceEditor.$editor.getTheme());
        });
    },
    
    enable : function(){
    },

    disable : function(){
    },

    destroy : function(){
    }
});

});

/**
 * Code Editor for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/themes_default/themes_default',['require','exports','module','core/ext','ext/themes/themes'],function(require, exports, module) {

var ext = require("core/ext");
var themes = require("ext/themes/themes");

module.exports = ext.register("ext/themes_default/themes_default", {
    name    : "Themes",
    dev     : "Ajax.org",
    alone   : true,
    type    : ext.GENERAL,
    nodes   : [],

    themes  : {
        "Chrome" : "ace/theme/chrome",
        "Clouds" : "ace/theme/clouds",
        "Clouds Midnight" : "ace/theme/clouds_midnight",
        "Cobalt" : "ace/theme/cobalt",
        "Crimson Editor" : "ace/theme/crimson_editor",
        "Dawn" : "ace/theme/dawn",
        "Eclipse" : "ace/theme/eclipse",
        "Idle Fingers" : "ace/theme/idle_fingers",
        "Kr Theme" : "ace/theme/kr_theme",
        "Merbivore" : "ace/theme/merbivore",
        "Merbivore Soft" : "ace/theme/merbivore_soft",
        "Mono Industrial" : "ace/theme/mono_industrial",
        "Monokai" : "ace/theme/monokai",
        "Pastel On Dark" : "ace/theme/pastel_on_dark",
        "Solarized Dark" : "ace/theme/solarized_dark",
        "Solarized Light" : "ace/theme/solarized_light",
        "TextMate" : "ace/theme/textmate",
        "Tomorrow" : "ace/theme/tomorrow",
        "Tomorrow Night" : "ace/theme/tomorrow_night",
        "Tomorrow Night Blue" : "ace/theme/tomorrow_night_blue",
        "Tomorrow Night Bright" : "ace/theme/tomorrow_night_bright",
        "Tomorrow Night Eighties" : "ace/theme/tomorrow_night_eighties",
        "Twilight" : "ace/theme/twilight",
        "Vibrant Ink" : "ace/theme/vibrant_ink"
    },

    init : function(){
        themes.register(this.themes);
    },

    enable : function(){
    },

    disable : function(){
    },

    destroy : function(){
    }
});

});
/**
 * Dock Panel for the Cloud9 IDE client
 * 
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
 
define('ext/dockpanel/dockpanel',['require','exports','module','core/ext','core/ide','ext/dockpanel/libdock','ext/settings/settings'],function(require, exports, module) {

var ext = require("core/ext");
var ide = require("core/ide");
var DockableLayout = require("ext/dockpanel/libdock");
var settings = require("ext/settings/settings");

module.exports = ext.register("ext/dockpanel/dockpanel", {
    name           : "Dock Panel",
    dev            : "Ajax.org",
    alone          : true,
    type           : ext.GENERAL,

    defaultState   : {
        bars : []
    },

    nodes          : [],
    dockpanels     : [],
    
    loaded : false,
    
    /**
     * Standard Extension functionality
     */
    init : function(amlNode){
        var _self = this;

        var vManager = new apf.visibilitymanager();
        this.layout = new DockableLayout(hboxDockPanel, 
            //Find Page
            function(arrExtension){
                if (!arrExtension || !_self.dockpanels[arrExtension[0]])
                    return false;

                var item = _self.dockpanels[arrExtension[0]][arrExtension[1]];
                if (item.page)
                    return item.page;

                var page = item.getPage();
                
                if (page)
                    page.$arrExtension = arrExtension;
                
                vManager.permanent(page, function(e){
                    item.mnuItem.check();
                }, function(){
                    item.mnuItem.uncheck();
                });

                return page;
            }, 
            //Store Page
            function(amlPage){
                var arrExtension = amlPage.$arrExtension;
                var item = _self.dockpanels[arrExtension[0]][arrExtension[1]];
                
                item.page = amlPage;
                item.mnuItem.uncheck();

                _self.saveSettings();
            },
            //@todo This can be deprecated
            //Find Button Options
            function(arrExtension){
                if (!arrExtension || !_self.dockpanels[arrExtension[0]])
                    return false;

                return _self.dockpanels[arrExtension[0]][arrExtension[1]].options;
            },
            //Change State Handler
            function(){
                _self.saveSettings();
            },
            //Animate Settings
            function(){
                return apf.isTrue(settings.model.queryValue('general/@animateui'));
            }
        );

        //@todo was loadsettings
        ide.addEventListener("extload", function(e){
            var model = settings.model;
            var strSettings = model.queryValue("auto/dockpanel/text()");

            var state = _self.defaultState;
            if (strSettings) {
                // JSON parse COULD fail
                try {
                    state = JSON.parse(strSettings);
                }
                catch (ex) {}
            }
            
            ide.dispatchEvent("dockpanel.load.settings", {state: state});
            
            _self.layout.loadState(state);
            _self.loaded = true;
        });

        mnuToolbar.appendChild(new apf.item({
            caption : "Restore Default",
            onclick : function(){
                var defaultSettings = _self.defaultState,//settings.model.queryValue("auto/dockpanel_default/text()"),
                    state;
                    
                if (defaultSettings) {
                    // JSON parse COULD fail
                    try {
                        state = defaultSettings;//objSettings.state;
                    }
                    catch (ex) {}
                    _self.layout.loadState(state);
                    
                    settings.model.setQueryValue("auto/dockpanel/text()", state)
                    
                    _self.saveSettings();
                    
                    ide.dispatchEvent("restorelayout");
                }
            }
        }));
        
        mnuToolbar.appendChild(new apf.divider());
    },
    
    saveSettings : function(){
        clearTimeout(this.$timer);
        
        var _self = this;;
        this.$timer = setTimeout(function(){
            var state = _self.layout.getState();
            
            settings.model.setQueryValue(
                "auto/dockpanel/text()",
                JSON.stringify(state)
            );
        });
    },

    enable : function(){
        if (this.$lastState)
            this.layout.loadState(this.$lastState);
    },

    disable : function(){
        this.$lastState = this.layout.getState();
        this.layout.clearState();
    },

    destroy : function(){
        this.layout.clearState();
    },

    register : function(name, type, options, getPage){
        var panel = this.dockpanels[name] || (this.dockpanels[name] = {});
        panel[type] = {
            options : options,
            getPage : getPage
        };

        var layout = this.layout, _self = this;

        panel[type].mnuItem = mnuToolbar.appendChild(new apf.item({
            caption : options.menu.split("/").pop(),
            id      : "mnu" + type,
            type    : "check",
            onclick : function(){
                var page = getPage();

                var uId = _self.getButtons(name, type)[0].uniqueId;
                layout.show(uId, true);
                if (layout.isExpanded(uId) < 0)
                    layout.showMenu(uId);
                
                page.parentNode.set(page);
            }
        }));        
    },

    addDockable : function(def){        
        var state = this.defaultState;
            
        if (!def.barNum)
            def.barNum = 0;
        
        if (def.sections) {
            if (def.barNum || def.barNum === 0) {
                if (state.bars[def.barNum])
                    state.bars[def.barNum].sections.merge(def.sections);
                else
                    state.bars[def.barNum] = def;
            }
            else
                state.bars.push(def);
            
            return;
        }

        if (!state.bars[def.barNum || 0])
            state.bars[def.barNum || 0] = {expanded: false, width: 230, sections: []};

        var bar = state.bars[def.barNum || 0];
        
        if (def.buttons) {
            bar.sections.push(def);
        }
        else {
            bar.sections.push({
                flex    : 2,
                width   : 260,
                height  : 350,
                buttons : [def]
            });
        }
        
        return bar.sections.slice(-1);
    }, //properties.forceShow ??
    
    getButtons : function(name, type, state){
        state = state || this.layout.getState(true);
        var list  = [];
        
        if(!state)
            return;
        
        if(!state.bars)
            state = state.state;
            
        state.bars.each(function(bar){
            bar.sections.each(function(section){
                section.buttons.each(function(button){
                    if ((!name || button.ext[0] == name)
                      && (!type || button.ext[1] == type))
                        list.push(button);
                });
            });
        });
        
        return list;
    },
    
    getBars : function(name, type, state){
        var state = state || this.layout.getState(true);
        var list  = [];
        
        if(!state)
            return;
        
        if(!state.bars)
            state = state.state;
        
        if (!state.bars)
            return list;
        
        state.bars.each(function(bar){
            var found = false;
            bar.sections.each(function(section){
                section.buttons.each(function(button){
                    if ((!name || button.ext[0] == name)
                      && (!type || button.ext[1] == type))
                        found = true;
                });
            });
            
            if (found)
                list.push(bar);
        });
        
        return list;
    },
    
    hideSection: function(name, collapse){
        var buttons = this.getButtons(name);
        var bars = [];
        var _self = this;
        
        buttons.each(function(button){
            if (button.hidden < 0)
                bars.pushUnique(_self.layout.findBar(button.uniqueId));
            if (button.hidden == -1)
                _self.layout.hide(button.uniqueId);
        });
        
        if (collapse) {
            bars.each(function(bar){
                if (bar.expanded == 1)
                    _self.layout.collapseBar(bar.uniqueId);
            });
        }
    },
    
    showSection: function(name, expand){
        var buttons = this.getButtons(name);
        var _self = this;
        var bars = [];
        
        buttons.each(function(button){
            if (button.hidden && button.hidden == 1) {
                _self.layout.show(button.uniqueId);
                bars.pushUnique(_self.layout.findBar(button.uniqueId));
            }
        });
        
        bars.each(function(bar){
            if (expand && bar.expanded < 0)
                _self.layout.expandBar(bar.uniqueId);
        });
    },
    
    showBar : function(bar){
        if (bar.cache) {
            bar.cache.show();
            return;
        }
        
        var _self = this;
        bar.sections.each(function(section){
            section.buttons.each(function(button){
                _self.layout.show(button.uniqueId);
            });
        });
    },
    
    hideBar : function(bar){
        if (bar.cache)
            bar.cache.hide();
    },
    
    expandBar : function(bar){
        this.layout.expandBar(bar.cache);
    },
    
    //@todo removal of pages
    
    /**
     * Increases the notification number count by one
     * 
     * @windowIdent identifier of the dock object
     */
    increaseNotificationCount: function(windowIdent){
        /*for(var doi = 0; doi < this.dockObjects.length; doi++) {
            if (this.dockObjects[doi].ident == windowIdent) {
                // Only increase notification count if window is hidden
                if (this.dockObjects[doi].btn.value == false) {
                    if (this.dockObjects[doi].notCount >= 99)
                        return true;

                    this.dockObjects[doi].notCount++;
                    this.updateNotificationElement(
                            this.dockObjects[doi].btn
                            , this.dockObjects[doi].notCount
                    );
                }
                
                return true;
            }
        }
        
        return false;*/
    },

    /**
     * Resets the notification count to 0
     */
    resetNotificationCount: function(windowIdent){
        if (windowIdent == -1) return;

        for(var doi = 0; doi < this.dockObjects.length; doi++) {
            if (this.dockObjects[doi].ident == windowIdent) {
                this.dockObjects[doi].notCount = 0;
                this.updateNotificationElement(this.dockObjects[doi].btn, 0);
                return true;
            }
        }
        
        return false;
    },
    
    /**
     * Updates the notification element to visually reflect notCount
     */
    updateNotificationElement: function(btnObj, count){
        var countInner = count === 0 ? "" : count;

        if (apf.isGecko)
            btnObj.$ext.getElementsByClassName("dock_notification")[0].textContent = countInner;
        else
            btnObj.$ext.getElementsByClassName("dock_notification")[0].innerText = countInner;
        
        return true;
    }
});

    }
);

/**
 * Code Editor for the Cloud9 IDE
 *
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/openfiles/openfiles',['require','exports','module','core/ide','core/ext','ext/panels/panels','text!ext/openfiles/openfiles.xml'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var panels = require("ext/panels/panels");
var markup = require("text!ext/openfiles/openfiles.xml");

module.exports = ext.register("ext/openfiles/openfiles", {
    name            : "Active Files",
    dev             : "Ajax.org",
    alone           : true,
    type            : ext.GENERAL,
    markup          : markup,
    nodes           : [],
    
    defaultWidth    : 130,

    hook : function(){
        panels.register(this, {
            position : 2000,
            caption: "Open Files",
            "class": "open_files"
        });
        
        var model = this.model = new apf.model().load("<files />");
        
        ide.addEventListener("afteropenfile", function(e){
            var node = e.doc.getNode();
            if (node) {
                if (!model.queryNode("//node()[@path='" + node.getAttribute("path") + "']"))
                    model.appendXml(apf.getCleanCopy(node));
            }
        });

        ide.addEventListener("closefile", function(e){
            var node = e.xmlNode;
            model.removeXml("//node()[@path='" + node.getAttribute("path") + "']");
        });

        ide.addEventListener("updatefile", function(e){
            var node = e.xmlNode;

            var path = e.path || node.getAttribute("path");

            var fNode = model.queryNode("//node()[@path='" + path + "']");
            if (node && fNode) {
                if (e.path)
                    fNode.setAttribute("path", node.getAttribute("path"));
                if (e.filename)
                    apf.xmldb.setAttribute(fNode, "name", apf.getFilename(e.filename));
                if (e.changed != undefined)
                    apf.xmldb.setAttribute(fNode, "changed", e.changed);
            }
        });
    },

    init : function() {
        var _self = this;
        
        this.panel = winOpenFiles;
        this.nodes.push(winOpenFiles);
        
        colLeft.appendChild(winOpenFiles);
        
        lstOpenFiles.addEventListener("afterselect", this.$afterselect = function(e) {
            var node = this.selected;
            if (!node || this.selection.length > 1)
                return;

            ide.dispatchEvent("openfile", { doc: ide.createDocument(node) });
        });

        lstOpenFiles.addEventListener("afterremove", function(e){
            //Close selected files
            var sel = this.getSelection();
            for (var i = 0; i < sel.length; i++) {
                tabEditors.remove(tabEditors.getPage(sel[i].getAttribute("path")));
            }
        });

        tabEditors.addEventListener("afterswitch", function(e){
            var page = e.nextPage;
            if (page && page.$model.data) {
                var node = _self.model.queryNode("file[@path='" 
                    + page.$model.data.getAttribute("path") + "']");
                if (node && !lstOpenFiles.isSelected(node))
                    lstOpenFiles.select(node);
            }
        });

        ide.addEventListener("treechange", function(e) {

            var path = e.path
                        .replace(/\/([^/]*)/g, "/node()[@name=\"$1\"]")
                        .replace(/\[@name="workspace"\]/, "")
                        .replace(/\//, "");
            var parent = trFiles.getModel().data.selectSingleNode(path);
            if (!parent)
                return;

            var nodes = parent.childNodes;
            var files = e.files;
            var removed = [];

            for (var i = 0; i < nodes.length; ++i) {
                var node = nodes[i];
                var name = node.getAttribute("name");

                if (files[name])
                    delete files[name];
                else
                    removed.push(node);
            }

            removed.forEach(function (node) {
                apf.xmldb.removeNode(node);
            });

            path = parent.getAttribute("path");

            for (var filename in files) {
                var file = files[filename];

                var xmlNode = "<" + file.type +
                    " type='" + file.type + "'" +
                    " name='" + filename + "'" +
                    " path='" + path + "/" + filename + "'" +
                "/>";

                trFiles.add(xmlNode, parent);
            }
        });
    },
    
    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },
    
    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },
    
    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
        
        panels.unregister(this);
    },
});

});

/**
 * Code Editor for the Cloud9 IDE
 *
 * @TODO
 * - Save & load scroll position of tree
 * - Comment everything
 * 
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/tree/tree',['require','exports','module','core/ide','core/ext','core/util','ext/filesystem/filesystem','ext/settings/settings','ext/panels/panels','text!ext/tree/tree.xml'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var util = require("core/util");
var fs = require("ext/filesystem/filesystem");
var settings = require("ext/settings/settings");
var panels = require("ext/panels/panels");
var markup = require("text!ext/tree/tree.xml");

module.exports = ext.register("ext/tree/tree", {
    name             : "Project Files",
    dev              : "Ajax.org",
    alone            : true,
    type             : ext.GENERAL,
    markup           : markup,

    defaultWidth     : 200,

    deps             : [fs],

    currentSettings  : [],
    loadedSettings   : 0,
    expandedList     : {},
    treeSelection    : { path : null, type : null },
    loading          : false,
    changed          : false,
    animControl      : {},
    nodes            : [],
    model            : null,

    "default"        : true,

    hook : function(){
        // Register this panel on the left-side panels
        panels.register(this, {
            position : 1000,
            caption: "Project Files",
            "class": "project_files"
        });

        var _self = this;

        /**
         * Wait for the filesystem extension to load before we set up our
         * model
         */
        ide.addEventListener("init.ext/filesystem/filesystem", function(e) {
            _self.model = e.ext.model;

            // loadedSettings is set after "loadsettings" is dispatched.
            // Thus if we have our model setup and we have the cached expanded
            // folders, then we can load the project tree
            if (_self.loadedSettings > 0 && _self.inited)
                _self.onReady();
        });

        ide.addEventListener("loadsettings", function(e){
            var model = e.model;
            (davProject.realWebdav || davProject).setAttribute("showhidden",
                apf.isTrue(model.queryValue('auto/projecttree/@showhidden')));

            // auto/projecttree contains the saved expanded nodes
            var strSettings = model.queryValue("auto/projecttree");
            if (strSettings) {
                try {
                    _self.currentSettings = JSON.parse(strSettings);
                }
                catch (ex) {
                    _self.currentSettings = [ide.davPrefix];
                }

                // Get the last selected tree node
                var savedTreeSelection = model.queryNode("auto/tree_selection");
                if (savedTreeSelection) {
                    _self.treeSelection.path = model.queryValue('auto/tree_selection/@path');
                    _self.treeSelection.type = model.queryValue('auto/tree_selection/@type');
                }

                _self.loadedSettings = 1;

                // Please see note above about waiting for both the model and
                // the settings to be loaded before loading the project tree
                if (_self.model && _self.inited)
                    _self.onReady();
            }
            else {
                _self.loadedSettings = 2;
                if (_self.model && _self.inited)
                    _self.onReady();
            }
        });

        ide.addEventListener("savesettings", function(e){
            if (!_self.changed)
                return;

            var xmlSettings = apf.createNodeFromXpath(e.model.data, "auto/projecttree/text()");
            _self.currentSettings = [];

            var path, id;
            
            // expandedList keeps an active record of all the expanded nodes
            // so that on each save this gets serialized into the auto/projecttree
            // settings node
            for (id in _self.expandedList) {
                path = _self.expandedList[id].getAttribute("path");
                if (!path) {
                    delete _self.expandedList[id];
                }
                else {
                    _self.currentSettings.push(path);
                }
            }

            xmlSettings.nodeValue = apf.serialize(_self.currentSettings);
            _self.changed = false;
            return true;
        });

        /**
         * This receives updates from the tree watcher on the backend
         * I haven't looked deeply at this code, but it looks like it removes
         * and adds nodes
         */
        ide.addEventListener("treechange", function(e) {
            var path = e.path.replace(/\/([^/]*)/g, "/node()[@name=\"$1\"]")
                                .replace(/\[@name="workspace"\]/, "")
                                .replace(/\//, "");
            var parent = trFiles.getModel().data.selectSingleNode(path);

            if (!parent)
                return;

            var nodes   = parent.childNodes;
            var files   = e.files;
            var removed = [];

            for (var i = 0; i < nodes.length; ++i) {
                var node = nodes[i],
                    name = node.getAttribute("name");

                if (files && files[name])
                    delete files[name];
                else
                    removed.push(node);
            }
            removed.forEach(function (node) {
                apf.xmldb.removeNode(node);
            });
            path = parent.getAttribute("path");
            for (var filename in files) {
                var file = files[filename];

                var xmlNode = "<" + file.type +
                    " type='" + file.type + "'" +
                    " name='" + filename + "'" +
                    " path='" + path + "/" + filename + "'" +
                "/>";
                trFiles.add(xmlNode, parent);
            }
        });
        
        ext.initExtension(this);
    },

    onReady : function() {
        var _self = this;
        trFiles.setAttribute("model", this.model);
        if(this.loadedSettings === 1) {
            setTimeout(function() {
                _self.loadProjectTree();
            }, 1000);
        }

        // If no settings were found, then we set the "get" attribute of
        // the AML insert rule for the tree and expand the root. The
        // "get" attr is originally empty by default so when we run
        // this.loadProjectTree() the tree itself doesn't try to duplicate
        // our actions
        else {
            trFilesInsertRule.setAttribute("get", "{davProject.readdir([@path])}");
            trFiles.expandAll();
        }
    },

    init : function() {
        var _self = this;

        // Set the panel var for the panels extension
        this.panel = winFilesViewer;
        this.nodes.push(winFilesViewer);

        colLeft.appendChild(winFilesViewer);

        // This adds a "Show Hidden Files" item to the settings dropdown
        // from the Project Files header
        mnuFilesSettings.appendChild(new apf.item({
            id      : "mnuitemHiddenFiles",
            type    : "check",
            caption : "Show Hidden Files",
            visible : "{trFiles.visible}",
            checked : "[{require('ext/settings/settings').model}::auto/projecttree/@showhidden]",
            onclick : function(e){
                setTimeout(function() {
                    _self.changed = true;
                    (davProject.realWebdav || davProject)
                        .setAttribute("showhidden", e.currentTarget.checked);

                    _self.refresh();
                });
            }
        }));

        this.setupTreeListeners();

        if (_self.loadedSettings > 0 && _self.model)
            _self.onReady();
    },

    /**
     * Sets up listeners on tree events
     */
    setupTreeListeners : function() {
        var _self = this;

        // After an item in the tree has been clicked on, this saves that
        // selection in the settings model
        trFiles.addEventListener("afterselect", this.$afterselect = function(e) {
            if (settings.model && settings.model.data && trFiles.selected) {
                var nodePath          = trFiles.selected.getAttribute("path");
                var nodeType          = trFiles.selected.getAttribute("type");
                var settingsData      = settings.model.data;
                var treeSelectionNode = settingsData.selectSingleNode("auto/tree_selection");
                if(treeSelectionNode) {
                    apf.xmldb.setAttribute(treeSelectionNode, "path", nodePath);
                    apf.xmldb.setAttribute(treeSelectionNode, "type", nodeType);
                }
                else {
                    apf.xmldb.appendChild(settingsData.selectSingleNode("auto"),
                        apf.getXml('<tree_selection path="' + nodePath +
                            '" type="' + nodeType + '" />')
                    );
                }

                // Also update our own internal selection vars for when the
                // user refreshes the tree
                _self.treeSelection.path = nodePath;
                _self.treeSelection.type = nodeType;
            }
        });

        // Opens a file after the user has double-clicked
        trFiles.addEventListener("afterchoose", this.$afterchoose = function() {
            var node = this.selected;
            if (!node || node.tagName != "file" || this.selection.length > 1 ||
                !ide.onLine && !ide.offlineFileSystemSupport) //ide.onLine can be removed after update apf
                    return;

            ide.dispatchEvent("openfile", {doc: ide.createDocument(node)});
        });

        trFiles.addEventListener("beforecopy", this.$beforecopy = function(e) {
            if (!ide.onLine && !ide.offlineFileSystemSupport)
                return false;

            var args     = e.args[0].args,
                filename = args[1].getAttribute("name");

            var count = 0;
            filename.match(/\.(\d+)$/, "") && (count = parseInt(RegExp.$1, 10));
            while (args[0].selectSingleNode("node()[@name='" + filename.replace(/'/g, "\\'") + "']")) {
                filename = filename.replace(/\.(\d+)$/, "") + "." + ++count;
            }
            args[1].setAttribute("newname", filename);

            setTimeout(function () {
                fs.beforeRename(args[1], null,
                    args[0].getAttribute("path").replace(/[\/]+$/, "") +
                    "/" + filename, true);
                args[1].removeAttribute("newname");
            });
        });

        trFiles.addEventListener("beforestoprename", this.$beforestoprename = function(e) {
            if (!ide.onLine && !ide.offlineFileSystemSupport)
                return false;

            return fs.beforeStopRename(e.value);
        });

        trFiles.addEventListener("beforerename", this.$beforerename = function(e){
            if (!ide.onLine && !ide.offlineFileSystemSupport) return false;

            if(trFiles.$model.data.firstChild == trFiles.selected)
                return false;

            // check for a path with the same name, which is not allowed to rename to:
            var path = e.args[0].getAttribute("path"),
                newpath = path.replace(/^(.*\/)[^\/]+$/, "$1" + e.args[1]).toLowerCase();

            var exists, nodes = trFiles.getModel().queryNodes(".//node()");
            for (var i = 0, len = nodes.length; i < len; i++) {
                var pathLwr = nodes[i].getAttribute("path").toLowerCase();
                if (nodes[i] != e.args[0] && pathLwr === newpath) {
                    exists = true;
                    break;
                }
            }

            if (exists) {
                util.alert("Error", "Unable to Rename",
                    "That name is already taken. Please choose a different name.");
                trFiles.getActionTracker().undo();
                return false;
            }

            fs.beforeRename(e.args[0], e.args[1]);
        });

        trFiles.addEventListener("beforemove", this.$beforemove = function(e){
            if (!ide.onLine && !ide.offlineFileSystemSupport)
                return false;

            setTimeout(function(){
                var changes = e.args;
                for (var i = 0; i < changes.length; i++) {
                    // If any file exists in its future destination, cancel the event.
                    fs.beforeMove(changes[i].args[0], changes[i].args[1], trFiles);
                }
            });
        });

        trFiles.addEventListener("beforeadd", this.cancelWhenOffline);
        trFiles.addEventListener("renamestart", this.cancelWhenOffline);
        trFiles.addEventListener("beforeremove", this.cancelWhenOffline);
        trFiles.addEventListener("dragstart", this.cancelWhenOffline);
        trFiles.addEventListener("dragdrop", this.cancelWhenOffline);

        // When a folder has been expanded, save it in expandedList
        trFiles.addEventListener("expand", this.$expand = function(e){
            if (!e.xmlNode)
                return;
            _self.expandedList[e.xmlNode.getAttribute(apf.xmldb.xmlIdTag)] = e.xmlNode;

            // Only save if we are not loading the tree
            if (!_self.loading) {
                _self.changed = true;
                settings.save();
            }
        });

        // When a folder has been expanded, remove it from expandedList
        trFiles.addEventListener("collapse", this.$collapse = function(e){
            if (!e.xmlNode)
                return;
            delete _self.expandedList[e.xmlNode.getAttribute(apf.xmldb.xmlIdTag)];

            if (!_self.loading) {
                _self.changed = true;
                settings.save();
            }
        });
    },

    $cancelWhenOffline : function() {
        if (!ide.onLine && !ide.offlineFileSystemSupport)
            return false;
    },

    moveFile : function(path, newpath){
        davProject.move(path, newpath);
        trFiles.enable();
        trFiles.focus();
    },

    /**
     * Loads the project tree based on currentSettings, which is an arry of
     * folders that were previously expanded, otherwise it contains only the
     * root identifier (i.e. ide.davPrefix)
     * 
     * @param callback callback Called fired when the tree is fully loaded
     */
    loadProjectTree : function(callback) {
        this.loading = true;

        var currentSettings = this.currentSettings;
        var len = currentSettings.length;
        var _self = this;

        /**
         * Called recursively. `i` is used as the iterator moving through
         * the currentSettings array
         * 
         * @param number i The iterator for referencing currentSettings' elements
         */
        function getLoadPath(i) {
            if (i >= len)
                return onFinish();

            var path = currentSettings[i];

            // At some point davProject.realWebdav is set but you'll note that
            // tree.xml is able ot use just davProject (which is an intended
            // global). Why we cannot use that here escapes me, so we have to
            // check which one is available for us to use (and yes, realWebdav
            // can sometimes not be set on initial load)
            (davProject.realWebdav || davProject).readdir(path, function(data, state, extra) {
                // Strip the extra "/" that webDav adds on
                var realPath = extra.url.substr(0, extra.url.length-1);

                // Get the parent node of the new items. If the path is the
                // same as `ide.davPrefix`, then we append to root
                var parentNode;
                if (realPath === ide.davPrefix)
                    parentNode = trFiles.queryNode("folder[@root=1]");
                else
                    parentNode = trFiles.queryNode('//folder[@path="' + realPath + '"]');

                // Hmm? Folder deleted?
                if (!parentNode)
                    return getLoadPath(++i);

                var dataXml = apf.getXml(data);
                for (var x = 0, xmlLen = dataXml.childNodes.length; x < xmlLen; x++) {
                    // Since appendChild removes the node from the array, we
                    // must first clone the node and then append it to the parent
                    var clonedNode = dataXml.childNodes[x].cloneNode(true);
                    apf.xmldb.appendChild(parentNode, clonedNode);
                }

                // If the load status is not set, then APF assumes the child
                // nodes still need to be loaded and the folder icon is replaced
                // with a perennial spinner
                trFiles.$setLoadStatus(parentNode, "loaded");

                // Slide open the folder and then get the next cached folder's
                // contents
                trFiles.slideToggle(apf.xmldb.getHtmlNode(parentNode, trFiles), 1, true, null, function() {
                    getLoadPath(++i);
                });
            });
        }

        // Called when every cached node has been loaded
        function onFinish() {
            _self.loading = false;

            // Re-select the last selected item
            if(_self.treeSelection.path) {
                var xmlNode = trFiles.$model.queryNode('//node()[@path="' +
                    _self.treeSelection.path + '" and @type="' +
                    _self.treeSelection.type + '"]');
                trFiles.select(xmlNode);
            }
            else {
                trFiles.select(trFiles.$model.queryNode("node()"));
            }

            // Now set the "get" attribute of the <a:insert> rule so the tree
            // knows to ask webdav for expanded folders' contents automatically
            trFilesInsertRule.setAttribute("get", "{davProject.readdir([@path])}");

            settings.save();

            if (callback)
                return callback();
        }

        // Let's kick this sucker off!
        getLoadPath(0);
    },

    /**
     * Called when the user hits the refresh button in the Project Files header
     */
    refresh : function(){
        trFiles.getModel().load("<data><folder type='folder' name='" +
            ide.projectName + "' path='" + ide.davPrefix + "' root='1'/></data>");
        this.expandedList = {};

        // Make sure the "get" attribute is empty so the file tree doesn't
        // think it's the one loading up all the data when loadProjectTree
        // expands folders
        trFilesInsertRule.setAttribute("get", "");

        ide.dispatchEvent("track_action", { type: "reloadtree" });

        this.loadProjectTree();
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        trFiles.removeEventListener("afterselect", this.$afterselect);
        trFiles.removeEventListener("afterchoose", this.$afterchoose);
        trFiles.removeEventListener("expand", this.$expand);
        trFiles.removeEventListener("collapse", this.$collapse);
        trFiles.removeEventListener("beforemove", this.$beforemove);
        trFiles.removeEventListener("beforerename", this.$beforerename);
        trFiles.removeEventListener("beforestoprenam", this.$beforestoprename);
        trFiles.removeEventListener("beforecopy", this.$beforecopy);
        trFiles.removeEventListener("beforeadd", this.$cancelWhenOffline);
        trFiles.removeEventListener("renamestart", this.$cancelWhenOffline);
        trFiles.removeEventListener("beforeremove", this.$cancelWhenOffline);
        trFiles.removeEventListener("dragstart", this.$cancelWhenOffline);
        trFiles.removeEventListener("dragdrop", this.$cancelWhenOffline);

        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];

        panels.unregister(this);
    }
});

});

/**
 * Refactor Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/save/save',['require','exports','module','core/ide','core/ext','core/util','ext/filesystem/filesystem','text!ext/save/save.css','text!ext/save/save.xml'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var util = require("core/util");
var fs = require("ext/filesystem/filesystem");
var css = require("text!ext/save/save.css");
var markup = require("text!ext/save/save.xml");

module.exports = ext.register("ext/save/save", {
    dev         : "Ajax.org",
    name        : "Save",
    alone       : true,
    type        : ext.GENERAL,
    markup      : markup,
    css         : css,
    deps        : [fs],
    offline     : true,

    commands    : {
        "quicksave": {hint: "save the currently active file to disk"},
        "saveas": {hint: "save the file to disk with a different filename"},
        "reverttosaved": {hint: "downgrade the currently active file to the last saved version"}
    },
    hotitems    : {},
    nodes       : [],
    saveBuffer  : {},

    hook : function(){
        if (!self.tabEditors) return;

        var _self = this;

        tabEditors.addEventListener("close", this.$close = function(e) {
            var at = e.page.$at;
            if (!at.undo_ptr)
                at.undo_ptr = at.$undostack[0];
            var node = e.page.$doc.getNode();
            if (node && at.undo_ptr && at.$undostack[at.$undostack.length-1] !== at.undo_ptr
              || !at.undo_ptr && node.getAttribute("changed") == 1
              && e.page.$doc.getValue()) {
                ext.initExtension(_self);

                var pages   = tabEditors.getPages(),
                currIdx = pages.indexOf(e.page);
                tabEditors.set(pages[currIdx].id); //jump to file

                var filename = node.getAttribute("path").replace(ide.workspaceDir, "").replace(ide.davPrefix, "");

                winCloseConfirm.page = e.page;
                winCloseConfirm.all  = -100;
                winCloseConfirm.show();

                fileDesc.insertMarkup("<div><h3>Save " +  "?</h3><div>This file has unsaved changes. Your changes will be lost if you don't save them.</div></div>");

                winCloseConfirm.addEventListener("hide", function(){
                    if (winCloseConfirm.all != -100) {
                        var f = function(resetUndo){
                            var page;
                            if (!(page=winCloseConfirm.page))
                                return;

                            tabEditors.remove(page, true, page.noAnim);
                            delete page.noAnim;
                            if (resetUndo)
                                page.$at.undo(-1);
                            delete winCloseConfirm.page;
                            page.dispatchEvent("aftersavedialogclosed");
                        };

                        if (winCloseConfirm.all == -200)
                            _self.quicksave(winCloseConfirm.page, f);
                        else
                            f(true);
                        /*winSaveAs.page = winCloseConfirm.page;*/
                    }
                    else
                        tabEditors.dispatchEvent("aftersavedialogcancel");

                    winCloseConfirm.removeEventListener("hide", arguments.callee);
                });

                btnYesAll.hide();
                btnNoAll.hide();

                e.preventDefault();
            }
        });

        this.nodes.push(ide.barTools.appendChild(new apf.button({
            id       : "btnSave",
            icon     : "save.png",
            tooltip  : "Save",
            skin     : "c9-toolbarbutton",
            disabled : "{!!!tabEditors.activepage}",
            onclick  : this.quicksave.bind(this)
        })));

        var saveItem, saveAsItem;
        this.nodes.push(
            ide.mnuFile.insertBefore(new apf.divider(), ide.mnuFile.firstChild),

            ide.mnuFile.insertBefore(new apf.item({
                caption : "Save All",
                onclick : function(){
                    _self.saveall();
                },
                disabled : "{!!!tabEditors.activepage}"
            }), ide.mnuFile.firstChild),

            saveAsItem = ide.mnuFile.insertBefore(new apf.item({
                caption : "Save As...",
                onclick : function () {
                    _self.saveas();
                },
                disabled : "{!!!tabEditors.activepage}"
            }), ide.mnuFile.firstChild),

            saveItem = ide.mnuFile.insertBefore(new apf.item({
                caption : "Save",
                onclick : this.quicksave.bind(this),
                disabled : "{!!!tabEditors.activepage}"
            }), ide.mnuFile.firstChild),

            ide.mnuFile.insertBefore(new apf.divider(), ide.mnuFile.firstChild),

            ide.mnuFile.insertBefore(new apf.item({
                caption : "Revert to Saved",
                onclick : function(){
                    _self.reverttosaved();
                },
                disabled : "{!!!tabEditors.activepage}"
            }), ide.mnuFile.firstChild)
        );

        this.hotitems.quicksave = [saveItem];
        this.hotitems.saveas = [saveAsItem];
    },

    init : function(amlNode){
        this.fileDesc = winCloseConfirm.selectSingleNode("a:vbox");

        apf.importCssString((this.css || ""));
        winCloseConfirm.onafterrender = function(){
            btnYesAll.addEventListener("click", function(){
                winCloseConfirm.all = 1;
                winCloseConfirm.hide();
            });
            btnNoAll.addEventListener("click", function(){
                winCloseConfirm.all = -1;
                winCloseConfirm.hide();
            });
            btnSaveYes.addEventListener("click", function(){
                winCloseConfirm.all = -200;
                winCloseConfirm.hide();
            });
            btnSaveNo.addEventListener("click", function(){
                winCloseConfirm.all = 0;
                winCloseConfirm.hide();
            });
            btnSaveCancel.addEventListener("click", function(){
                winCloseConfirm.all = -100;
                winCloseConfirm.hide();
            });
        };

        winSaveAs.addEventListener("hide", function(){
            if (winSaveAs.page) {
                tabEditors.remove(winSaveAs.page, true);
                winSaveAs.page.$at.undo(-1);
                delete winSaveAs.page;
            }
        });
    },

    reverttosaved : function(){
        ide.dispatchEvent("reload", {doc : tabEditors.getPage().$doc});
    },

    saveall : function(){
        tabEditors.getPages().forEach(this.quicksave, this);
    },

    saveAllInteractive : function(pages, callback){
        ext.initExtension(this);

        winCloseConfirm.all = 0;

        var _self = this;
        apf.asyncForEach(pages, function(item, next) {
            var at = item.$at;
            if (at.undo_ptr && at.$undostack[at.$undostack.length-1] !== at.undo_ptr) {
                if (winCloseConfirm.all == 1)
                    _self.quicksave(item);

                if (winCloseConfirm.all)
                    return next();

                tabEditors.set(item);
                winCloseConfirm.page = item;
                winCloseConfirm.show();
                winCloseConfirm.addEventListener("hide", function(){
                    if (winCloseConfirm.all == 1)
                        _self.quicksave(item);

                    winCloseConfirm.removeEventListener("hide", arguments.callee);
                    next();
                });

                btnYesAll.setProperty("visible", pages.length > 1);
                btnNoAll.setProperty("visible", pages.length > 1);
            }
            else
                next();
        },
        function() {
            callback(winCloseConfirm.all);
        });
    },

    // `silentsave` indicates whether the saving of the file is forced by the user or not.
    quicksave : function(page, callback, silentsave) {
        if (!page || !page.$at)
            page = tabEditors.getPage();

        if (!page)
            return;

        var doc  = page.$doc;
        var node = doc.getNode();
        var path = node.getAttribute("path");

        if (node.getAttribute("debug"))
            return;

        if (ide.dispatchEvent("beforefilesave", {node: node, doc: doc }) === false)
            return;

        if (node.getAttribute("newfile")){
            this.saveas(page, callback);
            return;
        }

        if (callback) {
            ide.addEventListener("afterfilesave", function(e) {
                if (e.node == node) {
                    callback();
                    this.removeEventListener("afterfilesave", arguments.callee);
                }
            });
        }

        // check if we're already saving!
        var saving = parseInt(node.getAttribute("saving"), 10);
        if (saving) {
            this.saveBuffer[path] = page;
            return;
        }

        apf.xmldb.setAttribute(node, "saving", "1");

        var _self = this, panel = sbMain.firstChild;
        panel.setAttribute("caption", "Saving file " + path);

        var value = doc.getValue();

        fs.saveFile(path, value, function(data, state, extra){
            if (state != apf.SUCCESS) {
                util.alert(
                    "Could not save document",
                    "An error occurred while saving this document",
                    "Please see if your internet connection is available and try again. "
                        + (state == apf.TIMEOUT
                            ? "The connection timed out."
                            : "The error reported was " + extra.message));
            }

            panel.setAttribute("caption", "Saved file " + path);

            ide.dispatchEvent("afterfilesave", {
                node: node,
                doc: doc,
                value: value,
                silentsave: silentsave
            });

            ide.dispatchEvent("track_action", {
                type: "save as filetype",
                fileType: node.getAttribute("name").split(".").pop(),
                success: state != apf.SUCCESS ? "false" : "true"
            });

            apf.xmldb.removeAttribute(node, "saving");
            apf.xmldb.removeAttribute(node, "new");
            apf.xmldb.setAttribute(node, "modifieddate", apf.queryValue(extra.data, "//d:getlastmodified"));

            if (_self.saveBuffer[path]) {
                delete _self.saveBuffer[path];
                _self.quicksave(page);
            }
        });

        var at = page.$at
        at.undo_ptr = at.$undostack[at.$undostack.length-1];
        page.$at.dispatchEvent("afterchange");
        return false;
    },

    _saveAsNoUI: function(page, path, newPath) {
        if (!page || !path)
            return;

        newPath = newPath || path;

        var file = page.$model.data;
        var saving = parseInt(file.getAttribute("saving"), 10);

        if (saving) {
            this.saveBuffer[path] = page;
            return;
        }
        apf.xmldb.setAttribute(file, "saving", "1");

        var self = this;
        var panel = sbMain.firstChild;
        var value = page.$doc.getValue();
        fs.saveFile(newPath, value, function(value, state, extra) {
            if (state != apf.SUCCESS) {
                util.alert("Could not save document",
                  "An error occurred while saving this document",
                  "Please see if your internet connection is available and try again.");
            }
            panel.setAttribute("caption", "Saved file " + newPath);

            var model = page.$model;
            var node = model.getXml();
            var doc = page.$doc;

            if (path !== newPath || parseInt(node.getAttribute("newfile") || 0, 10) === 1) {
                model.load(node);
                file = model.data;
                fs.beforeRename(file, null, newPath, false);
                doc.setNode(file);
            }

            apf.xmldb.removeAttribute(node, "saving");

            if (self.saveBuffer[path]) {
                delete self.saveBuffer[path];
                self._saveAsNoUI(page);
            }

            if (parseInt(file.getAttribute("newfile") || "0", 10) === 1) {
                apf.xmldb.removeAttribute(file, "newfile");
                apf.xmldb.removeAttribute(file, "changed");
                var xpath = newPath.replace(new RegExp("\/" + cloud9config.davPrefix.split("/")[1]), "")
                                    .replace(new RegExp("\/" + file.getAttribute("name")), "")
                                    .replace(/\/([^/]*)/g, "/node()[@name=\"$1\"]")
                                    .replace(/\/node\(\)\[@name="workspace"\]/, "")
                                    .replace(/\//, "");
                if (xpath) {
                    var oNode  = trFiles.queryNode(xpath);
                    if (oNode && !trFiles.queryNode('//node()[@path="' + newPath + '"]'))
                        apf.xmldb.appendChild(oNode, file);
                }
            }

            ide.dispatchEvent("afterfilesave", {
                node: node,
                doc: doc,
                value: value,
                silentsave: false // It is a forced save, comes from UI
            });
        });

        var at = page.$at
        at.undo_ptr = at.$undostack[at.$undostack.length-1];
        page.$at.dispatchEvent("afterchange");
    },

    choosePath : function(path, select) {
        fs.list((path.match(/(.*)\/[^/]*/) || {})[1] || path, function (data, state, extra) {
            if (new RegExp("<folder.*" + path + ".*>").test(data)) {
                path  = path.replace(new RegExp('\/' + cloud9config.davPrefix.split('/')[1]), '')
                            .replace(/\/([^/]*)/g, "/node()[@name=\"$1\"]")
                            .replace(/\/node\(\)\[@name="workspace"\]/, "")
                            .replace(/\//, "");

                trSaveAs.expandList([path], function() {
                    var node = trSaveAs.getModel().data.selectSingleNode(path);
                    trSaveAs.select(node);
                });
            }
        });
    },

    // Function called from the 'Save As' menu dialog, and from the C9 CLI.
    // It saves a file with a different name, involving UI.
    saveas : function(page, callback){
        if (!page || !page.$at)
            page = tabEditors.getPage();

        if (!page)
            return;

        var path = page ? page.$model.data.getAttribute("path") : false;
        if (!path)
            return;

        ext.initExtension(this);

        if (callback) {
            var doc = page.$doc;
            ide.addEventListener("afterfilesave", function(e){
                if (e.doc == doc) {
                    callback();
                    this.removeEventListener("afterfilesave", arguments.callee);
                }
            });
        }

        var fooPath = path.split('/');
        txtSaveAs.setValue(fooPath.pop());
        lblPath.setProperty('caption', fooPath.join('/') + '/');
        winSaveAs.show();
    },

    // Called by the UI 'confirm' button in winSaveAs.
    confirmSaveAs : function(page) {
        page = page || tabEditors.getPage();
        var file = page.$model.data;
        var path = file.getAttribute("path");
        var newPath = lblPath.getProperty('caption') + txtSaveAs.getValue();

        // check if we're already saving!
        var saving = parseInt(file.getAttribute("saving"), 10);
        if (saving) {
            this.saveBuffer[path] = page;
            return;
        }

        //apf.xmldb.setAttribute(file, "saving", "1");

        var self = this;
        var doSave = function() {
            winConfirm.hide();
            winSaveAs.hide();
            self._saveAsNoUI(page, path, newPath);
        };

        if (path !== newPath || parseInt(file.getAttribute("newfile") || 0, 10) === 1) {
            fs.exists(newPath, function (exists) {
                if (exists) {
                    var name = newPath.match(/\/([^/]*)$/)[1];
                    var folder = newPath.match(/\/([^/]*)\/[^/]*$/)[1];

                    util.confirm(
                        "Are you sure?",
                        "\"" + name + "\" already exists, do you want to replace it?",
                        "A file or folder with the same name already exists in the folder "
                        + folder + ". "
                        + "Replacing it will overwrite it's current contents.",
                        doSave);
                }
                else {
                    doSave();
                }
            });
        }
        else {
            doSave();
        }
    },

    expandTree : function(){
        var _self = this;
        setTimeout(function(){
            var tabPage = tabEditors.getPage(),
                path    = tabPage ? tabPage.$model.data.getAttribute('path') : false,
                isNew   = tabPage.$model.data.getAttribute('newfile');
            if(!isNew)
                _self.choosePath(path);
            else
                trSaveAs.slideOpen(null, trSaveAs.getModel().data.selectSingleNode('//folder'));
        });
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];

        tabEditors.removeEventListener("close", this.$close);
    }
});

});

/**
 * Vim mode for the Cloud9 IDE
 *
 * @author Sergi Mansilla <sergi AT c9 DOT io>
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/vim/cli',['require','exports','module','ext/save/save'],function(require, exports, module) {

var save;
var cmds = module.exports = {
    w: function(editor, data) {
        if (!save)
            save = require("ext/save/save");

        var page = tabEditors.getPage();
        if (!page)
            return;

        var lines = editor.session.getLength();
        if (data.argv.length === 2) {
            var path = ("/workspace/" + data.argv[1]).replace(/\/+/, "/");
            page.$model.data.setAttribute("path", path);

            save.saveas(page, function() {
                console.log(path + " [New] " + lines + "L, ##C written");
            });
        }
        else {
            save.quicksave(null, function() {
                console.log(page.name + " " + lines +"L, ##C written");
            });
        }
    }
};

// aliases
cmds.write = cmds.w;

});

/**
 * Adds a menu item with a submenu that lists all recently opened files
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/recentfiles/recentfiles',['require','exports','module','core/ide','core/ext'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");

module.exports = ext.register("ext/recentfiles/recentfiles", {
    dev         : "Ajax.org",
    name        : "Recent Files",
    alone       : true,
    type        : ext.GENERAL,
    deps        : [],
    offline     : true,

    currentSettings : [],
    nodes       : [],

    init : function(){
        var _self = this;

        this.nodes.push(
            ide.mnuFile.insertBefore(new apf.item({
                caption : "Open Recent",
                submenu : "mnuRecent"
            }), ide.mnuFile.firstChild),

            apf.document.body.appendChild(this.menu = new apf.menu({
                id : "mnuRecent",
                childNodes : [
                    this.divider = new apf.divider(),
                    new apf.item({
                        caption : "Clear Menu",
                        onclick : function(){
                            _self.clearMenu();
                        }
                    })
                ]
            }))
        );

        ide.addEventListener("loadsettings", function(e){
            var model = e.model;
            var strSettings = model.queryValue("auto/recentfiles");
            if (strSettings) {
                var currentSettings;
                try {
                    currentSettings = JSON.parse(strSettings);
                }
                catch (ex) {
                    //fail! revert to default
                    currentSettings = [];
                }

                _self.clearMenu();

                for (var i = currentSettings.length - 1; i >= 0; i--) {
                    _self.$add(currentSettings[i]);
                }
            }
        });

        ide.addEventListener("savesettings", function(e){
            if (!_self.changed)
                return;

            var xmlSettings = apf.createNodeFromXpath(e.model.data, "auto/recentfiles/text()");

            var currentSettings = [];
            var nodes = _self.menu.childNodes;
            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].localName == "item") {
                    currentSettings.push({
                        caption : nodes[i].caption,
                        value   : nodes[i].value
                    });
                }
                else break;
            }

            xmlSettings.nodeValue = apf.serialize(currentSettings);
            return true;
        });

        function evHandler(e){
            var node = e.node || e.xmlNode;

            if (!node)
                return;

            if (e.name != "afterfilesave" && node.getAttribute("newfile") == 1)
                return;

            var obj = {
                caption : node.getAttribute("name"),
                value   : node.getAttribute("path"),
                node    : node
            };

            _self.currentSettings.shift(obj);

            _self.$add(obj);
        }

        ide.addEventListener("afteropenfile", evHandler);
        ide.addEventListener("afterfilesave", evHandler);
        ide.addEventListener("closefile", evHandler);
    },

    $add : function(def) {
        var found, nodes = this.menu.childNodes;
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].nodeType != 1) continue;

            if (nodes[i].localName == "item") {
                if (nodes[i].value == def.value) {
                    found = nodes[i];
                    break;
                }
            }
            else break;
        }

        if (found) {
            this.menu.insertBefore(found, this.menu.firstChild);
        }
        else {
            this.menu.insertBefore(new apf.item({
                caption : def.caption,
                value   : def.value,
                onclick : function(){
                    var node = apf.getXml("<file />");
                    node.setAttribute("name", def.caption);
                    node.setAttribute("path", def.value);

                    ide.dispatchEvent("openfile", {doc: ide.createDocument(node)});
                }
            }), this.menu.firstChild);
        }

        while (this.menu.childNodes.length > 12) {
            this.menu.removeChild(this.divider.previousSibling);
        }

        this.changed = true;
    },

    clearMenu : function(){
        var nodes = this.menu.childNodes;
        for (var i = nodes.length - 1; i >= 0; i--) {
            if (nodes[0].localName == "item")
                this.menu.removeChild(nodes[0]);
            else break;
        }
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});

/**
 * Code Editor for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/gotofile/gotofile',['require','exports','module','core/ide','core/ext','ext/editors/editors','text!ext/gotofile/gotofile.xml'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var editors = require("ext/editors/editors");
var markup = require("text!ext/gotofile/gotofile.xml");

module.exports = ext.register("ext/gotofile/gotofile", {
    name    : "Filter Tree",
    dev     : "Ajax.org",
    alone   : true,
    offline : false,
    type    : ext.GENERAL,
    markup  : markup,
    offline : false,
    commands : {
        "gotofile": {hint: "search for a filename and jump to it"}
    },
    hotitems: {},

    nodes   : [],

    hook : function(){
        var _self = this;

        this.nodes.push(
            mnuFile.insertBefore(new apf.item({
                caption : "Open...",
                onclick : function() {
                    _self.toggleDialog(true);
                }
            }), mnuFile.firstChild),

            ide.barTools.appendChild(new apf.button({
                id      : "btnOpen",
                icon    : "open.png",
                width   : 29,
                tooltip : "Open...",
                skin    : "c9-toolbarbutton",
                onclick : function() {
                    _self.toggleDialog(true);
                }
            }))
        );

        this.hotitems["gotofile"] = [this.nodes[0]];
    },

    init : function() {
        var _self = this;
        
        txtGoToFile.addEventListener("keydown", function(e){
            if (txtGoToFile.value == "") {
                return;
            }

            if (e.keyCode == 13){
                //var node = trFiles.xmlRoot.selectSingleNode("folder[1]");
                mdlGoToFile.load("{davProject.report('" + ide.davPrefix //node.getAttribute("path")
                    + "', 'filesearch', {query: '" + txtGoToFile.value + "'})}");
                ide.dispatchEvent("track_action", {type: "gotofile"});
            }
            else if (e.keyCode == 40 && dgGoToFile.length) {
                var first = dgGoToFile.getFirstTraverseNode();
                if (first) {
                    dgGoToFile.select(first);
                    dgGoToFile.focus();
                }
            }
        });
        
        dgGoToFile.addEventListener("keydown", function(e) {
            if (e.keyCode == 38 && !e.shiftKey) {
                if (this.selected == this.getFirstTraverseNode())
                    txtGoToFile.focus();
            }
            else if (apf.isCharacter(e.keyCode)) {
                txtGoToFile.focus();
            }
        }, true);

        dgGoToFile.addEventListener("afterchoose", function(e) {
            _self.openFile();
        });

        this.nodes.push(winGoToFile);
    },
    
    openFile: function(){
        var nodes = dgGoToFile.getSelection();
        
        if(nodes.length == 0)
            return false;
            
        winGoToFile.hide();
        for (var i = 0; i < nodes.length; i++) {
            var path = ide.davPrefix.replace(/[\/]+$/, "") + "/" 
                + apf.getTextNode(nodes[i]).nodeValue.replace(/^[\/]+/, "");
            editors.showFile(path, 0, 0);
            ide.dispatchEvent("track_action", {type: "fileopen"});
        }
    },

    gotofile : function(){
        this.toggleDialog(true);
        return false;
    },

    toggleDialog: function(forceShow) {
        ext.initExtension(this);

        if (!winGoToFile.visible || forceShow)
            winGoToFile.show();
        else
            winGoToFile.hide();
        return false;
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        winGoToFile.destroy(true, true);
        this.nodes = [];
    }
});

});
/**
 * Refactor Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/undo/undo',['require','exports','module','core/ext'],function(require, exports, module) {

var ext = require("core/ext");
 
module.exports = ext.register("ext/undo/undo", {
    dev    : "Ajax.org",
    name   : "Undo",
    alone  : true,
    type   : ext.GENERAL,
    commands: {
        "undo": {hint: "undo one edit step in the active document"},
        "redo": {hint: "redo one edit step in the active document"}
    },

    nodes : [],

    init : function(amlNode){
        this.nodes.push(
            mnuEdit.appendChild(new apf.item({
                caption : "Undo",
                onclick : this.undo
            })),
            mnuEdit.appendChild(new apf.item({
                caption : "Redo",
                onclick : this.redo
            }))
        );

        this.hotitems = {
            "undo" : [this.nodes[0]],
            "redo" : [this.nodes[1]]
        };
    },

    undo: function() {
        var _tabPage;
        if(_tabPage = tabEditors.getPage())
            _tabPage.$at.undo();
    },

    redo: function() {
        var _tabPage;
        if(_tabPage = tabEditors.getPage())
            _tabPage.$at.redo();
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});
/**
 * Refactor Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/clipboard/clipboard',['require','exports','module','core/ext'],function(require, exports, module) {

"use strict";

var ext = require("core/ext");

module.exports = ext.register("ext/clipboard/clipboard", {
    dev    : "Ajax.org",
    name   : "Clipboard",
    alone  : true,
    type   : ext.GENERAL,

    nodes : [],

    init : function(amlNode){
        this.nodes.push(
            mnuEdit.appendChild(new apf.divider()),
            mnuEdit.appendChild(new apf.item({
                caption : "Cut",
                onclick : this.cut
            })),
            mnuEdit.appendChild(new apf.item({
                caption : "Copy",
                onclick : this.copy
            })),
            mnuEdit.appendChild(new apf.item({
                caption : "Paste",
                onclick : this.paste
            }))
        );

        /*this.hotitems = {
            "cut" : [this.nodes[1]],
            "copy" : [this.nodes[2]],
            "paste" : [this.nodes[3]]
        };*/
    },

    cut: function() {
        if (apf.document.activeElement == trFiles)
            apf.clipboard.cutSelection(trFiles);
    },

    copy: function() {
        if (apf.document.activeElement == trFiles)
            apf.clipboard.copySelection(trFiles);
    },

    paste: function() {
        if (apf.document.activeElement == trFiles)
            apf.clipboard.pasteSelection(trFiles);
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});
/**
 * Help menu for the Cloud 9 IDE
 * 
 * @author Garen J. Torikian
 * 
 * @copyright 2011, Cloud9 IDE, Inc
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/help/help',['require','exports','module','core/ide','core/ext','text!ext/help/help.xml','text!ext/help/style.css','text!ext/help/skin.xml'],function(require, exports, module) {

    var ide = require("core/ide");
    var ext = require("core/ext");
    var markup = require("text!ext/help/help.xml");
    var css = require("text!ext/help/style.css");
    var skin = require("text!ext/help/skin.xml");

    module.exports = ext.register("ext/help/help", {
        name: "Help Menu",
        dev: "Cloud9 IDE, Inc.",
        alone: true,
        type: ext.GENERAL,
        nodes: [],
        markup: markup,
        css: css,
        panels: {},
        skin: {
            id: "help-skin",
            data: skin,
            "media-path": "/static/ext/help/images/"
        },
        showingAll: true,

        initPanel: function(panelExt) {
            if (panelExt.panel) {
                return;
            }

            ext.initExtension(panelExt);
            this.$setEvents(panelExt);

            var set = this.$settings && this.$settings[panelExt.path];
            if (set) this.setPanelSettings(panelExt, set);

            panelExt.panel.setAttribute("draggable", "false");
        },

        register: function(panelExt) {
            var _self = this;
            if (!panelExt.alwayson) {
                panelExt.mnuItem = mnuPanels.appendChild(new apf.item({
                    caption: panelExt.name,
                    type: "check",
                    //checked : panelExt.visible || false,
                    checked: "{panelExt.visible}",
                    onclick: function() {
                        _self.initPanel(panelExt);
                        this.checked ? panelExt.enable() : panelExt.disable();
                    }
                }));
            }

            if (false && this.$settings && this.$settings[panelExt.path]) {
                this.setPanelSettings(panelExt, _self.$settings[panelExt.path]);
            }
            else if (panelExt.visible) {
                if (panelExt.skin) {
                    setTimeout(function() {
                        this.initPanel(panelExt);
                    });
                }
                else {
                    this.initPanel(panelExt);
                }
            }

            this.panels[panelExt.path] = panelExt;
        },


        unregister: function(panelExt) {
            panelExt.mnuItem.destroy(true, true);
            delete this.panels[panelExt.path];
        },

        init: function(amlNode) {
            apf.importCssString((this.css || ""));

            this.nodes.push(
            barMenu.appendChild(new apf.button({
                submenu: "mnuHelp",
                caption: "Help",
                skin: "c9-menu-btn",
                margin: "1 0 0 0"
            })), mnuWindows);

            if (window.location.host.indexOf("c9.io") >= 0 || window.location.host.indexOf("stage.io") >= 0) {                
                var blogURL = window.location.protocol + "//" + window.location.host + "/site/?json=get_tag_posts&tag_slug=changelog";
    
                var response = apf.ajax(blogURL, {
                    method: "GET",
                    contentType: "application/json",
                    async: true,
                    data: apf.serialize({
                        agent: navigator.userAgent,
                        type: "C9 SERVER EXCEPTION"
                    }),
                    callback: function( data, state) {
                        if (state == apf.SUCCESS) {
                            if (data !== undefined) {
                                var jsonBlog = JSON.parse(data);
                                var latestDate = jsonBlog.posts[0].date;
        
                                mnuChangelog.setAttribute("caption", mnuChangelog.caption + " (" + latestDate.split(" ")[0].replace(/-/g, ".") + ")");
                            }
                        }
                    }
                });
            }
        },

        showAbout: function() {
            aboutDialog.show();
            document.getElementById("c9Version").innerHTML = "Version " + window.cloud9config.version;
        },

        launchTwitter: function() {
            alert("Let's go to Twitter!");
        },

        enable: function() {
            this.nodes.each(function(item) {
                item.enable();
            });
        },

        disable: function() {
            this.nodes.each(function(item) {
                item.disable();
            });
        },

        destroy: function() {
            this.nodes.each(function(item) {
                item.destroy(true, true);
            });
            this.nodes = [];
        }
    });

});
/**
 * Code Editor for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/code/code',['require','exports','module','apf/elements/codeeditor','core/ide','core/ext','ace/edit_session','ace/keyboard/hash_handler','ace/lib/useragent','ace/document','ace/range','ext/code/proxydocument','ace/commands/command_manager','ace/commands/default_commands','text!ext/code/code.xml','ext/settings/settings','text!ext/code/settings.xml','ext/editors/editors'],function(require, exports, module) {

require("apf/elements/codeeditor");

var ide = require("core/ide");
var ext = require("core/ext");
var EditSession = require("ace/edit_session").EditSession;
var HashHandler = require("ace/keyboard/hash_handler").HashHandler;
var useragent = require("ace/lib/useragent");
var Document = require("ace/document").Document;
var Range = require("ace/range").Range;
var ProxyDocument = require("ext/code/proxydocument");
var CommandManager = require("ace/commands/command_manager").CommandManager;
var defaultCommands = require("ace/commands/default_commands").commands;
var markup = require("text!ext/code/code.xml");
var settings = require("ext/settings/settings");
var markupSettings = require("text!ext/code/settings.xml");
var editors = require("ext/editors/editors");

apf.actiontracker.actions.aceupdate = function(undoObj, undo){
    var q = undoObj.args;

    if (!undoObj.initial) {
        undoObj.initial = true;
        return;
    }

    if (undo)
        q[1].undoChanges(q[0]);
    else
        q[1].redoChanges(q[0]);
};

var SupportedModes = {
    "application/javascript": "javascript",
    "application/json": "json",
    "text/css": "css",
    "text/x-scss": "scss",
    "text/html": "html",
    "application/xhtml+xml": "html",
    "application/xml": "xml",
    "application/rdf+xml": "xml",
    "application/rss+xml": "xml",
    "image/svg+xml": "svg",
    "application/wsdl+xml": "xml",
    "application/xslt+xml": "xml",
    "application/atom+xml": "xml",
    "application/mathml+xml": "xml",
    "application/x-httpd-php": "php",
    "text/x-script.python": "python",
    "text/x-script.ruby": "ruby",
    "text/x-script.perl": "perl",
    "text/x-script.perl-module": "perl",
    "text/x-c": "c_cpp",
    "text/x-java-source": "java",
    "text/x-groovy": "groovy",
    "text/x-csharp": "csharp",
    "text/x-script.coffeescript": "coffee",
    "text/x-markdown": "markdown",
    "text/x-web-textile": "textile",
    "text/x-script.ocaml": "ocaml",
    "text/x-script.clojure": "clojure",
    "application/x-latex": "latex",
    "text/x-lua": "lua",
    "text/x-script.powershell": "powershell",
    "text/x-scala": "scala",
    "text/x-coldfusion": "coldfusion",
    "text/x-sql": "sql"
};

var contentTypes = {
    "js": "application/javascript",
    "json": "application/json",
    "css": "text/css",
    "less": "text/css",
    "scss": "text/x-scss",
    "sass": "text/x-sass",

    "xml": "application/xml",
    "rdf": "application/rdf+xml",
    "rss": "application/rss+xml",
    "svg": "image/svg+xml",
    "wsdl": "application/wsdl+xml",
    "xslt": "application/xslt+xml",
    "atom": "application/atom+xml",
    "mathml": "application/mathml+xml",
    "mml": "application/mathml+xml",

    "php": "application/x-httpd-php",
    "phtml": "application/x-httpd-php",
    "html": "text/html",
    "xhtml": "application/xhtml+xml",
    "coffee": "text/x-script.coffeescript",
    "*Cakefile": "text/x-script.coffeescript",
    "py": "text/x-script.python",

    "ru": "text/x-script.ruby",
    "gemspec": "text/x-script.ruby",
    "rake": "text/x-script.ruby",
    "rb": "text/x-script.ruby",

    "c": "text/x-c",
    "cc": "text/x-c",
    "cpp": "text/x-c",
    "cxx": "text/x-c",
    "h": "text/x-c",
    "hh": "text/x-c",
    "hpp": "text/x-c",

    "cs": "text/x-csharp",

    "java": "text/x-java-source",
    "clj": "text/x-script.clojure",
    "groovy": "text/x-groovy",
    "scala": "text/x-scala",

    "ml": "text/x-script.ocaml",
    "mli": "text/x-script.ocaml",

    "md": "text/x-markdown",
    "markdown": "text/x-markdown",
    "textile": "text/x-web-textile",
    "latex": "application/x-latex",
    "tex": "application/x-latex",
    "ltx": "application/x-latex",

    "lua": "text/x-lua",

    "pl": "text/x-script.perl",
    "pm": "text/x-script.perl-module",

    "ps1": "text/x-script.powershell",
    "cfm": "text/x-coldfusion",
    "sql": "text/x-sql"
};

module.exports = ext.register("ext/code/code", {
    name    : "Code Editor",
    dev     : "Ajax.org",
    type    : ext.EDITOR,
    markup  : markup,
    deps    : [editors],

    nodes : [],

    fileExtensions : Object.keys(contentTypes),
    supportedModes: Object.keys(SupportedModes),
    commandManager : new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands),

    getState : function(doc) {
        doc = doc ? doc.acesession : this.getDocument();
        if (!doc || typeof doc.getSelection != "function")
            return;

        var folds = doc.getAllFolds().map(function(fold) {
            return {
                start: fold.start,
                end: fold.end,
                placeholder: fold.placeholder
            };
        });

        var sel = doc.getSelection();
        return {
            scrolltop  : doc.getScrollTop(),
            scrollleft : doc.getScrollLeft(),
            selection  : sel.getRange(),
            folds      : folds
        };
    },

    setState : function(doc, state){
        var aceDoc = doc ? doc.acesession : this.getDocument();
        if (!aceDoc || !state || typeof aceDoc.getSelection != "function")
            return;

        var sel = aceDoc.getSelection();

        //are those 3 lines set the values in per document base or are global for editor
        sel.setSelectionRange(state.selection, false);

        aceDoc.setScrollTop(state.scrolltop);
        aceDoc.setScrollLeft(state.scrollleft);

        if (state.folds) {
            for (var i = 0, l=state.folds.length; i < l; i++) {
                var fold = state.folds[i];
                aceDoc.addFold(fold.placeholder, Range.fromPoints(fold.start, fold.end));
            }
        }

        // if newfile == 1 and there is text cached, restore it
        var node = doc.getNode && doc.getNode();
        if (node && parseInt(node.getAttribute("newfile") || 0, 10) === 1 && node.childNodes.length) {
            // the text is cached within a CDATA block as first childNode of the <file>
            if (doc.getNode().childNodes[0] instanceof CDATASection) {
                aceDoc.setValue(doc.getNode().childNodes[0].nodeValue);
            }
        }
    },

    getSyntax : function(node) {
        if (!node)
            return "";

        var mime = node.getAttribute("customtype");

        if (!mime) {
            var fileName = node.getAttribute("name");

            if (fileName.lastIndexOf(".") != -1)
                mime = contentTypes[fileName.split(".").pop()];
            else
                mime = contentTypes["*" + fileName];
        }

        if (mime) {
            mime = mime.split(";")[0];
            return (SupportedModes[mime] || "text");
        }

        return "text";
    },

    getSelection : function(){
        if (typeof ceEditor == "undefined")
            return null;
        return ceEditor.getSelection();
    },

    getDocument : function(){
        if (typeof ceEditor == "undefined")
            return null;
        return ceEditor.getSession();
    },

    setDocument : function(doc, actiontracker){
        var _self = this;

        if (!doc.acesession) {
            doc.isInited = doc.hasValue();
            doc.acedoc = doc.acedoc || new ProxyDocument(new Document(doc.getValue() || ""));
            doc.acesession = new EditSession(doc.acedoc);
            doc.acedoc = doc.acesession.getDocument();

            doc.acesession.setUndoManager(actiontracker);

            if (doc.isInited && doc.state)
                 _self.setState(doc, doc.state);

            doc.addEventListener("prop.value", function(e) {
                if (this.editor != _self)
                    return;

                doc.acesession.setValue(e.value || "");
                if (doc.state)
                    _self.setState(doc, doc.state);
                doc.isInited = true;
            });

            doc.addEventListener("retrievevalue", function(e) {
                if (this.editor != _self)
                    return;

                if (!doc.isInited)
                    return e.value;
                else
                    return doc.acesession.getValue();
            });

            doc.addEventListener("close", function(){
                if (this.editor != _self)
                    return;

                //??? destroy doc.acesession
            });
        }
        ceEditor.setProperty("value", doc.acesession);

        if (doc.editor && doc.editor != this) {
            var value = doc.getValue();
            if (doc.acesession.getValue() !== value) {
                doc.editor = this;
                doc.dispatchEvent("prop.value", {value : value});
            }
        }

        doc.editor = this;
    },

    hook: function() {
        var _self = this;

        //Settings Support
        ide.addEventListener("init.ext/settings/settings", function(e) {
            var heading = e.ext.getHeading("Code Editor");
            heading.insertMarkup(markupSettings);
        });

        ide.addEventListener("loadsettings", function(e) {
            var model = e.model;
            if (!model.queryNode("editors/code")) {
                var node = apf.n("<code />")
                  .attr("overwrite", "false")
                  .attr("selectstyle", "line")
                  .attr("activeline", "true")
                  .attr("showinvisibles", "false")
                  .attr("showprintmargin", "true")
                  .attr("printmargincolumn", "80")
                  .attr("softtabs", "true")
                  .attr("tabsize", "4")
                  .attr("scrollspeed", "2")
                  .attr("fontsize", "12")
                  .attr("wrapmode", "false")
                  .attr("wraplimitmin", "")
                  .attr("wraplimitmax", "")
                  .attr("gutter", "true")
                  .attr("folding", "true")
                  .attr("highlightselectedword", "true")
                  .attr("autohidehorscrollbar", "true").node();

                var editors = apf.createNodeFromXpath(model.data, "editors");
                apf.xmldb.appendChild(editors, node);
            }

            // pre load theme
            var theme = e.model.queryValue("editors/code/@theme");
            if (theme)
                require([theme], function() {});
            // pre load custom mime types
            _self.getCustomTypes(e.model);
        });

        ide.addEventListener("afteropenfile", function(e) {
            if (_self.setState)
                _self.setState(e.doc, e.doc.state);

            if (e.doc && e.doc.editor && e.doc.editor.ceEditor) {
                // check if there is a scriptid, if not check if the file is somewhere in the stack
                if (typeof mdlDbgStack != "undefined" && mdlDbgStack.data && e.node
                  && (!e.node.hasAttribute("scriptid") || !e.node.getAttribute("scriptid"))
                  && e.node.hasAttribute("scriptname") && e.node.getAttribute("scriptname")) {
                    var nodes = mdlDbgStack.data.selectNodes("//frame[@script='" + e.node.getAttribute("scriptname").replace(ide.workspaceDir + "/", "") + "']");
                    if (nodes.length) {
                        e.node.setAttribute("scriptid", nodes[0].getAttribute("scriptid"));
                    }
                }
                e.doc.editor.ceEditor.afterOpenFile(e.doc.editor.ceEditor.getSession());
            }
        });

        tabEditors.addEventListener("afterswitch", function(e) {
            ceEditor.afterOpenFile(ceEditor.getSession());
        });
    },

    init: function(amlPage) {
        amlPage.appendChild(ceEditor);
        ceEditor.show();

        this.ceEditor = this.amlEditor = ceEditor;
        ceEditor.$editor.commands = this.commandManager;

        // preload common language modes
        var noop = function() {};
        ceEditor.getMode("javascript", noop);
        ceEditor.getMode("html", noop);
        ceEditor.getMode("css", noop);

        var _self = this;

        var menuSyntaxHighlight = new apf.item({
            caption : "Syntax Highlighting",
            submenu : "mnuSyntax"
        });

        var menuShowInvisibles = new apf.item({
            type    : "check",
            caption : "Show Invisibles",
            checked : "[{require('ext/settings/settings').model}::editors/code/@showinvisibles]"
        });

        var menuWrapLines = new apf.item({
            type    : "check",
            caption : "Wrap Lines",
            checked : "{ceEditor.wrapmode}"
        });

        this.nodes.push(
            //Add a panel to the statusbar showing whether the insert button is pressed
            sbMain.appendChild(new apf.section({
                caption : "{ceEditor.insert}"
            })),

            //Add a panel to the statusbar showing the length of the document
            sbMain.appendChild(new apf.section({
                caption : "Length: {ceEditor.value.length}"
            })),

            mnuView.appendChild(new apf.divider()),
            mnuView.appendChild(menuSyntaxHighlight)
        );

        mnuSyntax.onitemclick = function(e) {
            var file = ide.getActivePageModel();

            if (file) {
                var value = e.relatedNode.value;

                if (value == "auto")
                    apf.xmldb.removeAttribute(file, "customtype", "");
                else
                    apf.xmldb.setAttribute(file, "customtype", value);

                if (file.getAttribute("customtype")) {
                    var fileName = file.getAttribute("name");

                    if (contentTypes["*" + fileName])
                        delete contentTypes["*" + fileName];

                    var mime = value.split(";")[0];
                    var fileExt = (fileName.lastIndexOf(".") != -1) ?
                        fileName.split(".").pop() : null;

                    if (fileExt && contentTypes[fileExt] !== mime)
                        delete contentTypes[fileExt];

                    var customType = fileExt ?
                        contentTypes[fileExt] : contentTypes["*" + fileName];

                    if (!customType)
                        _self.setCustomType(fileExt ? fileExt : file, mime);
                    ide.dispatchEvent("track_action", {
                        type: "syntax highlighting",
                        fileType: fileExt,
                        fileName: fileName,
                        mime: mime,
                        customType: customType
                    });
                }
            }
        };

        ide.addEventListener("init.ext/statusbar/statusbar", function (e) {
            // add preferences to the statusbar plugin
            e.ext.addPrefsItem(menuShowInvisibles.cloneNode(true), 0);
            e.ext.addPrefsItem(menuWrapLines.cloneNode(true), 1);
        });

        ide.addEventListener("keybindingschange", function(e) {
            if (typeof ceEditor == "undefined")
                return;

            var bindings = e.keybindings.code;
            ceEditor.$editor.setKeyboardHandler(new HashHandler(bindings));
            // In case the `keybindingschange` event gets fired after other
            // plugins that change keybindings have already changed them (i.e.
            // the vim plugin), we fire an event so these plugins can react to it.
            ide.dispatchEvent("code.ext:defaultbindingsrestored", {});
        });
    },

    /**
     * Saves custom syntax for extension type in settings.xml
     *
     * @param {String|xmlNode} ext Contains the extension type shorthand
     * @param {String} mime Mime type string the extension will be related to
     */
    setCustomType: function(ext, mime) {
        var node;

        if (typeof ext === "string") {
            node = settings.model.queryNode('auto/customtypes/mime[@ext="' + ext + '"]');
            if (!node)
                settings.model.appendXml('<mime name="' + mime + '" ext="' + ext + '" />', "auto/customtypes");
        } else {
            var name = ext.getAttribute("name") || "";
            node = settings.model.queryNode('auto/customtypes/mime[@filename="' + name + '"]');
            if (node)
                apf.xmldb.removeAttribute(node, "ext");
            else
                settings.model.appendXml('<mime name="' + mime + '" filename="' + name + '" />', "auto/customtypes");
        }

        apf.xmldb.setAttribute(node, "name", mime);
        settings.save();
    },

    /**
     * Retrieves custom syntax for extensions saved in settings.xml
     *
     * @param {Object} model Settings' model
     */
    getCustomTypes: function(model) {
        var customTypes = model.queryNode("auto/customtypes");
        if (!customTypes)
            customTypes = apf.createNodeFromXpath(model.data, "auto/customtypes");

        var mimes = customTypes.selectNodes("mime");
        mimes.forEach(function(n) {
            if (n.getAttribute("filename"))
                contentTypes["*" + n.getAttribute("filename")] = n.getAttribute("name");
            else
                contentTypes[n.getAttribute("ext")] = n.getAttribute("name");
        });
    },


    enable : function() {
        this.nodes.each(function(item){
            item.show();
        });
    },

    disable : function() {
        this.nodes.each(function(item){
            item.hide();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });

        if (self.ceEditor) {
            ceEditor.destroy(true, true);
            mnuSyntax.destroy(true, true);
        }

        this.nodes = [];
    }
});

});

/**
 * Searchreplace Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/searchreplace/searchreplace',['require','exports','module','core/ide','core/ext','ext/code/code','ace/search','ext/editors/editors','text!ext/searchreplace/searchreplace.xml','ext/settings/settings','ext/editors/editors'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var code = require("ext/code/code");
var search = require("ace/search");
var editors = require("ext/editors/editors");
var markup = require("text!ext/searchreplace/searchreplace.xml");

module.exports = ext.register("ext/searchreplace/searchreplace", {
    name    : "Searchreplace",
    dev     : "Ajax.org",
    type    : ext.GENERAL,
    alone   : true,
    markup  : markup,
    commands : {
        "search": {hint: "search for a string inside the active document"},
        "searchreplace": {hint: "search for a string inside the active document and replace it"}
    },
    hotitems: {},

    nodes   : [],

    hook : function(){
        var _self = this;

        this.nodes.push(
            mnuEdit.appendChild(new apf.divider()),
            mnuEdit.appendChild(new apf.item({
                caption : "Search...",
                onclick : function() {
                    _self.toggleDialog(false);
                }
            })),
            mnuEdit.appendChild(new apf.item({
                caption : "Search & Replace...",
                onclick : function() {
                    _self.toggleDialog(true);
                }
            }))
        );

        this.hotitems.search = [this.nodes[1]];
        this.hotitems.searchreplace = [this.nodes[2]];

        code.commandManager.addCommand({
            name: "replace",
            exec: function(editor) {
                _self.setEditor(editor, editor.getSelection()).toggleDialog(true, true);
            }
        });

    },

    init : function(amlNode){
        var _self = this;
        
        this.txtFind       = txtFind;//winSearchReplace.selectSingleNode("a:vbox/a:hbox[1]/a:textbox[1]");
        this.txtReplace    = txtReplace;//winSearchReplace.selectSingleNode("a:vbox/a:hbox[1]/a:textbox[1]");
        //bars
        this.barReplace    = barReplace;//winSearchReplace.selectSingleNode("a:vbox/a:hbox[2]");
        //buttons
        this.btnReplace    = btnReplace;//winSearchReplace.selectSingleNode("a:vbox/a:hbox/a:button[1]");
        this.btnReplace.onclick = this.replace.bind(this);
        this.btnReplaceAll = btnReplaceAll;//winSearchReplace.selectSingleNode("a:vbox/a:hbox/a:button[2]");
        this.btnReplaceAll.onclick = this.replaceAll.bind(this);
        this.btnFind       = btnFind;//winSearchReplace.selectSingleNode("a:vbox/a:hbox/a:button[3]");
        this.btnFind.onclick = this.findNext.bind(this);
        winSearchReplace.onclose = function() {
            ceEditor.focus();
        }
        
        this.txtFind.addEventListener("keydown", function(e){
            switch (e.keyCode){
//                case 13: //ENTER
//                    _self.execSearch(false, !!e.shiftKey);
//                    return false;
//                case 27: //ESCAPE
//                    _self.toggleDialog(-1);
//                    if (e.htmlEvent)
//                        apf.stopEvent(e.htmlEvent)
//                    else if (e.stop)
//                        e.stop();
//                    return false;
                case 38: //UP
                    _self.navigateList("prev");
                break;
                case 40: //DOWN
                    _self.navigateList("next");
                break;
                case 36: //HOME
                    if (!e.ctrlKey) return;
                    _self.navigateList("first");
                break;
                case 35: //END
                    if (!e.ctrlKey) return;
                    _self.navigateList("last");
                break;
            }
        });
    },
    
    navigateList : function(type){
        var settings = require("ext/settings/settings");
        if (!settings) return;
        
        var model = settings.model;
        var lines = model.queryNodes("search/word");
        
        var next;
        if (type == "prev")
            next = Math.max(0, this.position - 1);
        else if (type == "next")
            next = Math.min(lines.length - 1, this.position + 1);
        else if (type == "last")
            next = Math.max(lines.length - 1, 0);
        else if (type == "first")
            next = 0;

        if (lines[next]) {
            this.txtFind.setValue(lines[next].getAttribute("key"));
            this.txtFind.select();
            this.position = next;
        }
    },
    
    toggleDialog: function(isReplace, forceShow) {
        ext.initExtension(this);

        if (!winSearchReplace.visible || forceShow || this.$lastState != isReplace) {
            this.setupDialog(isReplace);

            var value;
            var editor = editors.currentEditor;
            if (editor) {
                if (editor.ceEditor)
                    value = editor.ceEditor.getLastSearchOptions().needle;

                if (!value) {
                    var sel   = editor.getSelection();
                    var doc   = editor.getDocument();
                    var range = sel.getRange();
                    value = doc.getTextRange(range);
                }
                
                if (value)
                    this.txtFind.setValue(value);

                winSearchReplace.setAttribute("title", isReplace
                        ? "Search & Replace" : "Search");
                winSearchReplace.show();
            }
        }
        else
            winSearchReplace.hide();
        return false;
    },

    onHide : function() {
        var editor = require('ext/editors/editors').currentEditor;
        if (editor && editor.ceEditor)
            editor.ceEditor.focus();
    },

    search: function() {
        return this.setEditor().toggleDialog(false, true);
    },

    searchreplace: function() {
        return this.setEditor().toggleDialog(true, true);
    },

    setupDialog: function(isReplace) {
        this.$lastState = isReplace;
        this.position = 0;

        // hide all 'replace' features
        this.barReplace.setProperty("visible", isReplace);
        this.btnReplace.setProperty("visible", isReplace);
        this.btnReplaceAll.setProperty("visible", isReplace);
        return this;
    },

    setEditor: function(editor, selection) {
        if (typeof ceEditor == "undefined")
            return;
        this.$editor = editor || ceEditor.$editor;
        this.$selection = selection || this.$editor.getSelection();
        return this;
    },

    getOptions: function() {
        return {
            backwards: chkSearchBackwards.checked,
            wrap: chkWrapAround.checked,
            caseSensitive: chkMatchCase.checked,
            wholeWord: chkWholeWords.checked,
            regExp: chkRegEx.checked,
            scope: chkSearchSelection.checked ? search.Search.SELECTION : search.Search.ALL
        };
    },

    findNext: function() {
        if (!this.$editor)
            this.setEditor();
        if (!this.$editor)
            return;
        var txt = this.txtFind.getValue();
        if (!txt)
            return;
        var options = this.getOptions();

        if (this.$crtSearch != txt) {
            this.$crtSearch = txt;
            // structure of the options:
            // {
            //     needle: "",
            //     backwards: false,
            //     wrap: false,
            //     caseSensitive: false,
            //     wholeWord: false,
            //     regExp: false
            // }
            this.$editor.find(txt, options);
        }
        else {
            this.$editor.find(txt, options);
        }
        chkSearchSelection.setAttribute("checked", false);
    },

    replace: function() {
        if (!this.$editor)
            this.setEditor();
        if (!this.$editor)
            return;
        if (!this.barReplace.visible)
            return;
        var options = this.getOptions();
        options.needle = this.txtFind.getValue();
        options.scope = search.Search.SELECTION;
        this.$editor.replace(this.txtReplace.getValue() || "", options);
        //this.$editor.find(this.$crtSearch, options);
        this.findNext();
        ide.dispatchEvent("track_action", {type: "replace"});
    },

    replaceAll: function() {
        if (!this.editor)
            this.setEditor();
        if (!this.$editor)
            return;
        this.$crtSearch = null;
        var options = this.getOptions();
        options.needle = this.txtFind.getValue();
        this.$editor.replaceAll(this.txtReplace.getValue() || "", options);
        ide.dispatchEvent("track_action", {type: "replace"});
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});
/**
 * quicksearch Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/quicksearch/quicksearch',['require','exports','module','core/ide','core/ext','ext/code/code','ext/editors/editors','ace/search','text!ext/quicksearch/skin.xml','text!ext/quicksearch/quicksearch.xml','ext/settings/settings','ext/settings/settings'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var code = require("ext/code/code");
var editors = require("ext/editors/editors");
var Search = require("ace/search").Search;
var skin = require("text!ext/quicksearch/skin.xml");
var markup = require("text!ext/quicksearch/quicksearch.xml");

var oIter, oTotal;

module.exports = ext.register("ext/quicksearch/quicksearch", {
    name    : "quicksearch",
    dev     : "Ajax.org",
    type    : ext.GENERAL,
    alone   : true,
    skin    : {
        id  : "quicksearch",
        data : skin,
        "icon-path" : ide.staticPrefix + "/ext/quicksearch/icons/"
    },
    markup  : markup,
    commands : {
        "quicksearch": {hint: "quickly search for a string inside the active document, without further options (see 'search')"},
        "find": {hint: "open the quicksearch dialog to quickly search for a phrase"},
        "findnext": {
            hint: "search for the next occurrence of the search query your entered last",
            msg: "Navigating to next match."
        },
        "findprevious": {
            hint: "search for the previous occurrence of the search query your entered last",
            msg: "Navigating to previous match."
        }
    },
    defaultOffset : 30,
    offsetWidth : 30,
    hotitems: {},

    nodes   : [],

    currentRange: null,

    hook : function(){
        var _self = this;
        code.commandManager.addCommand({
            name: "find",
            exec: function(env, args, request) {
                _self.toggleDialog(1);
            }
        });

        ide.addEventListener("minimap.visibility", function(e) {
            if (e.visibility === "shown")
                _self.offsetWidth = _self.defaultOffset + e.width;
            else
                _self.offsetWidth = _self.defaultOffset;

            _self.updateBarPosition();
        });
    },

    init : function(amlNode){
        var _self = this;

        txtQuickSearch.addEventListener("keydown", function(e){
            switch (e.keyCode){
                case 13: //ENTER
                    _self.execSearch(false, !!e.shiftKey);
                    return false;
                case 27: //ESCAPE
                    _self.toggleDialog(-1);
                    if (e.htmlEvent)
                        apf.stopEvent(e.htmlEvent);
                    else if (e.stop)
                        e.stop();
                    return false;
                case 38: //UP
                    _self.navigateList("prev");
                break;
                case 40: //DOWN
                    _self.navigateList("next");
                break;
                case 36: //HOME
                    if (!e.ctrlKey) return;
                    _self.navigateList("first");
                break;
                case 35: //END
                    if (!e.ctrlKey) return;
                    _self.navigateList("last");
                break;
            }
        });

        winQuickSearch.addEventListener("blur", function(e){
            if (!apf.isChildOf(winQuickSearch, e.toElement))
                _self.toggleDialog(-1);
        });
        txtQuickSearch.addEventListener("blur", function(e){
            if (!apf.isChildOf(winQuickSearch, e.toElement))
                _self.toggleDialog(-1);
        });

        var editor = editors.currentEditor;
        if (editor && editor.ceEditor)
            editor.ceEditor.parentNode.appendChild(winQuickSearch);
            
        setTimeout(function() {
            _self.updateBarPosition();
        });
    },

    updateBarPosition : function() {
        if (!window["winQuickSearch"])
            return;

        winQuickSearch.setAttribute("right", this.offsetWidth);
    },

    navigateList : function(type){
        var settings = require("ext/settings/settings");
        if (!settings)
            return;

        var model = settings.model;
        var lines = model.queryNodes("search/word");

        var next;
        if (type == "prev")
            next = Math.max(0, this.position - 1);
        else if (type == "next")
            next = Math.min(lines.length - 1, this.position + 1);
        else if (type == "last")
            next = Math.max(lines.length - 1, 0);
        else if (type == "first")
            next = 0;

        if (lines[next]) {
            txtQuickSearch.setValue(lines[next].getAttribute("key"));
            txtQuickSearch.select();
            this.position = next;
        }
    },

    handleQuicksearchEscape : function(e) {
        if (e.keyCode == 27)
            this.toggleDialog(-1);
    },

    updateCounter: function() {
        var ace = this.$getAce();
        var width, buttonWidth;

        if (!oIter) {
            oIter  = document.getElementById("spanSearchIter");
            oTotal = document.getElementById("spanSearchTotal");
        }

        if (oIter.parentNode) {
            if (!ace || !winQuickSearch.visible) {
                oIter.parentNode.style.width = "0px";
                return;
            }
            else
                oIter.parentNode.style.width = "auto";
        }

        setTimeout(function() {
            if (oIter.parentNode && txtQuickSearch && txtQuickSearch.$button) {
                width = oIter.parentNode.offsetWidth || 0;
                txtQuickSearch.$button.style.right = width + "px";
            }
        });

        var ranges = ace.$search.findAll(ace.getSession());
        if (!ranges || !ranges.length) {
            oIter.innerHTML = "0";
            oTotal.innerHTML = "of 0";
            return;
        }
        var crtIdx = -1;
        var cur = this.currentRange;
        if (cur) {
            // sort ranges by position in the current document
            ranges.sort(cur.compareRange.bind(cur));
            var range;
            var start = cur.start;
            var end = cur.end;
            for (var i = 0, l = ranges.length; i < l; ++i) {
                range = ranges[i];
                if (range.isStart(start.row, start.column) && range.isEnd(end.row, end.column)) {
                    crtIdx = i;
                    break;
                }
            }
        }
        oIter.innerHTML = String(++crtIdx);
        oTotal.innerHTML = "of " + ranges.length;
    },

    toggleDialog: function(force) {
        ext.initExtension(this);

        if (this.control && this.control.stop)
            this.control.stop();

        var editorPage = tabEditors.getPage();
        if (!editorPage) return;

        var editor = editors.currentEditor;
        if (!editor || !editor.ceEditor)
            return;

        var _self = this;

        if (!force && !winQuickSearch.visible || force > 0) {
            this.position = -1;

            var sel   = editor.getSelection();
            var doc   = editor.getDocument();
            var range = sel.getRange();
            var value = doc.getTextRange(range);

            if (!value && editor.ceEditor)
               value = editor.ceEditor.getLastSearchOptions().needle;

            if (value)
                txtQuickSearch.setValue(value);

            winQuickSearch.$ext.style.top = "-30px";
            winQuickSearch.show();
            txtQuickSearch.focus();
            txtQuickSearch.select();

            //Animate
            apf.tween.single(winQuickSearch, {
                type     : "top",
                anim     : apf.tween.easeInOutCubic,
                from     : -27,
                to       : 2,
                steps    : 8,
                interval : 10,
                control  : (this.control = {}),
                onfinish : function() {
                    _self.updateCounter();
                }
            });
        }
        else if (winQuickSearch.visible) {
            txtQuickSearch.focus();
            txtQuickSearch.select();

            //Animate
            apf.tween.single(winQuickSearch, {
                type     : "top",
                anim     : apf.tween.NORMAL,
                from     : winQuickSearch.$ext.offsetTop,
                to       : -30,
                steps    : 8,
                interval : 10,
                control  : (this.control = {}),
                onfinish : function(){
                    winQuickSearch.hide();
                    editor.ceEditor.focus();
                }
            });
        }

        return false;
    },

    quicksearch : function(){
        this.toggleDialog(1);
    },

    execSearch: function(close, backwards) {
        var ace = this.$getAce();
        if (!ace)
            return;

        var txt = txtQuickSearch.getValue();
        if (!txt)
            return;

        var options = {
            backwards: !!backwards,
            wrap: true,
            caseSensitive: false,
            wholeWord: false,
            regExp: false,
            scope: Search.ALL
        };

        if (this.$crtSearch != txt)
            this.$crtSearch = txt;
        ace.find(txt, options);
        this.currentRange = ace.selection.getRange();

        var settings = require("ext/settings/settings");
        if (settings.model) {
            var history = settings.model;
            var search = apf.createNodeFromXpath(history.data, "search");

            if (!search.firstChild || search.firstChild.getAttribute("key") != txt) {
                var keyEl = apf.getXml("<word />");
                keyEl.setAttribute("key", txt);
                apf.xmldb.appendChild(search, keyEl, search.firstChild);
            }
        }

        if (close) {
            winQuickSearch.hide();
            editors.currentEditor.ceEditor.focus();
        }

        this.updateCounter();
    },

    find: function() {
        this.toggleDialog(1);
        return false;
    },

    findnext: function() {
        var ace = this.$getAce();
        if (!ace)
            return;

        ace.findNext();
        this.currentRange = ace.selection.getRange();
        this.updateCounter();
        return false;
    },

    findprevious: function() {
        var ace = this.$getAce();
        if (!ace)
            return;

        ace.findPrevious();
        this.currentRange = ace.selection.getRange();
        this.updateCounter();
        return false;
    },

    $getAce: function() {
        var editor = editors.currentEditor;
        if (!editor || !editor.ceEditor)
            return;

        var ceEditor = editor.ceEditor;
        return ceEditor.$editor;
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});

/**
 * Gotoline Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/gotoline/gotoline',['require','exports','module','core/ide','core/ext','ext/code/code','ext/editors/editors','text!ext/gotoline/skin.xml','text!ext/gotoline/gotoline.xml','ext/editors/editors'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var code = require("ext/code/code");
var editors = require("ext/editors/editors");
var skin = require("text!ext/gotoline/skin.xml");
var markup = require("text!ext/gotoline/gotoline.xml");

module.exports = ext.register("ext/gotoline/gotoline", {
    name    : "Gotoline Window",
    dev     : "Ajax.org",
    type    : ext.GENERAL,
    alone   : true,
    skin    : {
        id  : "gotoline",
        data : skin,
        "media-path" : ide.staticPrefix + "/ext/gotoline/images/"
    },
    markup  : markup,
    commands : {
        "gotoline": {hint: "enter a linenumber and jump to it in the active document"}
    },
    hotitems: {},

    nodes   : [],

    hook : function(){
        var _self = this;
        this.nodes.push(
            mnuEdit.appendChild(new apf.divider()),
            mnuEdit.appendChild(new apf.item({
                caption : "Go to Line...",
                onclick : function(){
                    _self.gotoline();
                }
            }))
        );

        ide.addEventListener("gotoline", function() {
            _self.gotoline();
        });

        code.commandManager.addCommand({
            name: "gotoline",
            exec: function() {
                _self.gotoline();
            }
        });

        this.hotitems.gotoline = [this.nodes[1]];
    },

    init : function() {
        var _self = this;

        lstLineNumber.addEventListener("afterchoose", function() {
            if (lstLineNumber.selected) {
                _self.execGotoLine(parseInt(lstLineNumber.selected.getAttribute("nr"), 10));
            }
            else {
                _self.execGotoLine();
            }
        });
        lstLineNumber.addEventListener("afterselect", function() {
            if (this.selected)
                txtLineNr.setValue(this.selected.getAttribute("nr"));
        });

        var restricted = [38, 40, 36, 35];
        lstLineNumber.addEventListener("keydown", function(e) {
            if (e.keyCode == 13 && this.selected){
                return false;
            }
            else if (e.keyCode == 38) {
                if (this.selected == this.getFirstTraverseNode()) {
                    txtLineNr.focus();
                    this.clearSelection();
                }
            }
            else if (e.keyCode == 27){
                _self.hide();
                ceEditor.focus();
            }
            else if (restricted.indexOf(e.keyCode) == -1)
                txtLineNr.focus();
        }, true);

        txtLineNr.addEventListener("keydown", function(e) {
            if (e.keyCode == 13){
                _self.execGotoLine();
                return false;
            }
            else if (e.keyCode == 27){
                _self.hide();
                ceEditor.focus();
                return false;
            }
            else if (e.keyCode == 40) {
                var first = lstLineNumber.getFirstTraverseNode();
                if (first) {
                    lstLineNumber.select(first);
                    lstLineNumber.$container.scrollTop = 0;
                    lstLineNumber.focus();
                }
            }
            else if ((e.keyCode > 57 || e.keyCode == 32) && (e.keyCode < 96 || e.keyCode > 105))
                return false;
        });

        winGotoLine.addEventListener("blur", function(e){
            if (!apf.isChildOf(winGotoLine, e.toElement))
                _self.hide();
        });
        
        txtLineNr.addEventListener("blur", function(e){
            if (!apf.isChildOf(winGotoLine, e.toElement))
                _self.hide();
        });
    },
    
    show : function() {
        var editor = editors.currentEditor;
        var ace = editor.ceEditor.$editor;
        var aceHtml = editor.ceEditor.$ext;
        var cursor = ace.getCursorPosition();

        //Set the current line
        txtLineNr.setValue(txtLineNr.getValue() || cursor.row + 1);

        //Determine the position of the window
        var pos = ace.renderer.textToScreenCoordinates(cursor.row, cursor.column);
        var epos = apf.getAbsolutePosition(aceHtml);
        var maxTop = aceHtml.offsetHeight - 100;

        editor.ceEditor.parentNode.appendChild(winGotoLine);
        winGotoLine.setAttribute("top", Math.min(maxTop, pos.pageY - epos[1]));
        winGotoLine.setAttribute("left", -60);

        winGotoLine.show();
        txtLineNr.focus();

        //Animate
        apf.tween.single(winGotoLine, {
            type     : "left",
            anim     : apf.tween.easeInOutCubic,
            from     : -60,
            to       : 0,
            steps    : 8,
            interval : 10,
            control  : (this.control = {})
        });
    },

    hide : function() {
        apf.tween.single(winGotoLine, {
            type     : "left",
            anim     : apf.tween.EASEOUT,
            from     : winGotoLine.$ext.offsetLeft,
            to       : -60,
            steps    : 8,
            interval : 10,
            control  : (this.control = {}),
            onfinish : function(){
                winGotoLine.hide();
            }
        });
    },

    gotoline: function() {
        ext.initExtension(this);

        if (this.control && this.control.stop)
            this.control.stop();

        var editorPage = tabEditors.getPage();
        if (!editorPage)
            return;

        var editor = editors.currentEditor;
        if (!editor || !editor.ceEditor)
            return;

        if (!winGotoLine.visible)
            this.show();
        else
            this.hide();

        return false;
    },

    execGotoLine: function(line) {
        var editor = require('ext/editors/editors').currentEditor;
        if (!editor || !editor.ceEditor)
            return;

        var ceEditor = editor.ceEditor;
        var ace      = ceEditor.$editor;

        winGotoLine.hide();

        if (typeof line != "number")
            line = parseInt(txtLineNr.getValue(), 10) || 0;

        var history = lstLineNumber.$model;
        var gotoline, lineEl = history.queryNode("gotoline/line[@nr='" + line + "']");
        if (lineEl)
            gotoline = lineEl.parentNode;
        else {
            gotoline = apf.createNodeFromXpath(history.data, "gotoline");
            lineEl   = apf.getXml("<line nr='" + line + "' />");
        }

        if (lineEl != gotoline.firstChild)
            apf.xmldb.appendChild(gotoline, lineEl, gotoline.firstChild);

        ace.gotoLine(line);
        ceEditor.focus();
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});

/**
 * HTML Editor for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/html/html',['require','exports','module','core/ide','core/ext','ext/code/code','text!ext/html/html.xml'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var code = require("ext/code/code");
var markup = require("text!ext/html/html.xml");

var previewExtensions = [
    "htm", "html", "xhtml",
    "conf", "log", "text", "txt",
    "xml", "xsl"
];

module.exports = ext.register("ext/html/html", {
    name  : "HTML Editor",
    dev   : "Ajax.org",
    type  : ext.GENERAL,
    alone : true,
    deps  : [code],
    markup: markup,
    nodes : [],

    hook : function(){
        var _self = this;
        tabEditors.addEventListener("afterswitch", function(e){
            _self.afterSwitchOrOpen(e.nextPage);
        });
        ide.addEventListener("afteropenfile", function(e){
            // Only listen for event from editors.js
            if (e.editor && e.node.$model)
                _self.afterSwitchOrOpen(e.node);
        });
        ide.addEventListener("updatefile", function(e) {
            var page = tabEditors.getPage(e.newPath);
            if (!page || !page.$active)
                return;
            _self.afterSwitchOrOpen(page);
        });
    },

    afterSwitchOrOpen : function(node) {
        var name = node.$model.data.getAttribute("name");
        var fileExtension = name.split(".").pop();

        if (previewExtensions.indexOf(fileExtension) > -1) {
            ext.initExtension(this);
            this.page = node;
            this.enable();
        }
        else {
            this.disable();
        }
    },

    init : function() {
        //Append the button bar to the main toolbar
        var nodes = barHtmlMode.childNodes;
        var node;
        for (var i = nodes.length - 1; i >= 0; i--) {
            node = ide.barTools.appendChild(nodes[0]);
            if (node.nodeType != 1) {
                continue;
            }
            this.nodes.push(node);
        }

        btnHtmlOpen.onclick = this.onOpenPage.bind(this);
        this.enabled = true;
    },

    onOpenPage : function() {
        var file = this.page.$model.data;
        window.open(location.protocol + "//" + location.host + file.getAttribute("path"), "_blank");
    },

    enable : function() {
        if (this.enabled)
            return;
        this.enabled = true;

        this.nodes.each(function(item){
            item.show();
        });
    },

    disable : function(){
        if (!this.enabled)
            return;
        this.enabled = false;

        this.nodes.each(function(item){
            item.hide && item.hide();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy && item.destroy(true, true);
        });
        this.nodes = [];
    }
});
});

/**
 * Cloud9 Language Foundation
 *
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
define('ext/language/refactor',['require','exports','module','ace/placeholder','ext/language/marker','core/ide','ext/code/code'],function(require, exports, module) {

var PlaceHolder = require("ace/placeholder").PlaceHolder;
var marker = require("ext/language/marker");
var ide = require("core/ide");
var code = require("ext/code/code");

module.exports = {
    renameVariableItem: null,
    worker: null,
    
    hook: function(ext, worker) {
        var _self = this;
        this.worker = worker;
        
        worker.on("enableRefactorings", function(event) {
            _self.enableRefactorings(event);
        });
        
        worker.on("variableLocations", function(event) {
            _self.enableVariableRefactor(event.data);
        });

        var nodes = [];
        this.refactorItem = new apf.item({
            caption: "Rename variable",
            disabled: true,
            onclick: function() {
                _self.renameVariable();
            }
        });

        // There is a problem with APF setting the $disabled attribute of
        // a cloned menu item, so we have to create a second one ourselves
        this.refactorItemDup = new apf.item({
            caption: "Rename variable",
            disabled: true,
            onclick: function() {
                _self.renameVariable();
            }
        });

        nodes.push(this.refactorItem, this.refactorItemDup);

        mnuEdit.appendChild(this.refactorItem);

        ide.addEventListener("init.ext/statusbar/statusbar", function (e) {
            e.ext.addToolsItem(new apf.divider(), 3);
            e.ext.addToolsItem(_self.refactorItemDup, 4);
        });

        code.commandManager.addCommand({
            name: "renameVar",
            exec: function(editor) {
                _self.renameVariable();
            }
        });
        
        ext.hotitems.renameVar = [nodes[0]];
        ext.nodes.push(nodes[0], nodes[1]);
    },
    
    enableRefactorings: function(event) {
        var names = event.data;
        var enableVariableRename = false;
        for (var i = 0; i < names.length; i++) {
            var name = names[i];
            if (name === 'renameVariable') {
                enableVariableRename = true;
            }
        }

        this.refactorItem.setAttribute('disabled', !enableVariableRename);
        this.refactorItemDup.setAttribute('disabled', !enableVariableRename);
    },
    
    enableVariableRefactor: function(data) {
        // Temporarily disable these markers, to prevent weird slow-updating events whilst typing
        marker.disableMarkerType('occurrence_main');
        marker.disableMarkerType('occurrence_other');
        var cursor = ceEditor.$editor.getCursorPosition();
        var mainPos = data.pos;
        var p = new PlaceHolder(ceEditor.$editor.session, data.length, mainPos, data.others, "language_rename_main", "language_rename_other");
        if(cursor.row !== mainPos.row || cursor.column < mainPos.column || cursor.column > mainPos.column + data.length) {
            // Cursor is not "inside" the main identifier, move it there
            ceEditor.$editor.moveCursorTo(mainPos.row, mainPos.column);
        }
        p.showOtherMarkers();
        p.on("cursorLeave", function() {
            p.detach();
            marker.enableMarkerType('occurrence_main');
            marker.enableMarkerType('occurrence_other');
        });
    },
    
    renameVariable: function() {
        this.worker.emit("fetchVariablePositions", {data: ceEditor.$editor.getCursorPosition()});
    }
};

});
/**
 * Editor status bar for Cloud9 IDE
 * 
 * @TODO
 * 
 * Error icon from acebugs
 * 
 * @copyright 2012, Cloud9 IDE, Inc.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/statusbar/statusbar',['require','exports','module','core/ext','core/ide','ext/editors/editors','text!ext/statusbar/statusbar.xml','text!ext/statusbar/skin.xml'],function(require, exports, module) {

var ext = require("core/ext");
var ide = require("core/ide");
var editors = require("ext/editors/editors");
var markup = require("text!ext/statusbar/statusbar.xml");
var skin = require("text!ext/statusbar/skin.xml");

module.exports = ext.register("ext/statusbar/statusbar", {
    name     : "Status bar",
    dev      : "Cloud9 IDE, Inc.",
    alone    : true,
    type     : ext.GENERAL,
    markup   : markup,
    skin     : {
        id   : "statusbar",
        data : skin,
        "media-path" : ide.staticPrefix + "/style/images/",
        "icon-path"  : ide.staticPrefix + "/style/icons/"
    },
    expanded: false,
    nodes : [],
    toolItems: [],
    prefsItems: [],
    horScrollAutoHide : "false",
    edgeDistance : 3,
    offsetWidth : 0,

    hook : function(){
        var _self = this;
        ide.addEventListener("afteropenfile", this.$aofListener = function() {
            ext.initExtension(_self);
            ide.removeEventListener("afteropenfile", _self.$aofListener);
        });

        ide.addEventListener("loadsettings", function(e){
            var strSettings = e.model.queryValue("auto/statusbar");
            if (strSettings === "true") {
                if (_self.inited)
                    _self.toggleStatusBar();
                else
                    _self.toggleOnInit = true;
            }

            var codeSettings = e.model.queryNode("//editors/code");
            if (codeSettings && codeSettings.hasAttribute("autohidehorscrollbar")) {
                _self.horScrollAutoHide = codeSettings.getAttribute("autohidehorscrollbar");
            }
        });

        ide.addEventListener("savesettings", function(e){
            var xmlSettings = apf.createNodeFromXpath(e.model.data, "auto/statusbar/text()");
            xmlSettings.nodeValue = _self.expanded;
            return true;
        });

        ide.addEventListener("theme_change", function(e){
            var theme = e.theme || "ace/theme/textmate";
            _self.checkTheme(theme);
        });

        ide.addEventListener("vim.changeMode", function(e) {
            if (!window["lblInsertActive"])
                return;

            if (e.mode === "insert")
                lblInsertActive.show();
            else
                lblInsertActive.hide();
        });
    },

    init : function(){
        var _self = this;

        ide.addEventListener("minimap.visibility", function(e) {
            if (e.visibility === "shown")
                _self.offsetWidth = e.width;
            else
                _self.offsetWidth = 0;

            _self.setPosition();
        });

        tabEditors.addEventListener("afterswitch", function() {
            if (_self.$changeEvent)
                _self.editorSession.selection.removeEventListener("changeSelection", _self.$changeEvent);

            setTimeout(function() {
                if(editors.currentEditor.ceEditor) {
                    _self.setSelectionLength();

                    _self.editorSession = editors.currentEditor.ceEditor.$editor.session;
                    _self.editorSession.selection.addEventListener("changeSelection", _self.$changeEvent = function(e) {
                        _self.setSelectionLength();
                    });
                }
            }, 200);
        });

        tabEditors.addEventListener("resize", function() {
            _self.setPosition();
        });
        
        var editor = editors.currentEditor;
        if (editor && editor.ceEditor) {
            editor.ceEditor.parentNode.appendChild(barIdeStatus);
            this.sbWidth = ceEditor.$editor.renderer.scrollBar.width;
            barIdeStatus.setAttribute("right", this.sbWidth + this.edgeDistance);
            barIdeStatus.setAttribute("bottom", this.sbWidth + this.edgeDistance);
        }

        hboxStatusBarSettings.$ext.style.overflow = "hidden";

        for(var i = 0, l = this.toolItems.length; i < l; i++) {
            var tItem = this.toolItems[i];
            if (typeof tItem.pos === "number")
                mnuStatusBarTools.insertBefore(tItem.item, mnuStatusBarPrefs.childNodes[tItem.pos]);
            else
                mnuStatusBarTools.appendChild(tItem.item);
        }

        for(var i = 0, l = this.prefsItems.length; i < l; i++) {
            var pItem = this.prefsItems[i];
            if (typeof pItem.pos === "number")
                mnuStatusBarPrefs.insertBefore(pItem.item, mnuStatusBarPrefs.childNodes[pItem.pos]);
            else
                mnuStatusBarPrefs.appendChild(pItem.item);
        }

        var editor = ceEditor.$editor;
        var theme = editor && editor.getTheme() || "ace/theme/textmate";
        this.checkTheme(theme);

        if (this.toggleOnInit)
            this.toggleStatusBar();

        ceEditor.addEventListener("prop.autohidehorscrollbar", function(e) {
            if (e.changed) {
                _self.horScrollAutoHide = e.value ? "true" : "false";
                apf.layout.forceResize(tabEditors.parentNode.$ext);
            }
        });

        ide.addEventListener("track_action", function(e) {
            if(e.type === "vim" && window["lblInsertActive"]) {
                if(e.action === "disable")
                    lblInsertActive.hide();
                else if (e.mode === "insert")
                    lblInsertActive.show();
            }
        });

        this.inited = true;
    },

    addToolsItem: function(menuItem, position){
        if(!self["mnuStatusBarTools"]) {
            this.toolItems.push({ item : menuItem, pos : position });
        }
        else {
            if (typeof position === "number")
                mnuStatusBarTools.insertBefore(menuItem, mnuStatusBarTools.childNodes[position]);
            else
                mnuStatusBarTools.appendChild(menuItem);
        }
    },

    addPrefsItem: function(menuItem, position){
        if(!self["mnuStatusBarPrefs"]) {
            this.prefsItems.push({ item: menuItem, pos : position });
        }
        else {
            if (typeof position === "number")
                mnuStatusBarPrefs.insertBefore(menuItem, mnuStatusBarPrefs.childNodes[position]);
            else
                mnuStatusBarPrefs.appendChild(menuItem);
        }
    },
    
    setSelectionLength : function() {
        if (typeof lblSelectionLength === "undefined")
            return;

        var range = ceEditor.$editor.getSelectionRange();
        if (range.start.row != range.end.row || range.start.column != range.end.column) {
            var doc = ceEditor.getDocument();
            var value = doc.getTextRange(range);
            lblSelectionLength.setAttribute("caption", "(" + value.length + " Bytes)");
            lblSelectionLength.show();
        } else {
            lblSelectionLength.setAttribute("caption", "");
            lblSelectionLength.hide();
        }
    },

    toggleStatusBar: function(){
        if(this.expanded) {
            this.expanded = false;
            apf.setStyleClass(barIdeStatus.$ext, '', ["expanded"]);
            apf.tween.single(hboxStatusBarSettings.$ext, {
                type  : "width",
                anim  : apf.tween.easeOutQuint,
                from  : apf.isWebkit ? 50 : 52,
                to    : 1,
                steps : 8,
                interval : 5,
                onfinish : function(){
                    hboxStatusBarSettings.hide();
                }
            });
        }
        else {
            this.expanded = true;
            apf.setStyleClass(barIdeStatus.$ext, "expanded");
            hboxStatusBarSettings.show();
            apf.tween.single(hboxStatusBarSettings.$ext, {
                type  : "width",
                anim  : apf.tween.easeOutQuint,
                from  : 1,
                to    : apf.isWebkit ? 50 : 52,
                steps : 8,
                interval : 5
            });
        }
    },

    checkTheme: function(theme){
        require(["require", theme], function (require) {
            var reqTheme = require(theme);
            if(reqTheme.isDark)
                apf.setStyleClass(barIdeStatus.$ext, "ace_dark");
            else
                apf.setStyleClass(barIdeStatus.$ext, '', ["ace_dark"]);

            var aceBg = apf.getStyle(ceEditor.$editor.renderer.scroller, "background-color");
            aceBg = aceBg.replace("rgb", "rgba").replace(")", "");
            apf.setStyleRule(".bar-status", "background-color", aceBg + ", 0.0)");
            apf.setStyleRule(".bar-status:hover", "background-color", aceBg + ", 0.95)");
        });
    },

    setPosition : function() {
        if (typeof ceEditor != "undefined" && ceEditor.$editor) {
            var _self = this;
            var cw = ceEditor.$editor.renderer.scroller.clientWidth;
            var sw = ceEditor.$editor.renderer.scroller.scrollWidth;
            var bottom = this.edgeDistance;
            if (cw < sw || this.horScrollAutoHide === "false")
                bottom += this.sbWidth;

            if (this.$barMoveTimer)
                clearTimeout(this.$barMoveTimer);
            this.$barMoveTimer = setTimeout(function() {
                if (typeof barIdeStatus !== "undefined") {
                    barIdeStatus.setAttribute("bottom", bottom);
                    barIdeStatus.setAttribute("right", _self.sbWidth + _self.edgeDistance + _self.offsetWidth);
                }
            }, 50);
        }
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});

/**
 * Code Editor for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */


define('ext/imgview/imgview',['require','exports','module','core/ide','core/ext','text!ext/imgview/imgview.xml','ext/editors/editors'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var markup = require("text!ext/imgview/imgview.xml");
var editors = require("ext/editors/editors");

module.exports = ext.register("ext/imgview/imgview", {
    name    : "Image Viewer",
    dev     : "Ajax.org",
    fileExtensions : [
        "bmp",
        "djv",
        "djvu",
        "gif",
        "ico",
        "jpg",
        "jpeg",
        "pbm",
        "pgm",
        "png",
        "pnm",
        "ppm",
        "psd",
        "tiff",
        "xbm",
        "xpm"
    ],
    type    : ext.EDITOR,
    markup  : markup,
    deps    : [editors],

    nodes : [],

    setDocument : function(doc, actiontracker){
        doc.session = doc.getNode().getAttribute("path");
        imgEditor.setProperty("value", doc.session);
    },

    hook : function() {},

    init : function(amlPage) {
        var editor = imgEditor;
        
        ide.addEventListener("beforefilesave", function(e) {
            var path = e.node && e.node.getAttribute("path");
            if (!path)
                return;
            // don't save images for now.
            if (editor.value == path)
                return false;
        });
        
        amlPage.appendChild(editor);
        editor.show();

        this.imgEditor = this.amlEditor = editor;
        //this.nodes.push();
    },

    enable : function() {
        this.nodes.each(function(item){
            item.show();
        });
    },

    disable : function() {
        this.nodes.each(function(item){
            item.hide();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });

        this.nodes = [];
    }
});

});

/**
 * Extension Manager for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
 
 define('ext/extmgr/extmgr',['require','exports','module','core/ide','core/ext','core/util','text!ext/extmgr/extmgr.xml','ext/panels/panels','ext/settings/settings'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var util = require("core/util");
var markup = require("text!ext/extmgr/extmgr.xml");
var panels = require("ext/panels/panels");
var settings = require("ext/settings/settings");

module.exports = ext.register("ext/extmgr/extmgr", {
    name   : "Extension Manager",
    dev    : "Ajax.org",
    alone  : true,
    type   : ext.GENERAL, 
    markup : markup,
    desp   : [panels],
    
    nodes : [],
    
    hook : function(){
        var _self = this;
        var reloadDgExt = true;
        this.nodes.push(
            mnuWindows.insertBefore(new apf.divider(), mnuWindows.firstChild),

            mnuWindows.insertBefore(new apf.item({
                caption : "Extension Manager...",
                onclick : function(){
                    ext.initExtension(_self);
                    winExt.show();

                    // Hackity hackathon
                    // @TODO the problem is apparently that APF does not
                    // like to show the datagrid records when two datagrids are
                    // bound to the same model && that one of the xpath selectors
                    // used to filter the model, has no results
                    setTimeout(function() {
                        if (reloadDgExt) {
                            dgExt.reload();
                            reloadDgExt = false;
                        }
                    });
                }
            }), mnuWindows.firstChild)
        );

        // Load up extensions the user added manually
        ide.addEventListener("loadsettings", function(e){
            ide.addEventListener("extload", function(){
                var nodes = e.model.queryNodes("auto/extensions/plugin");
                for (var n = 0; n < nodes.length; n++)
                    _self.loadExtension(nodes[n].getAttribute("path"));
            });
        });

        // Save the manually-loaded extensions
        ide.addEventListener("savesettings", function(e){
            var eNode = e.model.data.selectSingleNode("auto/extensions");
            if (eNode) {
                eNode.parentNode.removeChild(eNode);
                eNode = null;
            }

            eNode = apf.createNodeFromXpath(e.model.data, "auto/extensions");
            var userExtensions = mdlExt.queryNodes("plugin[@userext='1']");
            for (var u = 0; u < userExtensions.length; u++) {
                var copy = apf.xmldb.cleanNode(userExtensions[u].cloneNode(false));
                eNode.appendChild(copy);
            }

            return true;
        });
    },

    init : function(amlNode){},

    loadExtension : function(path) {
        if (path || tbModuleName.validate()) {
            if (!path) {
                path = tbModuleName.value;
                tbModuleName.clear();
            }
            require([path], function() {
                var extNode = mdlExt.queryNode("plugin[@path='" + path + "']");
                if (extNode)
                    apf.xmldb.setAttribute(extNode, "userext", "1");
                settings.save();
            });
        } else {
            util.alert("Error", "Validation Error",
                "There was a problem validating your input: '" + 
                tbModuleName.value + "'");
        }
    },

    removeExtension : function() {
        var extPath = dgExtUser.selected.getAttribute("path");
        var extension = require(extPath);

        if(ext.unregister(extension)) {
            mdlExt.removeXml(mdlExt.queryNode("plugin[@path='" + extPath + "']"));
            settings.save();
        }
    },

    enableExt : function(path) {
        ext.enableExt(path);

        if (tabExtMgr.activepage === 0)
            btnUserExtEnable.setAttribute("caption", "Disable");
        else
            btnDefaultExtEnable.setAttribute("caption", "Disable");
    },

    disableExt : function(path) {
        ext.disableExt(path);

        if (tabExtMgr.activepage === 0)
            btnUserExtEnable.setAttribute("caption", "Enable");
        else
            btnDefaultExtEnable.setAttribute("caption", "Enable");
    },

    updateEnableBtnState : function() {
        if (tabExtMgr.activepage === 0) {
            if (dgExtUser.selected.getAttribute("enabled") === "1")
                btnUserExtEnable.setAttribute("caption", "Disable");
            else
                btnUserExtEnable.setAttribute("caption", "Enable");
        }
        else {
            if (dgExt.selected.getAttribute("enabled") === "1")
                btnDefaultExtEnable.setAttribute("caption", "Disable");
            else
                btnDefaultExtEnable.setAttribute("caption", "Enable");
        }
    },

    enable : function(){
        if (!this.disabled) return;
        
        this.nodes.each(function(item){
            item.enable();
        });
        this.disabled = false;
    },
    
    disable : function(){
        if (this.disabled) return;
        
        this.nodes.each(function(item){
            item.disable();
        });
        this.disabled = true;
    },
    
    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

    }
);
/**
 * Node Runner Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/noderunner/noderunner',['require','exports','module','apf/elements/debugger','apf/elements/debughost','core/ide','core/ext','core/settings','text!ext/noderunner/noderunner.xml'],function(require, exports, module) {

require("apf/elements/debugger");
require("apf/elements/debughost");

var ide = require("core/ide");
var ext = require("core/ext");
var settings = require("core/settings");
var markup = require("text!ext/noderunner/noderunner.xml");

module.exports = ext.register("ext/noderunner/noderunner", {
    name    : "Node Runner",
    dev     : "Ajax.org",
    type    : ext.GENERAL,
    alone   : true,
    offline : false,
    markup  : markup,
    commands: {
        "run": {
            "hint": "run a node program on the server",
            "commands": {
                "[PATH]": {"hint": "path pointing to an executable. Autocomplete with [TAB]"}
            }
        }
    },

    NODE_VERSION: "auto",

    init : function(){
        var _self = this;
        ide.addEventListener("socketDisconnect", this.onDisconnect.bind(this));
        ide.addEventListener("socketMessage", this.onMessage.bind(this));

        dbg.addEventListener("break", function(e){
            ide.dispatchEvent("break", e);
        });

        dbgNode.addEventListener("onsocketfind", function() {
            return ide.socket;
        });

        stDebugProcessRunning.addEventListener("activate", this.$onDebugProcessActivate.bind(this));
        stDebugProcessRunning.addEventListener("deactivate", this.$onDebugProcessDeactivate.bind(this));

        ide.addEventListener("consolecommand.run", function(e) {
            ide.send({
                command: "internal-isfile",
                argv: e.data.argv,
                cwd: e.data.cwd,
                sender: "noderunner"
            });
            return false;
        });

        ide.addEventListener("loadsettings", function(e){
            _self.NODE_VERSION = e.model.queryValue("auto/node-version/@version") || "auto";
        });
    },

    $onDebugProcessActivate : function() {
        dbg.attach(dbgNode, 0);
    },

    $onDebugProcessDeactivate : function() {
        dbg.detach(function(){});
    },

    onMessage : function(e) {
        var message = e.message;
        //console.log("MSG", message)

        switch(message.type) {
            case "node-debug-ready":
                ide.dispatchEvent("debugready");
                break;

            case "chrome-debug-ready":
                winTab.show();
                dbgChrome.loadTabs();
                ide.dispatchEvent("debugready");
                break;

            case "node-exit":
                stProcessRunning.deactivate();
                stDebugProcessRunning.deactivate();
                break;

            case "node-exit-with-error":
                stProcessRunning.deactivate();
                stDebugProcessRunning.deactivate();

                // TODO: is this the way to report an errror?
                txtOutput.addValue("<div class='item console_log' style='font-weight:bold;color:#ff0000'>[C9 Server Exception: "
                        + message.errorMessage + "</div>");
                break;

            case "state":
                stDebugProcessRunning.setProperty("active", message.debugClient || message.nodeDebugClient);
                stProcessRunning.setProperty("active", message.processRunning || message.nodeProcessRunning || message.pythonProcessRunning);
                dbgNode.setProperty("strip", message.workspaceDir + "/");
                ide.dispatchEvent("noderunnerready");
                break;

            case "error":
                // child process already running
                if (message.code == 1) {
                    stDebugProcessRunning.setProperty("active", false);
                    stProcessRunning.setProperty("active", true);

                    //ide.send({"command": "state"});
                    break;
                }
                // debug process already running
                else if (message.code == 5) {
                    stDebugProcessRunning.setProperty("active", true);
                    stProcessRunning.setProperty("active", true);

                    //ide.send({"command": "state"});
                    break;
                }

                /*
                    6:
                    401: Authorization Required
                */
                // Command error
                if (message.code === 9) {
                    txtConsole.addValue("<div class='item console_log' style='font-weight:bold;color:yellow'>"
                        + message.message + "</div>");
                }
                else if (message.code !== 6 && message.code != 401 && message.code != 455 && message.code != 456) {
                    txtConsole.addValue("<div class='item console_log' style='font-weight:bold;color:#ff0000'>[C9 Server Exception "
                        + (message.code || "") + "] " + message.message + "</div>");

                    apf.ajax("/debug", {
                        method      : "POST",
                        contentType : "application/json",
                        data        : apf.serialize({
                            agent   : navigator.userAgent,
                            type    : "C9 SERVER EXCEPTION",
                            code    : e.code,
                            message : e.message
//                            log     : apf.console.debugInfo.join("\n")
                        })
                    });
                }

                ide.send({"command": "state"});
                break;
        }
    },

    onDisconnect : function() {
        stDebugProcessRunning.deactivate();
    },

    debug : function() {
        this.$run(true);
    },

    run : function(path, args, debug, nodeVersion) {
        // this is a manual action, so we'll tell that to the debugger
        dbg.registerManualAttach();
        if (stProcessRunning.active || !stServerConnected.active || typeof path != "string")
            return false;

        if (nodeVersion == 'default')
            nodeVersion = "";

        path = path.trim();

        var page = ide.getActivePageModel();
        var command = {
            "command" : apf.isTrue(debug) ? "RunDebugBrk" : "Run",
            "file"    : path.replace(/^\/+/, ""),
            "runner"  : "node",
            "args"    : args || "",
            "version" : nodeVersion || settings.model.queryValue("auto/node-version/@version") || this.NODE_VERSION,
            "env"     : {
                "C9_SELECTED_FILE": page ? page.getAttribute("path").slice(ide.davPrefix.length) : ""
            }
        };
        ide.send(command);
    },

    stop : function() {
        if (!stProcessRunning.active)
            return;

        ide.send({
            "command": "kill",
            "runner"  : "node"
        });
    },

    enable : function(){
    },

    disable : function(){
    },

    destroy : function(){
    }
});

});

/**
 * Node Runner Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/runpanel/runpanel',['require','exports','module','core/ide','core/ext','ext/noderunner/noderunner','ext/panels/panels','ext/settings/settings','ext/dockpanel/dockpanel','ext/save/save','text!ext/runpanel/runpanel.xml','text!ext/runpanel/runbuttons.xml','text!ext/runpanel/settings.xml'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var noderunner = require("ext/noderunner/noderunner");
var panels = require("ext/panels/panels");
var settings = require("ext/settings/settings");
var dock = require("ext/dockpanel/dockpanel");
var save = require("ext/save/save");
var markup = require("text!ext/runpanel/runpanel.xml");
var buttonsMarkup = require("text!ext/runpanel/runbuttons.xml");
var markupSettings = require("text!ext/runpanel/settings.xml");

module.exports = ext.register("ext/runpanel/runpanel", {
    name    : "Run Panel",
    dev     : "Ajax.org",
    type    : ext.GENERAL,
    alone   : true,
    //offline : false,
    markup  : markup,
    deps    : [noderunner],

    defaultWidth : 270,

    commands : {
        "run": {
            "hint": "run and debug a node program on the server",
            "commands": {
                "[PATH]": {"hint": "path pointing to an executable. Autocomplete with [TAB]"}
            }
        },
        "stop": {
            "hint": "stop a running node program on the server",
            "commands": {
                "[PATH]": {"hint": "path pointing to an executable. Autocomplete with [TAB]"}
            }
        }
    },

    hotitems: {},

    nodes : [],

    hook : function(){
        var _self = this;

        panels.register(this, {
            position : 3000,
            caption: "Run",
            "class": "rundebug"
        });

        apf.document.body.insertMarkup(buttonsMarkup);

        this.nodes.push(
            mnuRunCfg
        );

        while (tbRun.childNodes.length) {
            var button = tbRun.firstChild;

            ide.barTools.appendChild(button);
            if (button.nodeType == 1) {
                this.nodes.push(button);
            }
        }

        mdlRunConfigurations.addEventListener("afterload", function(e) {
            _self.$populateMenu();
        });

        //Settings Support
        ide.addEventListener("init.ext/settings/settings", function(e) {
            var heading = e.ext.getHeading("General");
            heading.insertMarkup(markupSettings);
        });

        ide.addEventListener("loadsettings", function(e){
            var runConfigs = e.model.queryNode("auto/configurations");
            if (!runConfigs) {
                runConfigs = apf.createNodeFromXpath(e.model.data, "auto/configurations");
                apf.xmldb.setAttribute(runConfigs, "debug", "true");

                e.model.setQueryValue("general/@saveallbeforerun", false);
            }
            if (!e.model.queryNode("auto/configurations/@debug"))
                e.model.setQueryValue("auto/configurations/@debug", true);
            if (!e.model.queryNode("auto/configurations/@autohide"))
                e.model.setQueryValue("auto/configurations/@autohide", true);

            if (!runConfigs.selectSingleNode("config[@curfile]")) {
                var setLast = false;
                if (!e.model.queryNode("auto/configurations/config[@last='true']")) {
                    var config = e.model.queryNode("auto/configurations/config")
                    if (config)
                        apf.xmldb.setAttribute(config, "last", "true");
                    else
                        setLast = true;
                }

                var cfg = apf.n("<config />")
                    .attr("name", " (active file)")
                    .attr("curfile", "1");
                if (setLast)
                    cfg.attr("last", "true");
                runConfigs.insertBefore(cfg.node(), runConfigs.firstChild);
            }

            mdlRunConfigurations.load(runConfigs);
        });

        var page = tabEditors.getPage();
        if (page && page.$model) {
            var path = page.$model.queryValue("@path").replace(ide.davPrefix, "");
            mdlRunConfigurations.setQueryValue("config[@curfile]/@path", path);
            mdlRunConfigurations.setQueryValue("config[@curfile]/@name",
                path.split("/").pop() + " (active file)");
        }

        tabEditors.addEventListener("afterswitch", function(e){
            var page = e.nextPage;
            var path = page.$model.queryValue("@path").replace(ide.davPrefix, "");
            mdlRunConfigurations.setQueryValue("config[@curfile]/@path", path);
            mdlRunConfigurations.setQueryValue("config[@curfile]/@name",
                path.split("/").pop() + " (active file)");
        });

        ide.addEventListener("afterfilesave", function(e){
            var page = tabEditors.getPage();
            if (page) {
                var path = page.$model.queryValue("@path").replace(ide.davPrefix, "");
                mdlRunConfigurations.setQueryValue("config[@curfile]/@path", path);
                mdlRunConfigurations.setQueryValue("config[@curfile]/@name",
                    path.split("/").pop() + " (active file)");
            }
        });

        var hasBreaked = false;
        stProcessRunning.addEventListener("deactivate", function(){
            if (!_self.autoHidePanel())
                return;

            var name = "ext/debugger/debugger";
            dock.hideSection(name, false);
            hasBreaked = false;

            /*var bar = dock.getBars("ext/debugger/debugger", "pgDebugNav")[0];
            if (!bar.extended)
                dock.hideBar(bar);*/
        });
        /*stProcessRunning.addEventListener("activate", function(){
            if (!_self.shouldRunInDebugMode() || !_self.autoHidePanel())
                return;

            var bar = dock.getBars("ext/debugger/debugger", "pgDebugNav")[0];
            if (!bar.extended)
                dock.showBar(bar);
        });*/
        ide.addEventListener("break", function(){
            if (!_self.shouldRunInDebugMode() || !_self.autoHidePanel() || hasBreaked)
                return;

            hasBreaked = true;

            var name = "ext/debugger/debugger";
            dock.showSection(name, false);

            var uId = dock.getButtons(name, "pgDebugNav")[0].uniqueId;
            if (dock.layout.isExpanded(uId) < 0)
                dock.layout.showMenu(uId);

            //var bar = dock.getBars("ext/debugger/debugger", "pgDebugNav")[0];
            //dock.expandBar(bar);
        });
//        ide.addEventListener("dockpanel.load.settings", function(e){
//            var state = e.state;
//
//            if (_self.autoHidePanel() && !stProcessRunning.active) {
//                var bar = dock.getBars("ext/debugger/debugger", "pgDebugNav", state)[0];
//                bar.sections.each(function(section){
//                    section.buttons.each(function(button){
//                        if (!button.hidden || button.hidden == -1)
//                            button.hidden = 1;
//                    });
//                });
//            }
//        });

        // When we are not in debug mode and we close a page it goes back to be
        // automatically opened when the debug process starts
        ide.addEventListener("init.ext/debugger/debugger", function(){
            tabDebug.getPages().concat(tabDebugButtons.getPages()).each(function(page){
                page.addEventListener("afterclose", function(e){
                    if (_self.autoHidePanel() && !stProcessRunning.active) {
                        this.$dockbutton.$dockData.hidden = 1;
                    }
                });
            });
        });

        this.hotitems["run"]  = [btnRun];
        this.hotitems["stop"] = [btnStop];
    },

    checkAutoHide : function(){
        /*var value = settings.model.queryValue("auto/configurations/@autohide");
        var bar = dock.getBars("ext/debugger/debugger", "pgDebugNav")[0];

        if (value && bar.cache && bar.cache.visible)
            dock.hideSection("ext/debugger/debugger");
        else if (!value && bar.cache && !bar.cache.visible)
            dock.showSection("ext/debugger/debugger");*/
    },

    init : function(amlNode){
        this.panel = winRunPanel;

        colLeft.appendChild(winRunPanel);
        this.nodes.push(winRunPanel);

        lstRunCfg.addEventListener("afterremove", function(e){
            mnuRunCfg.childNodes.each(function(item){
                if (item.node == e.args[0].xmlNode)
                    item.destroy(true, true);
            });
        });
    },

    duplicate : function() {
        var config = lstRunCfg.selected;
        if (!config)
            return;

        var duplicate = config.cloneNode(true);
        apf.b(config).after(duplicate);
        lstRunCfg.select(duplicate);
        winRunPanel.show();
    },

    addConfig : function() {
        var path, name, file = ide.getActivePageModel();
        var extension = "";
        
        if(!file)
            return;
            
        path  = file.getAttribute("path").slice(ide.davPrefix.length + 1); //@todo inconsistent
        name  = file.getAttribute("name").replace(/\.(js|py)$/,
            function(full, ext){ extension = ext; return ""; });

        var cfg = apf.n("<config />")
            .attr("path", path)
            .attr("name", name)
            .attr("extension", extension)
            .attr("args", "").node();

        var node = mdlRunConfigurations.appendXml(cfg);
        this.$addMenuItem(node);
        lstRunCfg.select(cfg);
    },

    showRunConfigs : function() {
        panels.activate(this);
    },

    autoHidePanel : function(){
        return apf.isTrue(settings.model.queryValue("auto/configurations/@autohide"));
    },

    shouldRunInDebugMode : function(){
        return apf.isTrue(settings.model.queryValue('auto/configurations/@debug'));
    },

    run : function(debug) {
        this.runConfig(window.winRunPanel && winRunPanel.visible
            ? lstRunCfg.selected
            : (mdlRunConfigurations.queryNode("node()[@last='true']")
                || mdlRunConfigurations.queryNode("config[@curfile]")),
            this.shouldRunInDebugMode());
        ide.dispatchEvent("track_action", {type: debug ? "debug" : "run"});
    },

    $populateMenu : function() {
        var menu = mnuRunCfg;

        var item = menu.firstChild;
        while (item && item.tagName !== "a:divider") {
            menu.removeChild(item);
            item = menu.firstChild;
        }
        var divider = item;

        var configs = mdlRunConfigurations.queryNodes("config");
        if (!configs.length)
            menu.insertBefore(new apf.item({disabled:true, caption: "No run history"}), divider);
        else {
            for (var i =  0, l = configs.length; i < l; i++) {
                this.$addMenuItem(configs[i], divider);
            }
        }
    },

    $addMenuItem : function(cfg, divider){
        var _self = this;

        if (!divider)
            divider = mnuRunCfg.getElementsByTagNameNS(apf.ns.aml, "divider")[0];

        mnuRunCfg.insertBefore(new apf.item({
            caption  : "[{this.node}::@name]",
            node     : cfg,
            type     : "radio",
            selected : "[{this.node}::@last]",
            onclick  : function() {
                _self.runConfig(this.node, _self.shouldRunInDebugMode());
                if (self.lstRunCfg)
                    lstRunCfg.select(this.node);
            }
        }), divider)
    },

    runConfig : function(config, debug) {
        ext.initExtension(this);
        var model = settings.model;
        var saveallbeforerun = apf.isTrue(model.queryValue("general/@saveallbeforerun"));
        if (saveallbeforerun)
            save.saveall();

        if (debug === undefined)
            debug = config.parentNode.getAttribute("debug") == "1";

        var lastNode = apf.queryNode(config, "../node()[@last]");
        if (lastNode)
            apf.xmldb.removeAttribute(lastNode, "last");
        apf.xmldb.setAttribute(config, "last", "true");

        // dispatch here instead of in the implementation because the implementations
        // will vary over time
        ide.dispatchEvent("beforeRunning");

        noderunner.run(
            config.getAttribute("path"),
            (config.getAttribute("args") || "").split(" "),
            debug,
            ddRunnerSelector.value
        );
    },

    stop : function() {
        noderunner.stop();

        //dock.hideSection(["ext/run/run", "ext/debugger/debugger"]);
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];

        panels.unregister(this);
    }
});

});

/**
 * Tab Behaviors for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/tabbehaviors/tabbehaviors',['require','exports','module','core/ide','core/ext','ext/save/save','ext/panels/panels','ext/openfiles/openfiles','ext/panels/panels','ext/tree/tree'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var save = require("ext/save/save");
var panels = require("ext/panels/panels");
var openfiles = require("ext/openfiles/openfiles");

module.exports = ext.register("ext/tabbehaviors/tabbehaviors", {
    name       : "Tab Behaviors",
    dev        :  "Ajax.org",
    alone      : true,
    type       : ext.GENERAL,
    deps       : [panels],
    menus      : [],
    accessed   : [],
    $tabAccessCycle : 2,
    sep        : null,
    more       : null,
    menuOffset : 4, //This is fucking stupid
    commands   : {
        "closetab": {hint: "close the tab that is currently active", msg: "Closing active tab."},
        "closealltabs": {hint: "close all opened tabs", msg: "Closing all tabs."},
        "closeallbutme": {hint: "close all opened tabs, but the tab that is currently active", msg: "Closing tabs."},
        "gototabright": {hint: "navigate to the next tab, right to the tab that is currently active", msg: "Switching to right tab."},
        "gototableft": {hint: "navigate to the next tab, left to the tab that is currently active", msg: "Switching to left tab."},
        "tab1": {hint: "navigate to the first tab", msg: "Switching to tab 1."},
        "tab2": {hint: "navigate to the second tab", msg: "Switching to tab 2."},
        "tab3": {hint: "navigate to the third tab", msg: "Switching to tab 3."},
        "tab4": {hint: "navigate to the fourth tab", msg: "Switching to tab 4."},
        "tab5": {hint: "navigate to the fifth tab", msg: "Switching to tab 5."},
        "tab6": {hint: "navigate to the sixth tab", msg: "Switching to tab 6."},
        "tab7": {hint: "navigate to the seventh tab", msg: "Switching to tab 7."},
        "tab8": {hint: "navigate to the eighth tab", msg: "Switching to tab 8."},
        "tab9": {hint: "navigate to the ninth tab", msg: "Switching to tab 9."},
        "tab10": {hint: "navigate to the tenth tab", msg: "Switching to tab 10."},
        "revealtab": {hint: "reveal current tab in the file tree"},
        "nexttab": {hint: "navigate to the next tab in the stack of accessed tabs"},
        "previoustab": {hint: "navigate to the previous tab in the stack of accessed tabs"}
    },
    hotitems   : {},

    nodes      : [],

    init : function(amlNode){
        var _self = this;

        this.nodes.push(
            mnuTabs.appendChild(new apf.item({
                caption : "Reveal in File Tree",
                onclick : function() {
                    _self.revealtab(tabEditors.contextPage);
                },
                disabled : "{!!!tabEditors.activepage}"
            })),
            mnuTabs.appendChild(new apf.item({
                caption : "Close Tab",
                onclick : function() {
                    _self.closetab(tabEditors.contextPage);
                },
                disabled : "{!!!tabEditors.activepage}"
            })),
            mnuTabs.appendChild(new apf.item({
                caption : "Close All Tabs",
                onclick : this.closealltabs.bind(this),
                disabled : "{!!!tabEditors.activepage}"
            })),
            mnuTabs.appendChild(new apf.item({
                caption : "Close All But Current Tab",
                onclick : function() {
                    _self.closeallbutme();
                },
                disabled : "{!!!tabEditors.activepage}"
            })),
            mnuTabs.appendChild(new apf.item({
                caption : "Close Tabs to the Right",
                onclick : function() {
                    _self.closealltotheright();
                },
                disabled : "{!!!tabEditors.activepage}"
            })),
            mnuTabs.appendChild(new apf.item({
                caption : "Close Tabs to the Left",
                onclick : function() {
                    _self.closealltotheleft();
                },
                disabled : "{!!!tabEditors.activepage}"
            })),
            //mnuTabs.appendChild(new apf.divider()),
            apf.document.body.appendChild(new apf.menu({
                id : "mnuContextTabs",
                childNodes : [
                    new apf.item({
                        caption : "Reveal in File Tree",
                        onclick : function() {
                            _self.revealtab(tabEditors.contextPage);
                        },
                        disabled : "{!!!tabEditors.activepage}"
                    }),
                    new apf.item({
                        caption : "Close Tab",
                        onclick : function() {
                            _self.closetab(tabEditors.contextPage);
                        },
                        disabled : "{!!!tabEditors.activepage}"
                    }),
                    new apf.item({
                        caption : "Close All Tabs",
                        onclick : this.closealltabs.bind(this),
                        disabled : "{!!!tabEditors.activepage}"
                    }),
                    new apf.item({
                        caption : "Close Other Tabs",
                        onclick : function() {
                            _self.closeallbutme(tabEditors.contextPage);
                        },
                        disabled : "{!!!tabEditors.activepage}"
                    }),
                    new apf.item({
                        caption : "Close Tabs to the Right",
                        onclick : function() {
                            _self.closealltotheright();
                        },
                        disabled : "{!!!tabEditors.activepage}"
                    }),
                    new apf.item({
                        caption : "Close Tabs to the Left",
                        onclick : function() {
                            _self.closealltotheleft();
                        },
                        disabled : "{!!!tabEditors.activepage}"
                    })
                ]
            }))
        );
        
        this.hotitems.revealtab     = [this.nodes[0], mnuContextTabs.childNodes[0]];
        this.hotitems.closetab      = [this.nodes[1], mnuContextTabs.childNodes[1]];
        this.hotitems.closealltabs  = [this.nodes[2], mnuContextTabs.childNodes[2]];
        this.hotitems.closeallbutme = [this.nodes[3], mnuContextTabs.childNodes[3]];
        this.hotitems.closealltotheright = [this.nodes[4], mnuContextTabs.childNodes[4]];
        this.hotitems.closealltotheleftt = [this.nodes[5], mnuContextTabs.childNodes[5]];
        
        tabEditors.setAttribute("contextmenu", "mnuContextTabs");

        mnuContextTabs.addEventListener("prop.visible", function(e) {
            // If there are only 0 or 1 pages, disable both and return
            if (tabEditors.getPages().length <= 1) {
                mnuContextTabs.childNodes[3].setAttribute('disabled', true);
                mnuContextTabs.childNodes[4].setAttribute('disabled', true);
                mnuContextTabs.childNodes[5].setAttribute('disabled', true);
                return;
            }

            var page = tabEditors.getPage();
            var pages = tabEditors.getPages();

            // be optimistic, reset menu items to disabled
            mnuContextTabs.childNodes[3].setAttribute('disabled', false);
            mnuContextTabs.childNodes[4].setAttribute('disabled', false);
            mnuContextTabs.childNodes[5].setAttribute('disabled', false);

            // if last tab, remove "close to the right"
            if (page.nextSibling.localName !== "page") {
                mnuContextTabs.childNodes[4].setAttribute('disabled', true);
            }
            // if first tab, remove "close to the left"
            else if (pages.indexOf(page) == 0) {
                mnuContextTabs.childNodes[5].setAttribute('disabled', true);
            }
        });
        
        tabEditors.addEventListener("close", function(e) {
            if (!e || !e.htmlEvent)
                return;
            var page = e.page;
            e = e.htmlEvent;
            if (e.shiftKey) { // Shift = close all
                return _self.closealltabs();
            }
            else if(e.altKey) { // Alt/ Option = close all but this
                return _self.closeallbutme(page);
            }
        });

        tabEditors.addEventListener("DOMNodeInserted", function(e) {
            var page = e.currentTarget;
            if (page.localName != "page" || e.relatedNode != this || page.nodeType != 1)
                return;

            if (e.$isMoveWithinParent) {
                if (page.$tabMenu) {
                    mnuTabs.insertBefore(page.$tabMenu,
                        page.nextSibling ? page.nextSibling.$tabMenu : null);

                    _self.updateState();
                }
            }
            else if (page.fake)
                _self.addItem(page);
        });

        tabEditors.addEventListener("DOMNodeRemoved", function(e) {
            if (e.$doOnlyAdmin)
                return;

            var page = e.currentTarget;
            _self.removeItem(page);

            if (page.localName != "page" || e.relatedNode != this || page.nodeType != 1)
                return;

            if (!e.$doOnlyAdmin)
                _self.accessed.remove(page);
        });

        var cycleKeyPressed, cycleKey = apf.isMac ? 18 : 17;
        tabEditors.addEventListener("afterswitch", function(e) {
            var page = e.nextPage;

            if (!cycleKeyPressed) {
                _self.accessed.remove(page);
                _self.accessed.push(page);
            }
        });

        tabEditors.addEventListener("close", function(e) {
            if (tabEditors.getPage() == e.page)
                this.nextTabInLine = _self.accessed[_self.accessed.length - _self.$tabAccessCycle];
        });

        apf.addEventListener("keydown", function(eInfo) {
            if (eInfo.keyCode == cycleKey)
                cycleKeyPressed = true;
        });

        apf.addEventListener("keyup", function(eInfo) {
            if (eInfo.keyCode == cycleKey && cycleKeyPressed) {
                var page = tabEditors.getPage();
                if (page) {
                    _self.accessed.remove(page);
                    _self.accessed.push(page);
                }
                _self.$tabAccessCycle = 2;
                cycleKeyPressed = false;
            }
        });

        tabEditors.addEventListener("aftersavedialogcancel", function(e) {
            if (!_self.changedPages)
                return

            var i, l, page;
            for (i = 0, l = _self.changedPages.length; i < l; i++) {
                page = _self.changedPages[i];
                page.removeEventListener("aftersavedialogclosed", arguments.callee);
            }
        });
    },
    
    closetab: function() {
        var page = tabEditors.getPage();
        tabEditors.remove(page);
        return false;
    },

    closealltabs: function(callback) {
        callback = typeof callback == "function" ? callback : null;
        this.closeallbutme(1, callback);
    },

    // ignore is the page that shouldn't be closed, null to close all tabs
    closeallbutme: function(ignore, callback) {
        // if ignore isn't a page instance then fallback to current page
        if (!(ignore instanceof apf.page)) {
            ignore = null;
        }
        
        ignore = ignore || tabEditors.getPage();
        this.changedPages = [];
        this.unchangedPages = [];

        var page;
        var pages = tabEditors.getPages();

        var _self = this;
        for (var i = 0, l = pages.length; i < l; i++) {
            page = pages[i];

            if (ignore && (page == ignore || ignore.hasOwnProperty(i))) {
                continue;
            }

            if (page.$doc.getNode().getAttribute("changed") == "1") {
                page.noAnim = true; // turn off animation on closing tab
                this.changedPages.push(page);

                page.addEventListener("aftersavedialogclosed", function(e) {
                    var curPage = _self.changedPages[0];
                    if (_self.changedPages.length && curPage.caption != e.currentTarget.caption)
                        return
                    _self.changedPages.shift();
                    this.removeEventListener("aftersavedialogclosed", arguments.callee);
                    if (_self.changedPages.length == 0) {
                        _self.closeUnchangedPages(function() {
                            if (callback)
                                callback();
                        });
                    }
                    else {
                        tabEditors.remove(_self.changedPages[0], null, true);
                    }
                });
            }
            else {
                this.unchangedPages.push(page);
            }
        }

        if (this.changedPages.length) {
            tabEditors.remove(this.changedPages[0], null, true);
        }
        else {
            this.closeUnchangedPages(function() {
                if (callback)
                    callback();
            });
        }
    },

    closeUnchangedPages : function(callback) {
        var page;
        for (var i = 0, l = this.unchangedPages.length; i < l; i++) {
            page = this.unchangedPages[i];
            tabEditors.remove(page, null, true);
        }

        if (callback)
            callback();
    },

    closealltotheright : function() {
        var page = tabEditors.getPage();
        var pages = tabEditors.getPages();
    
        var currIdx = pages.indexOf(page);
        var ignore = {};
            
        for (var j = 0; j <= currIdx; j++) {
            ignore[j] = page;
        }

        this.closeallbutme(ignore);
    },

    closealltotheleft : function() {
        var page = tabEditors.getPage();
        var pages = tabEditors.getPages();
    
        var currIdx = pages.indexOf(page);
        var ignore = {};
            
        for (var j = pages.length - 1; j >= currIdx; j--) {
            ignore[j] = page;
        }
        
        this.closeallbutme(ignore);
    },
    
    nexttab : function(){
        var n = this.accessed.length - this.$tabAccessCycle++;
        if (n < 0) {
            n = this.accessed.length - 1;
            this.$tabAccessCycle = 2;
        }

        var next = this.accessed[n];
        if (next == tabEditors.getPage())
            return this.nexttab();

        tabEditors.set(next);
    },

    previoustab : function(){
        var n = this.accessed.length - --this.$tabAccessCycle;
        if (n ===  this.accessed.length) {
            n = 0;
            this.$tabAccessCycle = this.accessed.length;
        }

        var next = this.accessed[n];
        if (next == tabEditors.getPage())
            return this.previoustab();

        tabEditors.set(next);
    },

    gototabright: function() {
        return this.cycleTab("right");
    },

    gototableft: function() {
        return this.cycleTab("left");
    },

    cycleTab: function(dir) {
        var bRight  = dir == "right",
            tabs    = tabEditors,
            pages   = tabs.getPages(),
            curr    = tabs.getPage(),
            currIdx = pages.indexOf(curr);
        if (!curr || pages.length == 1)
            return;
        var idx = currIdx + (bRight ? 1 : -1);
        if (idx < 0)
            idx = pages.length - 1;
        if (idx > pages.length -1)
            idx = 0;

        // other plugins may modify this behavior
        var res = ide.dispatchEvent("beforecycletab", {
            index: idx,
            dir: dir,
            pages: pages
        });
        if (res === false)
            return;
        if (typeof res == "number")
            idx = res;

        tabs.set(pages[idx].id);
        return false;
    },

    tab1: function() {return this.showTab(1);},
    tab2: function() {return this.showTab(2);},
    tab3: function() {return this.showTab(3);},
    tab4: function() {return this.showTab(4);},
    tab5: function() {return this.showTab(5);},
    tab6: function() {return this.showTab(6);},
    tab7: function() {return this.showTab(7);},
    tab8: function() {return this.showTab(8);},
    tab9: function() {return this.showTab(9);},
    tab10: function() {return this.showTab(10);},

    showTab: function(nr) {
        // our indexes are 0 based an the number coming in is 1 based
        nr--;
        var pages = tabEditors.getPages();
        if (!pages[nr]) {
            return false;
        }
        
        tabEditors.set(pages[nr]);
        return false;
    },

    /**
     * Scrolls to the selected tab's file path in the "Project Files" tree
     *
     * Works by Finding the node related to the active tab in the tree, and
     * unfolds its parent folders until the node can be reached by an xpath
     * selector and focused, to finally scroll to the selected node.
     */
    revealtab: function(page) {
        if (!page || page.command)
            page = tabEditors.getPage();
        if (!page)
            return false;

        this.revealfile(page.$doc.getNode());
    },

    revealfile : function(docNode) {
        var path = docNode.getAttribute('path');
        var node = trFiles.queryNode('//file[@path="' + path + '"]');

        require("ext/panels/panels").activate(require("ext/tree/tree"));

        if (node) {
            trFiles.expandAndSelect(node);
            trFiles.focus();
            scrollToFile();
        }
        else {
            var parts = path.substr(ide.davPrefix.length).replace(/^\//, "").split("/");
            var file = parts.pop();
            var pathList = ["folder[1]"];
            var str = "";

            parts.forEach(function(part) {
                str += '/folder[@name="' + part + '"]';
                pathList.push("folder[1]" + str);
            });

            var xpath = pathList[pathList.length - 1];

            trFiles.expandList(pathList, function() {
                trFiles.select(trFiles.queryNode(xpath + '/file[@name="' + file + '"]'));
                trFiles.focus();
                scrollToFile();
            });
        }

        var parts = path.substr(ide.davPrefix.length).replace(/^\//, "").split("/");
        var file = parts.pop();
        var pathList = ["folder[1]"];
        var str = "";

        parts.forEach(function(part) {
            str += '/folder[@name="' + part + '"]';
            pathList.push("folder[1]" + str);
        });

        var xpath = pathList[pathList.length - 1];
        //var docNode = page.$doc.getNode();
        // Show spinner in active tab the file is being looked up
        apf.xmldb.setAttribute(docNode, "lookup", "1");

        trFiles.expandList(pathList, function() {
            trFiles.select(trFiles.queryNode(xpath + '/file[@name="' + file + '"]'));
            trFiles.focus();
            scrollToFile();
            // Hide spinner in active tab
            apf.xmldb.removeAttribute(docNode, "lookup");
        });

        function scrollToFile() {
            var tree = trFiles;
            var htmlNode = apf.xmldb.getHtmlNode(tree.selected, tree);
            if (!htmlNode)
                return;
            var itemPos = apf.getAbsolutePosition(htmlNode, tree.$container);
            var top = tree.$container.scrollTop;
            var bottom = top + tree.$container.offsetHeight;

            // No scrolling needed when item is between visible boundaries.
            if (itemPos[1] >= top && itemPos[1] <= bottom) {
                return;
            }
            
            var center = (tree.$container.offsetHeight / 2) | 0;
            var newTop = itemPos[1] - center;
            tree.$ext.scrollTop = newTop;
        }
    },

    addItem: function(page) {
        if (this.more)
            return; // no more items allowed...

        var mnu = mnuTabs.appendChild(new apf.item({
            caption : page.getAttribute("caption"),
            model   : page.$model,
            relPage : page.id,
            onclick : function() {
                tabEditors.set(this.relPage);
            }
        }));
        var no = this.nodes.push(mnu) - 1;

        page.$tabMenu = mnu;
        this.accessed.push(page);

        this.updateState();
    },

    removeItem: function(page) {
        var item, idx, keyId;
        var i = this.menuOffset;
        var l = this.nodes.length;
        var _self = this;
        for (; i < l; ++i) {
            if ((item = this.nodes[i]).relPage == page.id) {
                item.destroy(true, true);
                this.nodes.splice(i, 1);
                idx   = i - this.menuOffset + 1;
                keyId = "tab" + (idx == 10 ? 0 : idx);
                if (this.commands[keyId] && typeof this.commands[keyId].hotkey != "undefined")
                    apf.hotkeys.remove(this.commands[keyId].hotkey);

                setTimeout(function(){
                    _self.updateState();
                });
                return;
            }
        }
    },

    updateState: function(force) {
        var len = this.nodes.length - this.menuOffset;
        if (this.sep && !len) {
            this.sep.destroy(true, true);
            this.sep = null;
        }
        else if (!this.sep && (len || force)) {
            this.sep = mnuTabs.insertBefore(new apf.divider(), mnuTabs.childNodes[this.menuOffset]);
        }

        if (len < (force ? 19 : 20)) { // we already have 9 other menu items
            if (this.more) {
                this.more.destroy(true, true);
                this.more = null;
            }
        }
        else if (!this.more) {
            this.more = mnuTabs.appendChild(new apf.item({
                caption : "More...",
                onclick : function() {
                    panels.activate(openfiles);
                }
            }));
        }

        // update hotkeys and hotitems:
        var keyId, pages = tabEditors.getPages();
        for (var i = 0, l = pages.length; i < l; ++i) {
            keyId = "tab" + (i + 1 == 10 ? 0 : i + 1);
            this.hotitems[keyId] = [pages[i].$tabMenu];
            if (pages[i].$tabMenu && this.commands[keyId] && typeof this.commands[keyId].hotkey != "undefined")
                pages[i].$tabMenu.setAttribute("hotkey", this.commands[keyId].hotkey);
            else
                pages[i].$tabMenu.removeAttribute("hotkey");
        }
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});

/**
 * Tab Sessions for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/tabsessions/tabsessions',['require','exports','module','core/ide','core/ext','core/util','ext/settings/settings','ext/tabbehaviors/tabbehaviors','text!ext/save/save.css','text!ext/tabsessions/tabsessions.xml','ext/tabbehaviors/tabbehaviors'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var util = require("core/util");
var settings = require("ext/settings/settings");
var tabbehaviors = require("ext/tabbehaviors/tabbehaviors");
var css = require("text!ext/save/save.css");
var markup = require("text!ext/tabsessions/tabsessions.xml");
var tabbeh = require("ext/tabbehaviors/tabbehaviors");

tabbeh.menuOffset = 10;

module.exports = ext.register("ext/tabsessions/tabsessions", {
    name       : "Tab Sessions",
    dev        :  "Ajax.org",
    alone      : true,
    type       : ext.GENERAL,
    markup     : markup,
    css         : css,
    nodes      : [],
    commands   : {
        "savetabsession": {hint: "save the current tab state as a new session", msg: "Save tab session."},
    },
    hotitems   : [],
    init : function(amlNode){
        apf.importCssString((this.css || ""));
        
        var _self = this;
        ide.addEventListener("loadsettings", function(e) {            
            var model = e && e.model || settings.model;
        
            _self.nodes.push(
                apf.document.body.appendChild(new apf.menu({
                    id : "mnuTabLoadSessions",
                    onitemclick : function(e){
                        _self.loadSession(e.relatedNode.value);
                    }
                })),
                apf.document.body.appendChild(new apf.menu({
                    id : "mnuTabDeleteSessions",
                    onitemclick : function(e){
                        _self.removeSession(e.relatedNode.value);
                    }
                }))
            );
            
            var sessions = model.queryNodes("auto/sessions/session");
            
            // get sessionnames to order alfabetically
            var sessionnames = [];
            for (var i = 0, l = sessions.length; i < l; i++){ 
                sessionnames.push(sessions[i].getAttribute("name"));
            }
            sessionnames.sort();
            
            var name;
            sessionnames.forEach(function(name) {
                mnuTabLoadSessions.appendChild(new apf.item({
                    caption : name,
                    //type    : "radio",
                    value   : name
                }));
                mnuTabDeleteSessions.appendChild(new apf.item({
                    caption : name,
                    //type    : "radio",
                    value   : name
                }));
            });
    
            _self.nodes.push(
                mnuTabs.appendChild(new apf.divider()),
                mnuTabs.appendChild(new apf.item({
                    id      : "mnuFileLoadSession",
                    caption : "Load Tab Session",
                    submenu : "mnuTabLoadSessions",
                    disabled: !sessions.length
                })),
    
                mnuTabs.appendChild(new apf.item({
                    caption : "Save Tab Session",
                    onclick : function(){
                        winSaveSessionAs.show();
                    },
                    disabled : "{!!!tabEditors.activepage}"
                })),
                
                mnuTabs.appendChild(new apf.item({
                    id      : "mnuFileDeleteSession",
                    caption : "Delete Tab Session",
                    submenu : "mnuTabDeleteSessions",
                    disabled: !sessions.length
                }))
            );
            _self.hotitems["savetabsession"] = [_self.nodes[4]];
        });
    },
    
    saveSession : function(name, overwrite) {
        if (!name) {
            if (!txtSaveSessionAs.getValue() && trSaveSessionAs.selected)
                name = trSaveSessionAs.selected.getAttribute("name");
            else
                name = txtSaveSessionAs.getValue();
        }
        
        // check if session with given name already exists
        var session = settings.model.queryNode("auto/sessions/session[@name=\"" + name + "\"]");
        if (session && !overwrite) {
            var _self = this;
            return util.confirm("Overwrite Session", "Overwrite Session",
                "You're about to overwrite the session named " + name + ". Are you sure you want to do this?",
                function() {
                    _self.saveSession(name, true);
                    winSaveSessionAs.hide();
                    return;
                }
            );
        }
        
        if (!settings.model.queryNode("auto/sessions"))
            settings.model.appendXml("<sessions />", "auto");
        
        var files = settings.model.queryNode("auto/files");
        if (!files)
            return;
            
        // if session with given name already exist remove it
        if (session)
            settings.model.removeXml(session);
        else {
            mnuTabLoadSessions.appendChild(new apf.item({
                caption : name,
                //type    : "radio",
                value   : name
            }));
            mnuTabDeleteSessions.appendChild(new apf.item({
                caption : name,
                //type    : "radio",
                value   : name
            }));
        }
        
        session = apf.getXml("<session name=\"" + name + "\" />");
        session.appendChild(files);
        settings.model.appendXml(session, "auto/sessions");
        
        mnuFileLoadSession.enable();
        mnuFileDeleteSession.enable();
        
        settings.save();
        winSaveSessionAs.hide();
    },
    
    loadSession : function(name) {
        var _self = this;
        tabbehaviors.closealltabs(function() {
            _self.openSessionFiles(name);
        });
    },
    
    openSessionFiles : function(name) {
        var active = settings.model.queryValue("auto/sessions/session[@name=\"" + name + "\"]/files/@active");
        var nodes  = settings.model.queryNodes("auto/sessions/session[@name=\"" + name + "\"]/files/file");
        
        var sessionfiles = settings.model.queryNode("auto/sessions/session[@name=\"" + name + "\"]/files");
        if (!sessionfiles)
            return; // or display error
            
        for (var doc, i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            if (node.getAttribute("newfile") != "1")
                node.removeAttribute("changed");
            doc = ide.createDocument(node);
            doc.parentNode = {};
            
            var state = node.getAttribute("state");
            if (state) {
                try {
                    doc.state = JSON.parse(state);
                }
                catch(e) {}
            }
            
            ide.dispatchEvent("openfile", {
                doc    : doc,
                init   : true,
                active : active 
                    ? active == node.getAttribute("path")
                    : i == l - 1
            });
        }
  
        var oldfiles = settings.model.queryNode("auto/files");
        if (oldfiles)
            settings.model.removeXml("auto/files");
        
        settings.model.appendXml(sessionfiles.cloneNode(true), "auto");
        settings.save();
    },
    
    removeSession : function(name) {
        if (!settings.model.queryNode("auto/sessions/session[@name=\"" + name + "\"]"))
            return;
        
        settings.model.removeXml("auto/sessions/session[@name=\"" + name + "\"]");
        
        settings.save();
        var menuitems = mnuTabLoadSessions.childNodes.concat(mnuTabDeleteSessions.childNodes);
        for (var i = 0, l = menuitems.length; i < l; i++) {
            item = menuitems[i];
            if (item.value == name)
                mnuTabLoadSessions.removeChild(item);
        }
        
        if (menuitems.length == 2) {
            mnuFileLoadSession.disable();
            mnuFileDeleteSession.disable();
        }
        
    },
    
    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});

/**
 * Keybindings Manager for the Cloud9 IDE
 *
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
define('ext/keybindings/keybindings',['require','exports','module','core/ide','core/ext'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");

module.exports = ext.register("ext/keybindings/keybindings", {
    name: "Keybindings Manager",
    dev: "Ajax.org",
    alone: true,
    type: ext.GENERAL,
    current: null,
    nodes: [],

    init : function(amlNode) {
        // Fetch the default keybindings:
        var _self = this;
        ide.addEventListener("loadsettings", function(e) {
            var value = e.model.queryValue("general/keybindings/@preset") 
                || "default_" + (apf.isMac ? "mac" : "win");
                
            require(["ext/keybindings_default/" + value]);
        });
    },
    
    update : function(oExt) {
        var j, l, command, items, item, val;
        var name     = oExt.path.split("/").pop().toLowerCase();
        var bindings = this.current[name];
        
        if (!bindings || !oExt.commands) 
            return;
        for (command in oExt.commands) {
            if (!bindings[command])
                continue;
            if (typeof (val = oExt.commands[command])["hotkey"] !== "undefined")
                apf.hotkeys.remove(val.hotkey);
            oExt.commands[command].hotkey = bindings[command];
            if (ext.commandsLut[command])
                ext.commandsLut[command].hotkey = bindings[command];
            if ((items = (oExt.hotitems && oExt.hotitems[command]))) {
                for (j = 0, l = items.length; j < l; ++j) {
                    item = items[j];
                    if (!item.setAttribute) continue;
                    item.setAttribute("hotkey", bindings[command]);
                }
            }
            else if (typeof oExt[command] == "function") {
                apf.hotkeys.register(bindings[command], oExt[command].bind(oExt));
            }
            else {
                apf.console.error("Please implement the '" + command
                    + "' function on plugin '" + oExt.name + "' for the keybindings to work");
            }
        }
    },

    onLoad: function(def) {
        var _self = this;
        
        // update keybindings for extensions
        def = def.ext;
        
        // parse keybindings definition
        this.current = def;
        
        var i, oExt;
        for (i in ext.extLut) {
            //name     = i.substr(i.lastIndexOf("/") + 1).toLowerCase();
            //bindings = def[name];
            oExt     = ext.extLut[i];
            this.update(oExt);
        }
        
        if (!this.eventsInited) {
            ide.dispatchEvent("keybindingschange", { keybindings: def });
            ide.addEventListener("$event.keybindingschange", function(callback) {
                if (_self.current)
                    callback({keybindings: _self.current});
            });
            
            ide.addEventListener("ext.register", function(e){
                _self.update(e.ext);
            });
            
            this.eventsInited = true;
        }
        
        return def;
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});

/**
 * Default Keybindings Help Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
 
define('ext/keybindings_default/keybindings_default',['require','exports','module','core/ide','core/ext','text!ext/keybindings_default/keybindings_default.xml','text!ext/keybindings_default/keybindings_default.css','text!ext/keybindings_default/default_mac.js','text!ext/keybindings_default/default_win.js'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var markup = require("text!ext/keybindings_default/keybindings_default.xml");
var css = require("text!ext/keybindings_default/keybindings_default.css");

var mac = require("text!ext/keybindings_default/default_mac.js");
var win = require("text!ext/keybindings_default/default_win.js");

function parseKeyBindings(txt) {
    var json;
    txt.replace(/keys\.onLoad\(([\w\W\n\r]*)\);\n/gm, function(m, s){
        json = s.replace(/\);[\n\r\s]*\}$/, "");
    });
    return JSON.parse(json);
}

var extCache = {};

function uCaseFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

function generatePanelHtml(def, isMac) {
    var html = [];
    var div, extName, oExt, cmdName, command, parts;
    var count = 0;
    for (extName in def.ext) {
        ++count;
        oExt = extCache[extName];
        if (!extCache[extName]) {
            try {
                oExt = extCache[extName] = require("ext/" + extName + "/" + extName);
            }
            catch(ex) {
                continue;
            }
        }
        
        div = count % 3;
        html.push('<div class="keybindings_default_block',
            (div === 1 || div === 2 ? "_border" : ""),
            '"><h3>', oExt.name.toUpperCase(), "</h3>");
        for (cmdName in def.ext[extName]) {
            command = def.ext[extName][cmdName];
            html.push('<div class="keybindings_default_command">',
                '<span class="keybindings_default_cmdname">',
                    (oExt.commands && oExt.commands[cmdName].short 
                        ? oExt.commands[cmdName].short
                        : uCaseFirst(cmdName)
                    ),
                '</span><br/>');
            command = command.split("|")[0];
            if (isMac)
                parts = apf.hotkeys.toMacNotation(command).split(" ");
            else
                parts = command.split("-");
            html.push('<span class="keybindings_default_cmdkey">', 
                parts.join('</span><span class="keybindings_default_cmdop">+</span><span class="keybindings_default_cmdkey">'),
                '</span></div>');
        }
        html.push("</div>");
    }
    return html.join("");
}

module.exports = ext.register("ext/keybindings_default/keybindings_default", {
    name    : "Default Keybindings",
    dev     : "Ajax.org",
    type    : ext.GENERAL,
    alone   : true,
    
    commands : {
        "keybindings": {hint: "show a window that lists all available key shortcuts within the IDE"}
    },
    hotitems: {},

    nodes   : [],

    hook : function(){
        apf.importCssString(css || "");
        
        this.hotitems.keybindings = [this.nodes[0]];
    },

    init : function(amlNode){
        apf.document.body.insertMarkup(markup);
        
        var as = Array.prototype.slice.call(winKeyBindings.$ext.getElementsByTagName("a"));
        var _self = this;
        as.forEach(function(a) {
            var which = a.innerHTML.indexOf("Mac") > -1 ? "mac" : "win";
            apf.addListener(a, "mousedown", function(e) {
                _self.togglePanels(which);
            });
        });
        
        this.buildPanels();
    },
    
    togglePanels: function(which) {
        if (which == "mac") {
            //barKeyBindingsWin.hide();
            //barKeyBindingsMac.show();
            barKeyBindingsWin.setAttribute("visible", "false");
            barKeyBindingsMac.setAttribute("visible", "true");
        }
        else {
            barKeyBindingsMac.setAttribute("visible", "false");
            barKeyBindingsWin.setAttribute("visible", "true");
            //barKeyBindingsMac.hide();
            //barKeyBindingsWin.show();
        }
    },
    
    buildPanels: function() {
        // build windows panel:
        var panelWin = barKeyBindingsWin;
        panelWin.$ext.innerHTML = generatePanelHtml(parseKeyBindings(win));
        
        // build mac panel:
        var panelMac = barKeyBindingsMac;
        panelMac.$ext.innerHTML = generatePanelHtml(parseKeyBindings(mac), true);
    },
    
    keybindings: function() {
        ext.initExtension(this);
        winKeyBindings.show();
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});
/**
 * Watcher Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/watcher/watcher',['require','exports','module','core/ide','core/ext','core/util','ext/tree/tree'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var util = require("core/util");
var tree = require("ext/tree/tree");

module.exports = ext.register("ext/watcher/watcher", {
    name    : "Watcher",
    dev     : "Ajax.org",
    alone   : true,
    offline : false,
    type    : ext.GENERAL,
    markup  : null,
    visible : true,
    deps    : [tree],

    init : function() {
        // console.log("Initializing watcher");

        var removedPaths        = {},
            removedPathCount    = 0,
            changedPaths        = {},
            changedPathCount    = 0,
            expandedPaths       = {},
            _self               = this;

        function sendWatchFile(path) {
            ide.send({
                "command"     : "watcher",
                "type"        : "watchFile",
                "path"        : path.slice(ide.davPrefix.length).replace(/^\//, "")
            });
        }

        function sendUnwatchFile(path) {
            ide.send({
                "command"     : "watcher",
                "type"        : "unwatchFile",
                "path"        : path.slice(ide.davPrefix.length).replace(/^\//, "")
            });
        }

        function checkPage() {
            var page = tabEditors.getPage(),
                data = page.$model.data;
            if (!data || !data.getAttribute)
                return;

            var path = data.getAttribute("path");
            if (removedPaths[path]) {
                util.question(
                    "File removed, keep tab open?",
                    path + " has been deleted, or is no longer available.",
                    "Do you wish to keep the file open in the editor?",
                    function() { // Yes
                        apf.xmldb.setAttribute(data, "changed", "1");
                        delete removedPaths[path];
                        --removedPathCount;
                        winQuestion.hide();
                    },
                    function() { // Yes to all
                        var pages = tabEditors.getPages();

                        pages.forEach(function(page) {
                           apf.xmldb.setAttribute(page.$model.data, "changed", "1");
                        });
                        removedPaths = {};
                        removedPathCount = 0;
                        winQuestion.hide();
                    },
                    function() { // No
                        tabEditors.remove(page);
                        delete removedPaths[path];
                        --removedPathCount;
                        winQuestion.hide();
                    },
                    function() { // No to all
                        var pages = tabEditors.getPages();

                        pages.forEach(function(page) {
                            if (removedPaths[page.$model.data.getAttribute("path")])
                                tabEditors.remove(page);
                        });
                        removedPaths = {};
                        removedPathCount = 0;
                        winQuestion.hide();
                    }
                );
                btnQuestionYesToAll.setAttribute("visible", removedPathCount > 1);
                btnQuestionNoToAll.setAttribute("visible", removedPathCount > 1);
            } else if (changedPaths[path]) {
                util.question(
                    "File changed, reload tab?",
                    path + " has been changed by another application.",
                    "Do you want to reload it?",
                    function() { // Yes
                        ide.dispatchEvent("reload", {doc : page.$doc});
                        delete changedPaths[path];
                        --changedPathCount;
                        winQuestion.hide();
                    },
                    function() { // Yes to all
                        var pages = tabEditors.getPages();

                        pages.forEach(function (page) {
                            if (changedPaths[page.$model.data.getAttribute("path")])
                                ide.dispatchEvent("reload", {doc : page.$doc});
                        });
                        changedPaths = {};
                        changedPathCount = 0;
                        winQuestion.hide();
                    },
                    function() { // No
                        delete changedPaths[path];
                        --changedPathCount;
                        winQuestion.hide();
                    },
                    function() { // No to all
                        changedPaths = {};
                        changedPathCount = 0;
                        winQuestion.hide();
                    }
                );
                btnQuestionYesToAll.setAttribute("visible", changedPathCount > 1);
                btnQuestionNoToAll.setAttribute("visible", changedPathCount > 1);
            }
        }

        stServerConnected.addEventListener("activate", function() {
            if (_self.disabled) return;

            var pages = tabEditors.getPages();
            pages.forEach(function (page) {
                if(page.$model)
                    sendWatchFile(page.$model.data.getAttribute("path"));
            });
            for (var path in expandedPaths)
                sendWatchFile(path);
        });

        ide.addEventListener("openfile", function(e) {
            var path = e.doc.getNode().getAttribute("path");

            // console.log("Opened file " + path);
            sendWatchFile(path);
        });

        ide.addEventListener("closefile", function(e) {
            if (_self.disabled) return;

            var path = e.xmlNode.getAttribute("path");
            sendUnwatchFile(path);
        });

        ide.addEventListener("socketMessage", function(e) {
            if (_self.disabled) return;

            var pages = tabEditors.getPages();
            var message = e.message;
            if ((message.type && message.type != "watcher") || !message.path)
                return;

            var path = ide.davPrefix + message.path.slice(ide.workspaceDir.length);

            if (expandedPaths[path])
                return ide.dispatchEvent("treechange", {
                    path    : path,
                    files   : message.files
                });
            if (!pages.some(function (page) {
                return page.$model.data.getAttribute("path") == path;
            }))
                return;
            switch (message.subtype) {
            case "create":
                break;
            case "remove":
                if (!removedPaths[path]) {
                    removedPaths[path] = path;
                    ++removedPathCount;
                    checkPage();
                    /*
                    ide.dispatchEvent("treeremove", {
                        path : path
                    });
                    */
                }
                break;
            case "change":
                if (!changedPaths[path] &&
                    (new Date(message.lastmod).getTime() != new Date(tabEditors.getPage().$model.queryValue('@modifieddate')).getTime())) {
                    changedPaths[path] = path;
                    ++changedPathCount;
                    checkPage();
                }
                break;
            }
        });

        tabEditors.addEventListener("afterswitch", function(e) {
            if (_self.disabled) return;

            checkPage();
        });

        ide.addEventListener("init.ext/tree/tree", function(){
            trFiles.addEventListener("expand", function(e) {
                if (_self.disabled) return;

                var node = e.xmlNode;
                if (node && (node.getAttribute("type") == "folder" || node.tagName == "folder")) {
                    var path = node.getAttribute("path");

                    expandedPaths[path] = path;
                    sendWatchFile(path);
                }
            });

            trFiles.addEventListener("collapse", function (e) {
                if (_self.disabled) return;

                var node = e.xmlNode;
                if (node && (node.getAttribute("type") == "folder" || node.tagName == "folder")) {
                    var path = node.getAttribute("path");

                    delete expandedPaths[path];
                    sendUnwatchFile(path);
                }
            });
        });
    },

    enable : function(){
        this.disabled = false;

        //@todo add code here to set watchers again based on the current state
    },

    disable : function(){
        this.disabled = true;
    },

    destroy : function(){

    }
});

});

/**
 * This plugin gives a 'close confirmation' when closing the IDE
 *
 * @copyright 2012, Cloud9 IDE, Inc.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/closeconfirmation/closeconfirmation',['require','exports','module','core/ide','core/ext','ext/settings/settings'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var settings = require("ext/settings/settings");

module.exports = ext.register("ext/closeconfirmation/closeconfirmation", {
    name    : "Confirm closing",
    dev     : "Ajax.org",
    alone   : true,
    type    : ext.GENERAL,
    markup  : null,
    
    deps    : [ settings ],
    
    nodes : [],
    
    hook : function () {
        // when unloading the window
        window.onbeforeunload = this.onBeforeUnloadHandler;

        var _self = this;
        ide.addEventListener("init.ext/settings/settings", function (e) {
            // this is the checkbox
            var warnBeforeExiting = new apf.checkbox({
                "class" : "underlined",
                skin  : "checkbox_grey",
                value : "[general/@confirmexit]",
                label : "Warn before exiting"
            });
            
            // find the 'General' section in the settings plugin
            var heading = settings.getHeading("General");
            heading.appendChild(warnBeforeExiting);
    
            // add the checkbox to the node list of the plugin
            _self.nodes.push(warnBeforeExiting);
        });

        // init extension
        ext.initExtension(this);
    },
    
    init : function () {
    },
    
    onBeforeUnloadHandler : function () {
        // see what's in the settings
        var settingsNode = settings.model.queryNode("general/@confirmexit");
        if (settingsNode && apf.isTrue(settingsNode.value)) {
            return "Are you sure you want to leave Cloud9?";
        }        
    },

    enable : function() {
        this.nodes.each(function(item){
            item.enable();
        });
    },
    
    disable : function() {
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function() {
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
        
        // clean out the event handler
        if (window.onbeforeunload === this.onBeforeUnloadHandler) {
            window.onbeforeunload = null;
        }
    }
});

});
/**
 * Code Tools Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
 
define('ext/codetools/codetools',['require','exports','module','core/ide','core/ext'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");

module.exports = ext.register("ext/codetools/codetools", {
    dev    : "Ajax.org",
    name   : "Code Tools",
    alone  : true,
    type   : ext.GENERAL,

    nodes : [],

    hook : function(amlNode){
        var _self = this;
        
        ide.addEventListener("init.ext/code/code", function(e) {
            _self.attachEditorEvents(ceEditor);
        });
    },
    
    attachEditorEvents: function(amlEditor) {
        var editor = amlEditor.$editor;
        var prevRow, prevCol, multiClickTimer;

        editor.addEventListener("mousemove", function(e) {
            var pos = e.getDocumentPosition();
            var row = pos.row;
            var col = pos.column;
            var doc = editor.session.doc;
            var evObj = {
                amlEditor: amlEditor,
                editor: editor,
                pos: pos,
                doc: doc
            };
            
            if (prevRow !== row) {
                prevRow = row;
                ide.dispatchEvent("codetools.rowchange", evObj);
                // a row change is also considered a column change.
                ide.dispatchEvent("codetools.columnchange", evObj);
            }
            else if (prevCol !== col) {
                prevCol = col;
                ide.dispatchEvent("codetools.columnchange", evObj);
            }
        });
        
        editor.addEventListener("click", function(e) {
            clearTimeout(multiClickTimer);
            var pos = e.getDocumentPosition();
            var doc = editor.session.doc;
            
            multiClickTimer = setTimeout(function() {
                multiClickTimer = null;
                ide.dispatchEvent("codetools.codeclick", {
                    amlEditor: amlEditor,
                    editor: editor,
                    pos: pos,
                    doc: doc
                });
            }, 100);
        });
        
        editor.addEventListener("dblclick", function(e) {
            clearTimeout(multiClickTimer);
            multiClickTimer = null;

            var pos = e.getDocumentPosition();
            var doc = editor.session.doc;

            ide.dispatchEvent("codetools.codedblclick", {
                amlEditor: amlEditor,
                editor: editor,
                pos: pos,
                doc: doc
            });
        });
        
        function cursorChange() {
            var anchor = editor.session.selection.getSelectionAnchor();

            ide.dispatchEvent("codetools.cursorchange", {
                amlEditor: amlEditor,
                editor: editor,
                pos: {
                    row: anchor.row,
                    column: anchor.column
                },
                doc: editor.session.doc
            });
        }

        function selectionChange() {
            var anchor = editor.session.selection.getSelectionAnchor();
            var lead = editor.session.selection.getSelectionLead();

            if (anchor.row !== lead.row || Math.abs(anchor.column - lead.column) > 1) {
                ide.dispatchEvent("codetools.selectionchange", {
                    amlEditor: amlEditor,
                    editor: editor,
                    pos: {
                        start: lead,
                        end: anchor
                    },
                    doc: editor.session.doc
                });
            }
        }
        
        editor.addEventListener("changeSession", function(e) {
            if (e.oldsession) {
                e.oldsession.removeEventListener("changeCursor", cursorChange);
                e.oldsession.removeEventListener("changeSelection", selectionChange);
            }
            e.session.selection.addEventListener("changeCursor", cursorChange);
            e.session.selection.addEventListener("changeSelection", selectionChange);
        });
    },
    
    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});
/**
 * Console hints and autcompletion for the Cloud9 IDE
 *
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 * @contributor Sergi Mansilla <sergi AT c9 DOT io>
 */

define('ext/consolehints/consolehints',['require','exports','module','core/ide','core/ext','text!ext/consolehints/consolehints.xml','text!ext/consolehints/consolehints.css','ext/console/console'],function(require, exports, module) {

"use strict";

var ide = require("core/ide");
var ext = require("core/ext");
var markup = require("text!ext/consolehints/consolehints.xml");
var css = require("text!ext/consolehints/consolehints.css");
var Console = require("ext/console/console");

var winHints, selectedHint, animControl, hintsTimer;
var RE_lastWord = /(\w+)$/;
var filterCommands = function(commands, word) {
    return commands.filter(function(cmd) {
        return cmd !== word && cmd.search(new RegExp("^" + word)) !== -1;
    }).sort();
};

var mouseHandler = function(e) {
    clearTimeout(hintsTimer);
    var el = e.target || e.srcElement;
    while (el && el.nodeType === 3 && el.tagName !== "A" && el !== winHints)
        el = el.parentNode;

    if (el.tagName !== "A") return;

    var self = this;
    hintsTimer = setTimeout(function() { self.select(el); }, 5);
};

var fontSize;
// This function is not accurate, but we don't care since we don't need precision.
var getFontSize = function(txtNode) {
    if (fontSize)
        return fontSize;

    var font = apf.getStyle(txtNode, "font");
    var el = document.createElement("span");
    el.style.font = font;
    el.innerHTML = "m";
    document.body.appendChild(el);
    fontSize = {
        width: el.offsetWidth,
        height: el.offsetHeight
    };
    document.body.removeChild(el);
    return fontSize;
};

var hintLink = function(data) {
    var dataAttr = [data.base, data.cmdName, data.cursorPos, !!data.cmd].join(",");
    if (!data.cmd)
        return '<a href="#" data-hint="'+ dataAttr + '">' + data.cmdName + '</a>';

    var spanHotkey = "";
    var key = data.cmd.hotkey;
    if (key) {
        var notation = apf.isMac ? apf.hotkeys.toMacNotation(key) : key;
        spanHotkey = '<span class="hints_hotkey">' + notation + '</span>';
    }
    var cmdText = '<span>' + data.cmd.hint + '</span>' + spanHotkey;
    return '<a href="#" data-hint="'+ dataAttr + '">' + data.cmdName + cmdText + '</a>';
};

module.exports = ext.register("ext/consolehints/consolehints", {
    name   : "ConsoleHints",
    dev    : "Ajax.org",
    type   : ext.GENERAL,
    alone  : true,
    markup : markup,
    css    : css,
    deps   : [Console],
    hidden : true,
    nodes  : [],
    autoOpen : true,
    excludeParent : true,

    init: function() {
        var _self = this;
        var initConsoleDeps = function() {
            apf.importCssString(_self.css);
            winHints = document.getElementById("barConsoleHints");
            apf.addListener(winHints, "mousemove", mouseHandler.bind(_self));
            apf.addListener(winHints, "click", _self.click.bind(_self));
            
            Console.messages.commandhints = function(message) {
                var cmds = message.body;
                for (var cmd in cmds)
                    Console.allCommands[cmd] = cmds[cmd];
            };
            Console.messages["internal-autocomplete"] = function(message) {
                var cmds = message.body;
                _self.show(txtConsoleInput, "", cmds.matches, txtConsoleInput.getValue().length - 1);
            };
    
            // Asynchronously retrieve commands that other plugins may have
            // registered, hence the (relatively) long timeout.
            setTimeout(function() {
                ide.send({
                    command: "commandhints",
                    cwd: Console.getCwd()
                });
            }, 1000);
            
            txtConsoleInput.addEventListener("blur", function(e) { _self.hide(); });
            txtConsoleInput.addEventListener("keyup", function(e) {
                // Ignore up/down cursor arrows here
                if (e.keyCode === 38 || e.keyCode === 40 || e.keyCode === 9) return;
                var getCmdMatches = function(filtered) {
                    var cli = e.currentTarget;
                    if (filtered.length && filtered[0] !== "[PATH]")
                        _self.show(cli, "", filtered, cli.getValue().length - 1);
                    else {
                        _self.hide();
                    }
                };
    
                var cliValue = e.currentTarget.getValue();
                if (cliValue)
                    _self.getCmdCompletion(cliValue, getCmdMatches);
                else
                    _self.hide();
            });
    
            // Below we are overwriting the Console default key events in function of
            // whether the hints are being displayed or not.
            var redefinedKeys = {
                38: "selectUp",
                40: "selectDown",
                27: "hide",
                13: "onEnterKey",
                9: "onTabKey"
            };
    
            Object.keys(redefinedKeys).forEach(function(keyCode) {
                var previousKey = Console.keyEvents[keyCode];
                Console.keyEvents[keyCode] = function(target) {
                    if (winHints.style.display === "none" && previousKey) {
                        previousKey(target);
                    }
                    else {
                        // try executing the redefined mapping
                        // if it returns false, then execute the old func
                        if (!_self[redefinedKeys[keyCode]].call(_self)) {
                            previousKey(target);
                            _self.hide();
                        }
                    }
                };
            });
        };
        
        if (Console && Console.messages) {
            initConsoleDeps();
        }
        else {
            ide.addEventListener("init.ext/console/console", initConsoleDeps);
        }
    },
    
    show: function(textbox, base, hints, cursorPos) {
        if (animControl && animControl.stop)
            animControl.stop();

        var content = hints.map(function(hint) {
            var cmdName = base ? base + hint.substr(1) : hint;
            return hintLink({
                base: base,
                cmdName: cmdName,
                cursorPos: cursorPos,
                cmd: Console.allCommands[cmdName]
            });
        }).join("");

        winHints.innerHTML = content;
        selectedHint = null;

        if (apf.getStyle(winHints, "display") === "none") {
            winHints.style.display = "block";
            winHints.visible = true;
        }

        var size = getFontSize(textbox.$ext);
        winHints.style.left = parseInt(cursorPos * size.width, 10) + "px";
    },
    hide: function() {
        winHints.style.display = "none";
        winHints.visible = false;
        selectedHint = null;
        
        return true;
    },
    click: function(e) {
        var node = e.target;
        if (node.parentNode != winHints && node != winHints)
            node = node.parentNode;

        var parts = node.getAttribute("data-hint").split(",");
        var cmdName = parts[1];
        var isCmd = (parts[3] === "true");

        if (isCmd)
            cmdName += " "; // for commands we suffix with whitespace

        var cliValue = txtConsoleInput.getValue();
        var index = cliValue.search(RE_lastWord);
        if (index !== -1) // If the command is partially there or not
            cliValue = cliValue.replace(RE_lastWord, cmdName);
        else
            cliValue += cmdName;

        txtConsoleInput.setValue(cliValue);
        txtConsoleInput.focus();

        var input = txtConsoleInput.querySelector("input");
        if (input)
            input.selectionStart = input.selectionEnd = index + cmdName.length;

        this.hide();
    },
    // Given a value and a function for subCommands `fn1` and a function for one
    // command `fn2`, calls the functions with the proper array of completions,
    // if any.
    getCmdCompletion: function(value, fn1, fn2) {
        var fullCmd = value.match(/(\w+)\s+(.*)$/);
        if (fullCmd) {
            // If we don't recognize the root command
            var rootCmd = Console.allCommands[fullCmd[1]];
            if (!rootCmd)
                return fn1([]);

            var subCommands = rootCmd.commands;
            var filtered;
            if (subCommands && subCommands["[PATH]"])
                filtered = ["[PATH]"];
            else if (subCommands)
                filtered = filterCommands(Object.keys(subCommands), fullCmd[2]);
            else
                filtered = [];

            fn1(filtered, fullCmd[1], fullCmd[2]);
        }
        else {
            (fn2 || fn1)(filterCommands(Object.keys(Console.allCommands), value));
        }
    },
    onTabKey: function() {
        this.hide();

        var cliValue = txtConsoleInput.getValue();
        if (!cliValue) return;

        this.getCmdCompletion(cliValue,
            function(cmds, cmd1, cmd2) {
                if (cmds.length) {
                    // This is legacy. Not the best way to determine if a command
                    // accepts filename inputs
                    if (cmds[0] === "[PATH]") {
                        ide.send({
                            command: "internal-autocomplete",
                            argv: [cmd1, cmd2],
                            cwd: Console.getCwd()
                        });
                    }
                    else {
                        cliValue = cliValue.replace(RE_lastWord, cmds[0]);
                    }
                }
            },
            function(cmds) {
                if (cmds.length) cliValue = cmds[0];
            }
        );

        txtConsoleInput.setValue(cliValue);
        // In order to avoid default blurring behavior for TAB
        setTimeout(function() { txtConsoleInput.focus(); }, 50);
        
        return true;
    },
    onEnterKey: function() {
        var handled = false;
        var hintNodes = winHints.childNodes;
        for (var i = 0, l = hintNodes.length; i < l; ++i) {
            if (hintNodes[i].className === "selected") {
                this.click({ target: hintNodes[i] });
                handled = true;
                break;
            }
        }
        
        return handled;
    },
    selectUp: function() {
        var newHint = selectedHint - 1;
        if (newHint < 0)
            newHint = winHints.childNodes.length - 1;

        this.select(newHint);
        return true;
    },
    selectDown: function() {
        var newHint = selectedHint + 1;
        if (newHint > winHints.childNodes.length)
            newHint = 0;

        this.select(newHint);
        return true;
    },
    select: function(hint) {
        clearTimeout(hintsTimer);
        var hintNodes = winHints.childNodes;

        if (typeof hint === "number")
            hint = hintNodes[hint];

        for (var i = 0, l = hintNodes.length; i < l; ++i) {
            if (hintNodes[i] === hint) {
                selectedHint = i;
                continue;
            }
            hintNodes[i].className = "";
        }

        hint && (hint.className = "selected");
    },
    visible: function() {
        return winHints && !!winHints.visible;
    },
    selected: function() {
        return selectedHint && winHints.childNodes
            ? winHints.childNodes[selectedHint]
            : false;
    }
});
});

/**
 * Beautify extension for the Cloud9 IDE client
 *
 * Reformats the selected code in the current document
 *
 * Processing/formatting code from https://github.com/einars/js-beautify
 *
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/beautify/beautify',['require','exports','module','core/ext','core/ide','core/util','ext/code/code','ext/editors/editors','ace/range','ext/beautify/res/jsbeautify/jsbeautify-min','text!ext/beautify/settings.xml','ext/settings/settings'],function (require, exports, module) {

var ext = require("core/ext");
var ide = require("core/ide");
var util = require("core/util");
var code = require("ext/code/code");
var editors = require("ext/editors/editors");
var Range = require("ace/range").Range;
var jsbeautify = require("ext/beautify/res/jsbeautify/jsbeautify-min");
var settings = require("text!ext/beautify/settings.xml");
var extSettings = require("ext/settings/settings");

module.exports = ext.register("ext/beautify/beautify", {
    name: "JS Beautify",
    dev: "Ajax.org",
    alone: true,
    type: ext.GENERAL,

    commands: {
        "beautify": {
            hint: "reformat selected JavaScript code in the editor",
            msg: "Beautifying selection."
        }
    },

    nodes: [],
    hotitems: {},

    beautify: function () {
        var editor = editors.currentEditor;

        var sel = editor.getSelection();
        var doc = editor.getDocument();
        var range = sel.getRange();
        var value = doc.getTextRange(range);

        // Load up current settings data
        var preserveEmpty = apf.isTrue(extSettings.model.queryValue("beautify/jsbeautify/@preserveempty"));
        var keepIndentation = apf.isTrue(extSettings.model.queryValue("beautify/jsbeautify/@keeparrayindentation"));
        var jsLintHappy = apf.isTrue(extSettings.model.queryValue("beautify/jsbeautify/@jslinthappy"));
        var braces = extSettings.model.queryValue("beautify/jsbeautify/@braces") || "end-expand";
        var indentSize = extSettings.model.queryValue("editors/code/@tabsize");
        var indentTab = apf.isTrue(extSettings.model.queryValue("editors/code/@softtabs")) ? " " : "\t";

        if (indentTab == "\t") indentSize = 1;

        var line = doc.getLine(range.start.row);
        var indent = line.match(/^\s*/)[0];
        var trim = false;

        if (range.start.column < indent.length)
            range.start.column = 0;
        else
            trim = true;

        try {
            value = jsbeautify.js_beautify(value, {
                indent_size: indentSize,
                indent_char: indentTab,
                preserve_newlines: preserveEmpty,
                keep_array_indentation: keepIndentation,
                brace_style: braces,
                jslint_happy: jsLintHappy
            });
            value = value.replace(/^/gm, indent);
            if (trim) value = value.trim();
        }
        catch (e) {
            util.alert("Error", "This code could not be beautified", "Please correct any JavaScript errors and try again");
            return;
        }

        var end = doc.replace(range, value);
        sel.setSelectionRange(Range.fromPoints(range.start, end));
    },

    init: function () {
        var _self = this;
        tabEditors.addEventListener("afterswitch", function() {
            if (_self.$selectionEvent) {
                _self.editorSession.selection.removeEventListener("changeSelection",
                    _self.$selectionEvent);
            }

            setTimeout(function() {
                if(editors.currentEditor.ceEditor) {
                    _self.editorSession = editors.currentEditor.ceEditor.$editor.session;
                    _self.editorSession.selection.addEventListener("changeSelection",
                        _self.$selectionEvent = function(e) {
                            if (typeof beautify_selection === "undefined")
                                return;
    
                            var range = ceEditor.$editor.getSelectionRange();
                            if (range.start.row == range.end.row && range.start.column == range.end.column)
                                beautify_selection.disable();
                            else
                                beautify_selection.enable();
                        }
                    );
                }
            }, 200);
        });
    },

    hook: function () {
        var _self = this;
        var menuItem = new apf.item({
            id : "beautify_selection",
            disabled : "true",
            caption: "Beautify Selection",
            onclick: function () {
                _self.beautify();
            }
        });

        this.nodes.push(menuItem);

        ide.addEventListener("init.ext/statusbar/statusbar", function(e) {
            e.ext.addToolsItem(menuItem, 1);
        });

        this.hotitems.beautify = [this.nodes[0]];
        code.commandManager.addCommand({
            name: "beautify",
            exec: function () {
                _self.beautify();
            }
        });

        ide.addEventListener("init.ext/settings/settings", function (e) {
            var heading = e.ext.getHeading("JS Beautify");
            heading.insertMarkup(settings);
        });

        ide.addEventListener("loadsettings", function(e){
            var model = e.model;

            if (!model.queryNode("beautify/jsbeautify")) {
                model.setQueryValue("beautify/jsbeautify/@preserveempty", "true");
                model.setQueryValue("beautify/jsbeautify/@keeparrayindentation", "false");
                model.setQueryValue("beautify/jsbeautify/@jslinthappy", "false");
                model.setQueryValue("beautify/jsbeautify/@braces", "end-expand");
                model.setQueryValue("editors/code/@tabsize", "4");
                model.setQueryValue("editors/code/@softtabs", "true");
            }
        });
        
        ext.initExtension(this);
    },

    enable: function () {
        this.nodes.each(function (item) {
            item.enable();
        });
    },

    disable: function () {
        this.nodes.each(function (item) {
            item.disable();
        });
    },

    destroy: function () {
        this.nodes.each(function (item) {
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});
/**
 * Strip whitespace extension for the Cloud9 IDE client
 *
 * Strips whitespace at the end of each line in the current buffer.
 *
 * @author Sergi Mansilla
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/stripws/stripws',['require','exports','module','core/ext','core/ide','ext/editors/editors','ext/settings/settings'],function (require, exports, module) {

var ext = require("core/ext");
var ide = require("core/ide");
var editors = require("ext/editors/editors");
var extSettings = require("ext/settings/settings");

// Attaching to exports.module for testing purposes
var strip = module.exports.strip = function () {
    if (!editors.currentEditor.ceEditor)
        return;

    var editor = editors.currentEditor.ceEditor.$editor;
    var session = editor.getSession();

    var doc = session.getDocument();
    var lines = doc.getAllLines();

    for (var i = 0, l=lines.length; i < l; i++) {
        var line = lines[i];
        var index = line.search(/\s+$/);

        if (index !== -1)
            doc.removeInLine(i, index, line.length);
    }
    session.$syncInformUndoManager();
};

module.exports = ext.register("ext/stripws/stripws", {
    name: "Strip Whitespace",
    dev: "Ajax.org",
    alone: true,
    type: ext.GENERAL,

    commands: {
        "stripws": {
            hint: "strip whitespace at the end of each line"
        }
    },

    nodes: [],

    init: function () {},

    hook: function () {
        var self = this;
        var menuItem = new apf.item({
                            caption: "Strip Whitespace",
                            onclick: function () {
                                ext.initExtension(self);
                                strip();
                            }
                        });
        var menuItemClone = menuItem.cloneNode(true);

        this.nodes.push(
            ide.mnuEdit.appendChild(new apf.divider()),
            ide.mnuEdit.appendChild(menuItem),
            menuItemClone
        );

        ide.addEventListener("init.ext/statusbar/statusbar", function (e) {
            e.ext.addToolsItem(menuItemClone, 2);
        });

        ide.addEventListener("beforefilesave", function(data) {
            var node =
                extSettings.model.data.selectSingleNode("editors/code/@stripws");

            // If the 'Strip whitespace on save' option is enabled, we strip
            // whitespaces from the node value just before the file is saved.
            if (node && node.firstChild && node.firstChild.nodeValue == "true") {
                strip();
            }
        });

        ide.addEventListener("init.ext/settings/settings", function (e) {
            var heading = e.ext.getHeading("General");
            heading.appendChild(new apf.checkbox({
                "class" : "underlined",
                skin  : "checkbox_grey",
                value : "[editors/code/@stripws]",
                label : "On Save, Strip Whitespace"
            }))
        });
    },

    stripws: function() {
        strip();
    },

    enable: function () {
        this.nodes.each(function (item) {
            item.enable();
        });
    },

    disable: function () {
        this.nodes.each(function (item) {
            item.disable();
        });
    },

    destroy: function () {
        this.nodes.each(function (item) {
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});
});

/**
 * Zen mode
 *
 * @TODO
 * - Disabling the extension doesn't call the disable() function
 * - Exit zen mode when doing any keybinding operation (except openfiles, quicksearch, gotoline)
 * - While animating, disable ability to toggle zen mode (better: cancel and reverse the operation)
 *
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/zen/zen',['require','exports','module','ext/zen/firmin-all-min','core/ext','core/ide','ext/editors/editors','ext/settings/settings','text!ext/zen/zen.xml','text!ext/zen/skin.xml'],function(require, exports, module) {

require("ext/zen/firmin-all-min");

var ext = require("core/ext");
var ide = require("core/ide");
var editors = require("ext/editors/editors");
var settings = require("ext/settings/settings");
var markup = require("text!ext/zen/zen.xml");
var skin = require("text!ext/zen/skin.xml");

module.exports = ext.register("ext/zen/zen", {
    name     : "Zen mode",
    dev      : "Ajax.org",
    alone    : true,
    type     : ext.GENERAL,
    markup   : markup,
    skin     : {
        id   : "zen",
        data : skin,
        "media-path" : ide.staticPrefix + "/style/images/",
        "icon-path"  : ide.staticPrefix + "/style/icons/"
    },
    isFocused : false,
    neverShown : true,

    defaultOffset : 11,
    offsetWidth : 11,
    initialWidth : 0.70,

    handleLeftMove : false,
    handleRightMove : false,

    commands : {
        "zen": {hint: "toggle zen mode"},
        "zenslow": {hint: "toggle zen mode in slow-motion"}
    },

    nodes : [],

    hook : function(){
        var _self = this;
        ide.addEventListener("openfile", function() {
            if (_self.neverShown) {
                setTimeout(function() {
                    ext.initExtension(_self);
                }, 1000);
                _self.neverShown = false;
            }
        });

        ide.addEventListener("loadsettings", function(e){
            var strSettings = e.model.queryValue("auto/zen");
            if (strSettings)
                _self.initialWidth = strSettings;
        });

        ide.addEventListener("savesettings", function(e){
            var xmlSettings = apf.createNodeFromXpath(e.model.data, "auto/zen/text()");
            xmlSettings.nodeValue = _self.initialWidth;
            return true;
        });

        ide.addEventListener("minimap.visibility", function(e) {
            if (e.visibility === "shown")
                _self.offsetWidth = _self.defaultOffset + e.width;
            else
                _self.offsetWidth = _self.defaultOffset;

            _self.updateButtonPosition();
        });
    },

    init : function(amlNode){
        // Create all the elements used here
        this.animateZen = document.createElement("div");
        this.animateZen.setAttribute("id", "animateZen");
        this.animateZen.setAttribute("style", "display: none");
        document.body.appendChild(this.animateZen);

        this.animateZenPosition = document.createElement("div");
        this.animateZenPosition.setAttribute("id", "animateZenPosition");
        this.animateZenPosition.setAttribute("style", "display: none");
        document.body.appendChild(this.animateZenPosition);

        this.zenHandleLeft = document.createElement("div");
        this.zenHandleLeft.setAttribute("id", "zenHandleLeft");
        this.zenHandleLeft.setAttribute("style", "opacity: 0.0");
        document.body.appendChild(this.zenHandleLeft);

        this.zenHandleRight = document.createElement("div");
        this.zenHandleRight.setAttribute("id", "zenHandleRight");
        this.zenHandleRight.setAttribute("style", "opacity: 0.0");
        document.body.appendChild(this.zenHandleRight);

        this.setupHandleListeners();

        var editor = editors.currentEditor;
        if (editor && editor.ceEditor)
            editor.ceEditor.parentNode.appendChild(btnZenFullscreen);

        vbMain.parentNode.appendChild(new apf.vbox({
            anchors: "0 0 0 0",
            id: "vbZen",
            "class": "vbZen",
            visible: false
        }));

        setTimeout(function() {
            _self.updateButtonPosition();
        });

        this.animateZen = document.getElementById("animateZen");
        this.animateZenPosition = document.getElementById("animateZenPosition");

        var _self = this;
        vbZen.addEventListener("resize", function(e) {
            if (_self.isFocused) {
                _self.calculatePositions();
            }
        });
    },

    updateButtonPosition : function() {
        if (!window["btnZenFullscreen"])
            return;

        // Extra safe default width
        var sbWidth = 20;
        if (ceEditor && ceEditor.$editor)
            sbWidth = ceEditor.$editor.renderer.scrollBar.width;

        btnZenFullscreen.setAttribute("right", sbWidth + this.offsetWidth);
    },

    calculatePositions : function() {
        // Calculate the position
        var _self = this;
        var height = (window.innerHeight-32) + "px";
        tabEditors.parentNode.$ext.style.height = height;
        _self.animateZen.style.height = window.innerHeight + "px";
        var width = window.innerWidth * _self.initialWidth;
        var widthDiff = (window.innerWidth - width) / 2;
        tabEditors.parentNode.$ext.style.width = _self.animateZen.style.width = width + "px";
        _self.animateZen.style.left = widthDiff + "px";

        // Set the resize handle positions
        _self.zenHandleLeft.style.height = window.innerHeight + "px";
        _self.zenHandleLeft.style.left = (widthDiff+0) + "px";
        _self.zenHandleRight.style.height = window.innerHeight + "px";
        _self.zenHandleRight.style.left = ((widthDiff + width) - 5) + "px";
    },

    // @TODO implement removeListeners
    setupHandleListeners : function() {
        var _self = this;

        apf.addListener(this.zenHandleLeft, "mousedown", function(e) {
            _self.browserWidth = window.innerWidth;
            _self.handleLeftMove = true;
        });

        apf.addListener(this.zenHandleRight, "mousedown", function(e) {
            _self.browserWidth = window.innerWidth;
            _self.handleRightMove = true;
        });

        apf.addListener(document, "mousemove", function(e) {
            if (_self.isFocused) {
                // Now resize those love handles!
                function afterCalculation() {
                    if (_self.initialWidth < 0.4)
                        _self.initialWidth = 0.4;
                    else if (_self.initialWidth > 0.95)
                        _self.initialWidth = 1.0;
                    _self.calculatePositions();
                    apf.layout.forceResize(tabEditors.parentNode.$ext);
                }
                if (_self.handleLeftMove) {
                    _self.initialWidth = 1.0 - ((e.clientX * 2)/_self.browserWidth);
                    afterCalculation();
                }
                else if (_self.handleRightMove) {
                    var fakeLeftCalc = _self.browserWidth - e.clientX;
                    _self.initialWidth = 1.0 - ((fakeLeftCalc * 2)/_self.browserWidth);
                    afterCalculation();
                }
            }
        });

        apf.addListener(document, "mouseup", function() {
            if (!_self.isFocused)
                return;

            if (_self.handleLeftMove || _self.handleRightMove)
                settings.save();
            _self.handleLeftMove = false;
            _self.handleRightMove = false;
            apf.layout.forceResize();
        });
    },

    /**
     * Method attached to key combination (Cmd/Ctrl + E)
     */
    zen : function() {
        this.toggleFullscreenZen();
    },

    /**
     * Method attached to key combo for slow mode (Shift)
     */
    zenslow : function() {
        this.toggleFullscreenZen({ htmlEvent : { shiftKey : true }});
    },

    /**
     * Method invoked to do the actual toggling of zen mode
     * Detects if zened or not
     *
     * @param {amlEvent} e Event from click
     */
    toggleFullscreenZen : function(e) {
        var shiftKey = false;
        if (e)
            shiftKey = e.htmlEvent.shiftKey;

        if (this.isFocused)
            this.escapeFromZenMode(shiftKey);
        else
            this.enterIntoZenMode(shiftKey);
    },

    /**
     * Checks if the current browser supports fancy shmancy animations
     *
     * @return {boolean} true if supported, false otherwise
     */
    checkBrowserCssTransforms : function() {
        var isWebkitCapable = apf.isWebkit && (apf.versionSafari >= 3.1 || apf.versionChrome >= 11);
        var isGeckoCapable = apf.isGecko && apf.versionGecko >= 4;
        var isOperaCapable = apf.isOpera && apf.versionOpera >= 10;
        return isWebkitCapable || isGeckoCapable || isOperaCapable;
    },

    /**
     * Enters the editor into fullscreen/zen mode
     *
     * @param {boolean} slow Whether to slow down the animation
     */
    enterIntoZenMode : function(slow) {
        var _self = this;

        this.saveTabEditorsParentStyles();
        if (self.btnZenFullscreen)
            btnZenFullscreen.setAttribute("class", "full");

        // Calculates the destination position and dimensions of
        // the animated container
        var browserWidth = window.innerWidth;
        var afWidth = browserWidth * this.initialWidth;
        var leftOffset = (browserWidth-afWidth)/2 + "px";
        var afHeight = window.innerHeight + "px";

        // Do fancy animation
        if (this.checkBrowserCssTransforms()) {
            this.matchAnimationWindowPosition();
            this.setAceThemeBackground();

            editors.disableTabResizeEvent();
            this.placeTabIntoAnimationWindow();

            Firmin.animate(this.animateZen, {
                height: afHeight,
                left: leftOffset,
                top: "0",
                width: afWidth + "px",
                timingFunction: "ease-in-out"
            }, slow ? 3.7 : 0.7, function() {

                _self.isFocused = true;

                // Frustratingly, Firmin does not remove the csstransform attributes
                // after the animation is complete, so we must do it ourselves
                var astyles = "display:block;top:0;height:" + afHeight + ";left:" + leftOffset + ";width:" + afWidth + "px";
                _self.animateZen.setAttribute("style", astyles);

                apf.layout.forceResize();

                Firmin.animate(_self.zenHandleLeft, {
                    opacity : 1.0,
                    timingFunction: "ease-in-out"
                }, 0.7).animate({
                    opacity : 0.0
                }, 0.5);

                Firmin.animate(_self.zenHandleRight, {
                    opacity : 1.0,
                    timingFunction: "ease-in-out"
                }, 0.7).animate({
                    opacity : 0.0
                }, 0.5);

                setTimeout(function() {
                    if (self.ceEditor)
                        ceEditor.focus();
                    apf.layout.forceResize(tabEditors.parentNode.$ext);
                }, 100);
            });

            vbZen.show();
            Firmin.animate(vbZen.$ext, {
                opacity: "1"
            }, slow ? 3.5 : 0.5);
        }

        else {
            this.isFocused = true;
            vbZen.show();
            vbZen.$ext.style.opacity = "1";

            editors.disableTabResizeEvent();
            this.placeTabIntoAnimationWindow();
            this.animateZen.style.display = "block";

            var astyles = "display:block;top:0;height:" + afHeight + ";left:" + leftOffset + ";width:" + afWidth + "px";
            this.animateZen.setAttribute("style", astyles);

            _self.zenHandleLeft.style.opacity = "1.0";
            _self.zenHandleRight.style.opacity = "1.0";

            setTimeout(function() {
                apf.tween.single(_self.zenHandleLeft, {
                    type     : "opacity",
                    anim     : apf.tween.easeInOutCubic,
                    from     : 1.0,
                    to       : 0.0,
                    steps    : 8,
                    interval : 20,
                    control  : (this.control = {}),
                    onfinish : function(){
                    }
                });
                apf.tween.single(_self.zenHandleRight, {
                    type     : "opacity",
                    anim     : apf.tween.easeInOutCubic,
                    from     : 1.0,
                    to       : 0.0,
                    steps    : 8,
                    interval : 20,
                    control  : (this.control = {}),
                    onfinish : function(){
                    }
                });
            }, 700);
            apf.layout.forceResize();

            setTimeout(function() {
                ceEditor.focus();
            }, 100);
        }
    },

    /**
     * Returns the editor to its original, non-zen,
     * non-fullscreen state
     *
     * @param {boolean} slow Whether to slow down the animation
     */
    escapeFromZenMode : function(slow) {
        var _self = this;

        btnZenFullscreen.setAttribute("class", "notfull");
        this.isFocused = false;

        this.zenHandleLeft.style.opacity = "0.0";
        this.zenHandleRight.style.opacity = "0.0";

        tabEditors.parentNode.$ext.style.width = "100%";

        if (this.checkBrowserCssTransforms()) {
            // Get the destination values
            editors.setTabResizeValues(this.animateZenPosition);
            var left = this.animateZenPosition.style.left;
            var top = this.animateZenPosition.style.top;
            var width = this.animateZenPosition.style.width;
            var height = this.animateZenPosition.style.height;

            // Set the width to its actual width instead of "85%"
            var afWidth = apf.getHtmlInnerWidth(this.animateZen);
            this.animateZen.style.width = afWidth + "px";
            var afHeight = apf.getHtmlInnerHeight(this.animateZen);
            this.animateZen.style.height = afHeight + "px";

            Firmin.animate(this.animateZen, {
                height: height,
                width: width,
                left: left,
                top: top,
                timingFunction: "ease-in-out"
            }, slow ? 3.7 : 0.7, function() {
                _self.animateZen.style.display = "none";
                // Reset values
                _self.resetTabEditorsParentStyles();

                apf.document.body.appendChild(tabEditors.parentNode);

                editors.enableTabResizeEvent();
                apf.layout.forceResize(tabEditors.parentNode.$ext);

                tabEditors.parentNode.$ext.style.position = "absolute";

                setTimeout(function() {
                    if (self.ceEditor)
                        ceEditor.focus();
                    apf.layout.forceResize(tabEditors.parentNode.$ext);
                }, 100);
            });

            Firmin.animate(vbZen.$ext, {
                opacity: "0"
            }, slow ? 3.5 : 0.5, function() {
                vbZen.hide();
            });
        }
        else {
            this.resetTabEditorsParentStyles();

            apf.document.body.appendChild(tabEditors.parentNode);

            editors.enableTabResizeEvent();
            this.animateZen.style.display = "none";
            vbZen.$ext.style.opacity = "0";
            vbZen.hide();

            tabEditors.parentNode.$ext.style.position = "absolute";

            apf.layout.forceResize();
            setTimeout(function() {
                ceEditor.focus();
            }, 100);
        }

    },

    /**
     * Retrieves and saves the styles of tabEditors.parentNode
     * so that when we reset the position of it back to unzen mode,
     * all those position details remain intact
     */
    saveTabEditorsParentStyles : function() {
        this.teMarginLeft = tabEditors.parentNode.$ext.style.marginLeft;
        this.teMarginRight = tabEditors.parentNode.$ext.style.marginRight;
        this.teLeft = tabEditors.parentNode.$ext.style.left;
        this.teTop = tabEditors.parentNode.$ext.style.top;
    },

    /**
     * Resets the position and style properties of tabEditors.parent
     * to what they were when we saved them in #this.saveTabEditorsParentStyles
     */
    resetTabEditorsParentStyles : function() {
        tabEditors.parentNode.$ext.style.marginLeft = this.teMarginLeft;
        tabEditors.parentNode.$ext.style.marginRight = this.teMarginRight;
        tabEditors.parentNode.$ext.style.left = this.teLeft;
        tabEditors.parentNode.$ext.style.top = this.teTop;
    },

    /**
     * Gets the position and dimensions of tabEditors.parentNode
     * and applies those values to the window that temporarily
     * holds tabEditors.parentNode during the animation
     */
    matchAnimationWindowPosition : function() {
        var tePos = apf.getAbsolutePosition(tabEditors.parentNode.$ext);
        var teWidth = tabEditors.parentNode.getWidth();
        var teHeight = tabEditors.parentNode.getHeight();

        this.animateZen.style.left = tePos[0] + "px";
        this.animateZen.style.top = tePos[1] + "px";
        this.animateZen.style.width = teWidth + "px";
        this.animateZen.style.height = teHeight + "px";
        this.animateZen.style.display = "block";
    },

    /**
     * Gets the class selectors from the ace_editor element and
     * gets the corresponding bg color for the theme. Then it
     * applies that bg color to the scroller element
     *
     * Otherwise the default background color is grayish and the
     * animation exposes that bg color - making it look bad
     *
     * This is hacked and should probably be in Ace already
     */
    setAceThemeBackground : function() {
        // Set the background color so animating doesn't show a dumb gray background
        var ace_editor = document.getElementsByClassName("ace_editor")[0];
        if (!ace_editor)
            return;

        var classNames = ace_editor.getAttribute("class").split(" ");
        for (var cn = 0; cn < classNames.length; cn++) {
            if (classNames[cn].indexOf("ace-") === 0) {
                var selectorString = "." + classNames[cn] + " .ace_scroller";
                var bgColor = apf.getStyleRule(selectorString, "background-color");
                if (!bgColor)
                    bgColor = apf.getStyleRule(".ace_scroller", "background-color");
                ace_editor.style.backgroundColor = bgColor;
                break;
            }
        }
    },

    /**
     * Calls appendChild on the animation window to receive
     * tabEditors.parentNode - then sets the styles of
     * tabEditors.parentNode so it fits properly into the
     * animation window
     */
    placeTabIntoAnimationWindow : function() {
        var reappendlist = [];
        var iframelist   = apf.getArrayFromNodelist(
            tabEditors.parentNode.$ext.getElementsByTagName("iframe"));

        for (var i = 0; i < iframelist.length; i++) {
            reappendlist[i] = [
                iframelist[i].parentNode,
                iframelist[i].nextSibling,
                document.adoptNode(iframelist[i]),
            ]
        }

        this.animateZen.appendChild(tabEditors.parentNode.$ext);

        for (var i = reappendlist.length - 1; i >= 0; i--) {
            reappendlist[i][0].insertBefore(
                reappendlist[i][2],
                reappendlist[i][1]);
        }

        //this.animateZen.appendChild(tabEditors.parentNode.$ext);
        tabEditors.parentNode.$ext.style.width = "100%";
        tabEditors.parentNode.$ext.style.height = "100%";
        tabEditors.parentNode.$ext.style.position = "relative";
        tabEditors.parentNode.$ext.style.left = "0px";
        tabEditors.parentNode.$ext.style.top = "0px";
    },

    /**
     * Called during the onmouseover event from the zen button
     */
    fadeZenButtonIn : function() {
        apf.tween.single(btnZenFullscreen, {
            type     : "opacity",
            anim     : apf.tween.easeInOutCubic,
            from     : 0.01,
            to       : 1,
            steps    : 8,
            interval : 20,
            control  : (this.control = {}),
            onfinish : function(){
            }
        });
    },

    /**
     * Called during the onmouseout event from the zen button
     */
    fadeZenButtonOut : function() {
        if (self["btnZenFullscreen"]) {// for the guided tour
            apf.tween.single(btnZenFullscreen, {
                type     : "opacity",
                anim     : apf.tween.easeInOutCubic,
                from     : 1,
                to       : 0.01,
                steps    : 8,
                interval : 20,
                control  : (this.control = {}),
                onfinish : function(){
                }
            });
        } 
    },

    enable : function(){
        btnZenFullscreen.show();
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        if (this.isFocused)
            this.escapeFromZenMode();
        btnZenFullscreen.hide();
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});

/**
 * Cloud9 Language Foundation
 *
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
define('ext/language/complete',['require','exports','module','ext/editors/editors','ace/lib/dom'],function(require, exports, module) {

var editors = require("ext/editors/editors");
var dom = require("ace/lib/dom");

var oldCommandKey;
var ID_REGEX = /[a-zA-Z_0-9\$]/;

function retrievePreceedingIdentifier(text, pos) {
    var buf = [];
    for(var i = pos-1; i >= 0; i--) {
        if(ID_REGEX.test(text[i]))
            buf.push(text[i]);
        else
            break;
    }
    return buf.reverse().join("");
}

/**
 * Replaces the preceeding identifier (`prefix`) with `newText`, where ^^
 * indicates the cursor position after the replacement
 */
function replaceText(editor, prefix, newText) {
    var pos = editor.getCursorPosition();
    var line = editor.getSession().getLine(pos.row);
    var doc = editor.getSession().getDocument();
    
    if (newText.indexOf("^^") === -1)
        newText += "^^";

    // Find prefix whitespace of current line
    for (var i = 0; i < line.length && (line[i] === ' ' || line[i] === "\t");)
        i++;
    
    var prefixWhitespace = line.substring(0, i);
    
    // Pad the text to be inserted
    var paddedLines = newText.split("\n").join("\n" + prefixWhitespace);
    var splitPaddedLines = paddedLines.split("\n");
    var colOffset;
    for (var rowOffset = 0; rowOffset < splitPaddedLines.length; rowOffset++) {
        colOffset = splitPaddedLines[rowOffset].indexOf("^^");
        if (colOffset !== -1)
            break;
    }
    // Remove cursor marker
    paddedLines = paddedLines.replace("^^", "");
    
    doc.removeInLine(pos.row, pos.column - prefix.length, pos.column);
    doc.insert({row: pos.row, column: pos.column - prefix.length}, paddedLines);
    editor.moveCursorTo(pos.row + rowOffset, pos.column + colOffset - prefix.length);
}

module.exports = {
    hook: function(language, worker) {
        var _self = this;
        worker.on("complete", function(event) {
            _self.onComplete(event);
        });
    },
    
    showCompletionBox: function(matches, prefix) {
        var _self = this;
        this.editor = editors.currentEditor;
        var ace = this.editor.ceEditor.$editor;
        this.selectedIdx = 0;
        this.scrollIdx = 0;
        this.matchEls = [];
        this.prefix = prefix;
        this.matches = matches;
        this.completionElement = txtCompleter.$ext;
        this.cursorConfig = ace.renderer.$cursorLayer.config;
        var style = dom.computedStyle(this.editor.ceEditor.$ext);
        this.completionElement.style.fontSize = style.fontSize;
        //this.completionElement.style.maxHeight = 10 * this.cursorConfig.lineHeight;
        
        barCompleterCont.setAttribute('visible', true);

        // Monkey patch
        oldCommandKey = ace.keyBinding.onCommandKey;
        ace.keyBinding.onCommandKey = this.onKeyPress.bind(this);
        
        this.populateCompletionBox(matches);
        document.addEventListener("click", this.closeCompletionBox);
        ace.container.addEventListener("DOMMouseScroll", this.closeCompletionBox);
        ace.container.addEventListener("mousewheel", this.closeCompletionBox);
        
        apf.popup.setContent("completionBox", barCompleterCont.$ext);
        var completionBoxHeight = 5 + Math.min(10 * this.cursorConfig.lineHeight, this.matches.length * (this.cursorConfig.lineHeight+1));
        var cursorLayer = ace.renderer.$cursorLayer;
        var cursorLocation = cursorLayer.getPixelPosition(true);
        var distanceFromBottom = ace.container.offsetHeight - cursorLocation.top;
        if (distanceFromBottom < completionBoxHeight) {
            ace.centerSelection();
        }
        setTimeout(function() {
            apf.popup.show("completionBox", {
                x        : (prefix.length * -_self.cursorConfig.characterWidth) - 11,
                y        : _self.cursorConfig.lineHeight,
                animate  : false,
                ref      : cursorLayer.cursor,
                callback : function() {
                    barCompleterCont.setHeight(completionBoxHeight);
                    sbCompleter.$resize();
                    _self.completionElement.scrollTop = 0;
                }
            });
        }, 0);
    },

    closeCompletionBox : function(event, doNotHide) {
        var ace = editors.currentEditor.ceEditor.$editor;
        if (!doNotHide)
            barCompleterCont.$ext.style.display = "none";
        document.removeEventListener("click", this.closeCompletionBox);
        ace.container.removeEventListener("DOMMouseScroll", this.closeCompletionBox);
        ace.container.removeEventListener("mousewheel", this.closeCompletionBox);
        ace.keyBinding.onCommandKey = oldCommandKey;
    },
        

    populateCompletionBox: function (matches) {
        var _self = this;
        _self.completionElement.innerHTML = "";
        matches.forEach(function(match, idx) {
            var matchEl = dom.createElement("div");
            matchEl.className = idx === _self.selectedIdx ? "cc_complete_option_selected" : "cc_complete_option";
            matchEl.innerHTML = "<u>" + _self.prefix + "</u>" + match.name.substring(_self.prefix.length);
            if(match.meta) {
                matchEl.innerHTML += '<span class="meta">' + match.meta + '</score>';
            }
            matchEl.addEventListener("click", function() {
                var editor = editors.currentEditor.ceEditor.$editor;
                replaceText(editor, _self.prefix, match.replaceText);
                editor.focus();
            });
            _self.completionElement.appendChild(matchEl);
            _self.matchEls.push(matchEl);
        });
    },

    onKeyPress : function(e, hashKey, keyCode) {
        var _self = this;
        
        if(keyCode === 9 && !e.shiftKey) // Tab
            keyCode = 40; // Up
        else if(keyCode === 9 && e.shiftKey) // Shift-Tab
            keyCode = 38; // Down
        
        var keyBinding = editors.currentEditor.ceEditor.$editor.keyBinding;

        switch(keyCode) {
            case 0: break;
            case 32: // Space
                this.closeCompletionBox();
                break;
            case 27: // Esc
                this.closeCompletionBox();
                e.preventDefault();
                break;
            case 8: // Backspace
                oldCommandKey.apply(keyBinding, arguments);
                setTimeout(function() {
                    _self.closeCompletionBox(null, true);
                    _self.invoke(true);
                }, 100);
                e.preventDefault();
                break;
            case 37:
            case 39:
                oldCommandKey.apply(keyBinding, arguments);
                this.closeCompletionBox();
                e.preventDefault();
                break;
            case 13: // Enter
                var editor = editors.currentEditor.ceEditor.$editor;
                replaceText(editor, this.prefix, this.matches[this.selectedIdx].replaceText);
                this.closeCompletionBox();
                e.preventDefault();
                break;
            case 40: // Down
                this.matchEls[this.selectedIdx].className = "cc_complete_option";
                if(this.selectedIdx < this.matches.length-1) {
                    this.selectedIdx++;
                }
                this.matchEls[this.selectedIdx].className = "cc_complete_option_selected";
                if(this.selectedIdx - this.scrollIdx > 4) {
                    this.scrollIdx++;
                    this.matchEls[this.scrollIdx].scrollIntoView(true);
                }
                e.stopPropagation();
                e.preventDefault();
                break;
            case 38: // Up
                this.matchEls[this.selectedIdx].className = "cc_complete_option";
                if(this.selectedIdx > 0) {
                    this.selectedIdx--;
                }
                this.matchEls[this.selectedIdx].className = "cc_complete_option_selected";
                if(this.selectedIdx < this.matches.length - 4 && this.scrollIdx > 0) {
                    this.scrollIdx = this.selectedIdx - 4;
                    this.matchEls[this.scrollIdx].scrollIntoView(true);
                }
                e.stopPropagation();
                e.preventDefault();
                break;
            default:
                setTimeout(function() {
                    _self.closeCompletionBox(null, true);
                    _self.invoke(true);
                });
        }
    },
    
    setWorker: function(worker) {
        this.worker = worker;
    },

    invoke: function(forceBox) {
        var editor = editors.currentEditor.ceEditor.$editor;
        this.forceBox = forceBox;
        // This is required to ensure the updated document text has been sent to the worker before the 'complete' message
        var worker = this.worker;
        setTimeout(function() {
            worker.emit("complete", {data: editor.getCursorPosition()});
        });
    },
    
    onComplete: function(event) {
        var editor = editors.currentEditor.ceEditor.$editor;
        var pos = editor.getCursorPosition();
        var line = editor.getSession().getLine(pos.row);
        var identifier = retrievePreceedingIdentifier(line, pos.column);
    
        var matches = event.data;
        
        if (matches.length === 1 && !this.forceBox) {
            replaceText(editor, identifier, matches[0].replaceText);
        }
        else if (matches.length > 0) {
            this.showCompletionBox(matches, identifier);
        }
        else {
            if(typeof barCompleterCont !== 'undefined')
                barCompleterCont.$ext.style.display = "none";
        }
    }
};

});


define('ext/vim/keyboard',['require','exports','module','ace/keyboard/state_handler','ext/vim/commands','ext/editors/editors'],function(require, exports, module) {

"use strict";

var StateHandler = require("ace/keyboard/state_handler").StateHandler;
var cmds = require("ext/vim/commands");
var editors = require("ext/editors/editors");

var matchChar = function(buffer, hashId, key, symbolicName, keyId) {
    // If no command keys are pressed, then catch the input.
    // If only the shift key is pressed and a character key, then
    // catch that input as well.
    // Otherwise, we let the input got through.
    var matched = ((hashId === 0) || (((hashId === 1) || (hashId === 4)) && key.length === 1));
    //console.log("INFO", arguments)

    if (matched) {
        if (keyId) {
            keyId = String.fromCharCode(parseInt(keyId.replace("U+", "0x")));
        }

        var editor = editors.currentEditor.ceEditor.$editor;
        editor.commands.addCommand({
            name: "builder",
            exec: function(editor) {
                cmds.inputBuffer.push.call(cmds.inputBuffer, editor, symbolicName, keyId);
            }
        });
    }
    return matched;
};

var inIdleState = function() {
    if (cmds.inputBuffer.idle) {
        return true;
    }
    return false;
};

var states = exports.states = {
    start: [ // normal mode
        {
            key: "esc",
            exec: "stop",
            then: "start"
        },
        {
            regex: "^i$",
            match: inIdleState,
            exec: "start",
            then: "insertMode"
        },
        {
            regex: "^shift-i$",
            match: inIdleState,
            exec: "startBeginning",
            then: "insertMode"
        },
        {
            regex: "^a$",
            match: inIdleState,
            exec: "append",
            then: "insertMode"
        },
        {
            regex: "^shift-a$",
            match: inIdleState,
            exec: "appendEnd",
            then: "insertMode"
        },
        {
            // The rest of input will be processed here
            match: matchChar,
            exec: "builder"
        }
    ],
    insertMode: [
        {
            key: "esc",
            exec: "stop",
            then: "start"
        },
        {
            key: "backspace",
            exec: "backspace"
        }
    ]
};

exports.handler = new StateHandler(states);
});

/**
 * Vim mode for the Cloud9 IDE
 *
 * @author Sergi Mansilla <sergi@c9.io>
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/vim/vim',['require','exports','module','core/ide','core/ext','ext/editors/editors','ext/code/code','ext/vim/keyboard','ext/vim/commands','ext/vim/cli','ext/settings/settings','ext/vim/maps/util'],function(require, exports, module) {
"use strict";

var ide = require("core/ide");
var ext = require("core/ext");
var editors = require("ext/editors/editors");
var code = require("ext/code/code");
var handler = require("ext/vim/keyboard").handler;
var cmdModule = require("ext/vim/commands");
var commands = cmdModule.commands;
var cliCmds = require("ext/vim/cli");
var settings = require("ext/settings/settings");
var util = require("ext/vim/maps/util");

var VIM_ENABLED = false;
var OLD_HANDLER;

var onConsoleCommand = function onConsoleCommand(e) {
    var cmd = e.data.command;
    if (cmd && typeof cmd === "string") {
        
        if (cmd[0] === ":") {
            cmd = cmd.substr(1);

            if (cliCmds[cmd]) {
                cliCmds[cmd](ceEditor.$editor, e.data);
            }
            else if (cmd.match(/^\d+$/)) {
                ceEditor.$editor.gotoLine(parseInt(cmd, 10), 0);
                ceEditor.$editor.navigateLineStart();
            }
            else {
                console.log("Vim command '" + cmd + "' not implemented.");
            }

            ceEditor.focus();
            e.returnValue = false;
        }
        else if (cmd[0] === "/") {
            cmd = cmd.substr(1);
            cmdModule.searchStore.current = cmd;
            ceEditor.$editor.find(cmd, cmdModule.searchStore.options);
            ceEditor.focus();
            e.returnValue = false;
        }
    }
};

var addCommands = function addCommands(editor, commands) {
    Object.keys(commands).forEach(function(name) {
        var command = commands[name];
        if ("function" === typeof command)
            command = { exec: command };

        if (!command.name)
            command.name = name;

        editor.commands.addCommand(command);
    });
};

var removeCommands = function removeCommands(editor, commands) {
    Object.keys(commands).forEach(function(name) {
        editor.commands.removeCommand(commands[name]);
    });
};

var onCursorMove = function() {
    cmdModule.onCursorMove();
    onCursorMove.scheduled = false;
};

var enableVim = function enableVim() {
    ext.initExtension(this);

    var editor = ceEditor.$editor;
    addCommands(editor, commands);
    editor.renderer.container.addEventListener("click", onCursorMove, false);

    // Set Vim's own keyboard handle and store the old one.
    OLD_HANDLER = OLD_HANDLER || editor.getKeyboardHandler();
    editor.setKeyboardHandler(handler);

    // Set Vim in command (normal) mode
    commands.stop.exec(editor);
    VIM_ENABLED = true;
        
    ide.dispatchEvent("track_action", {type: "vim", action: "enable", mode: util.currentMode});
};

var disableVim = function() {
    var editor = ceEditor.$editor;
    removeCommands(editor, commands);
    editor.setKeyboardHandler(OLD_HANDLER);
    commands.start.exec(editor);
    editor.renderer.container.removeEventListener("click", onCursorMove, false);
    VIM_ENABLED = false;

    ide.dispatchEvent("track_action", { type: "vim", action: "disable" });
};

module.exports = ext.register("ext/vim/vim", {
    name  : "Vim mode",
    dev   : "Ajax.org",
    type  : ext.GENERAL,
    deps  : [editors, code, settings],
    nodes : [],
    alone : true,

    hook : function() {
        var self = this;
        var menuItem = new apf.item({
            caption: "Vim mode",
            type: "check",
            checked: "[{require('ext/settings/settings').model}::editors/code/@vimmode]",
            onclick: function() { self.toggle(); }
        });

        ide.addEventListener("init.ext/statusbar/statusbar", function (e) {
            e.ext.addToolsItem(menuItem.cloneNode(true), 0);
        });

        ide.addEventListener("init.ext/settings/settings", function (e) {
            e.ext.getHeading("Code Editor").appendChild(new apf.checkbox({
                "class" : "underlined",
                skin  : "checkbox_grey",
                value : "[editors/code/@vimmode]",
                label : "Vim mode",
                onclick: function() { self.toggle(); }
            }));
        });

        var tryEnabling = function () {
            if (settings.model) {
                VIM_ENABLED = apf.isTrue(settings.model.queryNode("editors/code").getAttribute("vimmode"));
            }
            self.enable(VIM_ENABLED === true);
        };
        ide.addEventListener("init.ext/code/code", tryEnabling);
        ide.addEventListener("code.ext:defaultbindingsrestored", tryEnabling);
    },

    toggle: function(show) {
        this.enable(VIM_ENABLED === false);
        if (typeof ceEditor !== "undefined") {
            ceEditor.focus();
        }
    },

    init: function() {
        txtConsoleInput.addEventListener("keydown", function(e) {
            if (e.keyCode === 27 && typeof ceEditor !== "undefined") { // ESC is pressed in the CLI
                ceEditor.focus();
            }
        });
    },

    // Enable accepts a `doEnable` argument which executes `disable` if false.
    enable: function(doEnable) {
        if (doEnable !== false) {
            ide.removeEventListener("consolecommand", onConsoleCommand);
            ide.addEventListener("consolecommand", onConsoleCommand);
            enableVim.call(this);
        }
        else {
            this.disable();
        }
    },

    disable: function() {
        ide.removeEventListener("consolecommand", onConsoleCommand);
        disableVim();
    },

    destroy: function() {
        this.nodes.forEach(function(item) { item.destroy(); });
        this.nodes = [];
    }
});
});

/**
 * Code Tools Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
 
define('ext/colorpicker/colorpicker',['require','exports','module','core/ide','core/ext','ext/editors/editors','ace/range','ext/colorpicker/colorpicker_regex','text!ext/colorpicker/colorpicker.css','text!ext/colorpicker/colorpicker.xml','text!ext/colorpicker/skin.xml'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var Editors = require("ext/editors/editors");

var Range = require("ace/range").Range;

var origArrowTop;
var Colors = {};

var Regexes = require("ext/colorpicker/colorpicker_regex");

var namedColors = apf.color.colorshex;

var css = require("text!ext/colorpicker/colorpicker.css");
var markup = require("text!ext/colorpicker/colorpicker.xml");
var skin = require("text!ext/colorpicker/skin.xml");

/**
 * Creates an ACE range object that points to the start of the color (row, column)
 * and the end of the color (row, column) inside the document.
 * 
 * @param {Number} row
 * @param {Number} col
 * @param {String} line
 * @param {String} color
 * @type {Range}
 */
function createColorRange(row, col, line, color) {
    if (col) {
        var str = line;
        var colorLen = color.length;
        var lastIdx;
        var atPos = false;
        while ((lastIdx = str.indexOf(color)) != -1) {
            str = str.substr(lastIdx + colorLen);
            if (lastIdx <= col && lastIdx + colorLen >= col) {
                atPos = true;
                col = lastIdx;
            }
        }
        if (!atPos)
            return null;
    }
    col = line.indexOf(color);
    return Range.fromPoints({
        row: row,
        column: col
    }, {
        row: row,
        column: col + color.length
    });
}

module.exports = ext.register("ext/colorpicker/colorpicker", {
    dev    : "Ajax.org",
    name   : "Colorpicker Code Tool",
    alone  : true,
    type   : ext.GENERAL,
    skin   : skin,

    nodes : [],

    /**
     * Initializes the plugin; inserts markup and adds event listeners to different
     * areas of the UI.
     * 
     * @type {void}
     */
    init: function() {
        apf.document.body.insertMarkup(markup);
        this.menu = mnuColorPicker;
        this.colorpicker = clrCodeTools;
        var divs = this.menu.$ext.getElementsByTagName("div");
        var _self = this;

        // fetch the colortool DOM node and that of the arrow of the menu.
        for (var i = 0, l = divs.length; i < l; ++i) {
            if (divs[i].className.indexOf("arrow") > -1)
                this.arrow = divs[i];
            else if (divs[i].className.indexOf("codetools_colorpicker_tools") > -1)
                this.colortools = divs[i];
        }

        // add listeners for interaction with the colortools element. This element
        // is propagated with colors used inside a document, which can be selected.
        apf.addListener(this.colortools, "mousemove", function(e) {
            var el = e.srcElement || e.target || e.element;
            if (!el || el.nodeType != 1 || el.className.indexOf("color") == -1)
                return;
            var cls;
            var spans = _self.colortools.getElementsByTagName("span");
            for (var i = 0, l = spans.length; i < l; ++i) {
                cls = spans[i].className;
                if (spans[i] !== el)
                    apf.setStyleClass(spans[i], null, ["color_hover"]);
                else if (cls.indexOf("color_hover") === -1 && spans[i] === el)
                    apf.setStyleClass(spans[i], "color_hover", []);
            }
        });

        apf.addListener(this.colortools, "mousedown", function(e) {
            var el = e.srcElement || e.target || e.element;
            if (el.nodeType != 1 || el.className.indexOf("color") == -1)
                return;

            var c = apf.color;
            var cp = _self.colorpicker;
            var hsb = c.hexToHSB(c.fixHex(el.getAttribute("data-color"), true));
            cp.setAttribute("hue", hsb.h);
            cp.setAttribute("saturation", hsb.s);
            cp.setAttribute("brightness", hsb.b);
        });

        // when a color was picked in the colorpicker, the 'hex' property changes.
        // we listen to 'hex', because we use this as the base format to convert
        // from and to.
        this.colorpicker.addEventListener("prop.hex", function(e) {
            _self.onColorPicked(e.oldvalue, e.value);
        });

        // when the menu (that contains the colorpicker) hides, do some housekeeping
        // like unregistering of event listeners.
        this.menu.addEventListener("prop.visible", function(e) {
            // when the the colorpicker hides, hide all tooltip markers
            if (!e.value) {
                var a = _self.$activeColor;
                if (a) {
                    apf.removeEventListener("keydown", a.listeners.onKeyDown);
                    a.editor.removeEventListener("mousewheel", a.listeners.onScroll);
                    ide.removeEventListener("codetools.cursorchange", a.listeners.onCursorChange);
                    ide.removeEventListener("codetools.selectionchange", a.listeners.onSelectionChange);
                    delete _self.$activeColor;
                    _self.hideColorTooltips(a.editor);
                    _self.colorpicker.$input.blur();
                    a.editor.focus();
                }
            }
        });
    },

    /**
     * In the hook function we load the CSS for the markers that appear on hover
     * and hook the event listeners of the codetools plugin.
     * The codetools plugin emits events when the user moves her mouse and we then
     * detect if the mouse pointer is hovering a color we recognize.
     * 
     * @type {void}
     */
    hook: function() {
        apf.importCssString(css || "");

        // detect and return a list of colors found on a line from an ACE document.
        function detectColors(pos, line) {
            var colors = line.match(Regexes.isColor);
            if (!colors || !colors.length)
                return [];
            var start, end;
            var col = pos.column;
            for (var i = 0, l = colors.length; i < l; ++i) {
                start = line.indexOf(colors[i]);
                end = start + colors[i].length;
                if (col >= start && col <= end)
                    return [colors, colors[i]];
            }
            return [colors];
        }

        var _self = this;
        var columnChangeTimer;

        ide.addEventListener("codetools.columnchange", function(e) {
            clearTimeout(columnChangeTimer);
            var doc = e.doc;
            var pos = e.pos;
            var editor = e.editor;

            var line = doc.getLine(1);
            if (!(e.amlEditor.syntax == "css" || e.amlEditor.syntax == "svg" 
              || e.amlEditor.syntax == "html" || (line && line.indexOf("<a:skin") > -1)))
                return;

            line = doc.getLine(pos.row);
            var colors = detectColors(pos, line);
            if (colors[0] && colors[0].length) {
                _self.showColorTooltip(pos, editor, line, colors[0]);
            }
            else {
                columnChangeTimer = setTimeout(function() {
                    _self.hideColorTooltips(editor);
                }, 100);
            }
        });

        ide.addEventListener("codetools.codeclick", function(e) {
            var doc = e.doc;
            var pos = e.pos;
            var editor = e.editor;

            var line = doc.getLine(1);
            if (!(e.amlEditor.syntax == "css" || e.amlEditor.syntax == "svg" 
              || e.amlEditor.syntax == "html" || (line && line.indexOf("<a:skin") > -1)))
                return;
            //do not show anything when a selection is made...
            var range = editor.selection.getRange();
            if (range.start.row !== range.end.row || range.start.column !== range.end.column)
                return;

            line = doc.getLine(pos.row);
            var colors = detectColors(pos, line);
            if (colors[1])
                _self.toggleColorPicker(pos, editor, line, colors[1]);
            else if (_self.menu && _self.menu.visible)
                _self.menu.hide();
        });

        ide.addEventListener("codetools.codedblclick", function(e) {
            _self.hideColorTooltips(e.editor);
        });

        function switchOrClose() {
            if (_self.menu && _self.menu.visible)
                _self.menu.hide();
            else
                _self.hideColorTooltips();
        }
        // hide all markers and the colorpicker upon tab-/ editorswitch
        ide.addEventListener("beforeeditorswitch", function() {
            switchOrClose();
        });

        ide.addEventListener("closefile", function(e) {
            var currentPage = tabEditors.getPage();
            if (currentPage) {
                if (e.page.name === currentPage.name)
                    switchOrClose();
            }
            else {
                switchOrClose();
            }
        });
    },

    /**
     * Show a marker/ tooltip on top of the code that is a color of the format
     * we recognize.
     * 
     * @param {Range} pos
     * @param {Editor} editor
     * @param {String} line
     * @param {Array} colors
     * @param {String} markerId
     * @type {void}
     */
    showColorTooltip: function(pos, editor, line, colors, markerId) {
        if (this.menu && this.menu.visible && !markerId)
            return;

        var markers = [];
        colors.forEach(function(color) {
            var id = markerId || color + (pos.row + "") + pos.column;
            var marker = Colors[id];
            // the tooltip DOM node is stored in the third element of the selection array
            if (!marker) {
                var range = createColorRange(pos.row, pos.column, line, color);
                if (!range)
                    return;
                marker = editor.session.addMarker(range, "codetools_colorpicker", function(stringBuilder, range, left, top, viewport) {
                    stringBuilder.push(
                        "<span class='codetools_colorpicker' style='",
                        "left:", left - 3, "px;",
                        "top:", top - 1, "px;",
                        "height:", viewport.lineHeight, "px;",
                        "' onclick='require(\'ext/codetools/codetools\').toggleColorPicker({row:",
                        pos.row, ",column:", pos.column, ",color:\'", color, "\'});'", (markerId ? " id='" + markerId + "'" : ""), ">", color, "</span>"
                    );
                }, true);
                Colors[id] = [range, marker, editor.session];
            }
            markers.push(marker);
        });

        this.hideColorTooltips(editor, markers);
    },

    /**
     * Hide all markers/ tooltips that are currently visible. Exceptions can be
     * provided via the [exceptions] argument.
     * 
     * @param {Editor} editor
     * @param {Array} exceptions
     * @type {void}
     */
    hideColorTooltips: function(editor, exceptions) {
        if (this.$activeColor)
            return;
        if (!exceptions && this.menu && this.menu.visible)
            this.menu.hide();
        if (exceptions && !apf.isArray(exceptions))
            exceptions = [exceptions];
        var marker, session;
        for (var mid in Colors) {
            marker = Colors[mid][1];
            session = editor ? editor.session : Colors[mid][2];
            if (exceptions && exceptions.indexOf(marker) > -1)
                continue;
            session.removeMarker(marker);
            delete Colors[mid];
        }
    },

    /**
     * Parses any color string and returns an object with the type of color (hex,
     * rgb or hsb), the color object or string (in the case of hex) and the hex
     * representation of that color.
     * 
     * @param {String} color
     * @type {Object}
     */
    parseColorString: function(color) {
        var ret = {
            orig: color
        };
        
        if (typeof namedColors[color] != "undefined")
            color = apf.color.fixHex(namedColors[color].toString(16));
        var rgb = color.match(Regexes.isRgb);
        var hsb = color.match(Regexes.isHsl);
        if (rgb && rgb.length >= 3) {
            ret.rgb = apf.color.fixRGB({
                r: rgb[1], 
                g: rgb[2], 
                b: rgb[3]
            });
            ret.hex = apf.color.RGBToHex(rgb);
            ret.type = "rgb";
        }
        else if (hsb && hsb.length >= 3) {
            ret.hsb = apf.color.fixHSB({
                h: hsb[1],
                s: hsb[2],
                b: hsb[3]
            });
            ret.hex = apf.color.HSBToHex(hsb);
            ret.type = "hsb";
        }
        else {
            ret.hex = apf.color.fixHex(color.replace("#", ""), true);
            ret.type = "hex";
        }

        return ret;
    },

    /**
     * Show or hide the colorpicker, depending on its current state (visible or not).
     * 
     * @param {Range} pos
     * @param {Editor} editor
     * @param {String} line
     * @param {String} color
     * @type {void}
     */
    toggleColorPicker: function(pos, editor, line, color) {
        ext.initExtension(this);
        var menu = this.menu;
        var cp = this.colorpicker;

        var parsed = this.parseColorString(color);

        if (menu.visible && parsed.hex == this.$activeColor.color.orig && pos.row == this.$activeColor.row)
            return menu.hide();

        // set appropriate event listeners, that will be removed when the colorpicker
        // hides.
        var onKeyDown, onScroll, onCursorChange, onSelectionChange;
        var _self = this;
        apf.addEventListener("keydown", onKeyDown = function(e) {
            var a = _self.$activeColor;

            if (!cp || !a || !cp.visible) 
                return;

            // when ESC is pressed, undo all changes made by the colorpicker
            if (e.keyCode === 27) {
                menu.hide();
                clearTimeout(_self.$colorPickTimer);
                var at = editor.session.$undoManager;
                if (at.undolength > a.start)
                    at.undo(at.undolength - a.start);
            }
        });

        ide.addEventListener("codetools.cursorchange", onCursorChange = function(e) {
            var a = _self.$activeColor;

            if (!cp || !a || !cp.visible) 
                return;

            var pos = e.pos;
            var range = a.marker[0];
            if (pos.row < range.start.row || pos.row > range.end.row 
              || pos.column < range.start.column || pos.column > range.end.column)
                menu.hide();
        });

        editor.addEventListener("mousewheel", onScroll = function(e) {
            var a = _self.$activeColor;

            if (!cp || !a || !cp.visible) 
                return;

            menu.hide();
        });

        var id = "colorpicker" + parsed.hex + pos.row;
        delete this.$activeColor;
        this.hideColorTooltips(editor);
        this.showColorTooltip(pos, editor, line, [parsed.orig], id);
        menu.show();
        cp.$input.focus();
        this.$activeColor = {
            color: parsed,
            hex: parsed.hex,
            markerNode: id,
            line: line,
            current: parsed.orig,
            pos: pos,
            marker: Colors[id],
            editor: editor,
            ignore: cp.value != color ? 2 : 1,
            start: editor.session.$undoManager.undolength,
            listeners: {
                onKeyDown: onKeyDown,
                onScroll: onScroll,
                onCursorChange: onCursorChange,
                onSelectionChange: onSelectionChange
            }
        };
        if (parsed.type == "rgb") {
            cp.setProperty("red", parsed.rgb.r);
            cp.setProperty("green", parsed.rgb.g);
            cp.setProperty("blue", parsed.rgb.b);
        }
        else if (parsed.type == "hsb") {
            cp.setProperty("hue", parsed.hsb.h);
            cp.setProperty("saturation", parsed.hsb.s);
            cp.setProperty("brightness", parsed.hsb.b);
        }
        else
            cp.setProperty("value", parsed.hex);

        this.updateColorTools(editor);

        this.resize();
    },

    /**
     * Scans the document for colors and generates the list as shown below the 
     * color picker for quick access to colors that are already in use.
     * 
     * @param {Editor} editor
     * @type {void}
     */
    updateColorTools: function(editor) {
        var lines = editor.session.getLines(0, 2000);
        var m;
        var colors = [];
        for (var i = 0, l = lines.length; i < l; ++i) {
            if (!(m = lines[i].match(Regexes.isColor)))
                continue;
            colors = colors.concat(m);
        }
        colors.makeUnique();

        var out = [];
        var parsed;
        for (i = 0, l = Math.min(colors.length, 11); i < l; ++i) {
            parsed = this.parseColorString(colors[i]);
            
            out.push('<span class="color" style="background-color: #', parsed.hex, 
                '" data-color="', parsed.hex, '" title="', parsed.orig, '">&nbsp;</span>');
        }
        this.colortools.innerHTML = "<span>Existing file colors:</span>" + out.join("");
    },

    /**
     * When a color is picked in the colorpicker, this function is called. It 
     * updates the color value inside the ACE document with the newly picked color.
     * Since the value change of the color picker is realtime and generates A LOT 
     * of calls to this function, we filter the calls and only apply the change
     * when no color was picked for 200ms.
     * 
     * @param {String} old
     * @param {String} color
     * @type {void}
     */
    onColorPicked: function(old, color) {
        var a = this.$activeColor;
        if (!a)
            return;
        if (a.ignore) {
            --a.ignore;
            return;
        }

        clearTimeout(this.$colorPickTimer);

        var doc = a.editor.session.doc;
        var line = doc.getLine(a.pos.row);
        if (typeof a.markerNode == "string") {
            var node = document.getElementById(a.markerNode);
            if (node)
                a.markerNode = node;
            else
                return;
        }
        var newLine, newColor;
        if (a.color.type == "hex") {
            newColor = "#" + color;
        }
        else if (a.color.type == "rgb") {
            var m = a.current.match(Regexes.isRgb);
            var regex = new RegExp("(rgba?)\\(\\s*" + m[1] + "\\s*,\\s*" + m[2] 
                + "\\s*,\\s*" + m[3] + "(\\s*,\\s*(?:1|0|0?\\.[0-9]{1,2})\\s*)?\\)", "i");
            if (!line.match(regex))
                return;
            var rgb = apf.color.hexToRGB(color);
            newLine = line.replace(regex, function(m, prefix, suffix) {
                return (newColor = prefix + "(" + rgb.r + ", " + rgb.g + ", " + rgb.b + (suffix || "") + ")");
            });
        }
        else if (a.color.type == "hsb") {
            var m = a.current.match(Regexes.isHsl);
            var regex = new RegExp("hsl\\(\\s*" + m[1] + "\\s*,\\s*" + m[2] 
                + "\\s*,\\s*" + m[3] + "\\s*\\)", "i");
            if (!line.match(regex))
                return;
            var hsb = apf.color.hexToHSB(color);
            newLine = line.replace(regex, function() {
                return (newColor = "hsl(" + parseInt(hsb.h, 10) + ", " 
                    + parseInt(hsb.s, 10) + "%, " + parseInt(hsb.b, 10) + "%)");
            });
        }
        a.hex = color;

        a.markerNode.innerHTML = newColor;

        this.$colorPickTimer = setTimeout(function() {
            var range = createColorRange(a.pos.row, a.pos.column, line, a.current);
            if (!range)
                return;
            a.marker[0] = range;
            doc.replace(range, newColor);
            a.current = newColor;
        }, 200);
    },

    /**
     * When the browser window is resized and the colorpicker menu is opened, the
     * position of the colorpicker has to be adjusted to the correct value.
     * This function also takes window edges and menu arrow positioning into 
     * account.
     * 
     * @param {Object} color
     * @type {void}
     */
    resize: function(color) {
        if (!this.menu.visible)
            return;

        var a = color || this.$activeColor;
        var pos = a.pos;
        var orig = a.color.orig;
        var line = a.line;
        var renderer = Editors.currentEditor.amlEditor.$editor.renderer;
        var cp = this.colorpicker;
        var menu = this.menu;

        //default to arrow on the left side:
        menu.setProperty("class", "left");

        // calculate the x and y (top and left) position of the colorpicker
        var coordsStart = renderer.textToScreenCoordinates(pos.row, line.indexOf(orig) - 1);
        var coordsEnd = renderer.textToScreenCoordinates(pos.row, line.indexOf(orig) + orig.length);
        var origX, origY;
        var y = origY = coordsEnd.pageY - 24;
        var x = origX = coordsEnd.pageX + 30;
        var pOverflow = apf.getOverflowParent(cp.$ext);
        // we take a margin of 20px on each side of the window:
        var height = menu.$ext.offsetHeight + 10;
        var width = menu.$ext.offsetWidth + 10;

        var edgeY = (pOverflow == document.documentElement
            ? (apf.isIE 
                ? pOverflow.offsetHeight 
                : (window.innerHeight + window.pageYOffset)) + pOverflow.scrollTop
            : pOverflow.offsetHeight + pOverflow.scrollTop);
        var edgeX = (pOverflow == document.documentElement
            ? (apf.isIE 
                ? pOverflow.offsetWidth
                : (window.innerWidth + window.pageXOffset)) + pOverflow.scrollLeft
            : pOverflow.offsetWidth + pOverflow.scrollLeft);

        if (y + height > edgeY) {
            y = edgeY - height;
            if (y < 0)
                y = 10;
        }
        if (x + width > edgeX) {
            x = edgeX - width;
            // check if the menu will be positioned on top of the text
            if (coordsEnd.pageX > x && coordsEnd.pageX < x + width) {
                // take 20px for the arrow...
                x = coordsStart.pageX - width - 20;
                menu.setProperty("class", "right");
            }
            if (x < 10) {
                menu.setProperty("class", "noarrow");
                if (coordsStart.pageY > height)
                    y = coordsStart.pageY - height + 10;
                else
                    y = coordsStart.pageY + 40;

                x = 10;
            }
        }

        // position the arrow
        if (!origArrowTop)
            origArrowTop = parseInt(apf.getStyle(this.arrow, "top"), 10);
        if (y != origY)
            this.arrow.style.top = (origArrowTop + (origY - y)) + "px"
        else
            this.arrow.style.top = origArrowTop + "px";

        menu.$ext.style.zIndex = 10002;
        menu.$ext.style.top = y + "px";
        menu.$ext.style.left = x + "px";
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        // hiding the menu also detaches all event listeners.
        if (this.menu.visible)
            this.menu.hide();

        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});

/**
 * Minimap extension for Cloud9 IDE
 * 
 * @author Sergi Mansilla
 * @contributor Matt Pardee
 * @copyright 2012, Cloud9 IDE, Inc.
 */
define('ext/minimap/minimap',['require','exports','module','core/ext','core/ide','ext/editors/editors','ext/minimap/map','text!ext/minimap/style.css'],function(require, exports, module) {

var ext = require("core/ext");
var ide = require("core/ide");
var editors = require("ext/editors/editors");
var Map = require("ext/minimap/map");
var css = require("text!ext/minimap/style.css");

return module.exports = ext.register("ext/minimap/minimap", {
    name  : "Minimap",
    dev   : "Cloud9 IDE, Inc.",
    type  : ext.GENERAL,
    alone : true,
    commands : {
        "minimap": {
            hint: "Hide or show the code minimap"
        }
    },
    nodes   : [],
    deps    : [editors],
    css     : css,
    map_width : 165,
    map_enabled : false,

    hook : function() {
        var _self = this;
        this.menuItem = new apf.item({
            id      : "mnuItemShowMinimap",
            type    : "check",
            caption : "Show Minimap",
            checked : "[{require('ext/settings/settings').model}::editors/code/@minimap]",
            onclick : function() {
                _self.toggle();
            }
        });

        this.nodes.push(mnuView.appendChild(this.menuItem));

        ide.addEventListener("afteropenfile", function() {
            ext.initExtension(_self);
            if (_self.editor)
                _self.updateMap();
        });

        ide.addEventListener("loadsettings", function(e) {
            _self.map_enabled = e.model.queryValue("editors/code/@minimap");
        });
    },

    init : function() {
        var _self = this;

        apf.importCssString((this.css || ""));

        this.editor = ceEditor.$editor;
        this.panel = ceEditor.parentNode.appendChild(new apf.bar({
            id : "minimapPanel",
            visible : false,
            top : 2,
            bottom : 0
        }));

        this.panel.$ext.style.right = "0";
        this.panel.$ext.style.webkitTextSizeAdjust = "none";
        this.canvas = document.createElement("canvas");
        this.panel.$ext.appendChild(this.canvas);
        this.visor = document.createElement("div");
        this.visor.setAttribute("id", "minimapVisor");
        this.panel.$ext.appendChild(this.visor);
        this.map = new Map(this.editor, this.canvas, this.visor);

        tabPlaceholder.addEventListener("resize", function() {
            if (_self.panel.visible)
                _self.map.resize(_self.map_width, ceEditor.getHeight());
        });

        tabEditors.addEventListener("afterswitch", function() {
            _self.updateMap();
            setTimeout(function() {
                _self.setupChangeListener();
            }, 200);
        });

        if (apf.isTrue(this.map_enabled)) {
            setTimeout(function() {
                _self.show();
            });
        }

        this.setupChangeListener();
    },
    
    setupChangeListener : function() {
        if (this.$changeEvent)
            this.editorSession.removeEventListener("change", this.$changeEvent);

        var _self = this;
        if(editors.currentEditor.ceEditor) {
            this.editorSession = editors.currentEditor.ceEditor.$editor.session;
            this.editorSession.addEventListener("change", this.$changeEvent = function() {
                if (_self.$updateTimer)
                    clearTimeout(_self.$updateTimer);
                _self.$updateTimer = setTimeout(function() {
                    _self.updateMap();
                }, 100);
            });
        }
    },

    // Support for CLI
    minimap : function() {
        mnuItemShowMinimap.dispatchEvent("click");
    },

    toggle : function() {
        if (apf.isTrue(this.map_enabled))
            this.hide();
        else
            this.show();
    },

    show : function() {
        this.editor.container.style.right = this.map_width + "px";
        this.panel.show();
        this.updateMap();
        this.map_enabled = true;

        ide.dispatchEvent("minimap.visibility", {
            visibility: "shown",
            width : this.map_width
        });
    },

    /**
     * Hide minimap
     * 
     * @param {boolean} noSetMapEnabled Whether to set `map_enabled`
     * @see this.disable()
     */
    hide : function(noSetMapEnabled) {
        this.panel.hide();
        this.editor.container.style.right = "0";

        if (!noSetMapEnabled)
            this.map_enabled = false;

        ide.dispatchEvent("minimap.visibility", {
            visibility: "hidden"
        });
    },

    updateMap : function() {
        if (this.panel.visible)
            this.map.updateSource(this.editor.getSession());
    },

    enable: function() {
        this.menuItem.show();

        if (this.map_enabled)
            this.show();
    },

    disable: function() {
        this.menuItem.hide();

        // We don't want to set the map_enabled var when disabling,
        // because when it's re-enabled we want it to re-appear if
        // map_enabled was originally set to true
        this.hide(true);
    },

    destroy: function() {
        this.nodes.each(function(item) {
            return item.destroy();
        });
        this.nodes = [];
        this.map.destroy();
        this.map = null;
        this.panel.destroy(true, true);
    }
});
});

/**
 * Searchinfiles Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/searchinfiles/searchinfiles',['require','exports','module','core/ide','core/ext','core/util','ext/editors/editors','ext/filesystem/filesystem','ext/console/console','text!ext/searchinfiles/skin.xml','text!ext/searchinfiles/searchinfiles.xml'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var util = require("core/util");
var editors = require("ext/editors/editors");
var fs = require("ext/filesystem/filesystem");
var ideConsole = require("ext/console/console");
var skin = require("text!ext/searchinfiles/skin.xml");
var markup = require("text!ext/searchinfiles/searchinfiles.xml");

module.exports = ext.register("ext/searchinfiles/searchinfiles", {
    name     : "Search in files",
    dev      : "Ajax.org",
    type     : ext.GENERAL,
    alone    : true,
    offline  : false,
    markup   : markup,
    skin     : {
        id   : "searchinfiles",
        data : skin,
        "media-path" : ide.staticPrefix + "/ext/searchinfiles/images/"
    },
    commands  : {
        "searchinfiles": {hint: "search for a string through all files in the current workspace"}
    },
    pageTitle: "Search Results",
    pageID   : "pgSFResults",
    hotitems : {},

    nodes    : [],

    hook : function(){
        var _self = this;

        this.nodes.push(
            mnuEdit.appendChild(new apf.divider()),
            mnuEdit.appendChild(new apf.item({
                caption : "Search in Files...",
                onclick : function() {
                    _self.toggleDialog(false);
                }
            }))
        );

        this.hotitems.searchinfiles = [this.nodes[1]];
    },

    init : function(amlNode){
        this.txtFind       = txtSFFind;
        this.btnFind       = btnSFFind;//winSearchInFiles.selectSingleNode("a:vbox/a:hbox/a:button[3]");
        this.btnFind.onclick = this.execFind.bind(this);

        var _self = this;
        
        winSearchInFiles.onhide = function() {
            if (typeof ceEditor != "undefined")
                ceEditor.focus();
            trFiles.removeEventListener("afterselect", _self.setSearchSelection);
        };
        winSearchInFiles.onshow = function() {
            trFiles.addEventListener("afterselect", _self.setSearchSelection);
            _self.setSearchSelection();
        };
        
        trSFHbox.addEventListener("afterrender", function(){
            trSFResult.addEventListener("afterselect", function(e) {
                var path,
                    root = trFiles.xmlRoot.selectSingleNode("folder[1]"),
                    node = trSFResult.selected,
                    line = 0,
                    text = "";
                if (node.tagName == "d:maxreached" || node.tagName == "d:querydetail")
                    return;
                if (node.tagName == "d:excerpt") {
                    path = node.parentNode.getAttribute("path");
                    line = node.getAttribute("line");
                    text = node.parentNode.getAttribute("query");
                }
                else {
                    path = node.getAttribute("path");
                    text = node.getAttribute("query");
                }
                editors.showFile(root.getAttribute("path") + "/" + path, line, 0, text);
            });
        });
        //ideConsole.show();
    },
    
    setSearchSelection: function(e){
        var selectedNode;
        // If originating from an event
        if (e && e.selected)
            selectedNode = e.selected;
        else
            selectedNode = this.getSelectedTreeNode();
        // get selected node in tree and set it as selection
        var name = selectedNode.getAttribute("name");
        if (name.length > 25)
            name = name.substr(0, 22) + "...";
        rbSFSelection.setAttribute("label", "Selection ( " + name + " )");
    },
    
    getSelectedTreeNode: function() {
        var node = self["trFiles"] ? trFiles.selected : fs.model.queryNode("folder[1]");
        if (!node)
            node = trFiles.xmlRoot.selectSingleNode("folder[1]");
        while (node.tagName != "folder")
            node = node.parentNode;
        return node;
    },

    toggleDialog: function(isReplace, forceShow) {
        ext.initExtension(this);

        if (apf.isWin && (location.host.indexOf("localhost") > -1 || location.host.indexOf("127.0.0.1") > -1)) {
            return util.alert("Search in Files", "Not Supported",
                "I'm sorry, searching through files is not yet supported on the Windows platform.");
        }

        if (!winSearchInFiles.visible || forceShow || this.$lastState != isReplace) {
            //this.setupDialog(isReplace);
            var editor = editors.currentEditor;
            if (editor) {
                var value  = editor.getDocument().getTextRange(editor.getSelection().getRange());
                if (value)
                    this.txtFind.setValue(value);
            }
            winSearchInFiles.show();
        }
        else {
            winSearchInFiles.hide();
        }
        return false;
    },

    onHide : function() {
        var editor = editors.currentEditor;
        if (editor && editor.ceEditor)
            editor.ceEditor.focus();
    },

    searchinfiles: function() {
        return this.toggleDialog(false, true);
    },

    setupDialog: function(isReplace) {
        this.$lastState = isReplace;

        // hide all 'replace' features
        //this.barReplace.setProperty("visible", isReplace);
        //this.btnReplace.setProperty("visible", isReplace);
        //this.btnReplaceAll.setProperty("visible", isReplace);
        return this;
    },

    getOptions: function() {
        var matchCase = "0";
        if (chkSFMatchCase.checked)
            matchCase = "1";
        var regex = "0";
        if (chkSFRegEx.checked)
            regex = "1";
        return {
            query: txtSFFind.value,
            pattern: ddSFPatterns.value,
            casesensitive: matchCase,
            regexp: regex
        };
    },

    execFind: function() {
        var _self = this;
        winSearchInFiles.hide();
        // show the console (also used by the debugger):
        ideConsole.show();
        if (!this.$panel) {
            this.$panel = tabConsole.add(this.pageTitle, this.pageID);
            this.$panel.setAttribute("closebtn", true);
            this.$panel.appendChild(trSFHbox);
            tabConsole.set(_self.pageID);
            trSFHbox.show();
            trSFResult.setProperty("visible", true);
            this.$model = trSFResult.getModel();
            // make sure the tab is shown when results come in
            this.$model.addEventListener("afterload", function() {
                tabConsole.set(_self.pageID);
            });

            this.$panel.addEventListener("afterclose", function(){
                this.removeNode();
                return false;
            });
        }
        else {
            tabConsole.appendChild(this.$panel);
        }
        // show the tab
        tabConsole.set(this.pageID);

        var node = this.$currentScope = grpSFScope.value == "projects"
            ? trFiles.xmlRoot.selectSingleNode("folder[1]")
            : this.getSelectedTreeNode();
            
        var findValueSanitized = txtSFFind.value.trim().replace(/([\[\]\{\}])/g, "\\$1");
        _self.$model.clear();
        trSFResult.setAttribute("empty-message", "Searching for '" + findValueSanitized + "'...");
        davProject.report(node.getAttribute("path"), "codesearch", this.getOptions(), function(data, state, extra){
            if (state !== apf.SUCCESS || !parseInt(data.getAttribute("count"), 10))
                return trSFResult.setAttribute("empty-message", "No results found for '" + findValueSanitized + "'");;

            _self.$model.load(data);
        });

        ide.dispatchEvent("track_action", {type: "searchinfiles"});
    },

    replaceAll: function() {
        return;
        /*if (!this.editor)
            this.setEditor();
        if (!this.$editor)
            return;
        this.$crtSearch = null;
        var options = this.getOptions();
        this.$editor.replaceAll(this.txtReplace.getValue() || "", options);
        ide.dispatchEvent("track_action", {type: "replace"});*/
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});

/**
 * Native drag 'n drop upload for Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 */

define('ext/dragdrop/dragdrop',['require','exports','module','core/ide','core/ext','core/util','ext/filesystem/filesystem'],function(require, exports, module) {

var ide  = require("core/ide");
var ext  = require("core/ext");
var util = require("core/util");
var fs   = require("ext/filesystem/filesystem");

var MAX_UPLOAD_SIZE = 52428800;
var MAX_OPENFILE_SIZE = 2097152;
var MAX_CONCURRENT_FILES = 10;

module.exports = ext.register("ext/dragdrop/dragdrop", {
    dev         : "Ajax.org",
    name        : "Dragdrop",
    alone       : true,
    type        : ext.GENERAL,
    
    nodes: [],
        
    init: function() {
        var _self  = this;

        var dropbox = document.createElement("div");
        apf.setStyleClass(dropbox, "draganddrop");
        
        var label = document.createElement("span");
        label.textContent = "Drop files here to upload";
        dropbox.appendChild(label);
        
        function decorateNode(holder) {
            dropbox = holder.dropbox = dropbox.cloneNode(true);
            holder.appendChild(dropbox);
            
            holder.addEventListener("dragenter", dragEnter, false);
            dropbox.addEventListener("dragleave", dragLeave, false);
            dropbox.addEventListener("drop", dragDrop, false);
            
            ["dragexit", "dragover"].forEach(function(e) {
                dropbox.addEventListener(e, noopHandler, false);
            });
        }
        
        ide.addEventListener("init.ext/editors/editors", function(){
            _self.nodes.push(tabEditors.$ext);
            decorateNode(tabEditors.$ext);
        });
        
        ide.addEventListener("init.ext/tree/tree", function(){
            _self.nodes.push(trFiles.$ext);
            decorateNode(trFiles.$ext);
        });
        
        this.dragStateEvent = {"dragenter": dragEnter};
        
        function dragLeave(e) {
            apf.stopEvent(e);
            apf.setStyleClass(this, null, ["over"]);
        }
        
        function dragEnter(e) {
            apf.stopEvent(e);
            apf.setStyleClass(this.dropbox, "over");
        }
        
        function dragDrop(e) {
            dragLeave.call(this, e);
            return _self.onBeforeDrop(e);
        }
        
        function noopHandler(e) {
            apf.stopEvent(e);
        }
        
        this.StatusBar = {
            $init: function() {
                if (!sbMain)
                    return;
                
                sbMain.firstChild.appendChild(
                    new apf.progressbar({
                        id: "pbMain",
                        anchors: "0 0 0 5",
                        //autohide: true
                    })
                );
            },
            start: function() {
                if (!sbMain.visible)
                    sbMain.show();
            },
            end: function() {
                sbMain.hide();
                
                if (sbMain.childNodes)
                    sbMain.childNodes[0].setAttribute("caption", "");
            },
            upload: function(file) {
                if (sbMain.childNodes) {
                    var caption = "Uploading file " + (file.name || "") + "(" + (file.type || "") + ")";
                    sbMain.childNodes[0].setAttribute("caption", caption);
                }
                pbMain.clear();
                pbMain.start();
                
            },
            progress: function(value) {
                pbMain.setValue(value);
            }
        };
            
        this.StatusBar.$init();
        
        apf.addEventListener("http.uploadprogress", this.onProgress.bind(this));
    },
    
    onBeforeDrop: function(e) {
        // @see Please, go to line 176 for clarification.
        if (!(window.File && window.FileReader/* && window.FormData*/)) {
            util.alert(
                "Could not upload file(s)", "An error occurred while dropping this file(s)",
                "Your browser does not offer support for drag and drop for file uploads. " +
                "Please try with a recent version of Chrome or Firefox browsers."
            );
            return false;
        }
        /** Check the number of dropped files exceeds the limit */
        if (e.dataTransfer.files.length > MAX_CONCURRENT_FILES) {
            util.alert(
                "Could not upload file(s)", "An error occurred while dropping this file(s)",
                "You can only drop " + MAX_CONCURRENT_FILES + " files to upload at the same time. " + 
                "Please try again with " + MAX_CONCURRENT_FILES + " or a lesser number of files."
            );
            return false;
        }
        /** Check total filesize of dropped files */
        for (var size = 0, i = 0, l = e.dataTransfer.files.length; i < l; ++i)
            size += e.dataTransfer.files[i].size;

        if (size > MAX_UPLOAD_SIZE) {
            util.alert(
                "Could not save document", "An error occurred while saving this document",
                "The file(s) you dropped exceeds the maximum of 50MB and could therefore not be uploaded."
            );
            return false;
        }
        
        if (e.dataTransfer.files.length < 1)
            return false;
        
        this.onDrop(e);
        
        return true;
    },
    
    onDrop: function(e) {
        var _self = this;
        var dt = e.dataTransfer;
        var files = dt.files;
        
        apf.asyncForEach(files, function(file, next) {
            _self.StatusBar.start();
            /** Chrome, Firefox */
            if (apf.hasFileApi) {
                /** Processing ... */
                var reader = new FileReader();
                /** Init the reader event handlers */
                reader.onloadend = _self.onLoad.bind(_self, file, next);
                /** Begin the read operation */
                reader.readAsBinaryString(file);
            }
            else {
                /** Safari >= 5.0.2 and Safari < 6.0 */
                _self.onLoad(file, next, _self.getFormData(file));
                /**
                 * @fixme Safari for Mac is buggy when sending XHR using FormData
                 * Problem in their source code causing sometimes `WebKitFormBoundary`
                 * to be added to the request body, making it imposible to construct
                 * a multipart message manually and to construct headers.
                 * 
                 * @see http://www.google.es/url?sa=t&source=web&cd=2&ved=0CCgQFjAB&url=https%3A%2F%2Fdiscussions.apple.com%2Fthread%2F2412523%3Fstart%3D0%26tstart%3D0&ei=GFWITr2BM4SEOt7doNUB&usg=AFQjCNF6WSGeTkrpaqioUyEswi9K2xhZ8g
                 * @todo For safari 6.0 seems like FileReader will be present
                 */
            }
        }, this.StatusBar.end);
    },
    
    onLoad: function(file, next, e) {
        var node = trFiles.selected;
        if (!node)
            node = trFiles.xmlRoot.selectSingleNode("folder");
            
        if (node.getAttribute("type") != "folder" && node.tagName != "folder")
            node = node.parentNode;
            
        var path     = node.getAttribute("path");
        var filename = file.name;
        var index    = 0;
        var _self    = this;

        function check(exists) {
            if (exists) {
                filename = file.name + "." + index++;
                fs.exists(path + "/" + filename, check);
            } else
                upload();
        }
        
        function upload() {
            var data = e instanceof FormData ? e : e.target.result;
            var oBinary = {
                filename: file.name,
                filesize: file.size,
                blob: file
            };
            /*if (data instanceof FormData) {
                oBinary.filedataname = file.name;
                oBinary.multipart = true;
            }*/
            
            fs.webdav.write(path + "/" + file.name, data, false, oBinary, complete);
            _self.StatusBar.upload(file);
        }
        
        function complete(data, state, extra) {
            if (state != apf.SUCCESS) {
                return util.alert(
                    "Could not save document",
                    "An error occurred while saving this document",
                    "Please see if your internet connection is available and try again. "
                        + (state == apf.TIMEOUT
                            ? "The connection timed out."
                            : "The error reported was " + extra.message),
                    next);
            }
            
            /** Request successful */
            fs.webdav.exec("readdir", [path], function(data) {
                if (data instanceof Error) {
                    // @todo: in case of error, show nice alert dialog.
                    return next();
                }
                
                var strXml = data.match(new RegExp(("(<file path='" + path +
                    "/" + filename + "'.*?>)").replace(/\//g, "\\/")));
                
                if(!strXml)
                    next();
                    
                strXml = strXml[1]
                var oXml = apf.xmldb.appendChild(node, apf.getXml(strXml));

                trFiles.select(oXml);
                if (file.size < MAX_OPENFILE_SIZE)
                    ide.dispatchEvent("openfile", {doc: ide.createDocument(oXml)});
                
                next();
            });
        }
        
        /** Check if path already exists, otherwise continue with upload() */
        fs.exists(path + "/" + file.name, check);
    },
    
    onProgress: function(o) {
        var e = o.extra;
        var total = (e.loaded / e.total) * 100;
        this.StatusBar.progress(total.toFixed());
    },
    
    getFormData: function(file) {
        var form = new FormData();
        form.append("upload", file);
        
        return form;
    },
    
    enable: function() {
        var _self = this;
        this.nodes.each(function(item) {
            for (var e in _self.dragStateEvent)
                item.addEventListener(e, _self.dragStateEvent[e], false);
        });
        apf.addEventListener("http.uploadprogress", this.onProgress);
    },
    
    disable: function() {
        var _self = this;
        this.nodes.each(function(item) {
            for (var e in _self.dragStateEvent)
                item.removeEventListener(e, _self.dragStateEvent[e], false);
        });
        apf.removeEventListener("http.uploadprogress", this.onProgress);
    },
    
    destroy: function() {
        var _self = this;
        this.nodes.each(function(item){
            item.removeChild(item.dropbox);
            for (var e in _self.dragStateEvent)
                item.removeEventListener(e, _self.dragStateEvent[e], false);
        });
        this.nodes = [];
        apf.removeEventListener("http.uploadprogress", this.onProgress);
    }
});

});
/**
 * Offline Support for Cloud9
 *
 * @copyright 2011, Ajax.org B.V.
 */

define('ext/offline/lib-offlinels',['require','exports','module','core/util','ext/filesystem/filesystem','core/ide'],function(require, exports, module) {

var util = require("core/util");
var fs = require("ext/filesystem/filesystem");
var ide = require("core/ide");

var WebdavLocalStorage = module.exports = function(callback, sync, fIdent) {
    this.fs     = null;
    this.sync   = sync;
    this.fIdent = fIdent;
    
    callback();
};

(function() {
    this.available = false;
    this.fake      = true;
    
    this.exists = function(path, callback) {
        if (localStorage[this.fIdent]) {
            var files = JSON.parse(localStorage[this.fIdent]);
            if (files[path])
                return callback(true);
            return callback(false);
        }
    };
    
    this.read = function(path, callback){
        if (localStorage[this.fIdent]) {
            var files = JSON.parse(localStorage[this.fIdent]);
            if (files[path])
                return callback(files[path], apf.SUCCESS, {});
        }
        this.handleError(callback);
    };
    
    this.write = function(path, data, x, callback){
        if (!ide.onLine) {
            this.sync.add(path, {
                type: "webdav-write",
                date: fs.model.queryValue("//file[@path='" + path + "']/@modifieddate"),
                path: path,
                data: data
            });
            
            if (callback)
                callback("", apf.SUCCESS, {});
        }
    };
    
    this.remove = function(path, lock, callback){
        return this.handleError(callback);
        
        /*
        this.sync.add(path, {
            type: "webdav-rm",
            path: path,
            lock: lock
        });
        
        if (callback)
            callback("", apf.SUCCESS, {});
        */
    };
    
    this.copy = function(from, to, overwrite, lock, callback){
        return this.handleError(callback);
        
        /*
        this.sync.add(from, {
            type: "webdav-copy",
            from: from,
            to: to,
            overwrite: overwrite,
            lock: lock
        });
        
        if (callback)
            callback("", apf.SUCCESS, {});
        */
    };
    
    this.move = function(from, to, overwrite, lock, callback){
        return this.handleError(callback);
        
        /*
        this.sync.add(from, {
            type: "webdav-move",
            from: from,
            to: to,
            overwrite: overwrite,
            lock: lock
        });
        
        if (callback)
            callback("", apf.SUCCESS, {});
        */
    };
    
    this.list = function(path, callback){
        this.handleError(callback);
    };
    
    this.exec = function(type, args, callback) {
        switch(type) {
            case "create":
                //args = [path, filename];
            break;
            case "mkdir":
                //args = [path, name]
            break;
            case "login":
            case "authenticate":
            case "logout":
            case "read":
            case "readdir":
            case "scandir":
            case "getroot":
            case "lock":
            case "unlock":
                break;
            case "exists":
            case "create":
            case "write":
            case "store":
            case "save":
            case "copy":
            case "cp":
            case "rename":
            case "move":
            case "mv":
            case "remove":
            case "rmdir":
            case "rm":
            case "mkdir":
            case "report":
                //No can do
                this.handleError(callback);
        }
    };
    
    this.handleError = function(callback){
        if (!ide.onLine) {
            util.alert("Sorry, you are offline right now and cannot perform this operation");
            callback(null, apf.ERROR, {});
        }
    };
}).call(WebdavLocalStorage.prototype = new apf.Class().$init());

});

/**
 * Offline Support for Cloud9
 *
 * @copyright 2011, Ajax.org B.V.
 */
 
define('ext/offline/lib-webdav-wrap',['require','exports','module','core/ide','ext/offline/lib-offlinedav','ext/offline/lib-offlinels'],function(require, exports, module) {

var ide = require("core/ide");

var WebdavHtml5FileSystem = require("ext/offline/lib-offlinedav");
var WebdavLocalStorage = require("ext/offline/lib-offlinels");

/**
 * Create the webdav wrapper, if we have a real webdav object we'll be
 * saving remotely, otherwise we'll save locally
 */
var WebdavWrapper = function(webdav, sync, fIdent, callback) {
    this.realWebdav    = webdav;
    
    // Check Local filesystem is available, or use localStorage
    this.hasFileSystem = WebdavHtml5FileSystem.isAvailable()  && false; //@todo this has to be changed when bgsync is 100% working
    if (this.hasFileSystem)
        this.localWebdav = new WebdavHtml5FileSystem(callback, sync);
    else
        this.localWebdav = new WebdavLocalStorage(callback, sync, fIdent);
};

(function() {
    this.available = true;
    this.fake      = true;
    
    /**
     * Check a file exists in the path
     */
    this.exists = function(path, callback) {
        if (ide.onLine)
            this.realWebdav.exists.apply(this.realWebdav, arguments);
        else if (this.hasFileSystem)
            this.localWebdav.exists.apply(this.localWebdav, arguments);
        else
            callback(null, apf.OFFLINE, {});
    };
    
    /**
    * Read function here currently takes in content as a string,
    * we probably want to do some MIME checking here for binary
    * files
    */
    this.read = function(path, callback){
        if (ide.onLine)
            this.realWebdav.read.apply(this.realWebdav, arguments);
        else if (this.hasFileSystem)
            this.localWebdav.read.apply(this.localWebdav, arguments);
        else
            callback(null, apf.OFFLINE, {});
    };
    /**
     * Here we write the file to the file system, then we also
     * need to add it to the sync operations for that file
     * when we go online
     * 
     * With write, if the project is syned, we also want to write offline
     * as well as offline, but if we are offline we only write to offline
     */
    this.writeFile =
    this.write     = function(path, data, x, callback){
        if (ide.onLine)
            this.realWebdav.write.apply(this.realWebdav, arguments);
        
        this.localWebdav.write.call(this.localWebdav, path, data, x, callback);
    };
    
    /**
     * Remove a file from the filesystem.  If we are online and the project
     * is syned, we write to both online and offline, if we are offline we
     * only write to offline
     */
    this.remove = function(sPath, bLock, callback) {
        if (ide.onLine)
            this.realWebdav.remove.apply(this.realWebdav, arguments);
        
        this.localWebdav.remove.call(this.localWebdav, sPath, bLock, callback);
    }
    
    /**
     * Copy a file from the filesystem.  If we are online and the project
     * is syned, we write to both online and offline, if we are offline we
     * only write to offline
     */
    this.copy = function(sFrom, sTo, bOverwrite, bLock, callback) {
        if (ide.onLine)
            this.realWebdav.copy.apply(this.realWebdav, arguments);
        
        this.localWebdav.copy.call(this.localWebdav, sFrom, sTo, bOverwrite, bLock, callback);
    }
    
    /**
     * Rename or move a file from the filesystem.  If we are online and the project
     * is syned, we write to both online and offline, if we are offline we
     * only write to offline
     */
    this.rename =
    this.move = function(sFrom, sTo, bOverwrite, bLock, callback) {
        if (ide.onLine)
            this.realWebdav.move.apply(this.realWebdav, arguments);
        
        this.localWebdav.move.call(this.localWebdav, sFrom, sTo, bOverwrite, bLock, callback);
    }
    
    this.report = function(sPath, reportName, oProperties, callback) {
        //if (ide.onLine)
            this.realWebdav.report.apply(this.realWebdav, arguments);
    }
    
    this.getProperties = function(sPath, iDepth, callback, oHeaders) {
    }
    
    this.setProperties = function(sPath, oPropsSet, oPropsDel, sLock) {
    }
    
    /**
     * method to do a ls on a directory, this returns
     * an array of FileEntry and DirectoryEntry objects
     * which can be itterated over to generate
     * a tree path
     */
    this.list = function(path, callback){
        if (ide.onLine)
            this.realWebdav.list.apply(this.realWebdav, arguments);
        else if (this.hasFileSystem)
            this.localWebdav.list.apply(this.localWebdav, arguments);
        else
            throw new Error("You are currently offline and the local filesystem is unavailable");
    };
    this.exec = function(type, args, callback) {
        if (ide.onLine)
            this.realWebdav.exec.apply(this.realWebdav, arguments);
        this.localWebdav.exec.call(this.localWebdav, type, args, callback);
    };
    
    this.handleError = function(callback, error) {
        callback(null, apf.ERROR, error ? {message: error.code} : {});
    }
}).call(WebdavWrapper.prototype = new apf.AmlElement().$init());

module.exports = WebdavWrapper

});

/**
 * Offline Support for Cloud9
 *
 * @copyright 2010, Ajax.org B.V.
 */
define('ext/offline/offline',['require','exports','module','core/ide','core/ext','core/util','ext/offline/lib-offline','ext/offline/lib-sync','ext/filesystem/filesystem','ext/offline/lib-webdav-wrap'],function(require, exports, module) {

var ide     = require("core/ide");
var ext     = require("core/ext");
var util    = require("core/util");
var Offline = require("ext/offline/lib-offline");
var Sync    = require("ext/offline/lib-sync");
var fs      = require("ext/filesystem/filesystem");
var WebdavWrapper = require("ext/offline/lib-webdav-wrap");

module.exports = ext.register("ext/offline/offline", {
    dev      : "Ajax.org",
    name     : "Offline",
    alone    : true,
    type     : ext.GENERAL,
    deps     : [fs],
    handlers : {},

    offlineStartup : 0,

    /**
     * Test method for going offline/online
     * @param {Boolean} online If the request is to go online or not
     */
    test : function(online){
        ide.testOffline = online ? 2 : 1;
        if (online)
            ide.socket.socket.connect();
        else
            ide.socket.socket.disconnect();
    },

    /**
     * Attach a method to a handler type
     * @param {String} type The handler hash type
     * @param {Function} handler The handler function
     */
    addHandler : function(type, handler){
        this.handlers[type] = handler;
    },

    /**
     * Init method to create the offline logic
     */
    init : function(){
        var _self   = this;
        var offline = this.offline = new Offline("cloud9", (window.location.pathname + "/$reconnect").replace(/\/\//g, "/"));
        var sync    = this.sync    = new Sync("cloud9");

        // preload the offline image programmatically:
        var img = new Image();
        img.src = ide.staticPrefix + "/style/images/offline.png";

        //Replace http checking because we already have a socket
        //offline.isSiteAvailable = function(){};

        //Set events necessary for checking online status using socket poll loop
        //@todo we still need to solve if (!_self.offlineStartup)
        /*ide.addEventListener("socketConnect", function(e){
            if (!_self.offlineStartup)
                offline.goOnline(); //Comment this out to test offline-start
        });

        ide.addEventListener("socketDisconnect", function(e){
            offline.goOffline();
        });*/

        //Forward Events
        offline.dispatchEvent = function(name, e){
            ide.dispatchEvent(name, e);
        };

        ide.onLine = -1;

        //If we are syncing stop sync.
        ide.addEventListener("beforeoffline", function(){
            if (sync.syncing)
                sync.stop();
        });

        ide.addEventListener("afteroffline", function(){
            stServerConnected.deactivate();
            ide.onLine = false;
            logobar.$ext.className = "c9-menu-bar offline";

            _self.bringExtensionsOffline();
        });

        //If we need to sync first, prevent Cloud9 from coming online
        ide.addEventListener("beforeonline", function(){
            if (sync.getLength()) {
                sync.start(function(data, next){
                    var item = data.item;
                    var cb   = function(){
                        if (next() < 0) //End of loop
                            offline.goOnline();
                    };

                    //Execute sync task here
                    var handler = _self.handlers[item.type];
                    if (!handler) {
                        if (self.console)
                            console.warn("Couldn't find handler for offline type '" + item.type + "'");
                        cb();
                    }
                    else
                        handler(item, cb);
                });
                return false;
            }
        });

        ide.addEventListener("afteronline", function(e){
            stServerConnected.activate();
            ide.onLine = true;
            logobar.$ext.className = "c9-menu-bar";

            _self.bringExtensionsOnline();
        });

        // after the IDE connects (either initial or after reconnect)
        ide.addEventListener("socketConnect", function (e) {
            // load the state, which is quite a weird name actually, but it contains
            // info about the debugger. The response is handled by 'noderunner.js'
            // who publishes info for the UI of the debugging controls based on this.
            ide.send({
                command: "state",
                action: "publish"
            });

            // the debugger needs to know that we are going to attach, but that its not a normal state message
            dbg.registerAutoAttach();
        });

        /**** File System ****/
        /**
         * Here, we need to first create the offlineWebdav object in the main scope
         * of the function, then we need to call the file system constructor. This
         * is async operation, so we need to wait on the filesystem becoming available
         * Due to the app starting in offline in this mode, we need to create a fake read
         * function here or an exception is thrown.
         * Once the file system is available, it's attached to the offlinefs instance, and we
         * can call it's methods with the correct filesystem scope
         */

        // fIdent is used for localStorage in Firefox or if local Filesystem is
        // not available
        var fIdent = "cloud9.files." + ide.workspaceId;


        ide.addEventListener("init.ext/filesystem/filesystem", function(){
            // If we don't have the real webdav, we need to use the offline one
            if (!fs.realWebdav)
                fs.realWebdav = fs.webdav;

            // Now we create a fake webdav object
            var fakeWebdav = new WebdavWrapper(fs.realWebdav, sync, fIdent, function(){
                // We need to set if we have offline file system support, and if we
                // do we don't need to disable plugins like tree, save, etc
                ide.offlineFileSystemSupport = fakeWebdav && fakeWebdav.hasFileSystem;
            });

            // Finally set the objects we need to make the calls on
            fs.webdav = fakeWebdav;
            davProject = fakeWebdav; //intended global
        });

        /**
         * Handler for syncing, wedav-write.  This is used when we go back online
         * and we need to sync file writes
         * @param {Object}      item
         * @param {Function}    callback
         */
        this.addHandler("webdav-write", function(item, callback){
            // Set the webdav object
            var webdav = fs.realWebdav || fs.webdav;
            if (webdav.fake) throw new Error("Found fake webdav, while expecting real one!");

            // Get the properties of the item
            webdav.getProperties(item.path, 0, function(data){
                var xml = apf.getXml(data);
                // Check the date is newwer
                var serverdate = new Date(xml.firstChild
                    ? xml.firstChild.getAttribute("modifieddate")
                    : 0);
                if (serverdate <= new Date(item.date))
                    webdav.write(item.path, item.data, null, callback);
                else {
                    // If the item is older, we need to confirm we want to
                    // overwrite the remote one
                    util.confirm(
                        "File conflict while syncing",
                        "Conflict found in file " + item.path,
                        "Clicking 'OK' will overwrite the online file.<br />"
                        + "Clicking 'Cancel' will save this file as:<br /><br />"
                        + item.path + "_backup",
                        function(){
                            webdav.write(item.path, item.data, null, callback);
                        },
                        function(){
                            webdav.write(item.path + "_backup", item.data, null, callback);
                        });
                }
            });
        });

        /**
         * Handler for the creation of a new file
         */
        this.addHandler("webdav-create", function(item, callback) {
            var webdav = fs.realWebdav || fs.webdav;
            if (webdav.fake) throw new Error("Found fake webdav, while expecting real one!");
            webdav.writeFile(item.path, item.data, false, null, callback);
        });

        /**
         * Handler for updating an existing file
         */
        this.addHandler("webdav-write", function(item, callback) {
            var webdav = fs.realWebdav || fs.webdav;
            if (webdav.fake) throw new Error("Found fake webdav, while expecting real one!");
            webdav.writeFile(item.path, item.data, false, null, callback);
        });

        /**
         * Handler for removing a file
         */
        this.addHandler("webdav-rm", function(item, callback) {
            var webdav = fs.realWebdav || fs.webdav;
            if (webdav.fake) throw new Error("Found fake webdav, while expecting real one!");
            webdav.remove(item.path, false, callback);
        });

        /**
         * Handler for creating a new directory
         */
        this.addHandler("webdav-mkdir", function(item, callback) {
            var webdav = fs.realWebdav || fs.webdav;
            if (webdav.fake) throw new Error("Found fake webdav, while expecting real one!");
            webdav.mkdir(item.path, false, callback);
        });

        /**
         * Handler for removing a directory
         */
        this.addHandler("webdav-rmdir", function(item, callback) {
            var webdav = fs.realWebdav || fs.webdav;
            if (webdav.fake) throw new Error("Found fake webdav, while expecting real one!");
            webdav.remove(item.path, false, callback);
        });

        /**
         * Handler for moving a file or directory
         */
        this.addHandler("webdav-move", function(item, callback) {
            var webdav = fs.realWebdav || fs.webdav;
            if (webdav.fake) throw new Error("Found fake webdav, while expecting real one!");
            webdav.move(item.from, item.to, false, false, callback);
        });

        /**
         * Handler for copying a file or directory
         */
        this.addHandler("webdav-copy", function(item, callback) {
            var webdav = fs.realWebdav || fs.webdav;
            if (webdav.fake) throw new Error("Found fake webdav, while expecting real one!");
            webdav.copy(item.from, item.to, true, false, callback);
        });

        /**
         * Handler for renaming a file or directory
         */
        this.addHandler("webdav-rename", function(item, callback) {
            var webdav = fs.realWebdav || fs.webdav;
            if (webdav.fake) throw new Error("Found fake webdav, while expecting real one!");
            webdav.rename(item.from, item.to, false, false, callback);
        });

        var ident = "cloud9.filetree." + ide.workspaceId;
        function saveModel(){
            localStorage[ident] = fs.model.data.xml;
        }

        //@todo after being longer than 5 minutes offline reload tree when coming online

        ide.addEventListener("afteroffline", function(){
            if (!fs.model.data) {
                if (localStorage[ident]) {
                    fs.model.load(localStorage[ident]);
                    fs.projectName = fs.model.queryValue("folder[@root='1']/@name");
                }
            }
            else {
                saveModel();
            }
        });

        fs.model.addEventListener("update", saveModel);
        fs.model.addEventListener("afterload", saveModel);

        //File contents
        /**
         * This is where we save the files if we have offline support
         */
        function saveFiles(e) {
            // Check for offline support
            if (!ide.offlineFileSystemSupport) {
                var pages = tabEditors.getPages();
                var files = {};
                var len = pages.length;
                if (len) {
                    for (var i = 0; i < len; i++) {
                        var node;
                        // Sometimes there is no model for the page, and this
                        // could cause Cloud9 to lose data
                        if (pages[i].$model && pages[i].$model.data)
                            node = pages[i].$model.data;

                        if (node)
                            files[node.getAttribute("path")] = pages[i].$doc.getValue();
                    }
                }

                try {
                    delete localStorage[fIdent];
                    localStorage[fIdent] = JSON.stringify(files);
                } catch(e) {
                    // TODO: What if we cannot store the files?
                }
            }
        }

        ide.addEventListener("savesettings", saveFiles);
        apf.addEventListener("exit", saveFiles);

        /**** Init ****/

        ide.addEventListener("socketConnect", function() {
            offline.goOnline();
            ide.removeEventListener("socketConnect", arguments.callee);
        });

        ide.addEventListener("extload", function() {
            offline.start();
        });

        if (_self.offlineStartup)
            ide.dispatchEvent("afteroffline"); //Faking offline startup
    },

    enable : function(){
    },

    disable : function(){
    },

    destroy : function(){
        //Remove all events
    },

    bringExtensionsOnline : function(){
        var exts = ext.extensions;
        for (var i = 0, l = exts.length; i < l; i++) {
            var _ext = exts[i];
            if (_ext.offline === false)
                _ext.enable();
        }
    },

    bringExtensionsOffline : function(){
        var exts = ext.extensions;
        for (var i = 0, l = exts.length; i < l; i++) {
            var _ext = exts[i];
            if (_ext.offline === false)
                _ext.disable();
        }
    }
});

/*

//#ifdef __WITH_AUTH
var auth = apf.document.getElementsByTagNameNS(apf.ns.apf, "auth")[0];
if (!auth)
    return;

//First let's log in to the services that need it before syncing changes
if (auth.needsLogin && auth.loggedIn) { // && !auth.loggedIn
    auth.authRequired({
        object : this,
        retry  : callback
    });
}

        //#ifdef __WITH_AUTH
//if (apf.auth.retry) //Don't want to ruin the chances of having a smooth ride on a bad connection
//    apf.auth.loggedIn = false; //we're logged out now, we'll auto-login when going online
//#endif

var _self = this;
apf.addEventListener("exit", function(){
    return _self.dispatchEvent("losechanges");
});
*/

});
/**
 * Test Panel for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/testpanel/testpanel',['require','exports','module','core/ide','core/ext','core/util','ext/panels/panels','text!ext/testpanel/testpanel.xml','ext/filesystem/filesystem','ext/settings/settings'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var util = require("core/util");
var panels = require("ext/panels/panels");
var markup = require("text!ext/testpanel/testpanel.xml");
var fs = require("ext/filesystem/filesystem");
var settings = require("ext/settings/settings");

function escapeXpathString(name){
    if (name.indexOf('"') > -1) {
        var out = [], parts = name.split('"');
        parts.each(function(part) {
            out.push(part == '' ? "'\"'" : '"' + part + '"');
        })
        return "concat(" + out.join(", ") + ")";
    }
    return '"' + name + '"';
}

module.exports = ext.register("ext/testpanel/testpanel", {
    name            : "Test Panel",
    dev             : "Ajax.org",
    alone           : true,
    type            : ext.GENERAL,
    markup          : markup,
    appliedFilter   : "all",
    nodes           : [],
    
    defaultWidth    : 290,

    hook : function(){
        panels.register(this, {
            position : 4000,
            caption: "Test",
            "class": "testing"
        });
        
        var _self = this;

        //ide.addEventListener("init.testrunner", function(){
            apf.document.body.appendChild(new apf.state({
                id : "stTestRun"
            }));
            
            apf.document.body.appendChild(new apf.menu({
                id : "mnuRunSettings"
                //pinned : "true"
            }));
            
            //ide.removeEventListener("init.testrunner", arguments.callee);
        //});
        
        ide.addEventListener("loadsettings", function(e){
            if (!e.model.queryValue("auto/testpanel/@autorun"))
                e.model.setQueryValue("auto/testpanel/@autorun", "none");
        });
        
        ide.addEventListener("afterfilesave", function(e) {
            var autoRun = settings.model.queryValue("auto/testpanel/@autorun");
            
            if (stRunning.active)
                return;
            
            if (autoRun == "none")
                return;
            
            if (autoRun == "selection") {
                var sel = dgTestProject.getSelection();
                if (sel.length)
                    _self.run(sel);
            }
            else if (autoRun == "pattern") {
                var list = (new Function('path', _self.getPattern()))(
                    e.node.getAttribute("path"));
                
                if (!list || list.dataType != apf.ARRAY) {
                    util.alert("Wrong output from pattern",
                        "Wrong output from pattern",
                        "Pattern did not generate list of strings");
                    return;
                }
                
                var nodes = [], node;
                list.forEach(function(path){
                    node = mdlTests.queryNode("//node()[@path=" 
                        + escapeXpathString(path) + "]");
                    if (node)
                        nodes.push(node);
                });
                
                if (nodes.length)
                    _self.run(nodes);
            }
        });
    },

    init : function() {
        var _self  = this;
        this.panel = winTestPanel;
        
        this.nodes.push(winTestPanel);
        
        ide.dispatchEvent("init.testrunner");

        colLeft.appendChild(winTestPanel);
        
        mnuFilter.onitemclick = function(e){
            if (e.value && e.relatedNode.type == "radio")
                _self.filter(e.value);
        }
    
        var altKey;
        apf.addListener(document, "keydown", function(e){
            altKey = (e || event).altKey;
        });
        
        apf.addListener(document, "keyup", function(e){
            altKey = (e || event).altKey ? false : altKey;
        });
    
        dgTestProject.addEventListener("afterchoose", function(e){
            var node = this.selected;
            if (!node || this.selection.length > 1)
                return;

            //Open
            if (altKey) {
                if (node.tagName != "file"
                  || !ide.onLine && !ide.offlineFileSystemSupport)
                    return;
                        
                ide.dispatchEvent("openfile", {doc: ide.createDocument(node)});
                
                //@todo choose a test or an assert should select that code
                //      inside ace.
            }
            //Run
            else {
                if ("file|test|repo".indexOf(node.tagName) == -1 || !ide.onLine)
                    return;
                
                _self.run([node]);
            }
        });
        
        ide.addEventListener("afteroffline", function(){
            btnTestRun.disable();
            _self.stop(true);
        });
        
        ide.addEventListener("afteronline", function(){
            btnTestRun.enable();
        });
        
        this.submodules = [];
        fs.readFile("/workspace/.git/config", function(data){
            data.replace(/\[submodule "([^"]*)"\]/g, function(s, m){
                var doc = mdlTests.data.ownerDocument;
                var node = doc.createElement("repo");
                node.setAttribute("name", m);
                mdlTests.appendXml(node);
                
                _self.submodules.push(m);
            });
        });
    },
    
    getPattern : function(){
        return settings.model.queryValue("auto/testpanel/pattern/text()") ||
            "// Enter any code below that returns the paths of the tests in an array of strings.\n"
            + "// You have access to the 'path' variable.\n"
            + "// Save this file to store the pattern.\n"
            + "var tests = [];\n"
            + "return tests.pushUnique(\n"
            + "    path.replace(/(?:_test)?\.js$/, \"_test.js\"),\n"
            + "    path.replace(/(?:_Test)?\.js$/, \"Test.js\")\n"
            + ");";
    },
    
    editAutoRunPattern : function(){
        var node = apf.getXml("<file />");
        node.setAttribute("name", "Pattern.js");
        node.setAttribute("path", "/workspace/.c9.test.pattern");
        node.setAttribute("changed", "1");
        node.setAttribute("newfile", "1");
                
        var pattern = this.getPattern();
                
        var doc = ide.createDocument(node);
        doc.cachedValue = pattern;
                    
        ide.dispatchEvent("openfile", {doc: doc, node: node});
        
        ide.addEventListener("beforefilesave", function(e){
            if (e.node == node) {
                
                var value = doc.getValue();
                settings.model.setQueryValue("auto/testpanel/pattern/text()", value);
                node.removeAttribute("changed");
                node.removeAttribute("newfile");
                
                var page = tabEditors.getPage("/workspace/.c9.test.pattern");
                tabEditors.remove(page);
                
                ide.removeEventListener("beforefilesave", arguments.callee);
                
                return false;
            }
        });
    },
    
    findParent : function(path){
        var _self = this;
        for (var i = 0; i < _self.submodules.length; i++) {
            if (path.match(new RegExp("^\/workspace\/" + _self.submodules[i].replace(/\//g, "\\\/"))))
                return mdlTests.queryNode("repo[@name='" + _self.submodules[i].replace(/'/g, "\\'") + "']");
        }
        
        return mdlTests.queryNode("repo[1]");
    },
    
    filter : function(value){
        this.appliedFilter = value;
        
        dgTestProject.setAttribute("each", value == "all"
            ? "[repo|file|test|assert|error]"
            : "[repo|file[@type='" + value + "']|test|assert|error]");
    },
    
    parseFile : function(xmlNode){
        ide.dispatchEvent("test.expand." + xmlNode.getAttribute("type"), {
            xmlNode : xmlNode
        });
        
        return "<file />";
    },
    
    getIcon : function(tagName, value, type) {
        if (tagName == "repo")
            return "folder.png";
        if (tagName == "assert" || tagName == "error" || tagName == "test") {
            if (!value || value == -1)
                return "bullet_blue.png";
            else if (value == 5) //running
                return "bullet_go.png";
            else if (value == 1) //ran
                return "bullet_green.png";
            else if (value == 0) //error
                return "exclamation.png";//bullet_red.png";
        }
        if (tagName == "error")
            return "exclamation.png";
        else
            return ide.dispatchEvent("test.icon." + type) || "page_white_text.png";
    },
    
    run : function(nodes){
        var _self = this;
        
        if (!nodes || stTestRun.active)
            return;
        
        mnuRunSettings.hide();
        
        var finish = function(){
            stTestRun.deactivate();
        }
        
        //Clean nodes
        nodes.each(function(node) {
            if (node.tagName == "test")
                node = node.parentNode;
            
            var cleanNodes = node.selectNodes(".//file|.//test");
            for (var k = 0; k < cleanNodes.length; k++) {
                apf.xmldb.removeAttribute(cleanNodes[k], "status");
            }
            [".//error", ".//assert"].forEach(function(type){
                var nodes = node.selectNodes(type);
                for (var k = 0; k < nodes.length; k++) {
                    apf.xmldb.removeNode(nodes[k]);
                }
            });
        });
        
        //Expand list
        var total = [];
        nodes.each(function(node){
            if (node.tagName == "repo")
                total = total.concat(apf.getArrayFromNodelist(node.selectNodes("file" + 
                    (_self.appliedFilter == "all" 
                        ? "" 
                        : "[@type='" + _self.appliedFilter + "']"))));
            else if (node.tagName == "file")
                total.push(node);
            else if (node.tagName == "test")
                total.push(node.parentNode);
        });
        
        stTestRun.activate();
        
        var i = 0;
        var next = function(){
            if (total[i]) {
                _self.setLog(total[i], "connecting");
                ide.dispatchEvent("test.run." + total[i].getAttribute("type"), {
                    xmlNode : total[i++],
                    next    : next
                });
            }
            else {
                finish();
            }
        };
        next();
    },
    
    stop : function(immediate){
        if (!stTestRun.active)
            return;
        
        ide.dispatchEvent("test.stop");
        stTestRun.setAttribute("stopping", 1);
        
        var _self = this;
        clearTimeout(this.$stopTimer);
        this.$stopTimer = setTimeout(function(){
            ide.dispatchEvent("test.hardstop");
            
            _self.stopped();
        }, immediate ? 0 : 10000);
    },
    
    stopped : function(){
        stTestRun.deactivate();
        stTestRun.removeAttribute("stopping");
        
        clearTimeout(this.$stopTimer);
    },
    
    setPass : function(xmlNode, msg){
        apf.xmldb.setAttribute(xmlNode, "status", 1);
        apf.xmldb.setAttribute(xmlNode, "status-message", msg || "");
    },
    setError : function(xmlNode, msg){
        apf.xmldb.setAttribute(xmlNode, "status", 0);
        apf.xmldb.setAttribute(xmlNode, "status-message", msg || "");
    },
    setLog : function(xmlNode, msg){
        apf.xmldb.setAttribute(xmlNode, "status", -1);
        apf.xmldb.setAttribute(xmlNode, "status-message", msg || "");
    },
    lastExecuteNode : null,
    setExecute : function(xmlNode, msg){
        if (xmlNode) {
            apf.xmldb.setAttribute(xmlNode, "status", 5);
            apf.xmldb.setAttribute(xmlNode, "status-message", msg || "");
            
            ide.dispatchEvent("test.pointer." + apf.queryValue(xmlNode, "ancestor-or-self::test/../@type"), {
                xmlNode : xmlNode
            });
        }
        if (this.lastExecuteNode 
          && this.lastExecuteNode.getAttribute("status") == 5) {
            apf.xmldb.setAttribute(this.lastExecuteNode, "status", 1);
            apf.xmldb.setAttribute(this.lastExecuteNode, "status-message", "");
        }
        this.lastExecuteNode = xmlNode;
    },
    
    showSubmodules : true,
    toggleSubmodules : function(value){
        this.showSubmodules = value;
        
        if (value) {
            dgTestProject.setAttribute("each", 
                "[" + dgTestProject.each.replace(/repo\[1\]/, "repo") + "]");
        }
        else {
            dgTestProject.setAttribute("each", 
                "[" + dgTestProject.each.replace(/repo/, "repo[1]") + "]");
        }
    },
    
    expandTests : true,
    toggleExpandTests : function(value){
        this.expandTests = value;
        
        if (value) {
            if (!expTestRule.parentNode)
                dgTestProject.appendChild(expTestRule);
        }
        else {
            if (expTestRule.parentNode)
                dgTestProject.removeChild(expTestRule);
        }
    },
    
    show : function(){
        if (navbar.current) {
            if (navbar.current == this)
                return;
            navbar.current.disable();
        }
        
        panels.initPanel(this);
        this.enable();
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },
    
    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.stop();
        
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
        
        panels.unregister(this);
    }
});

});

/**
 * Test Panel for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/nodeunit/nodeunit',['require','exports','module','core/ide','core/ext','ext/filesystem/filesystem','ext/newresource/newresource','ext/noderunner/noderunner','ext/testpanel/testpanel','ext/console/console','text!ext/nodeunit/nodeunit.template','treehugger/js/parse','treehugger/traverse'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var fs = require("ext/filesystem/filesystem");
var newresource = require("ext/newresource/newresource");
var noderunner = require("ext/noderunner/noderunner");
var testpanel = require("ext/testpanel/testpanel");
var console = require("ext/console/console");
var template = require("text!ext/nodeunit/nodeunit.template");

var parser = require("treehugger/js/parse");
require("treehugger/traverse");

function escapeXpathString(name){
    if (name.indexOf('"') > -1) {
        var out = [], parts = name.split('"');
        parts.each(function(part) {
            out.push(part == '' ? "'\"'" : '"' + part + '"');
        })
        return "concat(" + out.join(", ") + ")";
    }
    return '"' + name + '"';
}

module.exports = ext.register("ext/nodeunit/nodeunit", {
    name            : "Node Unit Test Manager",
    dev             : "Ajax.org",
    alone           : true,
    type            : ext.GENERAL,
    nodes           : [],
    template        : template,

    hook : function(){
        var _self = this;
        ide.addEventListener("init.ext/testpanel/testpanel", function(){
            ext.initExtension(_self);
        });
    },

    init : function() {
        var _self = this;

        this.nodes.push(
            mnuFilter.insertBefore(new apf.item({
                type    : "radio",
                value   : "nodeunit",
                caption : "Node Unit Tests"
            }), mnuFilter.getElementsByTagNameNS(apf.ns.aml, "divider")[1]),

            mnuTestNew.appendChild(new apf.item({
                caption : "Node Unit Test",
                onclick : function(){
                    _self.createAndOpenTest();
                }
            }))
        );

        davProject.report(ide.davPrefix, 'filelist', {},
          function(data, state, extra){
            if (state == apf.ERROR) {
                if (data && data.indexOf("jsDAV_Exception_FileNotFound") > -1) {
                    return;
                }

                //@todo
                return;
            }
            if (state == apf.TIMEOUT)
                return; //@todo

            var nodes = data.selectNodes("//d:href");
            for (var node, i = 0; i < nodes.length; i++) {
                node = nodes[i];

                //@todo support for submodules
                if (node.firstChild.nodeValue.match(/_test\.js$/)) {
                    var file = apf.getXml("<file />");
                    var path = ide.davPrefix + "/" + node.firstChild.nodeValue;
                    file.setAttribute("name", path.split("/").pop());
                    file.setAttribute("path", path);
                    file.setAttribute("type", "nodeunit");
                    apf.xmldb.appendChild(testpanel.findParent(path), file);
                }
            }
        });

        ide.addEventListener("afterfilesave", function(e){
            var node = e.node;
            var name = node.getAttribute("name");
            if (!name.match(/_test.js$/))
                return;

            var path = node.getAttribute("path");
            var fileNode = mdlTests.queryNode("//file[@path=" + escapeXpathString(path) + "]");
            if (!fileNode) {
                fileNode = apf.xmldb.getCleanCopy(node);
                fileNode.setAttribute("type", "nodeunit");
                apf.xmldb.appendChild(testpanel.findParent(path), fileNode);
            }
        });

        ide.addEventListener("test.expand.nodeunit", function(e){
            var xmlNode = e.xmlNode;
            _self.reloadTestFile(xmlNode);
        });

        ide.addEventListener("test.stop", function(e){
            if (!_self.running)
                return;
            _self.stop();
        });

        ide.addEventListener("test.icon.nodeunit", function(e){
            return "page_white_code.png";
        });

        ide.addEventListener("test.run.nodeunit", function(e){
            var fileNode = e.xmlNode;
            var next    = e.next;

            console.autoOpen = false;

            _self.stopping     = false;
            _self.running      = true;
            _self.lastTestNode = fileNode;

            testpanel.setLog(fileNode, "running");

            //@todo this should be loaded via file contents
            if (testpanel.expandTests) {
                if (dgTestProject.$hasLoadStatus(fileNode, "potential"))
                    dgTestProject.slideOpen(null, fileNode);
                else {
                    _self.reloadTestFile(fileNode);
                }
            }

            var timer = setInterval(function(){
                if (fileNode.selectNodes("test").length) {
                    clearTimeout(timer);
                    parseMessage({data: ""})
                }
            }, 10);

            var stack = [];
            ide.addEventListener("socketMessage", function(e){
                //@todo testpanel.setLog(node, "started");

                if (e.message.type == "node-data") {
                    parseMessage(e.message);
                }
                else if (e.message.type.indexOf("node-exit") > -1) {
                    ide.removeEventListener("socketMessage", arguments.callee);
                    if (_self.stopping)
                        _self.stopped();
                    else {
                        _self.running = false;
                        if (fileNode.getAttribute("status") == -1)
                            testpanel.setError(fileNode, "failed");
                        if (!stProcessRunning.active)
                            next();
                        else {
                            stProcessRunning.addEventListener("deactivate", function(){
                                next();
                                stProcessRunning.removeEventListener("deactivate", arguments.callee);
                            });
                        }
                    }
                }
            });

            function completed(){
                var nodes = apf.queryNodes(fileNode, "test[@status=0 or error]");

                if (_self.stopping) {
                    testpanel.setError(fileNode, "Test Cancelled");
                    return;
                }
                else if (nodes.length)
                    testpanel.setError(fileNode, "Failed " + (nodes.length)
                        + " tests of " + fileNode.selectNodes("test").length);
                else
                    testpanel.setPass(fileNode,
                        "(" + fileNode.selectNodes("test").length + ")");
            }

            function parseMessage(message){
                var data;
                if (stack.length) {
                    data = stack.join("") + message.data;
                    stack = [];
                }
                else
                    data = message.data;

                //Parse

                //Remove summary
                data = data.replace(/\s*Summary\:\s+Total number of tests[\s\S]*$/, "");
                data = data.substr(1);
                var parts = data.match(/\[(\d+)m[\s\S]*?(?:$|(?=\[[1-9]\d*m))/g);
                if (!parts)
                    return;

                var match;
                for (var i = 0; i < parts.length; i++) {
                    var part = parts[i];
                    //FAIL
                    if (part.substr(0, 3) == "[31") {
                        match = part.match(/^\[31m\[(\d+)\/(\d+)\]\s+(.*?)\s+FAIL.*([\S\s]*?)(?=\[\d+m|$)/);
                        if(!match)
                            continue;

                        var testNode = fileNode.selectSingleNode("test[@name=" + escapeXpathString(match[3]) + "]");
                        if (!testNode) {
                            var doc  = fileNode.ownerDocument;
                            testNode = doc.createElement("test");
                            testNode.setAttribute("name", match[3]);
                            apf.xmldb.appendChild(fileNode, testNode);
                        }
                        //fileNode.addNode();
                        testpanel.setError(testNode, "Test Failed");
                        testpanel.setLog(fileNode, "completed test " + match[2] + " of " + match[1]);

                        var errorNode = testNode.ownerDocument
                            .createElement("error");
                        errorNode.setAttribute("name", match[4]);
                        apf.xmldb.appendChild(testNode, errorNode);

                        if (match[2] == match[1])
                            completed();
                    }
                    //PASS
                    //[32m[4/1] test basic addition OK[0m
                    else if (part.substr(0, 3) == "[32") {
                        match = part.match(/^\[32m\[(\d+)\/(\d+)\]\s+(.*?)\sOK[\s\S]{4,6}/);
                        if(!match)
                            continue;

                        var testNode = fileNode.selectSingleNode("test[@name=" + escapeXpathString(match[3]) + "]");
                        if(!testNode) {
                            var doc  = fileNode.ownerDocument;
                            testNode = doc.createElement("test");
                            testNode.setAttribute("name", match[3]);
                            apf.xmldb.appendChild(fileNode, testNode);
                        }
                        testpanel.setPass(testNode);
                        testpanel.setLog(fileNode, "completed test " + match[2] + " of " + match[1]);

                        if (match[2] == match[1])
                            completed();
                    }
                }
            }

            var path = fileNode.getAttribute("path")
                .slice(ide.davPrefix.length + 1)
                .replace("//", "/");

            noderunner.run(path, [], false);
        });

        ide.addEventListener("socketMessage", function(e) {
            if (_self.disabled) return;

            var message = e.message;
            if ((message.type && message.type != "watcher") || !message.path)
                return;

            var path = message.path.slice(ide.workspaceDir.length);

            if (path != _self.testpath)
                return;

            switch (message.subtype) {
                case "create":
                    //Add file to model
                    break;
                case "remove":
                    //Remove file from model
                    break;
                case "change":
                    //Reread file and put tests update in model
                    var xmlNode = mdlTests.selectSingleNode("//file[@path='" + message.path + "']");
                    _self.reloadTestFile(xmlNode);
                    break;
            }
        });

        this.enable();
    },

    stop : function(){
        this.stopping = true;

        if (this.lastTestNode) {
            testpanel.setLog(this.lastTestNode.tagName == "file"
                ? this.lastTestNode
                : this.lastTestNode.parentNode, "Stopping...");
        }

        noderunner.stop();
    },

    stopped : function(msg){
        this.stopping = false;
        this.running  = false;

        testpanel.stopped();

        console.autoOpen = true;
    },

    createAndOpenTest : function(){
        var _self = this;
        var path  = (ide.davPrefix + "/" + this.testpath).split("/");
        var stack = [];

        var recur = function(){
            stack.push(path.shift());

            if (path.length == 0) {
                newresource.newfile("_test.js", _self.template,
                  ide.davPrefix + "/");
                return;
            }

            fs.exists(stack.join("/") + "/" + path[0], function(data, state, extra){
                if (data) {
                    recur();
                }
                else {
                    fs.webdav.exec("mkdir",
                      [stack.join("/"), path[0]], function(data) {
                        recur();
                    });
                }
            });
        }

        recur();
    },

    reloadTestFile : function(xmlNode) {
        fs.readFile(xmlNode.getAttribute("path"), function(data, state, extra){
            if (state == apf.SUCCESS) {
                var node, found = [];

                var ast = parser.parse(data);
                var doc  = xmlNode.ownerDocument;
                ast.traverseTopDown(
                    'Assign(PropAccess(Var("module"),"exports"), ObjectInit(inits))', function(b) {
                        b.inits.forEach(function(init) {
                            // init now contains PropertyInit("name", value) nodes, first branch is the name node
                            var name = init[0].value;

                            node = xmlNode.selectSingleNode("test[@name="
                              + escapeXpathString(name) + "]");

                            if (!node) {
                                node = doc.createElement("test");
                                node.setAttribute("name", name);

                                apf.xmldb.appendChild(xmlNode, node);
                            }

                            found.push(node);
                        });
                    }
                );

                var nodes = xmlNode.childNodes;
                for (var i = nodes.length - 1; i >= 0; i--) {
                    if (found.indexOf(nodes[i]) == -1)
                        apf.xmldb.removeNode(nodes[i]);
                }
            }
        });
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });

//@todo this is much more complex
//        ide.send({
//            "command"     : "watcher",
//            "type"        : "watchFile",
//            "path"        : this.testpath
//        });

        this.disabled = false;
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });

//        ide.send({
//            "command"     : "watcher",
//            "type"        : "unwatchFile",
//            "path"        : this.testpath
//        });

        this.disabled = true;
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];

        testpanel.unregister(this);
    }
});

});

/**
 * auto test Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
 
define('ext/autotest/autotest',['require','exports','module','core/ide','core/ext','ext/noderunner/noderunner','ext/filesystem/filesystem'],function(require, exports, module) {

var ide = require("core/ide");
var ext = require("core/ext");
var noderunner = require("ext/noderunner/noderunner");
var fs = require("ext/filesystem/filesystem");

module.exports = ext.register("ext/autotest/autotest", {
    name    : "autotest",
    dev     : "Ajax.org",
    type    : ext.GENERAL,
    alone   : true,

    hook : function() {
        ide.addEventListener("afterfilesave", function(e) {
            var node = e.node;

            var path = node.getAttribute("path");
            var m = path.match(/^.*(_test|Test)\.js$/);
            if (m) {
                run(path);
            } else {
                var testPath = path.replace(/\.js$/, "_test.js");
                if (path == testPath) return;
                fs.exists(testPath, function(exists) {
                    if (exists)
                        run(testPath);
                        
                    testPath = path.replace(/\.js$/, "Test.js");
                    if (path == testPath) return;
                    fs.exists(testPath, function(exists) {
                        if (exists)
                            run(testPath);
                    });
                });
            }
            
            function run(path) {
                path = path.slice(ide.davPrefix.length + 1).replace("//", "/");
                //console.log("running test", path);
                noderunner.run(path, [], false);
            }
        });
    },

    init : function(amlNode) {
    },
    
    enable : function() {
    },

    disable : function() {
    },

    destroy : function() {
    }
});

});
/**
 * Code Editor for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/debugger/debugger',['require','exports','module','apf/elements/codeeditor','core/ide','core/ext','ext/editors/editors','ext/dockpanel/dockpanel','ext/filesystem/filesystem','ext/noderunner/noderunner','text!ext/debugger/debugger.xml','ext/debugger/inspector','ext/settings/settings','ext/keybindings/keybindings','ext/debugger/debugger','ext/runpanel/runpanel'],function(require, exports, module) {

require("apf/elements/codeeditor");

var ide = require("core/ide");
var ext = require("core/ext");
var editors = require("ext/editors/editors");
var dock   = require("ext/dockpanel/dockpanel");
var fs = require("ext/filesystem/filesystem");
var noderunner = require("ext/noderunner/noderunner");
var markup = require("text!ext/debugger/debugger.xml");
var inspector = require("ext/debugger/inspector");
var settings = require("ext/settings/settings");

module.exports = ext.register("ext/debugger/debugger", {
    name    : "Debug",
    dev     : "Ajax.org",
    type    : ext.GENERAL,
    alone   : true,
    offline : false,
    markup  : markup,
    buttonClassName : "debug1",
    deps    : [fs, noderunner],
    commands: {
        "resume"   : {hint: "resume the current paused process"},
        "stepinto" : {hint: "step into the function that is next on the execution stack"},
        "stepover" : {hint: "step over the current expression on the execution stack"},
        "stepout"  : {hint: "step out of the current function scope"}
    },

    nodesAll: [],
    nodes : [],
    hotitems: {},

    hook : function(){
        var _self = this;

        ide.addEventListener("consolecommand.debug", function(e) {
            ide.send({
                command: "internal-isfile",
                argv: e.data.argv,
                cwd: e.data.cwd,
                sender: "debugger"
            });
            return false;
        });

        ide.addEventListener("loadsettings", function (e) {
            // restore the breakpoints from the IDE settings
            var bpFromIde = e.model.data.selectSingleNode("//breakpoints");
            // not there yet, create element
            if (!bpFromIde) {
                bpFromIde = e.model.data.ownerDocument.createElement("breakpoints");
                e.model.data.appendChild(bpFromIde);
            }
            // bind it to the Breakpoint model
            mdlDbgBreakpoints.load(bpFromIde);
        });

        stDebugProcessRunning.addEventListener("activate", function() {
            _self.activate();
        });
        stProcessRunning.addEventListener("deactivate", function() {
            _self.deactivate();
        });

        ide.addEventListener("afteropenfile", function(e) {
            var doc = e.doc;
            var node = e.node;
            if (!node)
                return;
            var path = node.getAttribute("path");

            node.setAttribute("scriptname", ide.workspaceDir + path.slice(ide.davPrefix.length));
        });

        var name = "ext/debugger/debugger"; //this.name

        dock.addDockable({
            expanded : -1,
            width    : 300,
            sections : [
                {
                    height     : 30,
                    width      : 150,
                    noflex     : true,
                    draggable  : false,
                    resizable  : false,
                    skin       : "dockwin_runbtns",
                    noTab      : true,
                    position   : 1,

                    buttons : [{
                        id      : "btnRunCommands",
                        caption : "Run Commands",
                        "class" : "btn-runcommands",
                        ext     : [name, "pgDebugNav"],
                        draggable: false,
                        hidden  : true
                    }]
                },
                {
                    width : 250,
                    height : 300,
                    buttons : [
                        { caption: "Call Stack", ext : [name, "dbgCallStack"], hidden: true}
                    ]
                },
                {
                    width : 250,
                    height : 300,
                    buttons : [
                        { caption: "Interactive", ext : [name, "dbInteractive"], hidden: true},
                        { caption: "Variables", ext : [name, "dbgVariable"], hidden: true},
                        { caption: "Breakpoints", ext : [name, "dbgBreakpoints"], hidden: true}
                    ]
                }
            ]
        });

        dock.register(name, "pgDebugNav", {
            menu : "Run Commands",
            primary : {
                backgroundImage: ide.staticPrefix + "/style/images/debugicons.png",
                defaultState: { x: -6, y: -265 },
                activeState: { x: -6, y: -265 }
            }
        }, function(type) {
            ext.initExtension(_self);
            return pgDebugNav;
        });

        dock.register(name, "dbgCallStack", {
            menu : "Debugger/Call Stack",
            primary : {
                backgroundImage: ide.staticPrefix + "/style/images/debugicons.png",
                defaultState: { x: -8, y: -47 },
                activeState: { x: -8, y: -47 }
            }
        }, function(type) {
            ext.initExtension(_self);
            return dbgCallStack;
        });

        dock.register(name, "dbInteractive", {
            menu : "Debugger/Interactive",
            primary : {
                backgroundImage: ide.staticPrefix + "/style/images/debugicons.png",
                defaultState: { x: -8, y: -130 },
                activeState: { x: -8, y: -130 }
            }
        }, function(type) {
            ext.initExtension(_self);
            return dbInteractive;
        });

        dock.register(name, "dbgVariable", {
            menu : "Debugger/Variables",
            primary : {
                backgroundImage: ide.staticPrefix + "/style/images/debugicons.png",
                defaultState: { x: -8, y: -174 },
                activeState: { x: -8, y: -174 }
            }
        }, function(type) {
            ext.initExtension(_self);

            // Why is this code here? This is super hacky and has lots of
            // unwanted side effects (Ruben)
            // when visible -> make sure to refresh the grid
            dbgVariable.addEventListener("prop.visible", function(e) {
                if (e.value && self.dgVars) {
                    dgVars.reload();
                }
            });

            return dbgVariable;
        });

        dock.register(name, "dbgBreakpoints", {
            menu : "Debugger/Breakpoints",
            primary : {
                backgroundImage: ide.staticPrefix + "/style/images/debugicons.png",
                defaultState: { x: -8, y: -88 },
                activeState: { x: -8, y: -88 }
            }
        }, function(type) {
            ext.initExtension(_self);
            return dbgBreakpoints;
        });
    },

    init : function(amlNode){
        var _self = this;

        this.paths = {};

        mdlDbgSources.addEventListener("afterload", function() {
            _self.$syncTree();
        });
        mdlDbgSources.addEventListener("update", function(e) {
            if (e.action !== "add") return;

            // TODO: optimize this!
            _self.$syncTree();
        });
        fs.model.addEventListener("update", function(e) {
            if (e.action != "insert")
                return;
            // TODO: optimize this!
            _self.$syncTree();
        });

        //@todo move this to noderunner...
        dbg.addEventListener("changeframe", function(e) {
            e.data && _self.showDebugFile(e.data.getAttribute("scriptid"));
        });

        pgDebugNav.addEventListener("afterrender", function(){
            _self.hotitems["resume"]   = [btnResume];
            _self.hotitems["stepinto"] = [btnStepInto];
            _self.hotitems["stepover"] = [btnStepOver];
            _self.hotitems["stepout"]  = [btnStepOut];

            require("ext/keybindings/keybindings").update(_self);
        });

        dbgBreakpoints.addEventListener("afterrender", function(){
            lstBreakpoints.addEventListener("afterselect", function(e) {
                if (e.selected && e.selected.getAttribute("scriptid"))
                    _self.showDebugFile(e.selected.getAttribute("scriptid"),
                        parseInt(e.selected.getAttribute("line"), 10) + 1);
                // TODO sometimes we don't have a scriptID
            });
        });

        dbgBreakpoints.addEventListener("dbInteractive", function(){
            lstScripts.addEventListener("afterselect", function(e) {
                e.selected && require("ext/debugger/debugger")
                    .showDebugFile(e.selected.getAttribute("scriptid"));
            });
        });

        ide.addEventListener("afterfilesave", function(e) {
            var node = e.node;
            var doc = e.doc;

            var scriptId = node.getAttribute("scriptid");
            if (!scriptId)
                return;

            var value = e.value || doc.getValue();
            var NODE_PREFIX = "(function (exports, require, module, __filename, __dirname) { ";
            var NODE_POSTFIX = "\n});";
            dbg.changeLive(scriptId, NODE_PREFIX + value + NODE_POSTFIX, false, function(e) {
                //console.log("v8 updated", e);
            });
        });

        // we're subsribing to the 'running active' prop
        // this property indicates whether the debugger is actually running (when on a break this value is false)
        stRunning.addEventListener("prop.active", function (e) {
            // if we are really running (so not on a break or something)
            if (e.value) {
                // we clear out mdlDbgStack
                mdlDbgStack.load("<frames></frames>");
            }
        });
    },

    showDebugFile : function(scriptId, row, column, text) {
        var file = fs.model.queryNode("//file[@scriptid='" + scriptId + "']");

        // check prerequisites
        if (self.ceEditor && !ceEditor.$updateMarkerPrerequisite()) {
            return;
        }

        if (file) {
            editors.jump(file, row, column, text, null, true);
        }
        else {
            var script = mdlDbgSources.queryNode("//file[@scriptid='" + scriptId + "']");
            if (!script)
                return;

            var name = script.getAttribute("scriptname");
            var value = name.split("/").pop();

            if (name.indexOf(ide.workspaceDir) === 0) {
                var path = ide.davPrefix + name.slice(ide.workspaceDir.length);
                // TODO this has to be refactored to support multiple tabs
                var page = tabEditors.getPage(path);
                if (page)
                    var node = page.xmlRoot;
                else {
                    var node = apf.n("<file />")
                        .attr("name", value)
                        .attr("path", path)
                        .attr("contenttype", "application/javascript")
                        .attr("scriptid", script.getAttribute("scriptid"))
                        .attr("scriptname", script.getAttribute("scriptname"))
                        .attr("lineoffset", "0").node();
                }
                editors.jump(node, row, column, text, null, page ? true : false);
            }
            else {
                var page = tabEditors.getPage(value);
                if (page)
                    editors.jump(page.xmlRoot, row, column, text, null, true);
                else {
                    var node = apf.n("<file />")
                        .attr("name", value)
                        .attr("path", name)
                        .attr("contenttype", "application/javascript")
                        .attr("scriptid", script.getAttribute("scriptid"))
                        .attr("scriptname", script.getAttribute("scriptname"))
                        .attr("debug", "1")
                        .attr("lineoffset", "0").node();

                    dbg.loadScript(script, function(source) {
                        var doc = ide.createDocument(node, source);
                        editors.jump(node, row, column, text, doc);
                    });
                }
            }
        }
    },

    count : 0,
    $syncTree : function() {
        if (this.inSync) return;
        this.inSync = true;
        var dbgFiles = mdlDbgSources.data.childNodes;

        var workspaceDir = ide.workspaceDir;
        for (var i=0,l=dbgFiles.length; i<l; i++) {
            var dbgFile = dbgFiles[i];
            var name = dbgFile.getAttribute("scriptname");
            if (name.indexOf(workspaceDir) !== 0)
                continue;
            this.paths[name] = dbgFile;
        }
        var treeFiles = fs.model.data.getElementsByTagName("file");
        var tabFiles = ide.getAllPageModels();
        var files = tabFiles.concat(Array.prototype.slice.call(treeFiles, 0));

        var davPrefix = ide.davPrefix;
        for (var i=0,l=files.length; i<l; i++) {
            var file = files[i];
            var path = file.getAttribute("scriptname");

            var dbgFile = this.paths[path];
            if (dbgFile)
                apf.b(file).attr("scriptid", dbgFile.getAttribute("scriptid"));
        }
        this.inSync = false;
    },

    activate : function(){
        ext.initExtension(this);

        this.nodes.each(function(item){
            if (item.show)
                item.show();
        });
    },

    deactivate : function(){
        this.nodes.each(function(item){
            if (item.hide)
                item.hide();
        });
    },

    enable : function(){
        if (!this.disabled) return;

        this.nodesAll.each(function(item){
            item.setProperty("disabled", item.$lastDisabled !== undefined
                ? item.$lastDisabled
                : true);
            delete item.$lastDisabled;
        });
        this.disabled = false;
    },

    disable : function(){
        if (this.disabled) return;

        //stop debugging
        require('ext/runpanel/runpanel').stop();
        this.deactivate();

        //loop from each item of the plugin and disable it
        this.nodesAll.each(function(item){
            if (!item.$lastDisabled)
                item.$lastDisabled = item.disabled;
            item.disable();
        });

        this.disabled = true;
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
            dock.unregisterPage(item);
        });

        tabDebug.destroy(true, true);
        this.$layoutItem.destroy(true, true);

        this.nodes = [];
    }
});

});

/**
 * Live object inspection for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/debugger/inspector',['require','exports','module','ext/console/console','ext/console/logger','ext/settings/settings'],function(require, exports, module) {

var Console = require("ext/console/console");
var Logger  = require("ext/console/logger");

exports.evaluate = function(expression, callback){
    var _self = this;
    var frame = (self.dgStack && dgStack.selected && dgStack.selected.getAttribute("ref")) || null;

    dbg.evaluate(expression, frame, null, null, callback || exports.showObject);
};

exports.checkChange = function(xmlNode){
    var value = xmlNode.getAttribute("value");
    if (xmlNode.tagName == "method" || "Boolean|String|undefined|null|Number".indexOf(xmlNode.getAttribute("type")) == -1)
        return false;
};

exports.applyChange = function(xmlNode){
    var value = xmlNode.getAttribute("value");
    var name = exports.calcName(xmlNode);
    try {
        if (name.indexOf(".") > -1) {
            var prop, obj = self.parent.eval(name.replace(/\.([^\.\s]+)$/, ""));
            if (obj && obj.$supportedProperties && obj.$supportedProperties.contains(prop = RegExp.$1)) {
                obj.setProperty(prop, self.parent.eval(value));
                return;
            }
        }

        self.parent.eval(name + " = " + value);

        //@todo determine new type
    }
    catch(e) {
        trObject.getActionTracker().undo();
        alert("Invalid Action: " + e.message);
        //@todo undo
    }
};

exports.consoleTextHandler = function(e) {
    if (!(e.keyCode == 13 && e.ctrlKey))
        return;

    var _self = this;

    var expression = txtCode.getValue().trim();
    if (!expression)
        return;

    Console.showOutput();
    Logger.log(expression, "command", null, null, true);

    this.evaluate(expression, function(xmlNode, body, refs, error){
        if (error) {
            Logger.log(error.message, "error");
        }
        else {
            var type      = body.type,
                value     = body.value || body.text,
                ref       = body.handle,
                className = body.className;

            if (className == "Function") {
                var pre = "<a class='xmlhl' href='javascript:void(0)' style='font-weight:bold;font-size:7pt;color:green' onclick='require(\"ext/debugger/inspector\").showObject(null, ["
                    + body.scriptId + ", " + body.line + ", " + body.position + ", "
                    + body.handle + ",\"" + (body.name || body.inferredName) + "\"], \""
                    + (expression || "").split(";").pop().replace(/"/g, "\\&quot;") + "\")'>";
                var post = "</a>";
                var name = body.name || body.inferredName || "function";
                Logger.log(name + "()", "log", pre, post, true);
            }
            else if (className == "Array") {
                var pre = "<a class='xmlhl' href='javascript:void(0)' style='font-weight:bold;font-size:7pt;color:green' onclick='require(\"ext/debugger/inspector\").showObject(\""
                    + apf.escapeXML(xmlNode.xml.replace(/"/g, "\\\"")) + "\", "
                    + ref + ", \"" + apf.escapeXML((expression || "").trim().split(/;|\n/).pop().trim().replace(/"/g, "\\\"")) + "\")'>";
                var post = " }</a>";

                Logger.log("Array { length: "
                    + (body.properties && body.properties.length - 1), "log", pre, post, txtOutput);
            }
            else if (type == "object") {
                var refs = [], props = body.properties;
                for (var i = 0, l = body.properties.length; i < l; i++)
                    refs.push(props[i].ref);

                var pre = "<a class='xmlhl' href='javascript:void(0)' style='font-weight:bold;font-size:7pt;color:green' onclick='require(\"ext/debugger/inspector\").showObject(\""
                    + apf.escapeXML(xmlNode.xml.replace(/"/g, "\\\"")) + "\", "
                    + ref + ", \"" + apf.escapeXML((expression || "").trim().split(/;|\n/).pop().trim().replace(/"/g, "\\\"")) + "\")'>";
                var post = " }</a>";

                dbg.$debugger.$debugger.lookup(refs, false, function(body) {
                    var out = [className || value, "{"];
                    for (var item, t = 0, i = 0; i < l; i++) {
                        item = body[refs[i]];
                        if (item.className == "Function" || item.className == "Object")
                            continue;
                        if (t == 5) {
                            out.push("more...");
                            break;
                        }
                        var name = props[i].name || (props[i].inferredName || "Unknown").split(".").pop();
                        out.push(name + "=" + item.value, ", ");
                        t++;
                    }
                    if (t) out.pop();

                    Logger.log(out.join(" "), "log", pre, post, true);
                });
            }
            else
                Logger.log(value, "log", null, null, true);
        }
    });

    require("ext/settings/settings").save();
    return false;
};

exports.showObject = function(xmlNode, ref, expression) {
    if (ref && ref.dataType == apf.ARRAY) {
        require(["ext/debugger/debugger"], function(dbg) {
            dbg.showDebugFile(ref[0], ref[1] + 1, 0, ref[4]);
        });
    }
    else {
        require(["ext/quickwatch/quickwatch"], function(quickwatch) {
            quickwatch.toggleDialog(1);

            if (xmlNode && typeof xmlNode == "string")
                xmlNode = apf.getXml(xmlNode);

            var name = xmlNode && xmlNode.getAttribute("name") || expression;
            txtCurObject.setValue(name);
            dgWatch.clear("loading");

            if (xmlNode) {
                setTimeout(function(){
                    var model = dgWatch.getModel();
                    var root  = apf.getXml("<data />");
                    apf.xmldb.appendChild(root, xmlNode);
                    model.load(root);
                    //model.appendXml(xmlNode);
                }, 10);
            }
            else if (ref) {

            }
            else {
                exports.evaluate(expression);
            }
        });

    }
};

var types    = ["Object", "Number", "Boolean", "String", "Array", "Date", "RegExp", "Function", "Object"];
var domtypes = [
    null, "Element", "Attr", "Text", "CDataSection",
    "EntityReference", "Entity", "ProcessingInstruction", "Comment",
    "Document", "DocumentType", "DocumentFragment", "Notation"
];

exports.calcName = function(xmlNode, useDisplay){
    var isMethod = xmlNode.tagName == "method";
    var name, loopNode = xmlNode, path = [];
    do {
        name = useDisplay
            ? loopNode.getAttribute("display") || loopNode.getAttribute("name")
            : loopNode.getAttribute("name");

        if (!name)
            break;

        var xmlDecode = function (input) {
            var e = document.createElement('div');
            e.innerHTML = input;
            return e.childNodes.length === 0 ? "" : e.childNodes[0].nodeValue;
        }

        name = xmlDecode(name);

        path.unshift(!name.match(/^[a-z_\$][\w_\$]*$/i)
            ? (parseInt(name, 10) == name
                ? "[" + name + "]"
                : "[\"" + name + "\"]")
            : name);
        loopNode = loopNode.parentNode;
        if (isMethod) {
            loopNode = loopNode.parentNode;
            isMethod = false;
        }
    }
    while (loopNode && loopNode.nodeType == 1);

    if (!path[0])
        return "";
    else if (path[0].charAt(0) == "[")
        path[0] = path[0].substr(2, path[0].length - 4);

    return path.join(".").replace(/\.\[/g, "[");
};

/**
 * Given an xmlNode determines whether this item can be edited in realtime
 */
exports.isEditable = function(xmlNode) {
    if (!xmlNode) return false;

    var type = xmlNode.getAttribute("type");

    // we can edit these types
    switch (type) {
        case "string":
        case "null":
        case "number":
        case "boolean":
            break;
        default:
            return false;
    }

    // V8 debugger cannot change variables that are locally scoped, so we need at least
    // one parent property.
    if (exports.calcName(xmlNode, true).indexOf(".") === -1) {
        return false;
    }

    // ok, move along
    return true;
};

/**
 * Determines whether a new value is valid to pass into an attribute
 */
exports.validateNewValue = function(xmlNode, value) {
    var type = xmlNode.getAttribute("type");
    var validator;

    switch (type) {
        case "string":
        case "null":
            validator = /(.*|^$)/;
            break;
        case "number":
            validator = /^\d+(\.\d+)?$/;
            break;
        case "boolean":
            validator = /^(true|false)$/;
            break;
        default:
            return false; // other types cannot be edited
    }

    return validator.test(value);
};

/**
 * Updates the value of a property to a new value
 */
exports.setNewValue = function(xmlNode, value, callback) {
    // find the prop plus its ancestors
    var expression = exports.calcName(xmlNode, true);

    // build an instruction for the compiler
    var instruction;
    switch (xmlNode.getAttribute("type")) {
        case "string":
        case "null":
            // escape strings
            instruction = expression + " = \"" + value.replace(/"/g, "\\\"") + "\"";
            break;
        default:
            instruction = expression + " = " + value;
            break;
    }

    // dispatch it to the debugger
    exports.evaluate(instruction, callback);
};

});

/**
 * quickwatch Module for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/quickwatch/quickwatch',['require','exports','module','core/ext','ext/editors/editors','ext/noderunner/noderunner','text!ext/quickwatch/quickwatch.xml','ext/debugger/inspector','ext/debugger/inspector'],function(require, exports, module) {

var ext = require("core/ext");
var editors = require("ext/editors/editors");
var noderunner = require("ext/noderunner/noderunner");
var markup = require("text!ext/quickwatch/quickwatch.xml");

module.exports = ext.register("ext/quickwatch/quickwatch", {
    name    : "quickwatch",
    dev     : "Ajax.org",
    type    : ext.GENERAL,
    alone   : true,
    markup  : markup,
    deps   : [noderunner],
    commands : {
        "quickwatch": {hint: "quickly inspect the variable that is under the cursor"}
    },
    hotitems: {},

    nodes   : [],

    hook : function(){
    },

    init : function(amlNode){
        txtCurObject.addEventListener("keydown", function(e){
            if (e.keyCode == 13) {
                if (!this.value.trim())
                    return dgWatch.clear();

                require("ext/debugger/inspector").evaluate(this.value);
            }
            else if (e.keyCode == 40 && dgWatch.length) {
                var first = dgWatch.getFirstTraverseNode();
                if (first) {
                    dgWatch.select(first);
                    dgWatch.focus();
                }
            }
        });

        var restricted = [38, 40, 36, 35];
        dgWatch.addEventListener("keydown", function(e) {
            if (e.keyCode == 38) {
                if (this.selected == this.getFirstTraverseNode())
                    txtCurObject.focus();
            }
            else if (restricted.indexOf(e.keyCode) == -1) {
                txtCurObject.focus();
            }
        }, true);
    },

    toggleDialog: function(force, exec) {
        ext.initExtension(this);

        if (!winQuickWatch.visible || force == 1) {
            var editor = editors.currentEditor;

            var range;
            var sel   = editor.getSelection();
            var doc   = editor.getDocument();
            if (sel.isEmpty()) {
                var cursor = sel.getCursor();
                range = doc.getWordRange(cursor.row, cursor.column);
            }
            else
                range = sel.getRange();
            var value = doc.getTextRange(range);

            if (value) {
                txtCurObject.setValue(value);
                if (exec) {
                    require("ext/debugger/inspector").evaluate(value);
                    txtCurObject.focus();
                }
            }

            winQuickWatch.show();
        }
        else
            winQuickWatch.hide();

        return false;
    },

    quickwatch : function(){
        this.toggleDialog(1, true);
    },

    enable : function(){
        this.nodes.each(function(item){
            item.enable();
        });
    },

    disable : function(){
        this.nodes.each(function(item){
            item.disable();
        });
    },

    destroy : function(){
        this.nodes.each(function(item){
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});
// this module adds inline variable inspecting + editing to cloud9
define('ext/language/liveinspect',['require','exports','module','core/ide','ext/debugger/inspector','core/ext','text!ext/language/liveinspect.xml','text!ext/language/liveinspect.skin.xml','ext/debugger/debugger'],function(require, exports, module) {

var ide = require("core/ide");
var inspector = require("ext/debugger/inspector");
var ext = require("core/ext");
var markup = require("text!ext/language/liveinspect.xml");
var skin = require("text!ext/language/liveinspect.skin.xml");
// postfix plugin because debugger is restricted keyword
var debuggerPlugin = require("ext/debugger/debugger"); 

module.exports = (function () {
    
    var activeTimeout = null;
    var windowHtml = null;
    var datagridHtml = null;
    var currentExpression = null;
    
    var init = function () {
        // get respective HTML elements
        windowHtml = winLiveInspect.$ext;
        datagridHtml = dgLiveInspect.$ext;
        winLiveInspect.addEventListener("prop.visible", function(e) {
            // don't track when hiding the window
            if (!e.value)
                return;
            ide.dispatchEvent("track_action", {
                type: "live inspect code",
                expression: currentExpression || "no expression available yet."
            });
        });
        
        ide.addEventListener("language.worker", function(e){
            // listen to the worker's response
            e.worker.on("inspect", function(event) {
                if (!event || !event.data) {
                    winLiveInspect.hide();
                    return;
                }
                
                // create an expression that the debugger understands
                var expression = event.data;
                if (expression) {
                    liveWatch(expression);
                }
            });
        });
        
        // bind mous events to all open editors
        ide.addEventListener("afteropenfile", function (e) {
            if (e.editor && e.editor.ceEditor) {
                var editor = e.editor.ceEditor;
                
                editor.$editor.addEventListener("mousemove", onEditorMouseMove);
                
                // when you click, or change the cursor position, then hide the window
                editor.$editor.addEventListener("mousedown", onEditorClick);
                editor.getSession().getSelection().addEventListener("changeCursor", onEditorClick);
            }
        });
        
        ide.addEventListener("init.ext/debugger/debugger", function(){
            // listen to changes that affect the debugger, so we can toggle the visibility based on this
            stRunning.addEventListener("prop.active", checkDebuggerActive);
            stDebugProcessRunning.addEventListener("prop.active", checkDebuggerActive);
            
            // when hovering over the inspector window we should ignore all further listeners
            apf.addListener(datagridHtml, "mouseover", function() {
                if (activeTimeout) {
                    clearTimeout(activeTimeout);
                }
            });
        });
        
        // we should track mouse movement over the whole window
        apf.addListener(document, "mousemove", onDocumentMouseMove);
        
        // yes, this is superhacky but the editor function in APF is crazy
        apf.addListener(datagridHtml, "dblclick", initializeEditor);
        
        // when collapsing or expanding the datagrid we want to resize
        dgLiveInspect.addEventListener("expand", resizeWindow);
        dgLiveInspect.addEventListener("collapse", resizeWindow);
    };
    
    var resizeWindow = function () {
        var gridRows = datagridHtml.querySelectorAll(".row");
        // iterate over all properties
        var rows = Object.keys(gridRows)
            .filter(function (r) { return !isNaN(r); }) // filter non numeric properties
            .map(function (r) { return gridRows[r]; }) // map them into real objects
            .filter(function (r) { return r.offsetHeight > 0; }); // check whether they are visible
        
        // if we have any rows
        if (rows && rows.length) {
            // determine height based on first one
            var height = rows[0].offsetHeight * rows.length;
            
            // add border of the container
            height += (windowHtml.offsetHeight - windowHtml.scrollHeight);
            
            // find header
            var header = datagridHtml.querySelector(".headings");
            if (header) {
                height += header.offsetHeight;
            }
            
            // we don't want this to fall of the screen
            var maxHeight = (window.innerHeight - winLiveInspect.$ext.offsetTop) - 30;
            if (height > maxHeight) {
                height = maxHeight;
            }
            
            // update height
            winLiveInspect.setAttribute("height", height);
        }
    };
        
    /**
     * WARNING this is a piece of junk
     * Initialize an editor in the place of the 'value' field when doubleclicking
     */
    var initializeEditor = function (ev) {
        // get the real clicked element
        var target = ev.target;
        
        // only interested in the node with index 1
        if (target.tagName === "U" /* its in an <u> */
          && target.parentNode.parentNode.childNodes[1] === target.parentNode /* [1] index */
          && !target.parentNode.hid /* and no header */) {
              
            // bug in APF? When having only 1 item the 'selected' property isnt set properly
            var selected = dgLiveInspect.selected;
            if (!selected && dgLiveInspect.getModel().data.childNodes.length === 1) {
                // because you just doubleclicked an item, well just grab the only one
                selected = dgLiveInspect.getModel().data.childNodes[0]; 
            }
              
            // check whether we are able to edit this item
            if (!inspector.isEditable(selected)) {
                return;
            }
            
            // V8 debugger cannot change variables that are locally scoped, so we need at least 
            // one parent property.
            if (inspector.calcName(selected, true).indexOf('.') === -1) {
                return;
            }
            
            // get current display property
            var originalDisplay = target.style.display;
            
            // create new simple input field
            var edit = document.createElement("input");
            edit.type = "text";
            edit.value = target.innerText;
            edit.style.width = "98%";
            edit.style.outline = "0";
            edit.style.border = "solid 1px gray";
            edit.style.height = "13px";
            edit.style["margin-top"] = "1px";
            
            // update variable
            var onBlur = function () {
                // remove to stop further prop
                edit.removeEventListener("blur", onBlur);
                
                // test for correct value
                if (!inspector.validateNewValue(selected, this.value)) {
                    alert("invalid value for type " + selected.getAttribute("type"));
                    return false;
                }
                
                // remove the texteditor
                this.parentNode.removeChild(this);
                
                // restore the label
                target.style.display = originalDisplay;
                target.innerText = this.value;
                
                inspector.setNewValue(selected, this.value, function (res) { });
            };
            
            // when blurring, update
            apf.addListener(edit, "blur", onBlur);
            
            // on keydown, same same
            apf.addListener(edit, "keydown", function(ev) {
                if (ev.keyCode === 27 || ev.keyCode === 13) { // tab or enter
                    return onBlur.call(this);
                }
                if (ev.keyCode === 32) {  // somewhere in APF the space is captured; no clue why
                    this.value += " "; // this is super lame, but better than nothing
                }
                return true;
            });
            
            // now hide the cur value
            target.style.display = "none";
            // and append textbox
            target.parentNode.appendChild(edit);
            
            // focus
            edit.focus();
        }
    };
    
    /**
     * Check whether the debugger is attached & on a breakpoint
     */
    var checkDebuggerActive = function () {
        if (!stRunning.active && stDebugProcessRunning.active) {
            // debugger running
        }
        else {
            winLiveInspect.hide();
        }
    };
    
    /**
     * onMouseMove handler that is being used to show / hide the inline quick watch
     */
    var onEditorMouseMove = function (ev) {
        if (activeTimeout) {
            clearTimeout(activeTimeout);   
        }
        
        if (!stRunning.active && stDebugProcessRunning.active) {
            activeTimeout = setTimeout(function () {
                var pos = ev.getDocumentPosition();
                ide.dispatchEvent("liveinspect", { row: pos.row, col: pos.column });
                
                // hide it, and set left / top so it gets positioned right when showing again
                winLiveInspect.hide();
                windowHtml.style.left = ev.pageX + "px";
                windowHtml.style.top = (ev.pageY + 8) + "px";
            }, 750);
        }
    };
    
    /**
     * onDocumentMove handler to clear the timeout
     */
    var onDocumentMouseMove = function (ev) {
        if (!activeTimeout) {
            return;   
        }
        
        // see whether we hover over the editor or the quickwatch window
        var mouseMoveAllowed = false;
        
        var eles = [ ceEditor, winLiveInspect ];
        // only the visible ones
        eles.filter(function (ele) { return ele.visible; })
            .map(function (ele) { return ele.$ext; }) // then get the HTML counterpart
            .forEach(function (ele) {
                // then detect real position
                var position = apf.getAbsolutePosition(ele, document.body);
                var left = position[0];
                var top = position[1];
                
                // x boundaries
                if (ev.pageX >= left && ev.pageX <= (left + ele.offsetWidth)) {
                    // y boundaries
                    if (ev.pageY >= top && ev.pageY <= (top + ele.offsetHeight)) {
                        // we are in the editor, so return; this will be handled
                        mouseMoveAllowed = true;
                    }
                }            
            });
        
        if (mouseMoveAllowed) return;
                
        // not in the editor?
        if (winLiveInspect.visible) {
            // if we are visible, then give the user 400 ms to get back into the window
            // otherwise hide it
            activeTimeout = setTimeout(function () {
                winLiveInspect.hide();
            }, 750);
        }
        else {
            // if not visible? then just clear the timeout
            clearTimeout(activeTimeout);
        }
    };
    
    /**
     * When clicking in the editor window, hide live inspect
     */
    var onEditorClick = function (ev) {
        winLiveInspect.hide();
    };
    
    /**
     * Execute live watching
     */
    var liveWatch = function (expr) {
        // already visible, and same expression?
        if (winLiveInspect.visible && expr === currentExpression) {
            return;
        }
        
        // if there is any modal window open, then don't show
        var windows = getNumericProperties(document.querySelectorAll(".winadv") || {}).filter(function (w) {
            return w.style.display !== "none" && w.style.visibility !== "hidden";
        });
        if (windows.length) {
            return;
        }
        
        // if context menu open, then also disable
        if (mnuCtxEditor && mnuCtxEditor.visible) {
            return;
        }
        
        // evaluate the expression in the debugger, and receive model as callback
        inspector.evaluate(expr, function (model) {
            // bind it to the datagrid
            var root  = apf.getXml("<data />");
            apf.xmldb.appendChild(root, model);
            dgLiveInspect.getModel().load(root);
            
            // clean UI to remove selected elements
            dgLiveInspect.selected = null; 
            dgLiveInspect.selection = []; 
            dgLiveInspect.sellength = 0;
            
            // store it
            currentExpression = expr;        
                        
            // show window
            winLiveInspect.show();
            
            // resize the window
            resizeWindow();
        });
    };
    
    var getNumericProperties = function (obj) {
        return Object.keys(obj).filter(function (k) { return !isNaN(k); }).map(function (k) { return obj[k]; });
    };
    
    // public interfaces
    return ext.register("ext/language/liveinspect", {
        init    : init,
        name    : "Live inspect",
        dev     : "Ajax.org",
        type    : ext.GENERAL,
        alone   : true,
        markup  : markup,
        deps    : [ debuggerPlugin ],
        skin    : {
            id   : "inlinedg",
            data : skin
        }
    });
} ());

});
/**
 * Cloud9 Language Foundation
 *
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
define('ext/language/language',['require','exports','module','core/ext','core/ide','ext/code/code','ext/editors/editors','ext/noderunner/noderunner','ace/worker/worker_client','ext/language/complete','ext/language/marker','ext/language/refactor','ext/language/liveinspect','text!ext/language/language.xml','text!ext/language/skin.xml','text!ext/language/language.css','ace/lib/lang','text!ext/language/settings.xml','ext/settings/settings'],function(require, exports, module) {

var ext = require("core/ext");
var ide = require("core/ide");
var code = require("ext/code/code");
var editors = require("ext/editors/editors");
var noderunner = require("ext/noderunner/noderunner");
var WorkerClient = require("ace/worker/worker_client").WorkerClient;

var complete = require('ext/language/complete');
var marker = require('ext/language/marker');
var refactor = require('ext/language/refactor');
var liveInspect = require('ext/language/liveinspect');

var markup = require("text!ext/language/language.xml");
var skin = require("text!ext/language/skin.xml");
var css = require("text!ext/language/language.css");
var lang = require("ace/lib/lang");

var settings = require("text!ext/language/settings.xml");
var extSettings = require("ext/settings/settings");

module.exports = ext.register("ext/language/language", {
    name    : "Javascript Outline",
    dev     : "Ajax.org",
    type    : ext.GENERAL,
    deps    : [editors, noderunner, code],
    nodes   : [],
    alone   : true,
    markup  : markup,
    skin    : skin,
    worker  : null,
    enabled : true,

    commands : {
        "complete": {hint: "code complete"},
        "renameVar": {hint: "Rename variable"}
    },

    hotitems: {},

    hook : function() {
		var _self = this;

        var deferred = lang.deferredCall(function() {
            _self.setPath();
        });

        var worker = this.worker = new WorkerClient(["treehugger", "ext", "ace", "c9"], "worker.js", "ext/language/worker", "LanguageWorker");
        complete.setWorker(worker);

        //ide.addEventListener("init.ext/code/code", function(){
        ide.addEventListener("afteropenfile", function(event){
            if (!event.node)
                return;
            if (!editors.currentEditor || !editors.currentEditor.ceEditor) // No editor, for some reason
                return;
            ext.initExtension(_self);
            var path = event.node.getAttribute("path");
            worker.call("switchFile", [path, editors.currentEditor.ceEditor.syntax, event.doc.getValue()]);
            event.doc.addEventListener("close", function() {
                worker.emit("documentClose", {data: path});
            });
            // This is necessary to know which file was opened last, for some reason the afteropenfile events happen out of sequence
            deferred.cancel().schedule(100);
        });

        // Language features
        marker.hook(this, worker);
        complete.hook(this, worker);
        refactor.hook(this, worker);

        ide.dispatchEvent("language.worker", {worker: worker});
        ide.addEventListener("$event.language.worker", function(callback){
            callback({worker: worker});
        });

        ide.addEventListener("init.ext/settings/settings", function (e) {
            var heading = e.ext.getHeading("Language Support");
            heading.insertMarkup(settings);
        });
    },

    init : function() {
        var _self = this;
        var worker = this.worker;
        apf.importCssString(css);
        if (!editors.currentEditor || !editors.currentEditor.ceEditor)
            return;
        this.editor = editors.currentEditor.ceEditor.$editor;
        this.$onCursorChange = this.onCursorChangeDefer.bind(this);
        this.editor.selection.on("changeCursor", this.$onCursorChange);
        var oldSelection = this.editor.selection;
        this.setPath();

        this.setJSHint();
        this.setInstanceHighlight();
        this.setUnusedFunctionArgs();
        this.setUndeclaredVars();

        this.editor.on("changeSession", function(event) {
            // Time out a litle, to let the page path be updated
            setTimeout(function() {
                _self.setPath();
                oldSelection.removeEventListener("changeCursor", _self.$onCursorChange);
                _self.editor.selection.on("changeCursor", _self.$onCursorChange);
                oldSelection = _self.editor.selection;
            }, 100);
        });

        this.editor.addEventListener("change", function(e) {
            e.range = {
                start: e.data.range.start,
                end: e.data.range.end
            };
            worker.emit("change", e);
            marker.onChange(_self.editor.session, e);
        });

        ide.addEventListener("liveinspect", function (e) {
            worker.emit("inspect", { data: { row: e.row, col: e.col } });
        });

        // Monkeypatching ACE's JS mode to disable worker
        // this will be handled by C9's worker
        ceEditor.getMode("javascript", function(mode) {
            mode.createWorker = function() {
                return null;
            };
        });
    },

    setPath: function() {
        var page =  tabEditors.getPage();
        if (!page)
            return;
        var currentPath = page.getAttribute("id");

        // Currently no code editor active
        if(!editors.currentEditor.ceEditor || !tabEditors.getPage())
            return;
        var currentPath = tabEditors.getPage().getAttribute("id");
        this.worker.call("switchFile", [currentPath, editors.currentEditor.ceEditor.syntax, this.editor.getSession().getValue(), this.editor.getCursorPosition()]);
    },

    setJSHint: function() {
        if(extSettings.model.queryValue("language/@jshint") != "false")
            this.worker.call("enableFeature", ["jshint"]);
        else
            this.worker.call("disableFeature", ["jshint"]);
        this.setPath();
    },

    setInstanceHighlight: function() {
        if(extSettings.model.queryValue("language/@instanceHighlight") != "false")
            this.worker.call("enableFeature", ["instanceHighlight"]);
        else
            this.worker.call("disableFeature", ["instanceHighlight"]);
        var cursorPos = this.editor.getCursorPosition();
        cursorPos.force = true;
        this.worker.emit("cursormove", {data: cursorPos});
    },

    setUnusedFunctionArgs: function() {
        if(extSettings.model.queryValue("language/@unusedFunctionArgs") != "false")
            this.worker.call("enableFeature", ["unusedFunctionArgs"]);
        else
            this.worker.call("disableFeature", ["unusedFunctionArgs"]);
        this.setPath();
    },

    setUndeclaredVars: function() {
        if(extSettings.model.queryValue("language/@undeclaredVars") != "false")
            this.worker.call("enableFeature", ["undeclaredVars"]);
        else
            this.worker.call("disableFeature", ["undeclaredVars"]);
        this.setPath();
    },

    /**
     * Method attached to key combo for complete
     */
    complete: function() {
        complete.invoke();
    },

    registerLanguageHandler: function(modulePath, className) {
        this.worker.call("register", [modulePath, className]);
    },

    onCursorChangeDefer: function() {
        if(!this.onCursorChangeDeferred) {
            this.onCursorChangeDeferred = lang.deferredCall(this.onCursorChange.bind(this));
        }
        this.onCursorChangeDeferred.cancel().schedule(250);
    },

    onCursorChange: function() {
        this.worker.emit("cursormove", {data: this.editor.getCursorPosition()});
    },

    enable : function() {
    },

    disable : function() {
    },

    destroy : function() {
    }
});

});

/**
 * Code completion for the Cloud9 IDE
 *
 * @copyright 2010, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
define('ext/codecomplete/codecomplete',['require','exports','module','core/ext','ext/editors/editors','ext/language/language'],function(require, exports, module) {

var ext = require("core/ext");
var editors = require("ext/editors/editors");
var language = require("ext/language/language");

module.exports = ext.register("ext/codecomplete/codecomplete", {
    name    : "Code Complete",
    dev     : "Ajax.org",
    type    : ext.GENERAL,
    deps    : [editors, language],
    nodes   : [],
    alone   : true,

    init : function() {
        language.registerLanguageHandler('ext/codecomplete/local_completer');
        language.registerLanguageHandler('ext/codecomplete/snippet_completer');
        language.registerLanguageHandler('ext/codecomplete/open_files_local_completer');
    },

    enable : function() {
    },

    disable : function() {
    },

    destroy : function() {
    }
});

});

/**
 * Cloud9 Language Foundation
 *
 * @copyright 2011, Ajax.org B.V.
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
define('ext/jslanguage/jslanguage',['require','exports','module','core/ext','ext/editors/editors','ext/language/language'],function(require, exports, module) {

var ext = require("core/ext");
var editors = require("ext/editors/editors");
var language = require("ext/language/language");

module.exports = ext.register("ext/jslanguage/jslanguage", {
    name    : "Javascript Language Support",
    dev     : "Ajax.org",
    type    : ext.GENERAL,
    deps    : [editors, language],
    nodes   : [],
    alone   : true,

    init : function() {
        language.registerLanguageHandler('ext/jslanguage/parse');
        language.registerLanguageHandler('ext/jslanguage/scope_analyzer');
        language.registerLanguageHandler('ext/jslanguage/narcissus_jshint');
        language.registerLanguageHandler('ext/jslanguage/debugger');
    },
    
    enable : function() {
    },

    disable : function() {
    },

    destroy : function() {
    }
});

});

/**
 * Guides the user through features of the IDE
 * 
 * @author Matt Pardee
 * @author Garen J. Torikian
 * 
 * @copyright 2011, Cloud9 IDE, Inc
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */

define('ext/guidedtour/guidedtour',['require','exports','module','core/ext','core/ide','text!ext/guidedtour/skin.xml','text!ext/guidedtour/guidedtour.xml','ext/console/console','ext/zen/zen','ext/dockpanel/dockpanel','ext/panels/panels','core/settings','text!ext/guidedtour/hello-world-script.txt','ext/newresource/newresource','ext/save/save','ext/tree/tree','ext/guidedtour/guidedtour','ext/guidedtour/guidedtour','ext/editors/editors','ext/runpanel/runpanel','ext/runpanel/runpanel','ext/runpanel/runpanel','ext/console/console','ext/tree/tree','ext/console/console','ext/tree/tree','ext/tree/tree','ext/console/console','ext/tree/tree','ext/guidedtour/guidedtour'],function(require, exports, module) {
    
var ext = require("core/ext");
var ide = require("core/ide");
var skin = require("text!ext/guidedtour/skin.xml");
var markup = require("text!ext/guidedtour/guidedtour.xml");
var ideConsole = require("ext/console/console");
var zen = require("ext/zen/zen");
var dockpanel = require("ext/dockpanel/dockpanel");
var panels = require("ext/panels/panels");
var settings = require("core/settings");
var helloWorldScript = require("text!ext/guidedtour/hello-world-script.txt");

var save;
var madeNewFile = false;
var wentToZen = false;
var madeDebug = false;
var deletedFile = false;
var hasDeploy = false;

var jsonTourIde = {
    initialText: "This guided tour introduces you to some of the ways<br/> Cloud9 IDE makes it easy for you to program faster and smarter.\n\nClick the play button below to be taken on the tour automatically. Or, you can click the forward and backward buttons to navigate on your own. Remember that during the tour, you won't be able to interact with any of the editor's features.",
    finalText: "Well, that's everything! Still have questions? Head on over to <a href=\"http://support.cloud9ide.com/forums\" target=\"_blank\">our documentation site</a>.",
    steps: [
    {
        el: navbar,
        desc: "This is the project bar. It controls the behavior of the IDE, as well as the presentation of your code.",
        pos: "right",
        time: 4
    }, {
        before: function() {
            // require("ext/tree/tree").enable();
        },
        el: apf.document.selectSingleNode('/html[1]/body[1]/a:vbox[1]/a:vbox[1]/a:hbox[1]/a:vbox[1]/button[@caption="Project Files"]'),
        desc: "This button shows and hides your project files.",
        pos: "right",
        time: 4
    }, {
        before: function() {
            //require("ext/openfiles/openfiles").enable();
        },
        el: apf.document.selectSingleNode('/html[1]/body[1]/a:vbox[1]/a:vbox[1]/a:hbox[1]/a:vbox[1]/button[@caption="Open Files"]'),
        desc: "This button shows and hides your open files in a list view.",
        pos: "right",
        time: 4
    }, {
        before: function() {
            //require("ext/settings/settings").enable();
        },
        el: apf.document.selectSingleNode('/html[1]/body[1]/a:vbox[1]/a:vbox[1]/a:hbox[1]/a:vbox[1]/button[@caption="Preferences"]'),
        desc: "Here, you can change the behavior of the editor, manipulate the code beautifier, and change the indentation and width of the editor, among other options.",
        pos: "right",
        time: 4
    }, {
        before: function() {
            //require("ext/tree/tree").enable();
        },
        el: "winFilesViewer",
        desc: "All your project files are listed here. You can rename and delete files, as well as drag in new ones from your computer. You can also right-click to see context options.",
        pos: "right",
        time: 4
    }, {
        before: function() {
            //require("ext/tree/tree").enable();
        },
        el: plus_tab_button,
        desc: "You can use this button to quickly add new files to the editor. We'll simulate pushing that right now.",
        pos: "left",
        time: 4
    }, {
        before: function(){
            if (madeNewFile == false) {
                madeNewFile = true;
                require("ext/newresource/newresource").newfile();
            }
        },
        el: (apf.XPath || apf.runXpath() || apf.XPath).selectNodes('DIV[1]', tabEditors.$ext),
        desc: "Here's a tabbed arrangement of all your active files, including the new one we just created. You can rearrange the tabs however you like and swap through them with keyboard shortcuts.",
        pos: "bottom",
        time: 4
    }, {
        before: function() {
            tabEditors.getPage().$doc.setValue(helloWorldScript);
            if (!save) 
                save = require("ext/save/save");
            var page = tabEditors.getPage();
            var file = page.$model.data;
            save._saveAsNoUI(page, file.getAttribute("path"), ide.davPrefix + "/helloWorld-quideTour.js");
            require("ext/tree/tree").refresh();
        },
        el: undefined,
        div: "ceEditor",
        desc: "We've just typed up a quick code example and saved it as \"helloWorld-quideTour.js.\" We'll work with this file, then delete it when we're done.",
        pos: "left",
        time: 5
    }, {
        before: function(){
            if (wentToZen){
                zen.fadeZenButtonOut();
                wentToZen = false;
            }
        },
        el: undefined,
        div: "DIV[1]",
        desc: "The gutter can do more than show line numbers. It also detects and displays warnings and errors in your code. If you're debugging an application, you can also set breakpoints here.",
        pos: "right",
        time: 5
    }, {
        before: function() {

        },
        el: undefined,
        div: "barIdeStatus",
        desc: "This is the status bar. It shows your current line number and column position, and clicking on it lets you modify some visual aspects, like vim mode, line margins, and beautify options.",
        pos: "left",
        time: 4
    }, {
        before: function(){
            wentToZen = true;
            zen.fadeZenButtonIn();
        },
        el: undefined,
        div: undefined,
        desc: "If you hover over this corner, you can activate \"Zen Mode,\" which is a distraction-free environment. We'll simulate pressing that button now.",
        pos: "left",
        time: 5
    }, {
        before: function() {
            var hlElement = require("ext/guidedtour/guidedtour").hlElement;
            hlElement.style.visibility = "hidden";
            winTourText.hide();
            document.getElementsByClassName("tgDialog")[0].style.display = "none";
            zen.fadeZenButtonOut();
            zen.enterIntoZenMode();
            
            setTimeout(function(){
                zen.escapeFromZenMode();
                document.getElementsByClassName("tgDialog")[0].style.display = "";
                require("ext/guidedtour/guidedtour").stepForward();
                zen.fadeZenButtonOut();
                                
                hlElement.style.visibility = "visible";
                winTourText.show();
            }, 2000);
        },
        time: 4,
        desc: "",
        skip: true
    }, {
        before: function(){
            //ideConsole.disable();
        },
        el: apf.document.selectSingleNode('/html[1]/body[1]/a:vbox[1]/a:vbox[1]/a:bar[1]/a:vbox[1]/a:hbox[1]'),
        desc: "This area down here acts just like a command line for your project in the Cloud9 IDE. You can always type 'help' to get a list of the available commands.",
        pos: "top",
        time: 5
    }, {
        before: function() {
            //ideConsole.enable();
            ideConsole.show();
        },
        el: (apf.XPath || apf.runXpath() || apf.XPath).selectNodes('DIV[1]', tabConsole.$ext),
        desc: "After clicking the expand arrows, you'll be able to get to the full console view. Any output from your program&mdash;like console.log() messages or compilation errors&mdash;appears in the Output tab.",
        pos: "top",
        time: 4
    }, {
        before: function() {
            //winRunCfgNew.hide();
            //ideConsole.disable();
            var doc = require("ext/editors/editors").currentEditor.ceEditor.getSession();
            doc.setBreakpoints([1]);
        },
        el: undefined,
        div: "DIV[1]",
        desc: "We're ready to test our code, so we've inserted a breakpoint on this line by clicking in the gutter. Before debugging, though, we'll need to set up a debugging scenario.",
        pos: "right",
        time: 5
    }, {
        before: function(){
            panels.activate(require("ext/runpanel/runpanel"));
            if (!madeDebug) {
                settings.model.setQueryValue('auto/configurations/@debug', true);
            }
            setTimeout(function(){
                lstRunCfg.select(lstRunCfg.$model.queryNode("//config"), null, null, null, true)
            });
        },
        el: "winRunPanel",
        desc: "Here's where the fun begins! After clicking Debug, then Run Configurations, you'll be able to create or modify a debug configuration. Every configuration needs a name and a file to run, but you can also pass arguments.",
        pos: "right",
        time: 5
    }, {
        before: function() {
            require('ext/runpanel/runpanel').run(true);
            var bar = dockpanel.layout.$getLastBar();
            if(!bar) {
                dockpanel.showBar(dockpanel.getBars("ext/debugger/debugger", "pgDebugNav")[0]);
            }
        },
        el: (apf.XPath || apf.runXpath() || apf.XPath).selectNodes('DIV[1]', tabConsole.$ext),
        desc: "Whoa! A lot of things just happened. First off, the Output tab opened up to show us that our code is running, and currently being debugged.",
        pos: "top",
        time: 4
    }, {
        before: function() {
        },
        el: function(){
            return dockpanel.layout.$getLastBar();;
        },
        desc: "Next, when you start debugging, you'll instantly get a new debugging toolbar.",
        pos: "left",
        time: 4
    }, {
        before: function() {
            var menuId = dockpanel.getButtons("ext/debugger/debugger", "pgDebugNav")[0];
            if(menuId) {
                dockpanel.layout.showMenu(menuId.uniqueId);
                if(!pgDebugNav.parentNode.parentNode.visible)
                    btnRunCommands.dispatchEvent("mousedown",  {});
            }
        },
        el: function(){
            return pgDebugNav;
        },
        desc: "In this toolbar, the usual start, stop, and step buttons are at the top, to help control the flow of the debugging.",
        pos: "left",
        time: 4
    }, {
        before: function() {
            var menuId = dockpanel.getButtons("ext/debugger/debugger", "dbgVariable")[0];
            if(menuId) {
                dockpanel.layout.showMenu(menuId.uniqueId);
                dbgVariable.parentNode.set(dbgVariable)
            }
        },
        el: function(){
            return dbgVariable;
        },
        desc: "In this section you can view variables in the debug state.",
        pos: "left",
        time: 4
    }, {
        before: function() {
            var menuId = dockpanel.getButtons("ext/debugger/debugger", "dbgCallStack")[0];
            if(menuId)
                dockpanel.layout.showMenu(menuId.uniqueId);
            dbgCallStack.parentNode.set(dbgCallStack)
        },
        el: function(){
            return dbgCallStack;
        },
        desc: "Here you can see the call stack of the program you are debugging.",
        pos: "left",
        time: 4
    }, {
        before: function() {
            
            dbgCallStack && dbgCallStack.parentNode && dbgCallStack.parentNode.parentNode.hide();
            dbg.continueScript();
            txtConsoleInput.setValue("git status");
        },
        el: (apf.XPath || apf.runXpath() || apf.XPath).selectNodes('DIV[1]', tabConsole.$ext),
        desc: "We indicated to the debugger that we want to continue. At last, the console.log() message printed out. Now, we're going to simulate typing 'git status' in the command line.",
        pos: "top",
        time: 4
    }, {
        before: function(){
            require(["c9/ext/deploy/deploy"], function(deploy) { 
                hasDeploy = true;
                panels.activate(deploy);
            });
        },
        el: "winDeploy",
        desc: "In this panel you can manage(add/remove) your deploy targets for your application, in different services, like Joyent and Heroku.",
        pos: "right",
        notAvailable: !hasDeploy,
        time: 5
    }, {
        before: function() {
            require('ext/runpanel/runpanel').stop();
            
            if(trFiles.$model.queryNode("//file[@path='" + ide.davPrefix + "/helloWorld-quideTour.js']")) {
                require("ext/console/console").commandTextHandler({
                    keyCode: 13,
                    currentTarget: txtConsoleInput
                });
                txtConsoleInput.setValue("rm helloWorld-quideTour.js");
            }
        },
        el: (apf.XPath || apf.runXpath() || apf.XPath).selectNodes('DIV[1]', tabConsole.$ext),
        desc: "As expected, there's been a new file added to git. We're done testing it, and don't want to keep it around, so let's remove it with 'rm helloWorld-quideTour.js'.",
        pos: "top",
        time: 4
    }, {
        before: function() {
            panels.activate(require("ext/tree/tree"));
            var demoFile = trFiles.$model.queryNode("//file[@path='" + ide.davPrefix + "/helloWorld-quideTour.js']");
            if(demoFile && !deletedFile) {
                deletedFile = true;
                tabEditors.remove(tabEditors.getPage());
                require("ext/console/console").commandTextHandler({
                    keyCode: 13,
                    currentTarget: txtConsoleInput
                });
                trFiles.confirmed = true;
                trFiles.remove(demoFile);
                trFiles.confirmed = false;
                require("ext/tree/tree").refresh();
            }
        },
        el: "winFilesViewer",
        desc: "Voila! Notice that the file is gone from your project.",
        pos: "right",
        time: 4
    }]
};

module.exports = ext.register("ext/guidedtour/guidedtour", {
    name: "Guided Tour",
    dev: "Cloud9 IDE, Inc.",
    alone: true,
    type: ext.GENERAL,
    markup: markup,
    skin    : {
        id   : "guidedtour",
        data : skin,
        "media-path" : "/static/ext/guidedtour/images/"
    },
    currentStep: -1,
    currentEl: null,
    nodes: [],

    hook: function() {
        //this.launchGT();
    },
    
    init: function(amlNode) {     
        this.initTour();
        this.tour = jsonTourIde;
        
        this.overlay   = document.createElement("div");
        this.hlElement = document.createElement("div");
        
        this.overlay.setAttribute("style", "display:none;position:fixed;left: 0px;top: 0px;width:100%;height:100%;opacity:0.3;background:#000;opacity:0");
        document.body.appendChild(this.overlay);

        this.hlElement.setAttribute("style", "z-index:9998;display:none;position:absolute;box-shadow:0px 0px 15px #000;");
        document.body.appendChild(this.hlElement);

        winTourGuide.addEventListener("hide", this.shutdown(this.hlElement));
        tourControlsDialog.addEventListener("hide", this.shutdown(this.hlElement));
    },

    launchGT: function(){        
        ext.initExtension(this);
        this.hideMenus();
        madeNewFile = wentToZen = madeDebug = deletedFile = false;
        this.currentStep = -1;
        winTourDesc.setValue(this.tour.initialText);
        winTourGuide.show();
        winTourButtonStart.show();
        winTourButtonClose.show();
        winTourButtonDone.hide();
    },
    
    hideMenus: function(){
        var buttons = dockpanel.getButtons("ext/debugger/debugger");
        if(!buttons)
            return;
            
        for(var i = 0, button; i < buttons.length; i++) {
            button = buttons[i];
            if(!button.showMenu || !button.cache)
                continue;
            
            self[button.cache.submenu].hide();
        }
    },
    
    initTour: function(){
        this.animateui = settings.model.queryValue('general/@animateui');
        settings.model.setQueryValue('general/@animateui', false);
        
        /*ide.addEventListener("loadsettings", function(e){
            _self.animateui = settings.model.queryValue('general/@animateui');
            settings.model.setQueryValue('general/@animateui', false);
        });*/
        
        !self["winFilesViewer"] && panels.activate(require("ext/tree/tree"));

        var demoFile = trFiles.$model.queryNode("//file[@path='" + ide.davPrefix + "/helloWorld-quideTour.js']");
        if (demoFile && !deletedFile) {
            txtConsoleInput.setValue("rm helloWorld-quideTour.js");
            deletedFile = true;
            require("ext/console/console").commandTextHandler({
                keyCode: 13,
                currentTarget: txtConsoleInput
            });
            trFiles.confirmed = true;
            trFiles.remove(demoFile);
            trFiles.confirmed = false;
            require("ext/tree/tree").refresh();
        }
    },
    
    /**
     * Play controls
     */
    togglePlay: function(){
        if (this.playing) this.pause();
        else this.play();
    },

    play: function(){
        btnTourPlay.$ext.childNodes[1].style.backgroundPosition = "-28px 3px";
        btnTourPlay.tooltip = "Play";
        this.playing = true;
        this.stepForwardAuto();
    },

    pause: function(){
        btnTourPlay.$ext.childNodes[1].style.backgroundPosition = "14px 4px";
        btnTourPlay.tooltip = "Pause";
        this.playing = false;
        clearTimeout(this.$timerForward);
    },

    end: function(){
        this.pause();
        this.hlElement.style.opacity = "0";
    },

    startTour: function(){
        var _self = this;
        
        this.currentStep = -1;
        winTourGuide.hide();
        tourControlsDialog.show();
        this.stepForward();
        
        this.overlay.style = 'block';
        
        settings.model.setQueryValue('general/@animateui', false);
        
        apf.removeEventListener("keyup", _self.keyUpEvent);
        
        apf.addEventListener("keyup", _self.keyUpEvent = function(e){
            if(e.keyCode == 39)
                _self.stepForward();
            else if(e.keyCode == 37)
                _self.stepBack();
        });
        
        // remove the modal overlay, but keep it around to block input
        //var modalBackground = document.getElementsByClassName("bk-window-cover");
        //modalBackground[modalBackground.length - 1].style.opacity = "0";
    },

    stepBack: function(){
        this.currentStep--;

        var step = this.tour.steps[this.currentStep];
        
        if(!step)
            return;
        
        if (step.skip !== undefined) { // we're in the zen mode step, go back one more
            this.currentStep--;
            step = this.tour.steps[this.currentStep];
        }

        if (this.currentStep === 0) {
            btnTourStepBack.disable();
            btnTourStepBack.$ext.childNodes[1].style.backgroundPosition = "20px -21px";
        }

        btnTourStepForward.enable();

        this.commonStepOps(step);
    },

    stepForwardAuto: function(){
        var _self = this;
        var timeout = this.currentStep > -1 ? this.tour.steps[this.currentStep].time : 0;

        this.$timerForward = setTimeout(function() {
            _self.stepForward();
            if (_self.tour.steps[_self.currentStep + 1]) 
                _self.stepForwardAuto();
            else {
                _self.end();
                _self.finalStep();
            }
        }, timeout * 1000);
    },

    stepForward: function(){
        this.currentStep++;
        if (!this.tour.steps[this.currentStep]) 
            this.finalStep();
        else {
            if (this.currentStep > 0){
                btnTourStepBack.enable();
                btnTourStepBack.$ext.childNodes[1].style.backgroundPosition = "20px 5px";
            }
            if(this.currentStep > 22) {
                btnTourStepBack.disable();
                btnTourStepBack.$ext.childNodes[1].style.backgroundPosition = "20px -21px";
            }
            var step = this.tour.steps[this.currentStep];
            this.commonStepOps(step);
        }
    },

    finalStep: function() {
        winTourText.close();
        tourControlsDialog.hide();
        this.closeTG();
        this.hlElement.style.display = "none";

        winTourGuide.show();
        winTourDesc.setValue(this.tour.finalText);
        this.currentStep = -1;
        winTourButtonStart.hide();
        winTourButtonClose.hide();
        winTourButtonDone.show();
    },
    
    // These are common operations we do for each step
    // forwards and back, so we DRY
    commonStepOps: function(step){
        function getCurrentEl(){
            if (step.el !== undefined) {
                if(typeof step.el == "string")
                    step.el = self[step.el];
                if(typeof step.el == "function")
                    step.el = step.el();
                _self.currentEl = step.el;
            }
            // All of these fix issues with elements not being available when this plugin loads
            else if (step.div == "ceEditor"){
                _self.currentEl = ceEditor;
            }
            else if (step.div == "expandedDbg") {
                _self.currentEl = expandedDbg;
            }
            else if (step.div == "barIdeStatus") {
                _self.currentEl = barIdeStatus;
            }
            else if (step.div !== undefined) {
                if (step.node !== undefined) {
                    _self.currentEl = (apf.XPath || apf.runXpath() || apf.XPath).selectNodes(step.div, apf.document.selectSingleNode(step.node).$ext);
                }
                else {
                    _self.currentEl = (apf.XPath || apf.runXpath() || apf.XPath).selectNodes(step.div, ceEditor.$ext);
                }
            }
            else {
                // fixes issue with no zen button existing
                _self.currentEl = btnZenFullscreen;
            }
        }
        var _self = this;
        if(step.notAvailable) {
            this.stepForward();
            return;
        }
        if (step.before) 
            step.before();
        
        setTimeout(function(){   
            getCurrentEl();
            if(!_self.currentEl)
                return;
                
            _self.highlightElement();
    
            textTourDesc.setValue(step.desc);
    
            // Reset Position
            winTourText.setAttribute("bottom", "");
            winTourText.setAttribute("top", "");
            winTourText.setAttribute("left", "");
            winTourText.setAttribute("right", "");
    
            var pos = _self.getElementPosition(_self.currentEl);
            
            if(!pos)
                return;
            
            winTourText.setAttribute("class", step.pos);
        
            _self.setPositions(step.pos, pos, winTourText);
            
            if(step.pos)
                winTourText.show();
        });
    },

    setPositions: function(position, posArray, div) {
        if (position == "top"){
            div.setAttribute("bottom", (window.innerHeight - posArray[1]) + 25);
            div.setAttribute("left", (posArray[0] + (posArray[2] / 2)) - (div.getWidth() / 2));
        }
        else if (position == "right"){
            div.setAttribute("left", posArray[0] + posArray[2] + 25);
            div.setAttribute("top", (posArray[1] + (posArray[3] / 2)) - (div.getHeight() / 2));
        }
        else if (position == "bottom"){
            div.setAttribute("top", posArray[3] + 50);
            div.setAttribute("right", (posArray[0] + (posArray[2] / 2)) - (div.getWidth() / 2));
        }
        else if (position == "left"){
            div.setAttribute("right", (window.innerWidth - posArray[0]) + 25);
            div.setAttribute("top", (posArray[1] + (posArray[3] / 2)) - (div.getHeight() / 2));
        }

        return div;
    },

    /**
     * Element methods
     */
    highlightElement: function(){        
        //this.currentEl.addEventListener("resize", this.$celResize = function() {
        //_self.resizeHighlightedEl();
        //});
        this.resizeHighlightedEl();
        
        var hlZindex = this.hlElement.style.zIndex;
        winTourText.$ext.style.zIndex = hlZindex + 1;
        tourControlsDialog.$ext.style.zIndex = hlZindex + 2;
    },

    resizeHighlightedEl: function() {
        var pos = this.getElementPosition(this.currentEl);
        this.hlElement.style.left = pos[0] + "px";
        this.hlElement.style.top = pos[1] + "px";
        this.hlElement.style.width = (pos[2] - 4) + "px";
        this.hlElement.style.height = (pos[3] - 4) + "px";
        this.hlElement.style.display = "block";
        this.hlElement.style.border = "solid 2px #bee82c";

        if (this.currentEl.$ext) {
            var zIndex;
            var pNode = this.currentEl;
            if (pNode) {
                while (pNode && pNode.tagName != "body" && (!zIndex || zIndex <= 9998)) {
                    zIndex = pNode.$ext && pNode.$ext.style && parseInt(pNode.$ext.style.zIndex || 9997) + 1;
                    pNode = pNode.parentNode;
                }
            }
            else {
                zIndex = 9998;
            }
        }
        else {
            zIndex = this.currentEl.style && parseInt(this.currentEl.style.zIndex || 9997) + 1;
        }

        this.hlElement.style.zIndex = zIndex;
    },

    getElementPosition: function(el){
        if(!el)
            return [0, 0, 0, 0];
            
        var elExt = el.$ext;
        if (elExt === undefined) {
            var pos = apf.getAbsolutePosition(el[0]);
            return [pos[0], pos[1], el[0].offsetWidth, el[0].offsetHeight];
        }
        else {
            var pos = apf.getAbsolutePosition(elExt);
            var w = el.getWidth();
            var h = el.getHeight();
            return [pos[0], pos[1], w, h];
        }
    },

    enable: function() {
        this.nodes.each(function(item) {
            item.enable();
        });
    },

    closeTG: function() {
        var _self = this;
        winTourGuide.hide();
        
        apf.removeEventListener("keyup", _self.keyUpEvent);
    },

    shutdown: function(hlElement) {
        var _self = this;
        
        apf.removeEventListener("keyup", _self.keyUpEvent);
        return function() {
            require("ext/guidedtour/guidedtour").pause(); // stop auto-moving
            winTourText.hide();
            tourControlsDialog.hide();
            zen.fadeZenButtonOut(); // in case it's still showing
            (hlElement || _self.hlElement).style.display = "none";
            _self.currentStep = -1;
            _self.overlay.style = 'none';
            
            //set anim settings to what it was before the tour
            settings.model.setQueryValue('general/@animateui', _self.animateui);
        };        
    },

    disable: function() {
        this.nodes.each(function(item) {
            item.disable();
        });
    },

    destroy: function() {
        this.nodes.each(function(item) {
            item.destroy(true, true);
        });
        this.nodes = [];
    }
});

});

/**
 * Identifies some "hot spots" in the IDE that users should be aware of
 * 
 * @author Garen J. Torikian
 * 
 * @copyright 2011, Cloud9 IDE, Inc
 * @license GPLv3 <http://www.gnu.org/licenses/gpl.txt>
 */
 
define('ext/quickstart/quickstart',['require','exports','module','core/ext','core/ide','text!ext/quickstart/skin.xml','text!ext/quickstart/quickstart.xml','ext/settings/settings','ext/settings/settings','ext/settings/settings','ext/settings/settings','ext/dockpanel/dockpanel','ext/guidedtour/guidedtour','ext/guidedtour/guidedtour'],function(require, exports, module) {

var ext = require("core/ext");
var ide = require("core/ide");
var skin = require("text!ext/quickstart/skin.xml");
var markup = require("text!ext/quickstart/quickstart.xml");

var jsonQuickStart = {
    identifiers: [
        {
            el : apf.document.selectSingleNode('/html[1]/body[1]/a:vbox[1]/a:vbox[1]/a:hbox[1]/a:vbox[1]/button[@caption="Project Files"]'),
            name : "qsProjectBar",
            pos: "right"
        },
        {
            el : logobar,
            name : "qsMenuBar",
            pos: "bottom"
        },
       {
            el : tabEditors,
            name : "qsToolbar",
            pos: "left",
            visible: function(){
                return hboxDockPanel.childNodes[0];
            }
        },
        {
            el : apf.document.selectSingleNode('/html[1]/body[1]/a:vbox[1]/a:vbox[1]/a:bar[1]/a:vbox[1]/a:hbox[1]'),
            name : "qsCLI",
            pos: "top"
        }
    ]
};

// require("ext/settings/settings").model.queryValue("auto/help/@show") == "false"
//ide.addEventListener("loadsettings", function(){

module.exports = ext.register("ext/quickstart/quickstart", {
    name     : "Quick Start",
    dev      : "Cloud9 IDE, Inc.",
    alone    : true,
    type     : ext.GENERAL,
    markup   : markup,
    skin    : {
        id   : "quickstart",
        data : skin,
        "media-path" : "/static/ext/quickstart/images/"
    },
    nodes : [],

    init : function(amlNode){   
        this.overlay = document.createElement("div");
        this.overlay.setAttribute("style",
            "z-index:9016;display:none;position:fixed;left: 0px;top: 0px;width:100%;height:100%;opacity:0.3;background:#000;");
        document.body.appendChild(this.overlay);
    },
    
    hook : function(){
        var _self = this;
                
        ide.addEventListener("loadsettings", function(e) {
            var showQS = require("ext/settings/settings").model.queryValue("auto/help/@show");
            if(showQS === "" || showQS == "true") {
                if(apf.getcookie("show-quick-start") == "false") {
                    require("ext/settings/settings").model.setQueryValue("auto/help/@show", "false");   
                }
                else {
                    require("ext/settings/settings").model.setQueryValue("auto/help/@show", "true");
                    apf.xmldb.setAttribute(require("ext/settings/settings").model.queryNode("auto/help"), "show", "true");
                    _self.launchQS();
                }
             }
         });
    },
    
    launchQS : function() {
        var _self = this;
        ext.initExtension(this);
        this.hideMenus();
         //debugPanelCompact.show();
        setTimeout(function(){
            _self.overlay.style.display = "block";
            _self.arrangeQSImages();
            quickStartDialog.show();
        })
    },
    
    setState: function(state){
        apf.setcookie("show-quick-start", state, new Date().getTime() + 1000*3600*24*365*2);
    },
    
    hideMenus: function(){
        var buttons = require("ext/dockpanel/dockpanel").getButtons("ext/debugger/debugger");
        if(!buttons)
            return;
        for(var i = 0, button; i < buttons.length; i++) {
            button = buttons[i];
            if(!button.showMenu || !button.cache)
                continue;
            
            self[button.cache.submenu].hide();
        }
    },
    
    /**
    * Arrange the images pointing out the locations
    */
    arrangeQSImages : function() {
        var divToId, position, imgDiv;
        for (var i = 0; i < jsonQuickStart.identifiers.length; i++) {
            if(jsonQuickStart.identifiers[i].visible && !jsonQuickStart.identifiers[i].visible())
                continue;            
            
            divToId = require("ext/guidedtour/guidedtour").getElementPosition(jsonQuickStart.identifiers[i].el);
            position = jsonQuickStart.identifiers[i].pos;
            imgDiv = apf.document.getElementById(jsonQuickStart.identifiers[i].name);
            
            imgDiv.setAttribute("bottom", "");
            imgDiv.setAttribute("top", "");
            imgDiv.setAttribute("left", "");
            imgDiv.setAttribute("right", "");
        
            this.setPositions(position, divToId, imgDiv);     
            
            imgDiv.show();
        }
    },
    
    setPositions : function(position, posArray, div) {
        if (position == "top") {
             div.setAttribute("bottom", (window.innerHeight - posArray[1]) + 100);
             div.setAttribute("left", (posArray[0] + (posArray[2]/2)) - (div.getWidth()/2));
        }
        else if (position == "right"){
            div.setAttribute("left", posArray[0] + posArray[2] - 2);
            div.setAttribute("top", (posArray[1] + (posArray[3]/2)) - (div.getHeight()/2));            
        }
        else if (position == "bottom"){
            div.setAttribute("top", posArray[3]);
            div.setAttribute("right", (posArray[0] + (posArray[2]/2)) - (div.getWidth()/2));
        }
        else if (position == "left"){
            div.setAttribute("top", 125);
            div.setAttribute("right", 0);
        }  
        
        return div;
    },
    
    closeStart : function() {
        //debugPanelCompact.hide();
        quickStartDialog.hide();
        this.overlay.style.display = "none";
        
        var imgDiv;
        for (var i = 0; i < jsonQuickStart.identifiers.length; i++) {
            imgDiv = apf.document.getElementById(jsonQuickStart.identifiers[i].name);
            imgDiv.hide();
        }
    },
    
    shutdownQSStartGT : function() {
        this.closeStart();
        require('ext/guidedtour/guidedtour').launchGT();
    }
});

});}());